"format register";
System.register("npm:core-js@0.9.14/library/modules/$.fw", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = function($) {
    $.FW = false;
    $.path = $.core;
    return $;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/helpers/class-call-check", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.def", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      global = $.g,
      core = $.core,
      isFunction = $.isFunction;
  function ctx(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  }
  $def.F = 1;
  $def.G = 2;
  $def.S = 4;
  $def.P = 8;
  $def.B = 16;
  $def.W = 32;
  function $def(type, name, source) {
    var key,
        own,
        out,
        exp,
        isGlobal = type & $def.G,
        isProto = type & $def.P,
        target = isGlobal ? global : type & $def.S ? global[name] : (global[name] || {}).prototype,
        exports = isGlobal ? core : core[name] || (core[name] = {});
    if (isGlobal)
      source = name;
    for (key in source) {
      own = !(type & $def.F) && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      if (isGlobal && !isFunction(target[key]))
        exp = source[key];
      else if (type & $def.B && own)
        exp = ctx(out, global);
      else if (type & $def.W && target[key] == out)
        !function(C) {
          exp = function(param) {
            return this instanceof C ? new C(param) : C(param);
          };
          exp.prototype = C.prototype;
        }(out);
      else
        exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;
      exports[key] = exp;
      if (isProto)
        (exports.prototype || (exports.prototype = {}))[key] = out;
    }
  }
  module.exports = $def;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.get-names", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      toString = {}.toString,
      getNames = $.getNames;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  function getWindowNames(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  }
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames($.toObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$", ["npm:core-js@0.9.14/library/modules/$.fw"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var global = typeof self != 'undefined' ? self : Function('return this')(),
      core = {},
      defineProperty = Object.defineProperty,
      hasOwnProperty = {}.hasOwnProperty,
      ceil = Math.ceil,
      floor = Math.floor,
      max = Math.max,
      min = Math.min;
  var DESC = !!function() {
    try {
      return defineProperty({}, 'a', {get: function() {
          return 2;
        }}).a == 2;
    } catch (e) {}
  }();
  var hide = createDefiner(1);
  function toInteger(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  }
  function desc(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  }
  function simpleSet(object, key, value) {
    object[key] = value;
    return object;
  }
  function createDefiner(bitmap) {
    return DESC ? function(object, key, value) {
      return $.setDesc(object, key, desc(bitmap, value));
    } : simpleSet;
  }
  function isObject(it) {
    return it !== null && (typeof it == 'object' || typeof it == 'function');
  }
  function isFunction(it) {
    return typeof it == 'function';
  }
  function assertDefined(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  }
  var $ = module.exports = require("npm:core-js@0.9.14/library/modules/$.fw")({
    g: global,
    core: core,
    html: global.document && document.documentElement,
    isObject: isObject,
    isFunction: isFunction,
    that: function() {
      return this;
    },
    toInteger: toInteger,
    toLength: function(it) {
      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
    },
    toIndex: function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    },
    has: function(it, key) {
      return hasOwnProperty.call(it, key);
    },
    create: Object.create,
    getProto: Object.getPrototypeOf,
    DESC: DESC,
    desc: desc,
    getDesc: Object.getOwnPropertyDescriptor,
    setDesc: defineProperty,
    setDescs: Object.defineProperties,
    getKeys: Object.keys,
    getNames: Object.getOwnPropertyNames,
    getSymbols: Object.getOwnPropertySymbols,
    assertDefined: assertDefined,
    ES5Object: Object,
    toObject: function(it) {
      return $.ES5Object(assertDefined(it));
    },
    hide: hide,
    def: createDefiner(0),
    set: global.Symbol ? simpleSet : hide,
    each: [].forEach
  });
  if (typeof __e != 'undefined')
    __e = core;
  if (typeof __g != 'undefined')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.object.statics-accept-primitives", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.def", "npm:core-js@0.9.14/library/modules/$.get-names"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      $def = require("npm:core-js@0.9.14/library/modules/$.def"),
      isObject = $.isObject,
      toObject = $.toObject;
  $.each.call(('freeze,seal,preventExtensions,isFrozen,isSealed,isExtensible,' + 'getOwnPropertyDescriptor,getPrototypeOf,keys,getOwnPropertyNames').split(','), function(KEY, ID) {
    var fn = ($.core.Object || {})[KEY] || Object[KEY],
        forced = 0,
        method = {};
    method[KEY] = ID == 0 ? function freeze(it) {
      return isObject(it) ? fn(it) : it;
    } : ID == 1 ? function seal(it) {
      return isObject(it) ? fn(it) : it;
    } : ID == 2 ? function preventExtensions(it) {
      return isObject(it) ? fn(it) : it;
    } : ID == 3 ? function isFrozen(it) {
      return isObject(it) ? fn(it) : true;
    } : ID == 4 ? function isSealed(it) {
      return isObject(it) ? fn(it) : true;
    } : ID == 5 ? function isExtensible(it) {
      return isObject(it) ? fn(it) : false;
    } : ID == 6 ? function getOwnPropertyDescriptor(it, key) {
      return fn(toObject(it), key);
    } : ID == 7 ? function getPrototypeOf(it) {
      return fn(Object($.assertDefined(it)));
    } : ID == 8 ? function keys(it) {
      return fn(toObject(it));
    } : require("npm:core-js@0.9.14/library/modules/$.get-names").get;
    try {
      fn('z');
    } catch (e) {
      forced = 1;
    }
    $def($def.S + $def.F * forced, 'Object', method);
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/object/define-property", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$");
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/object/keys", ["npm:core-js@0.9.14/library/modules/es6.object.statics-accept-primitives", "npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/es6.object.statics-accept-primitives");
  module.exports = require("npm:core-js@0.9.14/library/modules/$").core.Object.keys;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/object/define-property", ["npm:core-js@0.9.14/library/fn/object/define-property"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/object/define-property"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/object/keys", ["npm:core-js@0.9.14/library/fn/object/keys"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/object/keys"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/helpers/create-class", ["npm:babel-runtime@5.4.7/core-js/object/define-property"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$defineProperty = require("npm:babel-runtime@5.4.7/core-js/object/define-property")["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.shared", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      SHARED = '__core-js_shared__',
      store = $.g[SHARED] || $.hide($.g, SHARED, {})[SHARED];
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.uid", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var sid = 0;
  function uid(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));
  }
  uid.safe = require("npm:core-js@0.9.14/library/modules/$").g.Symbol || uid;
  module.exports = uid;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.cof", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      TAG = require("npm:core-js@0.9.14/library/modules/$.wks")('toStringTag'),
      toString = {}.toString;
  function cof(it) {
    return toString.call(it).slice(8, -1);
  }
  cof.classof = function(it) {
    var O,
        T;
    return it == undefined ? it === undefined ? 'Undefined' : 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);
  };
  cof.set = function(it, tag, stat) {
    if (it && !$.has(it = stat ? it : it.prototype, TAG))
      $.hide(it, TAG, tag);
  };
  module.exports = cof;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.assert", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$");
  function assert(condition, msg1, msg2) {
    if (!condition)
      throw TypeError(msg2 ? msg1 + msg2 : msg1);
  }
  assert.def = $.assertDefined;
  assert.fn = function(it) {
    if (!$.isFunction(it))
      throw TypeError(it + ' is not a function!');
    return it;
  };
  assert.obj = function(it) {
    if (!$.isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  assert.inst = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  module.exports = assert;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.redef", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@0.9.14/library/modules/$").hide;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.string-at", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$");
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String($.assertDefined(that)),
          i = $.toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/core.iter-helpers", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.iter"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var core = require("npm:core-js@0.9.14/library/modules/$").core,
      $iter = require("npm:core-js@0.9.14/library/modules/$.iter");
  core.isIterable = $iter.is;
  core.getIterator = $iter.get;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/object/create", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$");
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.number.statics", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.def"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      $def = require("npm:core-js@0.9.14/library/modules/$.def"),
      abs = Math.abs,
      floor = Math.floor,
      _isFinite = $.g.isFinite,
      MAX_SAFE_INTEGER = 0x1fffffffffffff;
  function isInteger(it) {
    return !$.isObject(it) && _isFinite(it) && floor(it) === it;
  }
  $def($def.S, 'Number', {
    EPSILON: Math.pow(2, -52),
    isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    },
    isInteger: isInteger,
    isNaN: function isNaN(number) {
      return number != number;
    },
    isSafeInteger: function isSafeInteger(number) {
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    parseFloat: parseFloat,
    parseInt: parseInt
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1/browser", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  function drainQueue() {
    if (draining) {
      return ;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      var i = -1;
      while (++i < len) {
        currentQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }
  process.nextTick = function(fun) {
    queue.push(fun);
    if (!draining) {
      setTimeout(drainQueue, 0);
    }
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.aggregates", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        CompositeDisposable = Rx.CompositeDisposable,
        AnonymousObservable = Rx.AnonymousObservable,
        disposableEmpty = Rx.Disposable.empty,
        isEqual = Rx.internals.isEqual,
        helpers = Rx.helpers,
        not = helpers.not,
        defaultComparer = helpers.defaultComparer,
        identity = helpers.identity,
        defaultSubComparer = helpers.defaultSubComparer,
        isFunction = helpers.isFunction,
        isPromise = helpers.isPromise,
        isArrayLike = helpers.isArrayLike,
        isIterable = helpers.isIterable,
        inherits = Rx.internals.inherits,
        observableFromPromise = Observable.fromPromise,
        observableFrom = Observable.from,
        bindCallback = Rx.internals.bindCallback,
        EmptyError = Rx.EmptyError,
        ObservableBase = Rx.ObservableBase,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function extremaBy(source, keySelector, comparer) {
      return new AnonymousObservable(function(o) {
        var hasValue = false,
            lastKey = null,
            list = [];
        return source.subscribe(function(x) {
          var comparison,
              key;
          try {
            key = keySelector(x);
          } catch (ex) {
            o.onError(ex);
            return ;
          }
          comparison = 0;
          if (!hasValue) {
            hasValue = true;
            lastKey = key;
          } else {
            try {
              comparison = comparer(key, lastKey);
            } catch (ex1) {
              o.onError(ex1);
              return ;
            }
          }
          if (comparison > 0) {
            lastKey = key;
            list = [];
          }
          if (comparison >= 0) {
            list.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(list);
          o.onCompleted();
        });
      }, source);
    }
    function firstOnly(x) {
      if (x.length === 0) {
        throw new EmptyError();
      }
      return x[0];
    }
    observableProto.aggregate = function() {
      var hasSeed = false,
          accumulator,
          seed,
          source = this;
      if (arguments.length === 2) {
        hasSeed = true;
        seed = arguments[0];
        accumulator = arguments[1];
      } else {
        accumulator = arguments[0];
      }
      return new AnonymousObservable(function(o) {
        var hasAccumulation,
            accumulation,
            hasValue;
        return source.subscribe(function(x) {
          !hasValue && (hasValue = true);
          try {
            if (hasAccumulation) {
              accumulation = accumulator(accumulation, x);
            } else {
              accumulation = hasSeed ? accumulator(seed, x) : x;
              hasAccumulation = true;
            }
          } catch (e) {
            return o.onError(e);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          hasValue && o.onNext(accumulation);
          !hasValue && hasSeed && o.onNext(seed);
          !hasValue && !hasSeed && o.onError(new EmptyError());
          o.onCompleted();
        });
      }, source);
    };
    var ReduceObservable = (function(__super__) {
      inherits(ReduceObservable, __super__);
      function ReduceObservable(source, acc, hasSeed, seed) {
        this.source = source;
        this.acc = acc;
        this.hasSeed = hasSeed;
        this.seed = seed;
        __super__.call(this);
      }
      ReduceObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new InnerObserver(observer, this));
      };
      function InnerObserver(o, parent) {
        this.o = o;
        this.acc = parent.acc;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.result = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return ;
        }
        !this.hasValue && (this.hasValue = true);
        if (this.hasAccumulation) {
          this.result = tryCatch(this.acc)(this.result, x);
        } else {
          this.result = this.hasSeed ? tryCatch(this.acc)(this.seed, x) : x;
          this.hasAccumulation = true;
        }
        if (this.result === errorObj) {
          this.o.onError(this.result.e);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.hasValue && this.o.onNext(this.result);
          !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
          !this.hasValue && !this.hasSeed && this.o.onError(new EmptyError());
          this.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      return ReduceObservable;
    }(ObservableBase));
    observableProto.reduce = function(accumulator) {
      var hasSeed = false;
      if (arguments.length === 2) {
        hasSeed = true;
        var seed = arguments[1];
      }
      return new ReduceObservable(this, accumulator, hasSeed, seed);
    };
    observableProto.some = function(predicate, thisArg) {
      var source = this;
      return predicate ? source.filter(predicate, thisArg).some() : new AnonymousObservable(function(observer) {
        return source.subscribe(function() {
          observer.onNext(true);
          observer.onCompleted();
        }, function(e) {
          observer.onError(e);
        }, function() {
          observer.onNext(false);
          observer.onCompleted();
        });
      }, source);
    };
    observableProto.any = function() {
      return this.some.apply(this, arguments);
    };
    observableProto.isEmpty = function() {
      return this.any().map(not);
    };
    observableProto.every = function(predicate, thisArg) {
      return this.filter(function(v) {
        return !predicate(v);
      }, thisArg).some().map(not);
    };
    observableProto.all = function() {
      return this.every.apply(this, arguments);
    };
    observableProto.includes = function(searchElement, fromIndex) {
      var source = this;
      function comparer(a, b) {
        return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));
      }
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(false);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i++ >= n && comparer(x, searchElement)) {
            o.onNext(true);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(false);
          o.onCompleted();
        });
      }, this);
    };
    observableProto.contains = function(searchElement, fromIndex) {
      observableProto.includes(searchElement, fromIndex);
    };
    observableProto.count = function(predicate, thisArg) {
      return predicate ? this.filter(predicate, thisArg).count() : this.reduce(function(count) {
        return count + 1;
      }, 0);
    };
    observableProto.indexOf = function(searchElement, fromIndex) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var i = 0,
            n = +fromIndex || 0;
        Math.abs(n) === Infinity && (n = 0);
        if (n < 0) {
          o.onNext(-1);
          o.onCompleted();
          return disposableEmpty;
        }
        return source.subscribe(function(x) {
          if (i >= n && x === searchElement) {
            o.onNext(i);
            o.onCompleted();
          }
          i++;
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(-1);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.sum = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).sum() : this.reduce(function(prev, curr) {
        return prev + curr;
      }, 0);
    };
    observableProto.minBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, function(x, y) {
        return comparer(x, y) * -1;
      });
    };
    observableProto.min = function(comparer) {
      return this.minBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.maxBy = function(keySelector, comparer) {
      comparer || (comparer = defaultSubComparer);
      return extremaBy(this, keySelector, comparer);
    };
    observableProto.max = function(comparer) {
      return this.maxBy(identity, comparer).map(function(x) {
        return firstOnly(x);
      });
    };
    observableProto.average = function(keySelector, thisArg) {
      return keySelector && isFunction(keySelector) ? this.map(keySelector, thisArg).average() : this.reduce(function(prev, cur) {
        return {
          sum: prev.sum + cur,
          count: prev.count + 1
        };
      }, {
        sum: 0,
        count: 0
      }).map(function(s) {
        if (s.count === 0) {
          throw new EmptyError();
        }
        return s.sum / s.count;
      });
    };
    observableProto.sequenceEqual = function(second, comparer) {
      var first = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var donel = false,
            doner = false,
            ql = [],
            qr = [];
        var subscription1 = first.subscribe(function(x) {
          var equal,
              v;
          if (qr.length > 0) {
            v = qr.shift();
            try {
              equal = comparer(v, x);
            } catch (e) {
              o.onError(e);
              return ;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (doner) {
            o.onNext(false);
            o.onCompleted();
          } else {
            ql.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          donel = true;
          if (ql.length === 0) {
            if (qr.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (doner) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));
        isPromise(second) && (second = observableFromPromise(second));
        var subscription2 = second.subscribe(function(x) {
          var equal;
          if (ql.length > 0) {
            var v = ql.shift();
            try {
              equal = comparer(v, x);
            } catch (exception) {
              o.onError(exception);
              return ;
            }
            if (!equal) {
              o.onNext(false);
              o.onCompleted();
            }
          } else if (donel) {
            o.onNext(false);
            o.onCompleted();
          } else {
            qr.push(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          doner = true;
          if (qr.length === 0) {
            if (ql.length > 0) {
              o.onNext(false);
              o.onCompleted();
            } else if (donel) {
              o.onNext(true);
              o.onCompleted();
            }
          }
        });
        return new CompositeDisposable(subscription1, subscription2);
      }, first);
    };
    function elementAtOrDefault(source, index, hasDefault, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError();
      }
      return new AnonymousObservable(function(o) {
        var i = index;
        return source.subscribe(function(x) {
          if (i-- === 0) {
            o.onNext(x);
            o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!hasDefault) {
            o.onError(new ArgumentOutOfRangeError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.elementAt = function(index) {
      return elementAtOrDefault(this, index, false);
    };
    observableProto.elementAtOrDefault = function(index, defaultValue) {
      return elementAtOrDefault(this, index, true, defaultValue);
    };
    function singleOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        var value = defaultValue,
            seenValue = false;
        return source.subscribe(function(x) {
          if (seenValue) {
            o.onError(new Error('Sequence contains more than one element'));
          } else {
            value = x;
            seenValue = true;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!seenValue && !hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(value);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.single = function(predicate, thisArg) {
      return predicate && isFunction(predicate) ? this.where(predicate, thisArg).single() : singleOrDefaultAsync(this, false);
    };
    observableProto.singleOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate && isFunction(predicate) ? this.filter(predicate, thisArg).singleOrDefault(null, defaultValue) : singleOrDefaultAsync(this, true, defaultValue);
    };
    function firstOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        return source.subscribe(function(x) {
          o.onNext(x);
          o.onCompleted();
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(defaultValue);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.first = function(predicate, thisArg) {
      return predicate ? this.where(predicate, thisArg).first() : firstOrDefaultAsync(this, false);
    };
    observableProto.firstOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate ? this.where(predicate).firstOrDefault(null, defaultValue) : firstOrDefaultAsync(this, true, defaultValue);
    };
    function lastOrDefaultAsync(source, hasDefault, defaultValue) {
      return new AnonymousObservable(function(o) {
        var value = defaultValue,
            seenValue = false;
        return source.subscribe(function(x) {
          value = x;
          seenValue = true;
        }, function(e) {
          o.onError(e);
        }, function() {
          if (!seenValue && !hasDefault) {
            o.onError(new EmptyError());
          } else {
            o.onNext(value);
            o.onCompleted();
          }
        });
      }, source);
    }
    observableProto.last = function(predicate, thisArg) {
      return predicate ? this.where(predicate, thisArg).last() : lastOrDefaultAsync(this, false);
    };
    observableProto.lastOrDefault = function(predicate, defaultValue, thisArg) {
      return predicate ? this.where(predicate, thisArg).lastOrDefault(null, defaultValue) : lastOrDefaultAsync(this, true, defaultValue);
    };
    function findValue(source, predicate, thisArg, yieldIndex) {
      var callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0;
        return source.subscribe(function(x) {
          var shouldRun;
          try {
            shouldRun = callback(x, i, source);
          } catch (e) {
            o.onError(e);
            return ;
          }
          if (shouldRun) {
            o.onNext(yieldIndex ? i : x);
            o.onCompleted();
          } else {
            i++;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(yieldIndex ? -1 : undefined);
          o.onCompleted();
        });
      }, source);
    }
    observableProto.find = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, false);
    };
    observableProto.findIndex = function(predicate, thisArg) {
      return findValue(this, predicate, thisArg, true);
    };
    observableProto.toSet = function() {
      if (typeof root.Set === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var s = new root.Set();
        return source.subscribe(function(x) {
          s.add(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(s);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.toMap = function(keySelector, elementSelector) {
      if (typeof root.Map === 'undefined') {
        throw new TypeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var m = new root.Map();
        return source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            o.onError(e);
            return ;
          }
          var element = x;
          if (elementSelector) {
            try {
              element = elementSelector(x);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          m.set(key, element);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(m);
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.async", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx.binding", "exports"], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx;
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        observableFromPromise = Observable.fromPromise,
        observableThrow = Observable.throwError,
        AnonymousObservable = Rx.AnonymousObservable,
        AsyncSubject = Rx.AsyncSubject,
        disposableCreate = Rx.Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        immediateScheduler = Rx.Scheduler.immediate,
        timeoutScheduler = Rx.Scheduler['default'],
        isScheduler = Rx.Scheduler.isScheduler,
        slice = Array.prototype.slice;
    var fnString = 'function',
        throwString = 'throw',
        isObject = Rx.internals.isObject;
    function toThunk(obj, ctx) {
      if (Array.isArray(obj)) {
        return objectToThunk.call(ctx, obj);
      }
      if (isGeneratorFunction(obj)) {
        return observableSpawn(obj.call(ctx));
      }
      if (isGenerator(obj)) {
        return observableSpawn(obj);
      }
      if (isObservable(obj)) {
        return observableToThunk(obj);
      }
      if (isPromise(obj)) {
        return promiseToThunk(obj);
      }
      if (typeof obj === fnString) {
        return obj;
      }
      if (isObject(obj) || Array.isArray(obj)) {
        return objectToThunk.call(ctx, obj);
      }
      return obj;
    }
    function objectToThunk(obj) {
      var ctx = this;
      return function(done) {
        var keys = Object.keys(obj),
            pending = keys.length,
            results = new obj.constructor(),
            finished;
        if (!pending) {
          timeoutScheduler.schedule(function() {
            done(null, results);
          });
          return ;
        }
        for (var i = 0,
            len = keys.length; i < len; i++) {
          run(obj[keys[i]], keys[i]);
        }
        function run(fn, key) {
          if (finished) {
            return ;
          }
          try {
            fn = toThunk(fn, ctx);
            if (typeof fn !== fnString) {
              results[key] = fn;
              return --pending || done(null, results);
            }
            fn.call(ctx, function(err, res) {
              if (finished) {
                return ;
              }
              if (err) {
                finished = true;
                return done(err);
              }
              results[key] = res;
              --pending || done(null, results);
            });
          } catch (e) {
            finished = true;
            done(e);
          }
        }
      };
    }
    function observableToThunk(observable) {
      return function(fn) {
        var value,
            hasValue = false;
        observable.subscribe(function(v) {
          value = v;
          hasValue = true;
        }, fn, function() {
          hasValue && fn(null, value);
        });
      };
    }
    function promiseToThunk(promise) {
      return function(fn) {
        promise.then(function(res) {
          fn(null, res);
        }, fn);
      };
    }
    function isObservable(obj) {
      return obj && typeof obj.subscribe === fnString;
    }
    function isGeneratorFunction(obj) {
      return obj && obj.constructor && obj.constructor.name === 'GeneratorFunction';
    }
    function isGenerator(obj) {
      return obj && typeof obj.next === fnString && typeof obj[throwString] === fnString;
    }
    var observableSpawn = Rx.spawn = function(fn) {
      var isGenFun = isGeneratorFunction(fn);
      return function(done) {
        var ctx = this,
            gen = fn;
        if (isGenFun) {
          for (var args = [],
              i = 0,
              len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
          }
          var len = args.length,
              hasCallback = len && typeof args[len - 1] === fnString;
          done = hasCallback ? args.pop() : handleError;
          gen = fn.apply(this, args);
        } else {
          done = done || handleError;
        }
        next();
        function exit(err, res) {
          timeoutScheduler.schedule(done.bind(ctx, err, res));
        }
        function next(err, res) {
          var ret;
          if (arguments.length > 2) {
            for (var res = [],
                i = 1,
                len = arguments.length; i < len; i++) {
              res.push(arguments[i]);
            }
          }
          if (err) {
            try {
              ret = gen[throwString](err);
            } catch (e) {
              return exit(e);
            }
          }
          if (!err) {
            try {
              ret = gen.next(res);
            } catch (e) {
              return exit(e);
            }
          }
          if (ret.done) {
            return exit(null, ret.value);
          }
          ret.value = toThunk(ret.value, ctx);
          if (typeof ret.value === fnString) {
            var called = false;
            try {
              ret.value.call(ctx, function() {
                if (called) {
                  return ;
                }
                called = true;
                next.apply(ctx, arguments);
              });
            } catch (e) {
              timeoutScheduler.schedule(function() {
                if (called) {
                  return ;
                }
                called = true;
                next.call(ctx, e);
              });
            }
            return ;
          }
          next(new TypeError('Rx.spawn only supports a function, Promise, Observable, Object or Array.'));
        }
      };
    };
    function handleError(err) {
      if (!err) {
        return ;
      }
      timeoutScheduler.schedule(function() {
        throw err;
      });
    }
    Observable.start = function(func, context, scheduler) {
      return observableToAsync(func, context, scheduler)();
    };
    var observableToAsync = Observable.toAsync = function(func, context, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return function() {
        var args = arguments,
            subject = new AsyncSubject();
        scheduler.schedule(function() {
          var result;
          try {
            result = func.apply(context, args);
          } catch (e) {
            subject.onError(e);
            return ;
          }
          subject.onNext(result);
          subject.onCompleted();
        });
        return subject.asObservable();
      };
    };
    Observable.fromCallback = function(func, context, selector) {
      return function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new AnonymousObservable(function(observer) {
          function handler() {
            var len = arguments.length,
                results = new Array(len);
            for (var i = 0; i < len; i++) {
              results[i] = arguments[i];
            }
            if (selector) {
              try {
                results = selector.apply(context, results);
              } catch (e) {
                return observer.onError(e);
              }
              observer.onNext(results);
            } else {
              if (results.length <= 1) {
                observer.onNext.apply(observer, results);
              } else {
                observer.onNext(results);
              }
            }
            observer.onCompleted();
          }
          args.push(handler);
          func.apply(context, args);
        }).publishLast().refCount();
      };
    };
    Observable.fromNodeCallback = function(func, context, selector) {
      return function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new AnonymousObservable(function(observer) {
          function handler(err) {
            if (err) {
              observer.onError(err);
              return ;
            }
            var len = arguments.length,
                results = [];
            for (var i = 1; i < len; i++) {
              results[i - 1] = arguments[i];
            }
            if (selector) {
              try {
                results = selector.apply(context, results);
              } catch (e) {
                return observer.onError(e);
              }
              observer.onNext(results);
            } else {
              if (results.length <= 1) {
                observer.onNext.apply(observer, results);
              } else {
                observer.onNext(results);
              }
            }
            observer.onCompleted();
          }
          args.push(handler);
          func.apply(context, args);
        }).publishLast().refCount();
      };
    };
    function createListener(element, name, handler) {
      if (element.addEventListener) {
        element.addEventListener(name, handler, false);
        return disposableCreate(function() {
          element.removeEventListener(name, handler, false);
        });
      }
      throw new Error('No listener found');
    }
    function createEventListener(el, eventName, handler) {
      var disposables = new CompositeDisposable();
      var toStr = Object.prototype.toString;
      if (toStr.call(el) === '[object NodeList]' || toStr.call(el) === '[object HTMLCollection]') {
        for (var i = 0,
            len = el.length; i < len; i++) {
          disposables.add(createEventListener(el.item(i), eventName, handler));
        }
      } else if (el) {
        disposables.add(createListener(el, eventName, handler));
      }
      return disposables;
    }
    Rx.config.useNativeEvents = false;
    Observable.fromEvent = function(element, eventName, selector) {
      if (element.addListener) {
        return fromEventPattern(function(h) {
          element.addListener(eventName, h);
        }, function(h) {
          element.removeListener(eventName, h);
        }, selector);
      }
      if (!Rx.config.useNativeEvents) {
        if (typeof element.on === 'function' && typeof element.off === 'function') {
          return fromEventPattern(function(h) {
            element.on(eventName, h);
          }, function(h) {
            element.off(eventName, h);
          }, selector);
        }
      }
      return new AnonymousObservable(function(observer) {
        return createEventListener(element, eventName, function handler(e) {
          var results = e;
          if (selector) {
            try {
              results = selector(arguments);
            } catch (err) {
              return observer.onError(err);
            }
          }
          observer.onNext(results);
        });
      }).publish().refCount();
    };
    var fromEventPattern = Observable.fromEventPattern = function(addHandler, removeHandler, selector) {
      return new AnonymousObservable(function(observer) {
        function innerHandler(e) {
          var result = e;
          if (selector) {
            try {
              result = selector(arguments);
            } catch (err) {
              return observer.onError(err);
            }
          }
          observer.onNext(result);
        }
        var returnValue = addHandler(innerHandler);
        return disposableCreate(function() {
          if (removeHandler) {
            removeHandler(innerHandler, returnValue);
          }
        });
      }).publish().refCount();
    };
    Observable.startAsync = function(functionAsync) {
      var promise;
      try {
        promise = functionAsync();
      } catch (e) {
        return observableThrow(e);
      }
      return observableFromPromise(promise);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.backpressure", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        AbstractObserver = Rx.internals.AbstractObserver,
        CompositeDisposable = Rx.CompositeDisposable,
        Notification = Rx.Notification,
        Subject = Rx.Subject,
        Observer = Rx.Observer,
        disposableEmpty = Rx.Disposable.empty,
        disposableCreate = Rx.Disposable.create,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        timeoutScheduler = Rx.Scheduler.timeout,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        identity = Rx.helpers.identity,
        isScheduler = Rx.Scheduler.isScheduler,
        isFunction = Rx.helpers.isFunction,
        checkDisposed = Rx.Disposable.checkDisposed;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    Rx.Pauser = (function(__super__) {
      inherits(Pauser, __super__);
      function Pauser() {
        __super__.call(this);
      }
      Pauser.prototype.pause = function() {
        this.onNext(false);
      };
      Pauser.prototype.resume = function() {
        this.onNext(true);
      };
      return Pauser;
    }(Subject));
    var PausableObservable = (function(__super__) {
      inherits(PausableObservable, __super__);
      function subscribe(observer) {
        var conn = this.source.publish(),
            subscription = conn.subscribe(observer),
            connection = disposableEmpty;
        var pausable = this.pauser.distinctUntilChanged().subscribe(function(b) {
          if (b) {
            connection = conn.connect();
          } else {
            connection.dispose();
            connection = disposableEmpty;
          }
        });
        return new CompositeDisposable(subscription, connection, pausable);
      }
      function PausableObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableObservable;
    }(Observable));
    observableProto.pausable = function(pauser) {
      return new PausableObservable(this, pauser);
    };
    function combineLatestSource(source, subject, resultSelector) {
      return new AnonymousObservable(function(o) {
        var hasValue = [false, false],
            hasValueAll = false,
            isDone = false,
            values = new Array(2),
            err;
        function next(x, i) {
          values[i] = x;
          hasValue[i] = true;
          if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
            if (err) {
              return o.onError(err);
            }
            var res = tryCatch(resultSelector).apply(null, values);
            if (res === errorObj) {
              return o.onError(res.e);
            }
            o.onNext(res);
          }
          isDone && values[1] && o.onCompleted();
        }
        return new CompositeDisposable(source.subscribe(function(x) {
          next(x, 0);
        }, function(e) {
          if (values[1]) {
            o.onError(e);
          } else {
            err = e;
          }
        }, function() {
          isDone = true;
          values[1] && o.onCompleted();
        }), subject.subscribe(function(x) {
          next(x, 1);
        }, function(e) {
          o.onError(e);
        }, function() {
          isDone = true;
          next(true, 1);
        }));
      }, source);
    }
    var PausableBufferedObservable = (function(__super__) {
      inherits(PausableBufferedObservable, __super__);
      function subscribe(o) {
        var q = [],
            previousShouldFire;
        function drainQueue() {
          while (q.length > 0) {
            o.onNext(q.shift());
          }
        }
        var subscription = combineLatestSource(this.source, this.pauser.distinctUntilChanged().startWith(false), function(data, shouldFire) {
          return {
            data: data,
            shouldFire: shouldFire
          };
        }).subscribe(function(results) {
          if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              drainQueue();
            }
          } else {
            previousShouldFire = results.shouldFire;
            if (results.shouldFire) {
              o.onNext(results.data);
            } else {
              q.push(results.data);
            }
          }
        }, function(err) {
          drainQueue();
          o.onError(err);
        }, function() {
          drainQueue();
          o.onCompleted();
        });
        return subscription;
      }
      function PausableBufferedObservable(source, pauser) {
        this.source = source;
        this.controller = new Subject();
        if (pauser && pauser.subscribe) {
          this.pauser = this.controller.merge(pauser);
        } else {
          this.pauser = this.controller;
        }
        __super__.call(this, subscribe, source);
      }
      PausableBufferedObservable.prototype.pause = function() {
        this.controller.onNext(false);
      };
      PausableBufferedObservable.prototype.resume = function() {
        this.controller.onNext(true);
      };
      return PausableBufferedObservable;
    }(Observable));
    observableProto.pausableBuffered = function(subject) {
      return new PausableBufferedObservable(this, subject);
    };
    var ControlledObservable = (function(__super__) {
      inherits(ControlledObservable, __super__);
      function subscribe(observer) {
        return this.source.subscribe(observer);
      }
      function ControlledObservable(source, enableQueue, scheduler) {
        __super__.call(this, subscribe, source);
        this.subject = new ControlledSubject(enableQueue, scheduler);
        this.source = source.multicast(this.subject).refCount();
      }
      ControlledObservable.prototype.request = function(numberOfItems) {
        return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
      };
      return ControlledObservable;
    }(Observable));
    var ControlledSubject = (function(__super__) {
      function subscribe(observer) {
        return this.subject.subscribe(observer);
      }
      inherits(ControlledSubject, __super__);
      function ControlledSubject(enableQueue, scheduler) {
        enableQueue == null && (enableQueue = true);
        __super__.call(this, subscribe);
        this.subject = new Subject();
        this.enableQueue = enableQueue;
        this.queue = enableQueue ? [] : null;
        this.requestedCount = 0;
        this.requestedDisposable = disposableEmpty;
        this.error = null;
        this.hasFailed = false;
        this.hasCompleted = false;
        this.scheduler = scheduler || currentThreadScheduler;
      }
      addProperties(ControlledSubject.prototype, Observer, {
        onCompleted: function() {
          this.hasCompleted = true;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onCompleted();
          } else {
            this.queue.push(Notification.createOnCompleted());
          }
        },
        onError: function(error) {
          this.hasFailed = true;
          this.error = error;
          if (!this.enableQueue || this.queue.length === 0) {
            this.subject.onError(error);
          } else {
            this.queue.push(Notification.createOnError(error));
          }
        },
        onNext: function(value) {
          var hasRequested = false;
          if (this.requestedCount === 0) {
            this.enableQueue && this.queue.push(Notification.createOnNext(value));
          } else {
            (this.requestedCount !== -1 && this.requestedCount-- === 0) && this.disposeCurrentRequest();
            hasRequested = true;
          }
          hasRequested && this.subject.onNext(value);
        },
        _processRequest: function(numberOfItems) {
          if (this.enableQueue) {
            while ((this.queue.length >= numberOfItems && numberOfItems > 0) || (this.queue.length > 0 && this.queue[0].kind !== 'N')) {
              var first = this.queue.shift();
              first.accept(this.subject);
              if (first.kind === 'N') {
                numberOfItems--;
              } else {
                this.disposeCurrentRequest();
                this.queue = [];
              }
            }
            return {
              numberOfItems: numberOfItems,
              returnValue: this.queue.length !== 0
            };
          }
          return {
            numberOfItems: numberOfItems,
            returnValue: false
          };
        },
        request: function(number) {
          this.disposeCurrentRequest();
          var self = this;
          this.requestedDisposable = this.scheduler.scheduleWithState(number, function(s, i) {
            var r = self._processRequest(i),
                remaining = r.numberOfItems;
            if (!r.returnValue) {
              self.requestedCount = remaining;
              self.requestedDisposable = disposableCreate(function() {
                self.requestedCount = 0;
              });
            }
          });
          return this.requestedDisposable;
        },
        disposeCurrentRequest: function() {
          this.requestedDisposable.dispose();
          this.requestedDisposable = disposableEmpty;
        }
      });
      return ControlledSubject;
    }(Observable));
    observableProto.controlled = function(enableQueue, scheduler) {
      if (enableQueue && isScheduler(enableQueue)) {
        scheduler = enableQueue;
        enableQueue = true;
      }
      if (enableQueue == null) {
        enableQueue = true;
      }
      return new ControlledObservable(this, enableQueue, scheduler);
    };
    var StopAndWaitObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new StopAndWaitObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(1);
        });
        return this.subscription;
      }
      inherits(StopAndWaitObservable, __super__);
      function StopAndWaitObservable(source) {
        __super__.call(this, subscribe, source);
        this.source = source;
      }
      var StopAndWaitObserver = (function(__sub__) {
        inherits(StopAndWaitObserver, __sub__);
        function StopAndWaitObserver(observer, observable, cancel) {
          __sub__.call(this);
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
        }
        var stopAndWaitObserverProto = StopAndWaitObserver.prototype;
        stopAndWaitObserverProto.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        stopAndWaitObserverProto.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        stopAndWaitObserverProto.next = function(value) {
          this.observer.onNext(value);
          var self = this;
          timeoutScheduler.schedule(function() {
            self.observable.source.request(1);
          });
        };
        stopAndWaitObserverProto.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return StopAndWaitObserver;
      }(AbstractObserver));
      return StopAndWaitObservable;
    }(Observable));
    ControlledObservable.prototype.stopAndWait = function() {
      return new StopAndWaitObservable(this);
    };
    var WindowedObservable = (function(__super__) {
      function subscribe(observer) {
        this.subscription = this.source.subscribe(new WindowedObserver(observer, this, this.subscription));
        var self = this;
        timeoutScheduler.schedule(function() {
          self.source.request(self.windowSize);
        });
        return this.subscription;
      }
      inherits(WindowedObservable, __super__);
      function WindowedObservable(source, windowSize) {
        __super__.call(this, subscribe, source);
        this.source = source;
        this.windowSize = windowSize;
      }
      var WindowedObserver = (function(__sub__) {
        inherits(WindowedObserver, __sub__);
        function WindowedObserver(observer, observable, cancel) {
          this.observer = observer;
          this.observable = observable;
          this.cancel = cancel;
          this.received = 0;
        }
        var windowedObserverPrototype = WindowedObserver.prototype;
        windowedObserverPrototype.completed = function() {
          this.observer.onCompleted();
          this.dispose();
        };
        windowedObserverPrototype.error = function(error) {
          this.observer.onError(error);
          this.dispose();
        };
        windowedObserverPrototype.next = function(value) {
          this.observer.onNext(value);
          this.received = ++this.received % this.observable.windowSize;
          if (this.received === 0) {
            var self = this;
            timeoutScheduler.schedule(function() {
              self.observable.source.request(self.observable.windowSize);
            });
          }
        };
        windowedObserverPrototype.dispose = function() {
          this.observer = null;
          if (this.cancel) {
            this.cancel.dispose();
            this.cancel = null;
          }
          __sub__.prototype.dispose.call(this);
        };
        return WindowedObserver;
      }(AbstractObserver));
      return WindowedObservable;
    }(Observable));
    ControlledObservable.prototype.windowed = function(windowSize) {
      return new WindowedObservable(this, windowSize);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.binding", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        Subject = Rx.Subject,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        ScheduledObserver = Rx.internals.ScheduledObserver,
        disposableCreate = Rx.Disposable.create,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        isFunction = Rx.helpers.isFunction,
        inherits = Rx.internals.inherits,
        addProperties = Rx.internals.addProperties,
        checkDisposed = Rx.Disposable.checkDisposed;
    function cloneArray(arr) {
      var len = arr.length,
          a = new Array(len);
      for (var i = 0; i < len; i++) {
        a[i] = arr[i];
      }
      return a;
    }
    observableProto.multicast = function(subjectOrSubjectSelector, selector) {
      var source = this;
      return typeof subjectOrSubjectSelector === 'function' ? new AnonymousObservable(function(observer) {
        var connectable = source.multicast(subjectOrSubjectSelector());
        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
      }, source) : new ConnectableObservable(source, subjectOrSubjectSelector);
    };
    observableProto.publish = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new Subject();
      }, selector) : this.multicast(new Subject());
    };
    observableProto.share = function() {
      return this.publish().refCount();
    };
    observableProto.publishLast = function(selector) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new AsyncSubject();
      }, selector) : this.multicast(new AsyncSubject());
    };
    observableProto.publishValue = function(initialValueOrSelector, initialValue) {
      return arguments.length === 2 ? this.multicast(function() {
        return new BehaviorSubject(initialValue);
      }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
    };
    observableProto.shareValue = function(initialValue) {
      return this.publishValue(initialValue).refCount();
    };
    observableProto.replay = function(selector, bufferSize, windowSize, scheduler) {
      return selector && isFunction(selector) ? this.multicast(function() {
        return new ReplaySubject(bufferSize, windowSize, scheduler);
      }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
    };
    observableProto.shareReplay = function(bufferSize, windowSize, scheduler) {
      return this.replay(null, bufferSize, windowSize, scheduler).refCount();
    };
    var InnerSubscription = function(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function() {
      if (!this.subject.isDisposed && this.observer !== null) {
        var idx = this.subject.observers.indexOf(this.observer);
        this.subject.observers.splice(idx, 1);
        this.observer = null;
      }
    };
    var BehaviorSubject = Rx.BehaviorSubject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          observer.onNext(this.value);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
        } else {
          observer.onCompleted();
        }
        return disposableEmpty;
      }
      inherits(BehaviorSubject, __super__);
      function BehaviorSubject(value) {
        __super__.call(this, subscribe);
        this.value = value, this.observers = [], this.isDisposed = false, this.isStopped = false, this.hasError = false;
      }
      addProperties(BehaviorSubject.prototype, Observer, {
        getValue: function() {
          checkDisposed(this);
          if (this.hasError) {
            throw this.error;
          }
          return this.value;
        },
        hasObservers: function() {
          return this.observers.length > 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onCompleted();
          }
          this.observers.length = 0;
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          this.hasError = true;
          this.error = error;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onError(error);
          }
          this.observers.length = 0;
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.value = value;
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            os[i].onNext(value);
          }
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
          this.value = null;
          this.exception = null;
        }
      });
      return BehaviorSubject;
    }(Observable));
    var ReplaySubject = Rx.ReplaySubject = (function(__super__) {
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function createRemovableDisposable(subject, observer) {
        return disposableCreate(function() {
          observer.dispose();
          !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
        });
      }
      function subscribe(observer) {
        var so = new ScheduledObserver(this.scheduler, observer),
            subscription = createRemovableDisposable(this, so);
        checkDisposed(this);
        this._trim(this.scheduler.now());
        this.observers.push(so);
        for (var i = 0,
            len = this.q.length; i < len; i++) {
          so.onNext(this.q[i].value);
        }
        if (this.hasError) {
          so.onError(this.error);
        } else if (this.isStopped) {
          so.onCompleted();
        }
        so.ensureActive();
        return subscription;
      }
      inherits(ReplaySubject, __super__);
      function ReplaySubject(bufferSize, windowSize, scheduler) {
        this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
        this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
        this.scheduler = scheduler || currentThreadScheduler;
        this.q = [];
        this.observers = [];
        this.isStopped = false;
        this.isDisposed = false;
        this.hasError = false;
        this.error = null;
        __super__.call(this, subscribe);
      }
      addProperties(ReplaySubject.prototype, Observer.prototype, {
        hasObservers: function() {
          return this.observers.length > 0;
        },
        _trim: function(now) {
          while (this.q.length > this.bufferSize) {
            this.q.shift();
          }
          while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {
            this.q.shift();
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          var now = this.scheduler.now();
          this.q.push({
            interval: now,
            value: value
          });
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onNext(value);
            observer.ensureActive();
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          this.error = error;
          this.hasError = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onError(error);
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.isStopped = true;
          var now = this.scheduler.now();
          this._trim(now);
          for (var i = 0,
              os = cloneArray(this.observers),
              len = os.length; i < len; i++) {
            var observer = os[i];
            observer.onCompleted();
            observer.ensureActive();
          }
          this.observers.length = 0;
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
        }
      });
      return ReplaySubject;
    }(Observable));
    var ConnectableObservable = Rx.ConnectableObservable = (function(__super__) {
      inherits(ConnectableObservable, __super__);
      function ConnectableObservable(source, subject) {
        var hasSubscription = false,
            subscription,
            sourceObservable = source.asObservable();
        this.connect = function() {
          if (!hasSubscription) {
            hasSubscription = true;
            subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function() {
              hasSubscription = false;
            }));
          }
          return subscription;
        };
        __super__.call(this, function(o) {
          return subject.subscribe(o);
        });
      }
      ConnectableObservable.prototype.refCount = function() {
        var connectableSubscription,
            count = 0,
            source = this;
        return new AnonymousObservable(function(observer) {
          var shouldConnect = ++count === 1,
              subscription = source.subscribe(observer);
          shouldConnect && (connectableSubscription = source.connect());
          return function() {
            subscription.dispose();
            --count === 0 && connectableSubscription.dispose();
          };
        });
      };
      return ConnectableObservable;
    }(Observable));
    observableProto.singleInstance = function() {
      var source = this,
          hasObservable = false,
          observable;
      function getObservable() {
        if (!hasObservable) {
          hasObservable = true;
          observable = source.finally(function() {
            hasObservable = false;
          }).publish().refCount();
        }
        return observable;
      }
      ;
      return new AnonymousObservable(function(o) {
        return getObservable().subscribe(o);
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.coincidence", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        Subject = Rx.Subject,
        observableProto = Observable.prototype,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        AnonymousObservable = Rx.AnonymousObservable,
        observerCreate = Rx.Observer.create,
        addRef = Rx.internals.addRef,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        noop = Rx.helpers.noop,
        identity = Rx.helpers.identity,
        isPromise = Rx.helpers.isPromise,
        observableFromPromise = Observable.fromPromise,
        ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError;
    var Dictionary = (function() {
      var primes = [1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593, 16777213, 33554393, 67108859, 134217689, 268435399, 536870909, 1073741789, 2147483647],
          noSuchkey = "no such key",
          duplicatekey = "duplicate key";
      function isPrime(candidate) {
        if ((candidate & 1) === 0) {
          return candidate === 2;
        }
        var num1 = Math.sqrt(candidate),
            num2 = 3;
        while (num2 <= num1) {
          if (candidate % num2 === 0) {
            return false;
          }
          num2 += 2;
        }
        return true;
      }
      function getPrime(min) {
        var index,
            num,
            candidate;
        for (index = 0; index < primes.length; ++index) {
          num = primes[index];
          if (num >= min) {
            return num;
          }
        }
        candidate = min | 1;
        while (candidate < primes[primes.length - 1]) {
          if (isPrime(candidate)) {
            return candidate;
          }
          candidate += 2;
        }
        return min;
      }
      function stringHashFn(str) {
        var hash = 757602046;
        if (!str.length) {
          return hash;
        }
        for (var i = 0,
            len = str.length; i < len; i++) {
          var character = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + character;
          hash = hash & hash;
        }
        return hash;
      }
      function numberHashFn(key) {
        var c2 = 0x27d4eb2d;
        key = (key ^ 61) ^ (key >>> 16);
        key = key + (key << 3);
        key = key ^ (key >>> 4);
        key = key * c2;
        key = key ^ (key >>> 15);
        return key;
      }
      var getHashCode = (function() {
        var uniqueIdCounter = 0;
        return function(obj) {
          if (obj == null) {
            throw new Error(noSuchkey);
          }
          if (typeof obj === 'string') {
            return stringHashFn(obj);
          }
          if (typeof obj === 'number') {
            return numberHashFn(obj);
          }
          if (typeof obj === 'boolean') {
            return obj === true ? 1 : 0;
          }
          if (obj instanceof Date) {
            return numberHashFn(obj.valueOf());
          }
          if (obj instanceof RegExp) {
            return stringHashFn(obj.toString());
          }
          if (typeof obj.valueOf === 'function') {
            var valueOf = obj.valueOf();
            if (typeof valueOf === 'number') {
              return numberHashFn(valueOf);
            }
            if (typeof valueOf === 'string') {
              return stringHashFn(valueOf);
            }
          }
          if (obj.hashCode) {
            return obj.hashCode();
          }
          var id = 17 * uniqueIdCounter++;
          obj.hashCode = function() {
            return id;
          };
          return id;
        };
      }());
      function newEntry() {
        return {
          key: null,
          value: null,
          next: 0,
          hashCode: 0
        };
      }
      function Dictionary(capacity, comparer) {
        if (capacity < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (capacity > 0) {
          this._initialize(capacity);
        }
        this.comparer = comparer || defaultComparer;
        this.freeCount = 0;
        this.size = 0;
        this.freeList = -1;
      }
      var dictionaryProto = Dictionary.prototype;
      dictionaryProto._initialize = function(capacity) {
        var prime = getPrime(capacity),
            i;
        this.buckets = new Array(prime);
        this.entries = new Array(prime);
        for (i = 0; i < prime; i++) {
          this.buckets[i] = -1;
          this.entries[i] = newEntry();
        }
        this.freeList = -1;
      };
      dictionaryProto.add = function(key, value) {
        this._insert(key, value, true);
      };
      dictionaryProto._insert = function(key, value, add) {
        if (!this.buckets) {
          this._initialize(0);
        }
        var index3,
            num = getHashCode(key) & 2147483647,
            index1 = num % this.buckets.length;
        for (var index2 = this.buckets[index1]; index2 >= 0; index2 = this.entries[index2].next) {
          if (this.entries[index2].hashCode === num && this.comparer(this.entries[index2].key, key)) {
            if (add) {
              throw new Error(duplicatekey);
            }
            this.entries[index2].value = value;
            return ;
          }
        }
        if (this.freeCount > 0) {
          index3 = this.freeList;
          this.freeList = this.entries[index3].next;
          --this.freeCount;
        } else {
          if (this.size === this.entries.length) {
            this._resize();
            index1 = num % this.buckets.length;
          }
          index3 = this.size;
          ++this.size;
        }
        this.entries[index3].hashCode = num;
        this.entries[index3].next = this.buckets[index1];
        this.entries[index3].key = key;
        this.entries[index3].value = value;
        this.buckets[index1] = index3;
      };
      dictionaryProto._resize = function() {
        var prime = getPrime(this.size * 2),
            numArray = new Array(prime);
        for (index = 0; index < numArray.length; ++index) {
          numArray[index] = -1;
        }
        var entryArray = new Array(prime);
        for (index = 0; index < this.size; ++index) {
          entryArray[index] = this.entries[index];
        }
        for (var index = this.size; index < prime; ++index) {
          entryArray[index] = newEntry();
        }
        for (var index1 = 0; index1 < this.size; ++index1) {
          var index2 = entryArray[index1].hashCode % prime;
          entryArray[index1].next = numArray[index2];
          numArray[index2] = index1;
        }
        this.buckets = numArray;
        this.entries = entryArray;
      };
      dictionaryProto.remove = function(key) {
        if (this.buckets) {
          var num = getHashCode(key) & 2147483647,
              index1 = num % this.buckets.length,
              index2 = -1;
          for (var index3 = this.buckets[index1]; index3 >= 0; index3 = this.entries[index3].next) {
            if (this.entries[index3].hashCode === num && this.comparer(this.entries[index3].key, key)) {
              if (index2 < 0) {
                this.buckets[index1] = this.entries[index3].next;
              } else {
                this.entries[index2].next = this.entries[index3].next;
              }
              this.entries[index3].hashCode = -1;
              this.entries[index3].next = this.freeList;
              this.entries[index3].key = null;
              this.entries[index3].value = null;
              this.freeList = index3;
              ++this.freeCount;
              return true;
            } else {
              index2 = index3;
            }
          }
        }
        return false;
      };
      dictionaryProto.clear = function() {
        var index,
            len;
        if (this.size <= 0) {
          return ;
        }
        for (index = 0, len = this.buckets.length; index < len; ++index) {
          this.buckets[index] = -1;
        }
        for (index = 0; index < this.size; ++index) {
          this.entries[index] = newEntry();
        }
        this.freeList = -1;
        this.size = 0;
      };
      dictionaryProto._findEntry = function(key) {
        if (this.buckets) {
          var num = getHashCode(key) & 2147483647;
          for (var index = this.buckets[num % this.buckets.length]; index >= 0; index = this.entries[index].next) {
            if (this.entries[index].hashCode === num && this.comparer(this.entries[index].key, key)) {
              return index;
            }
          }
        }
        return -1;
      };
      dictionaryProto.count = function() {
        return this.size - this.freeCount;
      };
      dictionaryProto.tryGetValue = function(key) {
        var entry = this._findEntry(key);
        return entry >= 0 ? this.entries[entry].value : undefined;
      };
      dictionaryProto.getValues = function() {
        var index = 0,
            results = [];
        if (this.entries) {
          for (var index1 = 0; index1 < this.size; index1++) {
            if (this.entries[index1].hashCode >= 0) {
              results[index++] = this.entries[index1].value;
            }
          }
        }
        return results;
      };
      dictionaryProto.get = function(key) {
        var entry = this._findEntry(key);
        if (entry >= 0) {
          return this.entries[entry].value;
        }
        throw new Error(noSuchkey);
      };
      dictionaryProto.set = function(key, value) {
        this._insert(key, value, false);
      };
      dictionaryProto.containskey = function(key) {
        return this._findEntry(key) >= 0;
      };
      return Dictionary;
    }());
    observableProto.join = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(observer) {
        var group = new CompositeDisposable();
        var leftDone = false,
            rightDone = false;
        var leftId = 0,
            rightId = 0;
        var leftMap = new Dictionary(),
            rightMap = new Dictionary();
        group.add(left.subscribe(function(value) {
          var id = leftId++;
          var md = new SingleAssignmentDisposable();
          leftMap.add(id, value);
          group.add(md);
          var expire = function() {
            leftMap.remove(id) && leftMap.count() === 0 && leftDone && observer.onCompleted();
            group.remove(md);
          };
          var duration;
          try {
            duration = leftDurationSelector(value);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
          rightMap.getValues().forEach(function(v) {
            var result;
            try {
              result = resultSelector(value, v);
            } catch (exn) {
              observer.onError(exn);
              return ;
            }
            observer.onNext(result);
          });
        }, observer.onError.bind(observer), function() {
          leftDone = true;
          (rightDone || leftMap.count() === 0) && observer.onCompleted();
        }));
        group.add(right.subscribe(function(value) {
          var id = rightId++;
          var md = new SingleAssignmentDisposable();
          rightMap.add(id, value);
          group.add(md);
          var expire = function() {
            rightMap.remove(id) && rightMap.count() === 0 && rightDone && observer.onCompleted();
            group.remove(md);
          };
          var duration;
          try {
            duration = rightDurationSelector(value);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, observer.onError.bind(observer), expire));
          leftMap.getValues().forEach(function(v) {
            var result;
            try {
              result = resultSelector(v, value);
            } catch (exn) {
              observer.onError(exn);
              return ;
            }
            observer.onNext(result);
          });
        }, observer.onError.bind(observer), function() {
          rightDone = true;
          (leftDone || rightMap.count() === 0) && observer.onCompleted();
        }));
        return group;
      }, left);
    };
    observableProto.groupJoin = function(right, leftDurationSelector, rightDurationSelector, resultSelector) {
      var left = this;
      return new AnonymousObservable(function(observer) {
        var group = new CompositeDisposable();
        var r = new RefCountDisposable(group);
        var leftMap = new Dictionary(),
            rightMap = new Dictionary();
        var leftId = 0,
            rightId = 0;
        function handleError(e) {
          return function(v) {
            v.onError(e);
          };
        }
        ;
        group.add(left.subscribe(function(value) {
          var s = new Subject();
          var id = leftId++;
          leftMap.add(id, s);
          var result;
          try {
            result = resultSelector(value, addRef(s, r));
          } catch (e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          observer.onNext(result);
          rightMap.getValues().forEach(function(v) {
            s.onNext(v);
          });
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var expire = function() {
            leftMap.remove(id) && s.onCompleted();
            group.remove(md);
          };
          var duration;
          try {
            duration = leftDurationSelector(value);
          } catch (e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
          }, expire));
        }, function(e) {
          leftMap.getValues().forEach(handleError(e));
          observer.onError(e);
        }, observer.onCompleted.bind(observer)));
        group.add(right.subscribe(function(value) {
          var id = rightId++;
          rightMap.add(id, value);
          var md = new SingleAssignmentDisposable();
          group.add(md);
          var expire = function() {
            rightMap.remove(id);
            group.remove(md);
          };
          var duration;
          try {
            duration = rightDurationSelector(value);
          } catch (e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          md.setDisposable(duration.take(1).subscribe(noop, function(e) {
            leftMap.getValues().forEach(handleError(e));
            observer.onError(e);
          }, expire));
          leftMap.getValues().forEach(function(v) {
            v.onNext(value);
          });
        }, function(e) {
          leftMap.getValues().forEach(handleError(e));
          observer.onError(e);
        }));
        return r;
      }, left);
    };
    observableProto.buffer = function(bufferOpeningsOrClosingSelector, bufferClosingSelector) {
      return this.window.apply(this, arguments).selectMany(function(x) {
        return x.toArray();
      });
    };
    observableProto.window = function(windowOpeningsOrClosingSelector, windowClosingSelector) {
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);
      }
      return typeof windowOpeningsOrClosingSelector === 'function' ? observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) : observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);
    };
    function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {
      return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function(_, win) {
        return win;
      });
    }
    function observableWindowWithBoundaries(windowBoundaries) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var win = new Subject(),
            d = new CompositeDisposable(),
            r = new RefCountDisposable(d);
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));
        d.add(windowBoundaries.subscribe(function(w) {
          win.onCompleted();
          win = new Subject();
          observer.onNext(addRef(win, r));
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        return r;
      }, source);
    }
    function observableWindowWithClosingSelector(windowClosingSelector) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            r = new RefCountDisposable(d),
            win = new Subject();
        observer.onNext(addRef(win, r));
        d.add(source.subscribe(function(x) {
          win.onNext(x);
        }, function(err) {
          win.onError(err);
          observer.onError(err);
        }, function() {
          win.onCompleted();
          observer.onCompleted();
        }));
        function createWindowClose() {
          var windowClose;
          try {
            windowClose = windowClosingSelector();
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));
          var m1 = new SingleAssignmentDisposable();
          m.setDisposable(m1);
          m1.setDisposable(windowClose.take(1).subscribe(noop, function(err) {
            win.onError(err);
            observer.onError(err);
          }, function() {
            win.onCompleted();
            win = new Subject();
            observer.onNext(addRef(win, r));
            createWindowClose();
          }));
        }
        createWindowClose();
        return r;
      }, source);
    }
    observableProto.pairwise = function() {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var previous,
            hasPrevious = false;
        return source.subscribe(function(x) {
          if (hasPrevious) {
            observer.onNext([previous, x]);
          } else {
            hasPrevious = true;
          }
          previous = x;
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer));
      }, source);
    };
    observableProto.partition = function(predicate, thisArg) {
      return [this.filter(predicate, thisArg), this.filter(function(x, i, o) {
        return !predicate.call(thisArg, x, i, o);
      })];
    };
    observableProto.groupBy = function(keySelector, elementSelector, comparer) {
      return this.groupByUntil(keySelector, elementSelector, observableNever, comparer);
    };
    observableProto.groupByUntil = function(keySelector, elementSelector, durationSelector, comparer) {
      var source = this;
      elementSelector || (elementSelector = identity);
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(observer) {
        function handleError(e) {
          return function(item) {
            item.onError(e);
          };
        }
        var map = new Dictionary(0, comparer),
            groupDisposable = new CompositeDisposable(),
            refCountDisposable = new RefCountDisposable(groupDisposable);
        groupDisposable.add(source.subscribe(function(x) {
          var key;
          try {
            key = keySelector(x);
          } catch (e) {
            map.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          var fireNewMapEntry = false,
              writer = map.tryGetValue(key);
          if (!writer) {
            writer = new Subject();
            map.set(key, writer);
            fireNewMapEntry = true;
          }
          if (fireNewMapEntry) {
            var group = new GroupedObservable(key, writer, refCountDisposable),
                durationGroup = new GroupedObservable(key, writer);
            try {
              duration = durationSelector(durationGroup);
            } catch (e) {
              map.getValues().forEach(handleError(e));
              observer.onError(e);
              return ;
            }
            observer.onNext(group);
            var md = new SingleAssignmentDisposable();
            groupDisposable.add(md);
            var expire = function() {
              map.remove(key) && writer.onCompleted();
              groupDisposable.remove(md);
            };
            md.setDisposable(duration.take(1).subscribe(noop, function(exn) {
              map.getValues().forEach(handleError(exn));
              observer.onError(exn);
            }, expire));
          }
          var element;
          try {
            element = elementSelector(x);
          } catch (e) {
            map.getValues().forEach(handleError(e));
            observer.onError(e);
            return ;
          }
          writer.onNext(element);
        }, function(ex) {
          map.getValues().forEach(handleError(ex));
          observer.onError(ex);
        }, function() {
          map.getValues().forEach(function(item) {
            item.onCompleted();
          });
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    var GroupedObservable = (function(__super__) {
      inherits(GroupedObservable, __super__);
      function subscribe(observer) {
        return this.underlyingObservable.subscribe(observer);
      }
      function GroupedObservable(key, underlyingObservable, mergedDisposable) {
        __super__.call(this, subscribe);
        this.key = key;
        this.underlyingObservable = !mergedDisposable ? underlyingObservable : new AnonymousObservable(function(observer) {
          return new CompositeDisposable(mergedDisposable.getDisposable(), underlyingObservable.subscribe(observer));
        });
      }
      return GroupedObservable;
    }(Observable));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.experimental", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableConcat = Observable.concat,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        disposableEmpty = Rx.Disposable.empty,
        CompositeDisposable = Rx.CompositeDisposable,
        SerialDisposable = Rx.SerialDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        Enumerator = Rx.internals.Enumerator,
        Enumerable = Rx.internals.Enumerable,
        enumerableOf = Enumerable.of,
        immediateScheduler = Rx.Scheduler.immediate,
        currentThreadScheduler = Rx.Scheduler.currentThread,
        slice = Array.prototype.slice,
        AsyncSubject = Rx.AsyncSubject,
        Observer = Rx.Observer,
        inherits = Rx.internals.inherits,
        bindCallback = Rx.internals.bindCallback,
        addProperties = Rx.internals.addProperties,
        helpers = Rx.helpers,
        noop = helpers.noop,
        isPromise = helpers.isPromise,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
      done: true,
      value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
      return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function(o) {
      return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var WhileEnumerable = (function(__super__) {
      inherits(WhileEnumerable, __super__);
      function WhileEnumerable(c, s) {
        this.c = c;
        this.s = s;
      }
      WhileEnumerable.prototype[$iterator$] = function() {
        var self = this;
        return {next: function() {
            return self.c() ? {
              done: false,
              value: self.s
            } : {
              done: true,
              value: void 0
            };
          }};
      };
      return WhileEnumerable;
    }(Enumerable));
    function enumerableWhile(condition, source) {
      return new WhileEnumerable(condition, source);
    }
    observableProto.letBind = observableProto['let'] = function(func) {
      return func(this);
    };
    Observable['if'] = Observable.ifThen = function(condition, thenSource, elseSourceOrScheduler) {
      return observableDefer(function() {
        elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());
        isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));
        isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));
        typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));
        return condition() ? thenSource : elseSourceOrScheduler;
      });
    };
    Observable['for'] = Observable.forIn = function(sources, resultSelector, thisArg) {
      return enumerableOf(sources, resultSelector, thisArg).concat();
    };
    var observableWhileDo = Observable['while'] = Observable.whileDo = function(condition, source) {
      isPromise(source) && (source = observableFromPromise(source));
      return enumerableWhile(condition, source).concat();
    };
    observableProto.doWhile = function(condition) {
      return observableConcat([this, observableWhileDo(condition, this)]);
    };
    Observable['case'] = Observable.switchCase = function(selector, sources, defaultSourceOrScheduler) {
      return observableDefer(function() {
        isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));
        defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());
        typeof defaultSourceOrScheduler.now === 'function' && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));
        var result = sources[selector()];
        isPromise(result) && (result = observableFromPromise(result));
        return result || defaultSourceOrScheduler;
      });
    };
    observableProto.expand = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var q = [],
            m = new SerialDisposable(),
            d = new CompositeDisposable(m),
            activeCount = 0,
            isAcquired = false;
        var ensureActive = function() {
          var isOwner = false;
          if (q.length > 0) {
            isOwner = !isAcquired;
            isAcquired = true;
          }
          if (isOwner) {
            m.setDisposable(scheduler.scheduleRecursive(function(self) {
              var work;
              if (q.length > 0) {
                work = q.shift();
              } else {
                isAcquired = false;
                return ;
              }
              var m1 = new SingleAssignmentDisposable();
              d.add(m1);
              m1.setDisposable(work.subscribe(function(x) {
                observer.onNext(x);
                var result = null;
                try {
                  result = selector(x);
                } catch (e) {
                  observer.onError(e);
                }
                q.push(result);
                activeCount++;
                ensureActive();
              }, observer.onError.bind(observer), function() {
                d.remove(m1);
                activeCount--;
                if (activeCount === 0) {
                  observer.onCompleted();
                }
              }));
              self();
            }));
          }
        };
        q.push(source);
        activeCount++;
        ensureActive();
        return d;
      }, this);
    };
    Observable.forkJoin = function() {
      var allSources = [];
      if (Array.isArray(arguments[0])) {
        allSources = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          allSources.push(arguments[i]);
        }
      }
      return new AnonymousObservable(function(subscriber) {
        var count = allSources.length;
        if (count === 0) {
          subscriber.onCompleted();
          return disposableEmpty;
        }
        var group = new CompositeDisposable(),
            finished = false,
            hasResults = new Array(count),
            hasCompleted = new Array(count),
            results = new Array(count);
        for (var idx = 0; idx < count; idx++) {
          (function(i) {
            var source = allSources[i];
            isPromise(source) && (source = observableFromPromise(source));
            group.add(source.subscribe(function(value) {
              if (!finished) {
                hasResults[i] = true;
                results[i] = value;
              }
            }, function(e) {
              finished = true;
              subscriber.onError(e);
              group.dispose();
            }, function() {
              if (!finished) {
                if (!hasResults[i]) {
                  subscriber.onCompleted();
                  return ;
                }
                hasCompleted[i] = true;
                for (var ix = 0; ix < count; ix++) {
                  if (!hasCompleted[ix]) {
                    return ;
                  }
                }
                finished = true;
                subscriber.onNext(results);
                subscriber.onCompleted();
              }
            }));
          })(idx);
        }
        return group;
      });
    };
    observableProto.forkJoin = function(second, resultSelector) {
      var first = this;
      return new AnonymousObservable(function(observer) {
        var leftStopped = false,
            rightStopped = false,
            hasLeft = false,
            hasRight = false,
            lastLeft,
            lastRight,
            leftSubscription = new SingleAssignmentDisposable(),
            rightSubscription = new SingleAssignmentDisposable();
        isPromise(second) && (second = observableFromPromise(second));
        leftSubscription.setDisposable(first.subscribe(function(left) {
          hasLeft = true;
          lastLeft = left;
        }, function(err) {
          rightSubscription.dispose();
          observer.onError(err);
        }, function() {
          leftStopped = true;
          if (rightStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        rightSubscription.setDisposable(second.subscribe(function(right) {
          hasRight = true;
          lastRight = right;
        }, function(err) {
          leftSubscription.dispose();
          observer.onError(err);
        }, function() {
          rightStopped = true;
          if (leftStopped) {
            if (!hasLeft) {
              observer.onCompleted();
            } else if (!hasRight) {
              observer.onCompleted();
            } else {
              var result;
              try {
                result = resultSelector(lastLeft, lastRight);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
              observer.onCompleted();
            }
          }
        }));
        return new CompositeDisposable(leftSubscription, rightSubscription);
      }, first);
    };
    observableProto.manySelect = observableProto.extend = function(selector, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      var source = this;
      return observableDefer(function() {
        var chain;
        return source.map(function(x) {
          var curr = new ChainObservable(x);
          chain && chain.onNext(x);
          chain = curr;
          return curr;
        }).tap(noop, function(e) {
          chain && chain.onError(e);
        }, function() {
          chain && chain.onCompleted();
        }).observeOn(scheduler).map(selector);
      }, source);
    };
    var ChainObservable = (function(__super__) {
      function subscribe(observer) {
        var self = this,
            g = new CompositeDisposable();
        g.add(currentThreadScheduler.schedule(function() {
          observer.onNext(self.head);
          g.add(self.tail.mergeAll().subscribe(observer));
        }));
        return g;
      }
      inherits(ChainObservable, __super__);
      function ChainObservable(head) {
        __super__.call(this, subscribe);
        this.head = head;
        this.tail = new AsyncSubject();
      }
      addProperties(ChainObservable.prototype, Observer, {
        onCompleted: function() {
          this.onNext(Observable.empty());
        },
        onError: function(e) {
          this.onNext(Observable.throwError(e));
        },
        onNext: function(v) {
          this.tail.onNext(v);
          this.tail.onCompleted();
        }
      });
      return ChainObservable;
    }(Observable));
    observableProto.exclusive = function() {
      var sources = this;
      return new AnonymousObservable(function(observer) {
        var hasCurrent = false,
            isStopped = false,
            m = new SingleAssignmentDisposable(),
            g = new CompositeDisposable();
        g.add(m);
        m.setDisposable(sources.subscribe(function(innerSource) {
          if (!hasCurrent) {
            hasCurrent = true;
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            var innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);
            innerSubscription.setDisposable(innerSource.subscribe(observer.onNext.bind(observer), observer.onError.bind(observer), function() {
              g.remove(innerSubscription);
              hasCurrent = false;
              if (isStopped && g.length === 1) {
                observer.onCompleted();
              }
            }));
          }
        }, observer.onError.bind(observer), function() {
          isStopped = true;
          if (!hasCurrent && g.length === 1) {
            observer.onCompleted();
          }
        }));
        return g;
      }, this);
    };
    observableProto.exclusiveMap = function(selector, thisArg) {
      var sources = this,
          selectorFunc = bindCallback(selector, thisArg, 3);
      return new AnonymousObservable(function(observer) {
        var index = 0,
            hasCurrent = false,
            isStopped = true,
            m = new SingleAssignmentDisposable(),
            g = new CompositeDisposable();
        g.add(m);
        m.setDisposable(sources.subscribe(function(innerSource) {
          if (!hasCurrent) {
            hasCurrent = true;
            innerSubscription = new SingleAssignmentDisposable();
            g.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              var result;
              try {
                result = selectorFunc(x, index++, innerSource);
              } catch (e) {
                observer.onError(e);
                return ;
              }
              observer.onNext(result);
            }, function(e) {
              observer.onError(e);
            }, function() {
              g.remove(innerSubscription);
              hasCurrent = false;
              if (isStopped && g.length === 1) {
                observer.onCompleted();
              }
            }));
          }
        }, function(e) {
          observer.onError(e);
        }, function() {
          isStopped = true;
          if (g.length === 1 && !hasCurrent) {
            observer.onCompleted();
          }
        }));
        return g;
      }, this);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.joinpatterns", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableThrow = Observable.throwError,
        observerCreate = Rx.Observer.create,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        AbstractObserver = Rx.internals.AbstractObserver,
        noop = Rx.helpers.noop,
        defaultComparer = Rx.internals.isEqual,
        inherits = Rx.internals.inherits,
        Enumerable = Rx.internals.Enumerable,
        Enumerator = Rx.internals.Enumerator,
        $iterator$ = Rx.iterator,
        doneEnumerator = Rx.doneEnumerator;
    var Map = root.Map || (function() {
      function Map() {
        this._keys = [];
        this._values = [];
      }
      Map.prototype.get = function(key) {
        var i = this._keys.indexOf(key);
        return i !== -1 ? this._values[i] : undefined;
      };
      Map.prototype.set = function(key, value) {
        var i = this._keys.indexOf(key);
        i !== -1 && (this._values[i] = value);
        this._values[this._keys.push(key) - 1] = value;
      };
      Map.prototype.forEach = function(callback, thisArg) {
        for (var i = 0,
            len = this._keys.length; i < len; i++) {
          callback.call(thisArg, this._values[i], this._keys[i]);
        }
      };
      return Map;
    }());
    function Pattern(patterns) {
      this.patterns = patterns;
    }
    Pattern.prototype.and = function(other) {
      return new Pattern(this.patterns.concat(other));
    };
    Pattern.prototype.thenDo = function(selector) {
      return new Plan(this, selector);
    };
    function Plan(expression, selector) {
      this.expression = expression;
      this.selector = selector;
    }
    Plan.prototype.activate = function(externalSubscriptions, observer, deactivate) {
      var self = this;
      var joinObservers = [];
      for (var i = 0,
          len = this.expression.patterns.length; i < len; i++) {
        joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], observer.onError.bind(observer)));
      }
      var activePlan = new ActivePlan(joinObservers, function() {
        var result;
        try {
          result = self.selector.apply(self, arguments);
        } catch (e) {
          observer.onError(e);
          return ;
        }
        observer.onNext(result);
      }, function() {
        for (var j = 0,
            jlen = joinObservers.length; j < jlen; j++) {
          joinObservers[j].removeActivePlan(activePlan);
        }
        deactivate(activePlan);
      });
      for (i = 0, len = joinObservers.length; i < len; i++) {
        joinObservers[i].addActivePlan(activePlan);
      }
      return activePlan;
    };
    function planCreateObserver(externalSubscriptions, observable, onError) {
      var entry = externalSubscriptions.get(observable);
      if (!entry) {
        var observer = new JoinObserver(observable, onError);
        externalSubscriptions.set(observable, observer);
        return observer;
      }
      return entry;
    }
    function ActivePlan(joinObserverArray, onNext, onCompleted) {
      this.joinObserverArray = joinObserverArray;
      this.onNext = onNext;
      this.onCompleted = onCompleted;
      this.joinObservers = new Map();
      for (var i = 0,
          len = this.joinObserverArray.length; i < len; i++) {
        var joinObserver = this.joinObserverArray[i];
        this.joinObservers.set(joinObserver, joinObserver);
      }
    }
    ActivePlan.prototype.dequeue = function() {
      this.joinObservers.forEach(function(v) {
        v.queue.shift();
      });
    };
    ActivePlan.prototype.match = function() {
      var i,
          len,
          hasValues = true;
      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
        if (this.joinObserverArray[i].queue.length === 0) {
          hasValues = false;
          break;
        }
      }
      if (hasValues) {
        var firstValues = [],
            isCompleted = false;
        for (i = 0, len = this.joinObserverArray.length; i < len; i++) {
          firstValues.push(this.joinObserverArray[i].queue[0]);
          this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);
        }
        if (isCompleted) {
          this.onCompleted();
        } else {
          this.dequeue();
          var values = [];
          for (i = 0, len = firstValues.length; i < firstValues.length; i++) {
            values.push(firstValues[i].value);
          }
          this.onNext.apply(this, values);
        }
      }
    };
    var JoinObserver = (function(__super__) {
      inherits(JoinObserver, __super__);
      function JoinObserver(source, onError) {
        __super__.call(this);
        this.source = source;
        this.onError = onError;
        this.queue = [];
        this.activePlans = [];
        this.subscription = new SingleAssignmentDisposable();
        this.isDisposed = false;
      }
      var JoinObserverPrototype = JoinObserver.prototype;
      JoinObserverPrototype.next = function(notification) {
        if (!this.isDisposed) {
          if (notification.kind === 'E') {
            return this.onError(notification.exception);
          }
          this.queue.push(notification);
          var activePlans = this.activePlans.slice(0);
          for (var i = 0,
              len = activePlans.length; i < len; i++) {
            activePlans[i].match();
          }
        }
      };
      JoinObserverPrototype.error = noop;
      JoinObserverPrototype.completed = noop;
      JoinObserverPrototype.addActivePlan = function(activePlan) {
        this.activePlans.push(activePlan);
      };
      JoinObserverPrototype.subscribe = function() {
        this.subscription.setDisposable(this.source.materialize().subscribe(this));
      };
      JoinObserverPrototype.removeActivePlan = function(activePlan) {
        this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);
        this.activePlans.length === 0 && this.dispose();
      };
      JoinObserverPrototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        if (!this.isDisposed) {
          this.isDisposed = true;
          this.subscription.dispose();
        }
      };
      return JoinObserver;
    }(AbstractObserver));
    observableProto.and = function(right) {
      return new Pattern([this, right]);
    };
    observableProto.thenDo = function(selector) {
      return new Pattern([this]).thenDo(selector);
    };
    Observable.when = function() {
      var len = arguments.length,
          plans;
      if (Array.isArray(arguments[0])) {
        plans = arguments[0];
      } else {
        plans = new Array(len);
        for (var i = 0; i < len; i++) {
          plans[i] = arguments[i];
        }
      }
      return new AnonymousObservable(function(o) {
        var activePlans = [],
            externalSubscriptions = new Map();
        var outObserver = observerCreate(function(x) {
          o.onNext(x);
        }, function(err) {
          externalSubscriptions.forEach(function(v) {
            v.onError(err);
          });
          o.onError(err);
        }, function(x) {
          o.onCompleted();
        });
        try {
          for (var i = 0,
              len = plans.length; i < len; i++) {
            activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function(activePlan) {
              var idx = activePlans.indexOf(activePlan);
              activePlans.splice(idx, 1);
              activePlans.length === 0 && o.onCompleted();
            }));
          }
        } catch (e) {
          observableThrow(e).subscribe(o);
        }
        var group = new CompositeDisposable();
        externalSubscriptions.forEach(function(joinObserver) {
          joinObserver.subscribe();
          group.add(joinObserver);
        });
        return group;
      });
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.sorting", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableNever = Observable.never,
        isEqual = Rx.internals.isEqual,
        defaultSubComparer = Rx.helpers.defaultSubComparer;
    observableProto.jortSort = function() {
      return this.jortSortUntil(observableNever());
    };
    observableProto.jortSortUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var arr = [];
        return source.takeUntil(other).subscribe(arr.push.bind(arr), observer.onError.bind(observer), function() {
          var sorted = arr.slice(0).sort(defaultSubComparer);
          observer.onNext(isEqual(arr, sorted));
          observer.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.virtualtime", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Scheduler = Rx.Scheduler,
        PriorityQueue = Rx.internals.PriorityQueue,
        ScheduledItem = Rx.internals.ScheduledItem,
        SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive,
        disposableEmpty = Rx.Disposable.empty,
        inherits = Rx.internals.inherits,
        defaultSubComparer = Rx.helpers.defaultSubComparer,
        notImplemented = Rx.helpers.notImplemented;
    Rx.VirtualTimeScheduler = (function(__super__) {
      function localNow() {
        return this.toDateTimeOffset(this.clock);
      }
      function scheduleNow(state, action) {
        return this.scheduleAbsoluteWithState(state, this.clock, action);
      }
      function scheduleRelative(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime), action);
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this.scheduleRelativeWithState(state, this.toRelative(dueTime - this.now()), action);
      }
      function invokeAction(scheduler, action) {
        action();
        return disposableEmpty;
      }
      inherits(VirtualTimeScheduler, __super__);
      function VirtualTimeScheduler(initialClock, comparer) {
        this.clock = initialClock;
        this.comparer = comparer;
        this.isEnabled = false;
        this.queue = new PriorityQueue(1024);
        __super__.call(this, localNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      }
      var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;
      VirtualTimeSchedulerPrototype.add = notImplemented;
      VirtualTimeSchedulerPrototype.toDateTimeOffset = notImplemented;
      VirtualTimeSchedulerPrototype.toRelative = notImplemented;
      VirtualTimeSchedulerPrototype.schedulePeriodicWithState = function(state, period, action) {
        var s = new SchedulePeriodicRecursive(this, state, period, action);
        return s.start();
      };
      VirtualTimeSchedulerPrototype.scheduleRelativeWithState = function(state, dueTime, action) {
        var runAt = this.add(this.clock, dueTime);
        return this.scheduleAbsoluteWithState(state, runAt, action);
      };
      VirtualTimeSchedulerPrototype.scheduleRelative = function(dueTime, action) {
        return this.scheduleRelativeWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.start = function() {
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
        }
      };
      VirtualTimeSchedulerPrototype.stop = function() {
        this.isEnabled = false;
      };
      VirtualTimeSchedulerPrototype.advanceTo = function(time) {
        var dueToClock = this.comparer(this.clock, time);
        if (this.comparer(this.clock, time) > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return ;
        }
        if (!this.isEnabled) {
          this.isEnabled = true;
          do {
            var next = this.getNext();
            if (next !== null && this.comparer(next.dueTime, time) <= 0) {
              this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);
              next.invoke();
            } else {
              this.isEnabled = false;
            }
          } while (this.isEnabled);
          this.clock = time;
        }
      };
      VirtualTimeSchedulerPrototype.advanceBy = function(time) {
        var dt = this.add(this.clock, time),
            dueToClock = this.comparer(this.clock, dt);
        if (dueToClock > 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (dueToClock === 0) {
          return ;
        }
        this.advanceTo(dt);
      };
      VirtualTimeSchedulerPrototype.sleep = function(time) {
        var dt = this.add(this.clock, time);
        if (this.comparer(this.clock, dt) >= 0) {
          throw new ArgumentOutOfRangeError();
        }
        this.clock = dt;
      };
      VirtualTimeSchedulerPrototype.getNext = function() {
        while (this.queue.length > 0) {
          var next = this.queue.peek();
          if (next.isCancelled()) {
            this.queue.dequeue();
          } else {
            return next;
          }
        }
        return null;
      };
      VirtualTimeSchedulerPrototype.scheduleAbsolute = function(dueTime, action) {
        return this.scheduleAbsoluteWithState(action, dueTime, invokeAction);
      };
      VirtualTimeSchedulerPrototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        var self = this;
        function run(scheduler, state1) {
          self.queue.remove(si);
          return action(scheduler, state1);
        }
        var si = new ScheduledItem(this, state, run, dueTime, this.comparer);
        this.queue.enqueue(si);
        return si.disposable;
      };
      return VirtualTimeScheduler;
    }(Scheduler));
    Rx.HistoricalScheduler = (function(__super__) {
      inherits(HistoricalScheduler, __super__);
      function HistoricalScheduler(initialClock, comparer) {
        var clock = initialClock == null ? 0 : initialClock;
        var cmp = comparer || defaultSubComparer;
        __super__.call(this, clock, cmp);
      }
      var HistoricalSchedulerProto = HistoricalScheduler.prototype;
      HistoricalSchedulerProto.add = function(absolute, relative) {
        return absolute + relative;
      };
      HistoricalSchedulerProto.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      HistoricalSchedulerProto.toRelative = function(timeSpan) {
        return timeSpan;
      };
      return HistoricalScheduler;
    }(Rx.VirtualTimeScheduler));
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.testing", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx.virtualtime", "exports"], function(Rx, exports) {
        root.Rx = factory(root, exports, Rx);
        return root.Rx;
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observer = Rx.Observer,
        Observable = Rx.Observable,
        Notification = Rx.Notification,
        VirtualTimeScheduler = Rx.VirtualTimeScheduler,
        Disposable = Rx.Disposable,
        disposableEmpty = Disposable.empty,
        disposableCreate = Disposable.create,
        CompositeDisposable = Rx.CompositeDisposable,
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        inherits = Rx.internals.inherits,
        defaultComparer = Rx.internals.isEqual;
    function OnNextPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnNextPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'N') {
        return false;
      }
      return this.predicate(other.value);
    };
    function OnErrorPredicate(predicate) {
      this.predicate = predicate;
    }
    ;
    OnErrorPredicate.prototype.equals = function(other) {
      if (other === this) {
        return true;
      }
      if (other == null) {
        return false;
      }
      if (other.kind !== 'E') {
        return false;
      }
      return this.predicate(other.exception);
    };
    var ReactiveTest = Rx.ReactiveTest = {
      created: 100,
      subscribed: 200,
      disposed: 1000,
      onNext: function(ticks, value) {
        return typeof value === 'function' ? new Recorded(ticks, new OnNextPredicate(value)) : new Recorded(ticks, Notification.createOnNext(value));
      },
      onError: function(ticks, error) {
        return typeof error === 'function' ? new Recorded(ticks, new OnErrorPredicate(error)) : new Recorded(ticks, Notification.createOnError(error));
      },
      onCompleted: function(ticks) {
        return new Recorded(ticks, Notification.createOnCompleted());
      },
      subscribe: function(start, end) {
        return new Subscription(start, end);
      }
    };
    var Recorded = Rx.Recorded = function(time, value, comparer) {
      this.time = time;
      this.value = value;
      this.comparer = comparer || defaultComparer;
    };
    Recorded.prototype.equals = function(other) {
      return this.time === other.time && this.comparer(this.value, other.value);
    };
    Recorded.prototype.toString = function() {
      return this.value.toString() + '@' + this.time;
    };
    var Subscription = Rx.Subscription = function(start, end) {
      this.subscribe = start;
      this.unsubscribe = end || Number.MAX_VALUE;
    };
    Subscription.prototype.equals = function(other) {
      return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;
    };
    Subscription.prototype.toString = function() {
      return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';
    };
    var MockDisposable = Rx.MockDisposable = function(scheduler) {
      this.scheduler = scheduler;
      this.disposes = [];
      this.disposes.push(this.scheduler.clock);
    };
    MockDisposable.prototype.dispose = function() {
      this.disposes.push(this.scheduler.clock);
    };
    var MockObserver = (function(__super__) {
      inherits(MockObserver, __super__);
      function MockObserver(scheduler) {
        __super__.call(this);
        this.scheduler = scheduler;
        this.messages = [];
      }
      var MockObserverPrototype = MockObserver.prototype;
      MockObserverPrototype.onNext = function(value) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));
      };
      MockObserverPrototype.onError = function(exception) {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(exception)));
      };
      MockObserverPrototype.onCompleted = function() {
        this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));
      };
      return MockObserver;
    })(Observer);
    function MockPromise(scheduler, messages) {
      var self = this;
      this.scheduler = scheduler;
      this.messages = messages;
      this.subscriptions = [];
      this.observers = [];
      for (var i = 0,
          len = this.messages.length; i < len; i++) {
        var message = this.messages[i],
            notification = message.value;
        (function(innerNotification) {
          scheduler.scheduleAbsoluteWithState(null, message.time, function() {
            var obs = self.observers.slice(0);
            for (var j = 0,
                jLen = obs.length; j < jLen; j++) {
              innerNotification.accept(obs[j]);
            }
            return disposableEmpty;
          });
        })(notification);
      }
    }
    MockPromise.prototype.then = function(onResolved, onRejected) {
      var self = this;
      this.subscriptions.push(new Subscription(this.scheduler.clock));
      var index = this.subscriptions.length - 1;
      var newPromise;
      var observer = Rx.Observer.create(function(x) {
        var retValue = onResolved(x);
        if (retValue && typeof retValue.then === 'function') {
          newPromise = retValue;
        } else {
          var ticks = self.scheduler.clock;
          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);
        }
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      }, function(err) {
        onRejected(err);
        var idx = self.observers.indexOf(observer);
        self.observers.splice(idx, 1);
        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);
      });
      this.observers.push(observer);
      return newPromise || new MockPromise(this.scheduler, this.messages);
    };
    var HotObservable = (function(__super__) {
      function subscribe(observer) {
        var observable = this;
        this.observers.push(observer);
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        return disposableCreate(function() {
          var idx = observable.observers.indexOf(observer);
          observable.observers.splice(idx, 1);
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
        });
      }
      inherits(HotObservable, __super__);
      function HotObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        var message,
            notification,
            observable = this;
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
        this.observers = [];
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            scheduler.scheduleAbsoluteWithState(null, message.time, function() {
              var obs = observable.observers.slice(0);
              for (var j = 0,
                  jLen = obs.length; j < jLen; j++) {
                innerNotification.accept(obs[j]);
              }
              return disposableEmpty;
            });
          })(notification);
        }
      }
      return HotObservable;
    })(Observable);
    var ColdObservable = (function(__super__) {
      function subscribe(observer) {
        var message,
            notification,
            observable = this;
        this.subscriptions.push(new Subscription(this.scheduler.clock));
        var index = this.subscriptions.length - 1;
        var d = new CompositeDisposable();
        for (var i = 0,
            len = this.messages.length; i < len; i++) {
          message = this.messages[i];
          notification = message.value;
          (function(innerNotification) {
            d.add(observable.scheduler.scheduleRelativeWithState(null, message.time, function() {
              innerNotification.accept(observer);
              return disposableEmpty;
            }));
          })(notification);
        }
        return disposableCreate(function() {
          observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);
          d.dispose();
        });
      }
      inherits(ColdObservable, __super__);
      function ColdObservable(scheduler, messages) {
        __super__.call(this, subscribe);
        this.scheduler = scheduler;
        this.messages = messages;
        this.subscriptions = [];
      }
      return ColdObservable;
    })(Observable);
    Rx.TestScheduler = (function(__super__) {
      inherits(TestScheduler, __super__);
      function baseComparer(x, y) {
        return x > y ? 1 : (x < y ? -1 : 0);
      }
      function TestScheduler() {
        __super__.call(this, 0, baseComparer);
      }
      TestScheduler.prototype.scheduleAbsoluteWithState = function(state, dueTime, action) {
        dueTime <= this.clock && (dueTime = this.clock + 1);
        return __super__.prototype.scheduleAbsoluteWithState.call(this, state, dueTime, action);
      };
      TestScheduler.prototype.add = function(absolute, relative) {
        return absolute + relative;
      };
      TestScheduler.prototype.toDateTimeOffset = function(absolute) {
        return new Date(absolute).getTime();
      };
      TestScheduler.prototype.toRelative = function(timeSpan) {
        return timeSpan;
      };
      TestScheduler.prototype.startWithTiming = function(create, created, subscribed, disposed) {
        var observer = this.createObserver(),
            source,
            subscription;
        this.scheduleAbsoluteWithState(null, created, function() {
          source = create();
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, subscribed, function() {
          subscription = source.subscribe(observer);
          return disposableEmpty;
        });
        this.scheduleAbsoluteWithState(null, disposed, function() {
          subscription.dispose();
          return disposableEmpty;
        });
        this.start();
        return observer;
      };
      TestScheduler.prototype.startWithDispose = function(create, disposed) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, disposed);
      };
      TestScheduler.prototype.startWithCreate = function(create) {
        return this.startWithTiming(create, ReactiveTest.created, ReactiveTest.subscribed, ReactiveTest.disposed);
      };
      TestScheduler.prototype.createHotObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new HotObservable(this, args);
      };
      TestScheduler.prototype.createColdObservable = function() {
        var len = arguments.length,
            args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ColdObservable(this, args);
      };
      TestScheduler.prototype.createResolvedPromise = function(ticks, value) {
        return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);
      };
      TestScheduler.prototype.createRejectedPromise = function(ticks, reason) {
        return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);
      };
      TestScheduler.prototype.createObserver = function() {
        return new MockObserver(this);
      };
      return TestScheduler;
    })(VirtualTimeScheduler);
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx.time", ["npm:rx@2.5.3/dist/rx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function(factory) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    if (typeof define === 'function' && define.amd) {
      define(["rx"], function(Rx, exports) {
        return factory(root, exports, Rx);
      });
    } else if (typeof module === 'object' && module && module.exports === freeExports) {
      module.exports = factory(root, module.exports, require("npm:rx@2.5.3/dist/rx"));
    } else {
      root.Rx = factory(root, {}, root.Rx);
    }
  }.call(this, function(root, exp, Rx, undefined) {
    var Observable = Rx.Observable,
        observableProto = Observable.prototype,
        AnonymousObservable = Rx.AnonymousObservable,
        observableDefer = Observable.defer,
        observableEmpty = Observable.empty,
        observableNever = Observable.never,
        observableThrow = Observable.throwException,
        observableFromArray = Observable.fromArray,
        timeoutScheduler = Rx.Scheduler['default'],
        SingleAssignmentDisposable = Rx.SingleAssignmentDisposable,
        SerialDisposable = Rx.SerialDisposable,
        CompositeDisposable = Rx.CompositeDisposable,
        RefCountDisposable = Rx.RefCountDisposable,
        Subject = Rx.Subject,
        addRef = Rx.internals.addRef,
        normalizeTime = Rx.Scheduler.normalize,
        helpers = Rx.helpers,
        isPromise = helpers.isPromise,
        isFunction = helpers.isFunction,
        isScheduler = Rx.Scheduler.isScheduler,
        observableFromPromise = Observable.fromPromise;
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function observableTimerDate(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithAbsolute(dueTime, function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerDateAndPeriod(dueTime, period, scheduler) {
      return new AnonymousObservable(function(observer) {
        var d = dueTime,
            p = normalizeTime(period);
        return scheduler.scheduleRecursiveWithAbsoluteAndState(0, d, function(count, self) {
          if (p > 0) {
            var now = scheduler.now();
            d = d + p;
            d <= now && (d = now + p);
          }
          observer.onNext(count);
          self(count + 1, d);
        });
      });
    }
    function observableTimerTimeSpan(dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithRelative(normalizeTime(dueTime), function() {
          observer.onNext(0);
          observer.onCompleted();
        });
      });
    }
    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
      return dueTime === period ? new AnonymousObservable(function(observer) {
        return scheduler.schedulePeriodicWithState(0, period, function(count) {
          observer.onNext(count);
          return count + 1;
        });
      }) : observableDefer(function() {
        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
      });
    }
    var observableinterval = Observable.interval = function(period, scheduler) {
      return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
    };
    var observableTimer = Observable.timer = function(dueTime, periodOrScheduler, scheduler) {
      var period;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (periodOrScheduler !== undefined && typeof periodOrScheduler === 'number') {
        period = periodOrScheduler;
      } else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }
      if (dueTime instanceof Date && period === undefined) {
        return observableTimerDate(dueTime.getTime(), scheduler);
      }
      if (dueTime instanceof Date && period !== undefined) {
        period = periodOrScheduler;
        return observableTimerDateAndPeriod(dueTime.getTime(), period, scheduler);
      }
      return period === undefined ? observableTimerTimeSpan(dueTime, scheduler) : observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
    };
    function observableDelayTimeSpan(source, dueTime, scheduler) {
      return new AnonymousObservable(function(observer) {
        var active = false,
            cancelable = new SerialDisposable(),
            exception = null,
            q = [],
            running = false,
            subscription;
        subscription = source.materialize().timestamp(scheduler).subscribe(function(notification) {
          var d,
              shouldRun;
          if (notification.value.kind === 'E') {
            q = [];
            q.push(notification);
            exception = notification.value.exception;
            shouldRun = !running;
          } else {
            q.push({
              value: notification.value,
              timestamp: notification.timestamp + dueTime
            });
            shouldRun = !active;
            active = true;
          }
          if (shouldRun) {
            if (exception !== null) {
              observer.onError(exception);
            } else {
              d = new SingleAssignmentDisposable();
              cancelable.setDisposable(d);
              d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function(self) {
                var e,
                    recurseDueTime,
                    result,
                    shouldRecurse;
                if (exception !== null) {
                  return ;
                }
                running = true;
                do {
                  result = null;
                  if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                    result = q.shift().value;
                  }
                  if (result !== null) {
                    result.accept(observer);
                  }
                } while (result !== null);
                shouldRecurse = false;
                recurseDueTime = 0;
                if (q.length > 0) {
                  shouldRecurse = true;
                  recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
                } else {
                  active = false;
                }
                e = exception;
                running = false;
                if (e !== null) {
                  observer.onError(e);
                } else if (shouldRecurse) {
                  self(recurseDueTime);
                }
              }));
            }
          }
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    }
    function observableDelayDate(source, dueTime, scheduler) {
      return observableDefer(function() {
        return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);
      });
    }
    observableProto.delay = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return dueTime instanceof Date ? observableDelayDate(this, dueTime.getTime(), scheduler) : observableDelayTimeSpan(this, dueTime, scheduler);
    };
    observableProto.debounce = observableProto.throttleWithTimeout = function(dueTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(observer) {
        var cancelable = new SerialDisposable(),
            hasvalue = false,
            value,
            id = 0;
        var subscription = source.subscribe(function(x) {
          hasvalue = true;
          value = x;
          id++;
          var currentId = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function() {
            hasvalue && id === currentId && observer.onNext(value);
            hasvalue = false;
          }));
        }, function(e) {
          cancelable.dispose();
          observer.onError(e);
          hasvalue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasvalue && observer.onNext(value);
          observer.onCompleted();
          hasvalue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, this);
    };
    observableProto.throttle = function(dueTime, scheduler) {
      return this.debounce(dueTime, scheduler);
    };
    observableProto.windowWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      var source = this,
          timeShift;
      timeShiftOrScheduler == null && (timeShift = timeSpan);
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      if (typeof timeShiftOrScheduler === 'number') {
        timeShift = timeShiftOrScheduler;
      } else if (isScheduler(timeShiftOrScheduler)) {
        timeShift = timeSpan;
        scheduler = timeShiftOrScheduler;
      }
      return new AnonymousObservable(function(observer) {
        var groupDisposable,
            nextShift = timeShift,
            nextSpan = timeSpan,
            q = [],
            refCountDisposable,
            timerD = new SerialDisposable(),
            totalTime = 0;
        groupDisposable = new CompositeDisposable(timerD), refCountDisposable = new RefCountDisposable(groupDisposable);
        function createTimer() {
          var m = new SingleAssignmentDisposable(),
              isSpan = false,
              isShift = false;
          timerD.setDisposable(m);
          if (nextSpan === nextShift) {
            isSpan = true;
            isShift = true;
          } else if (nextSpan < nextShift) {
            isSpan = true;
          } else {
            isShift = true;
          }
          var newTotalTime = isSpan ? nextSpan : nextShift,
              ts = newTotalTime - totalTime;
          totalTime = newTotalTime;
          if (isSpan) {
            nextSpan += timeShift;
          }
          if (isShift) {
            nextShift += timeShift;
          }
          m.setDisposable(scheduler.scheduleWithRelative(ts, function() {
            if (isShift) {
              var s = new Subject();
              q.push(s);
              observer.onNext(addRef(s, refCountDisposable));
            }
            isSpan && q.shift().onCompleted();
            createTimer();
          }));
        }
        ;
        q.push(new Subject());
        observer.onNext(addRef(q[0], refCountDisposable));
        createTimer();
        groupDisposable.add(source.subscribe(function(x) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onNext(x);
          }
        }, function(e) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onError(e);
          }
          observer.onError(e);
        }, function() {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onCompleted();
          }
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    observableProto.windowWithTimeOrCount = function(timeSpan, count, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var timerD = new SerialDisposable(),
            groupDisposable = new CompositeDisposable(timerD),
            refCountDisposable = new RefCountDisposable(groupDisposable),
            n = 0,
            windowId = 0,
            s = new Subject();
        function createTimer(id) {
          var m = new SingleAssignmentDisposable();
          timerD.setDisposable(m);
          m.setDisposable(scheduler.scheduleWithRelative(timeSpan, function() {
            if (id !== windowId) {
              return ;
            }
            n = 0;
            var newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
            createTimer(newId);
          }));
        }
        observer.onNext(addRef(s, refCountDisposable));
        createTimer(0);
        groupDisposable.add(source.subscribe(function(x) {
          var newId = 0,
              newWindow = false;
          s.onNext(x);
          if (++n === count) {
            newWindow = true;
            n = 0;
            newId = ++windowId;
            s.onCompleted();
            s = new Subject();
            observer.onNext(addRef(s, refCountDisposable));
          }
          newWindow && createTimer(newId);
        }, function(e) {
          s.onError(e);
          observer.onError(e);
        }, function() {
          s.onCompleted();
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    observableProto.bufferWithTime = function(timeSpan, timeShiftOrScheduler, scheduler) {
      return this.windowWithTime.apply(this, arguments).selectMany(function(x) {
        return x.toArray();
      });
    };
    observableProto.bufferWithTimeOrCount = function(timeSpan, count, scheduler) {
      return this.windowWithTimeOrCount(timeSpan, count, scheduler).selectMany(function(x) {
        return x.toArray();
      });
    };
    observableProto.timeInterval = function(scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return observableDefer(function() {
        var last = scheduler.now();
        return source.map(function(x) {
          var now = scheduler.now(),
              span = now - last;
          last = now;
          return {
            value: x,
            interval: span
          };
        });
      });
    };
    observableProto.timestamp = function(scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return this.map(function(x) {
        return {
          value: x,
          timestamp: scheduler.now()
        };
      });
    };
    function sampleObservable(source, sampler) {
      return new AnonymousObservable(function(o) {
        var atEnd = false,
            value,
            hasValue = false;
        function sampleSubscribe() {
          if (hasValue) {
            hasValue = false;
            o.onNext(value);
          }
          atEnd && o.onCompleted();
        }
        var sourceSubscription = new SingleAssignmentDisposable();
        sourceSubscription.setDisposable(source.subscribe(function(newValue) {
          hasValue = true;
          value = newValue;
        }, function(e) {
          o.onError(e);
        }, function() {
          atEnd = true;
          sourceSubscription.dispose();
        }));
        return new CompositeDisposable(sourceSubscription, sampler.subscribe(sampleSubscribe, function(e) {
          o.onError(e);
        }, sampleSubscribe));
      }, source);
    }
    observableProto.sample = observableProto.throttleLatest = function(intervalOrSampler, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return typeof intervalOrSampler === 'number' ? sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : sampleObservable(this, intervalOrSampler);
    };
    observableProto.timeout = function(dueTime, other, scheduler) {
      (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(observer) {
        var id = 0,
            original = new SingleAssignmentDisposable(),
            subscription = new SerialDisposable(),
            switched = false,
            timer = new SerialDisposable();
        subscription.setDisposable(original);
        function createTimer() {
          var myId = id;
          timer.setDisposable(scheduler[schedulerMethod](dueTime, function() {
            if (id === myId) {
              isPromise(other) && (other = observableFromPromise(other));
              subscription.setDisposable(other.subscribe(observer));
            }
          }));
        }
        createTimer();
        original.setDisposable(source.subscribe(function(x) {
          if (!switched) {
            id++;
            observer.onNext(x);
            createTimer();
          }
        }, function(e) {
          if (!switched) {
            id++;
            observer.onError(e);
          }
        }, function() {
          if (!switched) {
            id++;
            observer.onCompleted();
          }
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    Observable.generateWithAbsoluteTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithAbsoluteAndState(initialState, scheduler.now(), function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return ;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    Observable.generateWithRelativeTime = function(initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var first = true,
            hasResult = false;
        return scheduler.scheduleRecursiveWithRelativeAndState(initialState, 0, function(state, self) {
          hasResult && observer.onNext(state);
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            if (hasResult) {
              var result = resultSelector(state);
              var time = timeSelector(state);
            }
          } catch (e) {
            observer.onError(e);
            return ;
          }
          if (hasResult) {
            self(result, time);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    observableProto.delaySubscription = function(dueTime, scheduler) {
      var scheduleMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var d = new SerialDisposable();
        d.setDisposable(scheduler[scheduleMethod](dueTime, function() {
          d.setDisposable(source.subscribe(o));
        }));
        return d;
      }, this);
    };
    observableProto.delayWithSelector = function(subscriptionDelay, delayDurationSelector) {
      var source = this,
          subDelay,
          selector;
      if (isFunction(subscriptionDelay)) {
        selector = subscriptionDelay;
      } else {
        subDelay = subscriptionDelay;
        selector = delayDurationSelector;
      }
      return new AnonymousObservable(function(observer) {
        var delays = new CompositeDisposable(),
            atEnd = false,
            subscription = new SerialDisposable();
        function start() {
          subscription.setDisposable(source.subscribe(function(x) {
            var delay = tryCatch(selector)(x);
            if (delay === errorObj) {
              return observer.onError(delay.e);
            }
            var d = new SingleAssignmentDisposable();
            delays.add(d);
            d.setDisposable(delay.subscribe(function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }, function(e) {
              observer.onError(e);
            }, function() {
              observer.onNext(x);
              delays.remove(d);
              done();
            }));
          }, function(e) {
            observer.onError(e);
          }, function() {
            atEnd = true;
            subscription.dispose();
            done();
          }));
        }
        function done() {
          atEnd && delays.length === 0 && observer.onCompleted();
        }
        if (!subDelay) {
          start();
        } else {
          subscription.setDisposable(subDelay.subscribe(start, function(e) {
            observer.onError(e);
          }, start));
        }
        return new CompositeDisposable(subscription, delays);
      }, this);
    };
    observableProto.timeoutWithSelector = function(firstTimeout, timeoutdurationSelector, other) {
      if (arguments.length === 1) {
        timeoutdurationSelector = firstTimeout;
        firstTimeout = observableNever();
      }
      other || (other = observableThrow(new Error('Timeout')));
      var source = this;
      return new AnonymousObservable(function(observer) {
        var subscription = new SerialDisposable(),
            timer = new SerialDisposable(),
            original = new SingleAssignmentDisposable();
        subscription.setDisposable(original);
        var id = 0,
            switched = false;
        function setTimer(timeout) {
          var myId = id;
          function timerWins() {
            return id === myId;
          }
          var d = new SingleAssignmentDisposable();
          timer.setDisposable(d);
          d.setDisposable(timeout.subscribe(function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
            d.dispose();
          }, function(e) {
            timerWins() && observer.onError(e);
          }, function() {
            timerWins() && subscription.setDisposable(other.subscribe(observer));
          }));
        }
        ;
        setTimer(firstTimeout);
        function observerWins() {
          var res = !switched;
          if (res) {
            id++;
          }
          return res;
        }
        original.setDisposable(source.subscribe(function(x) {
          if (observerWins()) {
            observer.onNext(x);
            var timeout;
            try {
              timeout = timeoutdurationSelector(x);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
          }
        }, function(e) {
          observerWins() && observer.onError(e);
        }, function() {
          observerWins() && observer.onCompleted();
        }));
        return new CompositeDisposable(subscription, timer);
      }, source);
    };
    observableProto.debounceWithSelector = function(durationSelector) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var value,
            hasValue = false,
            cancelable = new SerialDisposable(),
            id = 0;
        var subscription = source.subscribe(function(x) {
          var throttle;
          try {
            throttle = durationSelector(x);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(throttle) && (throttle = observableFromPromise(throttle));
          hasValue = true;
          value = x;
          id++;
          var currentid = id,
              d = new SingleAssignmentDisposable();
          cancelable.setDisposable(d);
          d.setDisposable(throttle.subscribe(function() {
            hasValue && id === currentid && observer.onNext(value);
            hasValue = false;
            d.dispose();
          }, observer.onError.bind(observer), function() {
            hasValue && id === currentid && observer.onNext(value);
            hasValue = false;
            d.dispose();
          }));
        }, function(e) {
          cancelable.dispose();
          observer.onError(e);
          hasValue = false;
          id++;
        }, function() {
          cancelable.dispose();
          hasValue && observer.onNext(value);
          observer.onCompleted();
          hasValue = false;
          id++;
        });
        return new CompositeDisposable(subscription, cancelable);
      }, source);
    };
    observableProto.throttleWithSelector = function(durationSelector) {
      return this.debounceWithSelector(durationSelector);
    };
    observableProto.skipLastWithTime = function(duration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0 && now - q[0].interval >= duration) {
            o.onNext(q.shift().value);
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now();
          while (q.length > 0) {
            var next = q.shift();
            if (now - next.interval <= duration) {
              o.onNext(next.value);
            }
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastBufferWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          var now = scheduler.now();
          q.push({
            interval: now,
            value: x
          });
          while (q.length > 0 && now - q[0].interval >= duration) {
            q.shift();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          var now = scheduler.now(),
              res = [];
          while (q.length > 0) {
            var next = q.shift();
            now - next.interval <= duration && res.push(next.value);
          }
          o.onNext(res);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.skipWithTime = function(duration, scheduler) {
      var source = this;
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      return new AnonymousObservable(function(observer) {
        var open = false;
        return new CompositeDisposable(scheduler.scheduleWithRelative(duration, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && observer.onNext(x);
        }, observer.onError.bind(observer), observer.onCompleted.bind(observer)));
      }, source);
    };
    observableProto.skipUntilWithTime = function(startTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = startTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        var open = false;
        return new CompositeDisposable(scheduler[schedulerMethod](startTime, function() {
          open = true;
        }), source.subscribe(function(x) {
          open && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        }));
      }, source);
    };
    observableProto.takeUntilWithTime = function(endTime, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var source = this,
          schedulerMethod = endTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
      return new AnonymousObservable(function(o) {
        return new CompositeDisposable(scheduler[schedulerMethod](endTime, function() {
          o.onCompleted();
        }), source.subscribe(o));
      }, source);
    };
    observableProto.throttleFirst = function(windowDuration, scheduler) {
      isScheduler(scheduler) || (scheduler = timeoutScheduler);
      var duration = +windowDuration || 0;
      if (duration <= 0) {
        throw new RangeError('windowDuration cannot be less or equal zero.');
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var lastOnNext = 0;
        return source.subscribe(function(x) {
          var now = scheduler.now();
          if (lastOnNext === 0 || now - lastOnNext >= duration) {
            lastOnNext = now;
            o.onNext(x);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    return Rx;
  }));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.wks", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.shared", "npm:core-js@0.9.14/library/modules/$.uid"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var global = require("npm:core-js@0.9.14/library/modules/$").g,
      store = require("npm:core-js@0.9.14/library/modules/$.shared")('wks');
  module.exports = function(name) {
    return store[name] || (store[name] = global.Symbol && global.Symbol[name] || require("npm:core-js@0.9.14/library/modules/$.uid").safe('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.iter", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.cof", "npm:core-js@0.9.14/library/modules/$.assert", "npm:core-js@0.9.14/library/modules/$.wks", "npm:core-js@0.9.14/library/modules/$.shared"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      cof = require("npm:core-js@0.9.14/library/modules/$.cof"),
      classof = cof.classof,
      assert = require("npm:core-js@0.9.14/library/modules/$.assert"),
      assertObject = assert.obj,
      SYMBOL_ITERATOR = require("npm:core-js@0.9.14/library/modules/$.wks")('iterator'),
      FF_ITERATOR = '@@iterator',
      Iterators = require("npm:core-js@0.9.14/library/modules/$.shared")('iterators'),
      IteratorPrototype = {};
  setIterator(IteratorPrototype, $.that);
  function setIterator(O, value) {
    $.hide(O, SYMBOL_ITERATOR, value);
    if (FF_ITERATOR in [])
      $.hide(O, FF_ITERATOR, value);
  }
  module.exports = {
    BUGGY: 'keys' in [] && !('next' in [].keys()),
    Iterators: Iterators,
    step: function(done, value) {
      return {
        value: value,
        done: !!done
      };
    },
    is: function(it) {
      var O = Object(it),
          Symbol = $.g.Symbol;
      return (Symbol && Symbol.iterator || FF_ITERATOR) in O || SYMBOL_ITERATOR in O || $.has(Iterators, classof(O));
    },
    get: function(it) {
      var Symbol = $.g.Symbol,
          getIter;
      if (it != undefined) {
        getIter = it[Symbol && Symbol.iterator || FF_ITERATOR] || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
      }
      assert($.isFunction(getIter), it, ' is not iterable!');
      return assertObject(getIter.call(it));
    },
    set: setIterator,
    create: function(Constructor, NAME, next, proto) {
      Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});
      cof.set(Constructor, NAME + ' Iterator');
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.iter-define", ["npm:core-js@0.9.14/library/modules/$.def", "npm:core-js@0.9.14/library/modules/$.redef", "npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.cof", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@0.9.14/library/modules/$.def"),
      $redef = require("npm:core-js@0.9.14/library/modules/$.redef"),
      $ = require("npm:core-js@0.9.14/library/modules/$"),
      cof = require("npm:core-js@0.9.14/library/modules/$.cof"),
      $iter = require("npm:core-js@0.9.14/library/modules/$.iter"),
      SYMBOL_ITERATOR = require("npm:core-js@0.9.14/library/modules/$.wks")('iterator'),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values',
      Iterators = $iter.Iterators;
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE) {
    $iter.create(Constructor, NAME, next);
    function createMethod(kind) {
      function $$(that) {
        return new Constructor(that, kind);
      }
      switch (kind) {
        case KEYS:
          return function keys() {
            return $$(this);
          };
        case VALUES:
          return function values() {
            return $$(this);
          };
      }
      return function entries() {
        return $$(this);
      };
    }
    var TAG = NAME + ' Iterator',
        proto = Base.prototype,
        _native = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        _default = _native || createMethod(DEFAULT),
        methods,
        key;
    if (_native) {
      var IteratorPrototype = $.getProto(_default.call(new Base));
      cof.set(IteratorPrototype, TAG, true);
      if ($.FW && $.has(proto, FF_ITERATOR))
        $iter.set(IteratorPrototype, $.that);
    }
    if ($.FW)
      $iter.set(proto, _default);
    Iterators[NAME] = _default;
    Iterators[TAG] = $.that;
    if (DEFAULT) {
      methods = {
        keys: IS_SET ? _default : createMethod(KEYS),
        values: DEFAULT == VALUES ? _default : createMethod(VALUES),
        entries: DEFAULT != VALUES ? _default : createMethod('entries')
      };
      if (FORCE)
        for (key in methods) {
          if (!(key in proto))
            $redef(proto, key, methods[key]);
        }
      else
        $def($def.P + $def.F * $iter.BUGGY, NAME, methods);
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.string.iterator", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.string-at", "npm:core-js@0.9.14/library/modules/$.uid", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.iter-define"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var set = require("npm:core-js@0.9.14/library/modules/$").set,
      $at = require("npm:core-js@0.9.14/library/modules/$.string-at")(true),
      ITER = require("npm:core-js@0.9.14/library/modules/$.uid").safe('iter'),
      $iter = require("npm:core-js@0.9.14/library/modules/$.iter"),
      step = $iter.step;
  require("npm:core-js@0.9.14/library/modules/$.iter-define")(String, 'String', function(iterated) {
    set(this, ITER, {
      o: String(iterated),
      i: 0
    });
  }, function() {
    var iter = this[ITER],
        O = iter.o,
        index = iter.i,
        point;
    if (index >= O.length)
      return step(1);
    point = $at(O, index);
    iter.i += point.length;
    return step(0, point);
  });
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/object/create", ["npm:core-js@0.9.14/library/fn/object/create"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/object/create"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/number/is-integer", ["npm:core-js@0.9.14/library/modules/es6.number.statics", "npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/es6.number.statics");
  module.exports = require("npm:core-js@0.9.14/library/modules/$").core.Number.isInteger;
  global.define = __define;
  return module.exports;
});

System.register("npm:process@0.10.1", ["npm:process@0.10.1/browser"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.10.1/browser");
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.unscope", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      UNSCOPABLES = require("npm:core-js@0.9.14/library/modules/$.wks")('unscopables');
  if ($.FW && !(UNSCOPABLES in []))
    $.hide(Array.prototype, UNSCOPABLES, {});
  module.exports = function(key) {
    if ($.FW)
      [][UNSCOPABLES][key] = true;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/helpers/inherits", ["npm:babel-runtime@5.4.7/core-js/object/create"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$create = require("npm:babel-runtime@5.4.7/core-js/object/create")["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/object/get-own-property-descriptor", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/es6.object.statics-accept-primitives"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$");
  require("npm:core-js@0.9.14/library/modules/es6.object.statics-accept-primitives");
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/number/is-integer", ["npm:core-js@0.9.14/library/fn/number/is-integer"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/number/is-integer"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1/index", ["npm:process@0.10.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.10.1");
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.array.iterator", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.unscope", "npm:core-js@0.9.14/library/modules/$.uid", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.iter-define"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      setUnscope = require("npm:core-js@0.9.14/library/modules/$.unscope"),
      ITER = require("npm:core-js@0.9.14/library/modules/$.uid").safe('iter'),
      $iter = require("npm:core-js@0.9.14/library/modules/$.iter"),
      step = $iter.step,
      Iterators = $iter.Iterators;
  require("npm:core-js@0.9.14/library/modules/$.iter-define")(Array, 'Array', function(iterated, kind) {
    $.set(this, ITER, {
      o: $.toObject(iterated),
      i: 0,
      k: kind
    });
  }, function() {
    var iter = this[ITER],
        O = iter.o,
        kind = iter.k,
        index = iter.i++;
    if (!O || index >= O.length) {
      iter.o = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  setUnscope('keys');
  setUnscope('values');
  setUnscope('entries');
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/object/get-own-property-descriptor", ["npm:core-js@0.9.14/library/fn/object/get-own-property-descriptor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/object/get-own-property-descriptor"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("github:jspm/nodelibs-process@0.1.1", ["github:jspm/nodelibs-process@0.1.1/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.1/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/web.dom.iterable", ["npm:core-js@0.9.14/library/modules/es6.array.iterator", "npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/es6.array.iterator");
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      Iterators = require("npm:core-js@0.9.14/library/modules/$.iter").Iterators,
      ITERATOR = require("npm:core-js@0.9.14/library/modules/$.wks")('iterator'),
      ArrayValues = Iterators.Array,
      NL = $.g.NodeList,
      HTC = $.g.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype;
  if ($.FW) {
    if (NL && !(ITERATOR in NLProto))
      $.hide(NLProto, ITERATOR, ArrayValues);
    if (HTC && !(ITERATOR in HTCProto))
      $.hide(HTCProto, ITERATOR, ArrayValues);
  }
  Iterators.NodeList = Iterators.HTMLCollection = ArrayValues;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/helpers/get", ["npm:babel-runtime@5.4.7/core-js/object/get-own-property-descriptor"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$getOwnPropertyDescriptor = require("npm:babel-runtime@5.4.7/core-js/object/get-own-property-descriptor")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      desc = parent = getter = undefined;
      _again = false;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/dist/rx", ["github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function(undefined) {
      var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
      };
      var root = (objectTypes[typeof window] && window) || this,
          freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
          freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
          moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
          freeGlobal = objectTypes[typeof global] && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
      }
      var Rx = {
        internals: {},
        config: {Promise: root.Promise},
        helpers: {}
      };
      var noop = Rx.helpers.noop = function() {},
          notDefined = Rx.helpers.notDefined = function(x) {
            return typeof x === 'undefined';
          },
          identity = Rx.helpers.identity = function(x) {
            return x;
          },
          pluck = Rx.helpers.pluck = function(property) {
            return function(x) {
              return x[property];
            };
          },
          just = Rx.helpers.just = function(value) {
            return function() {
              return value;
            };
          },
          defaultNow = Rx.helpers.defaultNow = Date.now,
          defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
            return isEqual(x, y);
          },
          defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
            return x > y ? 1 : (x < y ? -1 : 0);
          },
          defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
            return x.toString();
          },
          defaultError = Rx.helpers.defaultError = function(err) {
            throw err;
          },
          isPromise = Rx.helpers.isPromise = function(p) {
            return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
          },
          asArray = Rx.helpers.asArray = function() {
            return Array.prototype.slice.call(arguments);
          },
          not = Rx.helpers.not = function(a) {
            return !a;
          },
          isFunction = Rx.helpers.isFunction = (function() {
            var isFn = function(value) {
              return typeof value == 'function' || false;
            };
            if (isFn(/x/)) {
              isFn = function(value) {
                return typeof value == 'function' && toString.call(value) == '[object Function]';
              };
            }
            return isFn;
          }());
      function cloneArray(arr) {
        for (var a = [],
            i = 0,
            len = arr.length; i < len; i++) {
          a.push(arr[i]);
        }
        return a;
      }
      Rx.config.longStackSupport = false;
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e) {
        hasStacks = !!e.stack;
      }
      var rStartingLine = captureLine(),
          rFileName;
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
          var stacks = [];
          for (var o = observable; !!o; o = o.source) {
            if (o.stack) {
              stacks.unshift(o.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          error.stack = filterStackString(concatedStacks);
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split("\n"),
            desiredLines = [];
        for (var i = 0,
            len = lines.length; i < len; i++) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0],
            lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      function captureLine() {
        if (!hasStacks) {
          return ;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return ;
          }
          rFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      var EmptyError = Rx.EmptyError = function() {
        this.message = 'Sequence contains no elements.';
        Error.call(this);
      };
      EmptyError.prototype = Error.prototype;
      var ObjectDisposedError = Rx.ObjectDisposedError = function() {
        this.message = 'Object has been disposed';
        Error.call(this);
      };
      ObjectDisposedError.prototype = Error.prototype;
      var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
        this.message = 'Argument out of range';
        Error.call(this);
      };
      ArgumentOutOfRangeError.prototype = Error.prototype;
      var NotSupportedError = Rx.NotSupportedError = function(message) {
        this.message = message || 'This operation is not supported';
        Error.call(this);
      };
      NotSupportedError.prototype = Error.prototype;
      var NotImplementedError = Rx.NotImplementedError = function(message) {
        this.message = message || 'This operation is not implemented';
        Error.call(this);
      };
      NotImplementedError.prototype = Error.prototype;
      var notImplemented = Rx.helpers.notImplemented = function() {
        throw new NotImplementedError();
      };
      var notSupported = Rx.helpers.notSupported = function() {
        throw new NotSupportedError();
      };
      var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
      if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
        $iterator$ = '@@iterator';
      }
      var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
      };
      var isIterable = Rx.helpers.isIterable = function(o) {
        return o[$iterator$] !== undefined;
      };
      var isArrayLike = Rx.helpers.isArrayLike = function(o) {
        return o && o.length !== undefined;
      };
      Rx.helpers.iterator = $iterator$;
      var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
        if (typeof thisArg === 'undefined') {
          return func;
        }
        switch (argCount) {
          case 0:
            return function() {
              return func.call(thisArg);
            };
          case 1:
            return function(arg) {
              return func.call(thisArg, arg);
            };
          case 2:
            return function(value, index) {
              return func.call(thisArg, value, index);
            };
          case 3:
            return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
        }
        return function() {
          return func.apply(thisArg, arguments);
        };
      };
      var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;
      var argsClass = '[object Arguments]',
          arrayClass = '[object Array]',
          boolClass = '[object Boolean]',
          dateClass = '[object Date]',
          errorClass = '[object Error]',
          funcClass = '[object Function]',
          numberClass = '[object Number]',
          objectClass = '[object Object]',
          regexpClass = '[object RegExp]',
          stringClass = '[object String]';
      var toString = Object.prototype.toString,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          supportsArgsClass = toString.call(arguments) == argsClass,
          supportNodeClass,
          errorProto = Error.prototype,
          objectProto = Object.prototype,
          stringProto = String.prototype,
          propertyIsEnumerable = objectProto.propertyIsEnumerable;
      try {
        supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
      } catch (e) {
        supportNodeClass = true;
      }
      var nonEnumProps = {};
      nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        'constructor': true,
        'toLocaleString': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        'constructor': true,
        'toString': true,
        'valueOf': true
      };
      nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        'constructor': true,
        'toString': true
      };
      nonEnumProps[objectClass] = {'constructor': true};
      var support = {};
      (function() {
        var ctor = function() {
          this.x = 1;
        },
            props = [];
        ctor.prototype = {
          'valueOf': 1,
          'y': 1
        };
        for (var key in new ctor) {
          props.push(key);
        }
        for (key in arguments) {}
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
        support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
      }(1));
      var isObject = Rx.internals.isObject = function(value) {
        var type = typeof value;
        return value && (type == 'function' || type == 'object') || false;
      };
      function keysIn(object) {
        var result = [];
        if (!isObject(object)) {
          return result;
        }
        if (support.nonEnumArgs && object.length && isArguments(object)) {
          object = slice.call(object);
        }
        var skipProto = support.enumPrototypes && typeof object == 'function',
            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object) {
          if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
            result.push(key);
          }
        }
        if (support.nonEnumShadows && object !== objectProto) {
          var ctor = object.constructor,
              index = -1,
              length = dontEnumsLength;
          if (object === (ctor && ctor.prototype)) {
            var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
                nonEnum = nonEnumProps[className];
          }
          while (++index < length) {
            key = dontEnums[index];
            if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
        }
        return result;
      }
      function internalFor(object, callback, keysFunc) {
        var index = -1,
            props = keysFunc(object),
            length = props.length;
        while (++index < length) {
          var key = props[index];
          if (callback(object[key], key, object) === false) {
            break;
          }
        }
        return object;
      }
      function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn);
      }
      function isNode(value) {
        return typeof value.toString != 'function' && typeof(value + '') == 'string';
      }
      var isArguments = function(value) {
        return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
      };
      if (!supportsArgsClass) {
        isArguments = function(value) {
          return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
        };
      }
      var isEqual = Rx.internals.isEqual = function(x, y) {
        return deepEquals(x, y, [], []);
      };
      function deepEquals(a, b, stackA, stackB) {
        if (a === b) {
          return a !== 0 || (1 / a == 1 / b);
        }
        var type = typeof a,
            otherType = typeof b;
        if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
          return false;
        }
        var className = toString.call(a),
            otherClass = toString.call(b);
        if (className == argsClass) {
          className = objectClass;
        }
        if (otherClass == argsClass) {
          otherClass = objectClass;
        }
        if (className != otherClass) {
          return false;
        }
        switch (className) {
          case boolClass:
          case dateClass:
            return +a == +b;
          case numberClass:
            return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
          case regexpClass:
          case stringClass:
            return a == String(b);
        }
        var isArr = className == arrayClass;
        if (!isArr) {
          if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
            return false;
          }
          var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
              ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
          if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
            return false;
          }
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == a) {
            return stackB[length] == b;
          }
        }
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
          length = a.length;
          size = b.length;
          result = size == length;
          if (result) {
            while (size--) {
              var index = length,
                  value = b[size];
              if (!(result = deepEquals(a[size], value, stackA, stackB))) {
                break;
              }
            }
          }
        } else {
          internalForIn(b, function(value, key, b) {
            if (hasOwnProperty.call(b, key)) {
              size++;
              return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
            }
          });
          if (result) {
            internalForIn(a, function(value, key, a) {
              if (hasOwnProperty.call(a, key)) {
                return (result = --size > -1);
              }
            });
          }
        }
        stackA.pop();
        stackB.pop();
        return result;
      }
      var hasProp = {}.hasOwnProperty,
          slice = Array.prototype.slice;
      var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
        function __() {
          this.constructor = child;
        }
        __.prototype = parent.prototype;
        child.prototype = new __();
      };
      var addProperties = Rx.internals.addProperties = function(obj) {
        for (var sources = [],
            i = 1,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
        for (var idx = 0,
            ln = sources.length; idx < ln; idx++) {
          var source = sources[idx];
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      };
      var addRef = Rx.internals.addRef = function(xs, r) {
        return new AnonymousObservable(function(observer) {
          return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
        });
      };
      function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) {
          a[i] = factory();
        }
        return a;
      }
      var errorObj = {e: {}};
      var tryCatchTarget;
      function tryCatcher() {
        try {
          return tryCatchTarget.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn) {
        if (!isFunction(fn)) {
          throw new TypeError('fn must be a function');
        }
        tryCatchTarget = fn;
        return tryCatcher;
      }
      function thrower(e) {
        throw e;
      }
      function IndexedItem(id, value) {
        this.id = id;
        this.value = value;
      }
      IndexedItem.prototype.compareTo = function(other) {
        var c = this.value.compareTo(other.value);
        c === 0 && (c = this.id - other.id);
        return c;
      };
      var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
        this.items = new Array(capacity);
        this.length = 0;
      };
      var priorityProto = PriorityQueue.prototype;
      priorityProto.isHigherPriority = function(left, right) {
        return this.items[left].compareTo(this.items[right]) < 0;
      };
      priorityProto.percolate = function(index) {
        if (index >= this.length || index < 0) {
          return ;
        }
        var parent = index - 1 >> 1;
        if (parent < 0 || parent === index) {
          return ;
        }
        if (this.isHigherPriority(index, parent)) {
          var temp = this.items[index];
          this.items[index] = this.items[parent];
          this.items[parent] = temp;
          this.percolate(parent);
        }
      };
      priorityProto.heapify = function(index) {
        +index || (index = 0);
        if (index >= this.length || index < 0) {
          return ;
        }
        var left = 2 * index + 1,
            right = 2 * index + 2,
            first = index;
        if (left < this.length && this.isHigherPriority(left, first)) {
          first = left;
        }
        if (right < this.length && this.isHigherPriority(right, first)) {
          first = right;
        }
        if (first !== index) {
          var temp = this.items[index];
          this.items[index] = this.items[first];
          this.items[first] = temp;
          this.heapify(first);
        }
      };
      priorityProto.peek = function() {
        return this.items[0].value;
      };
      priorityProto.removeAt = function(index) {
        this.items[index] = this.items[--this.length];
        this.items[this.length] = undefined;
        this.heapify();
      };
      priorityProto.dequeue = function() {
        var result = this.peek();
        this.removeAt(0);
        return result;
      };
      priorityProto.enqueue = function(item) {
        var index = this.length++;
        this.items[index] = new IndexedItem(PriorityQueue.count++, item);
        this.percolate(index);
      };
      priorityProto.remove = function(item) {
        for (var i = 0; i < this.length; i++) {
          if (this.items[i].value === item) {
            this.removeAt(i);
            return true;
          }
        }
        return false;
      };
      PriorityQueue.count = 0;
      var CompositeDisposable = Rx.CompositeDisposable = function() {
        var args = [],
            i,
            len;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
          len = args.length;
        } else {
          len = arguments.length;
          args = new Array(len);
          for (i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        for (i = 0; i < len; i++) {
          if (!isDisposable(args[i])) {
            throw new TypeError('Not a disposable');
          }
        }
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length;
      };
      var CompositeDisposablePrototype = CompositeDisposable.prototype;
      CompositeDisposablePrototype.add = function(item) {
        if (this.isDisposed) {
          item.dispose();
        } else {
          this.disposables.push(item);
          this.length++;
        }
      };
      CompositeDisposablePrototype.remove = function(item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
          var idx = this.disposables.indexOf(item);
          if (idx !== -1) {
            shouldDispose = true;
            this.disposables.splice(idx, 1);
            this.length--;
            item.dispose();
          }
        }
        return shouldDispose;
      };
      CompositeDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var len = this.disposables.length,
              currentDisposables = new Array(len);
          for (var i = 0; i < len; i++) {
            currentDisposables[i] = this.disposables[i];
          }
          this.disposables = [];
          this.length = 0;
          for (i = 0; i < len; i++) {
            currentDisposables[i].dispose();
          }
        }
      };
      var Disposable = Rx.Disposable = function(action) {
        this.isDisposed = false;
        this.action = action || noop;
      };
      Disposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.action();
          this.isDisposed = true;
        }
      };
      var disposableCreate = Disposable.create = function(action) {
        return new Disposable(action);
      };
      var disposableEmpty = Disposable.empty = {dispose: noop};
      var isDisposable = Disposable.isDisposable = function(d) {
        return d && isFunction(d.dispose);
      };
      var checkDisposed = Disposable.checkDisposed = function(disposable) {
        if (disposable.isDisposed) {
          throw new ObjectDisposedError();
        }
      };
      var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SingleAssignmentDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SingleAssignmentDisposable.prototype.setDisposable = function(value) {
        if (this.current) {
          throw new Error('Disposable has already been assigned');
        }
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose();
      };
      SingleAssignmentDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var SerialDisposable = Rx.SerialDisposable = function() {
        this.isDisposed = false;
        this.current = null;
      };
      SerialDisposable.prototype.getDisposable = function() {
        return this.current;
      };
      SerialDisposable.prototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      SerialDisposable.prototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      var RefCountDisposable = Rx.RefCountDisposable = (function() {
        function InnerDisposable(disposable) {
          this.disposable = disposable;
          this.disposable.count++;
          this.isInnerDisposed = false;
        }
        InnerDisposable.prototype.dispose = function() {
          if (!this.disposable.isDisposed && !this.isInnerDisposed) {
            this.isInnerDisposed = true;
            this.disposable.count--;
            if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
              this.disposable.isDisposed = true;
              this.disposable.underlyingDisposable.dispose();
            }
          }
        };
        function RefCountDisposable(disposable) {
          this.underlyingDisposable = disposable;
          this.isDisposed = false;
          this.isPrimaryDisposed = false;
          this.count = 0;
        }
        RefCountDisposable.prototype.dispose = function() {
          if (!this.isDisposed && !this.isPrimaryDisposed) {
            this.isPrimaryDisposed = true;
            if (this.count === 0) {
              this.isDisposed = true;
              this.underlyingDisposable.dispose();
            }
          }
        };
        RefCountDisposable.prototype.getDisposable = function() {
          return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
        };
        return RefCountDisposable;
      })();
      function ScheduledDisposable(scheduler, disposable) {
        this.scheduler = scheduler;
        this.disposable = disposable;
        this.isDisposed = false;
      }
      function scheduleItem(s, self) {
        if (!self.isDisposed) {
          self.isDisposed = true;
          self.disposable.dispose();
        }
      }
      ScheduledDisposable.prototype.dispose = function() {
        this.scheduler.scheduleWithState(this, scheduleItem);
      };
      var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable();
      };
      ScheduledItem.prototype.invoke = function() {
        this.disposable.setDisposable(this.invokeCore());
      };
      ScheduledItem.prototype.compareTo = function(other) {
        return this.comparer(this.dueTime, other.dueTime);
      };
      ScheduledItem.prototype.isCancelled = function() {
        return this.disposable.isDisposed;
      };
      ScheduledItem.prototype.invokeCore = function() {
        return this.action(this.scheduler, this.state);
      };
      var Scheduler = Rx.Scheduler = (function() {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
          this.now = now;
          this._schedule = schedule;
          this._scheduleRelative = scheduleRelative;
          this._scheduleAbsolute = scheduleAbsolute;
        }
        Scheduler.isScheduler = function(s) {
          return s instanceof Scheduler;
        };
        function invokeAction(scheduler, action) {
          action();
          return disposableEmpty;
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function(action) {
          return this._schedule(action, invokeAction);
        };
        schedulerProto.scheduleWithState = function(state, action) {
          return this._schedule(state, action);
        };
        schedulerProto.scheduleWithRelative = function(dueTime, action) {
          return this._scheduleRelative(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative(state, dueTime, action);
        };
        schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
          return this._scheduleAbsolute(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute(state, dueTime, action);
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function(timeSpan) {
          timeSpan < 0 && (timeSpan = 0);
          return timeSpan;
        };
        return Scheduler;
      }());
      var normalizeTime = Scheduler.normalize,
          isScheduler = Scheduler.isScheduler;
      (function(schedulerProto) {
        function invokeRecImmediate(scheduler, pair) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          function recursiveAction(state1) {
            action(state1, function(state2) {
              var isAdded = false,
                  isDone = false,
                  d = scheduler.scheduleWithState(state2, function(scheduler1, state3) {
                    if (isAdded) {
                      group.remove(d);
                    } else {
                      isDone = true;
                    }
                    recursiveAction(state3);
                    return disposableEmpty;
                  });
              if (!isDone) {
                group.add(d);
                isAdded = true;
              }
            });
          }
          recursiveAction(state);
          return group;
        }
        function invokeRecDate(scheduler, pair, method) {
          var state = pair[0],
              action = pair[1],
              group = new CompositeDisposable();
          function recursiveAction(state1) {
            action(state1, function(state2, dueTime1) {
              var isAdded = false,
                  isDone = false,
                  d = scheduler[method](state2, dueTime1, function(scheduler1, state3) {
                    if (isAdded) {
                      group.remove(d);
                    } else {
                      isDone = true;
                    }
                    recursiveAction(state3);
                    return disposableEmpty;
                  });
              if (!isDone) {
                group.add(d);
                isAdded = true;
              }
            });
          }
          ;
          recursiveAction(state);
          return group;
        }
        function scheduleInnerRecursive(action, self) {
          action(function(dt) {
            self(action, dt);
          });
        }
        schedulerProto.scheduleRecursive = function(action) {
          return this.scheduleRecursiveWithState(action, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithState = function(state, action) {
          return this.scheduleWithState([state, action], invokeRecImmediate);
        };
        schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
          return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
          return this._scheduleRelative([state, action], dueTime, function(s, p) {
            return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
          });
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
          return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
          return this._scheduleAbsolute([state, action], dueTime, function(s, p) {
            return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function(period, action) {
          return this.schedulePeriodicWithState(null, period, action);
        };
        Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          if (typeof root.setInterval === 'undefined') {
            throw new NotSupportedError();
          }
          period = normalizeTime(period);
          var s = state,
              id = root.setInterval(function() {
                s = action(s);
              }, period);
          return disposableCreate(function() {
            root.clearInterval(id);
          });
        };
      }(Scheduler.prototype));
      (function(schedulerProto) {
        schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
          return new CatchScheduler(this, handler);
        };
      }(Scheduler.prototype));
      var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
        function tick(command, recurse) {
          recurse(0, this._period);
          try {
            this._state = this._action(this._state);
          } catch (e) {
            this._cancel.dispose();
            throw e;
          }
        }
        function SchedulePeriodicRecursive(scheduler, state, period, action) {
          this._scheduler = scheduler;
          this._state = state;
          this._period = period;
          this._action = action;
        }
        SchedulePeriodicRecursive.prototype.start = function() {
          var d = new SingleAssignmentDisposable();
          this._cancel = d;
          d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
          return d;
        };
        return SchedulePeriodicRecursive;
      }());
      var immediateScheduler = Scheduler.immediate = (function() {
        function scheduleNow(state, action) {
          return action(this, state);
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      }());
      var currentThreadScheduler = Scheduler.currentThread = (function() {
        var queue;
        function runTrampoline() {
          while (queue.length > 0) {
            var item = queue.dequeue();
            !item.isCancelled() && item.invoke();
          }
        }
        function scheduleNow(state, action) {
          var si = new ScheduledItem(this, state, action, this.now());
          if (!queue) {
            queue = new PriorityQueue(4);
            queue.enqueue(si);
            var result = tryCatch(runTrampoline)();
            queue = null;
            if (result === errorObj) {
              return thrower(result.e);
            }
          } else {
            queue.enqueue(si);
          }
          return si.disposable;
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function() {
          return !queue;
        };
        return currentScheduler;
      }());
      var scheduleMethod,
          clearMethod;
      var localTimer = (function() {
        var localSetTimeout,
            localClearTimeout = noop;
        if (!!root.setTimeout) {
          localSetTimeout = root.setTimeout;
          localClearTimeout = root.clearTimeout;
        } else if (!!root.WScript) {
          localSetTimeout = function(fn, time) {
            root.WScript.Sleep(time);
            fn();
          };
        } else {
          throw new NotSupportedError();
        }
        return {
          setTimeout: localSetTimeout,
          clearTimeout: localClearTimeout
        };
      }());
      var localSetTimeout = localTimer.setTimeout,
          localClearTimeout = localTimer.clearTimeout;
      (function() {
        var nextHandle = 1,
            tasksByHandle = {},
            currentlyRunning = false;
        clearMethod = function(handle) {
          delete tasksByHandle[handle];
        };
        function runTask(handle) {
          if (currentlyRunning) {
            localSetTimeout(function() {
              runTask(handle);
            }, 0);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunning = true;
              var result = tryCatch(task)();
              clearMethod(handle);
              currentlyRunning = false;
              if (result === errorObj) {
                return thrower(result.e);
              }
            }
          }
        }
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
        function postMessageSupported() {
          if (!root.postMessage || root.importScripts) {
            return false;
          }
          var isAsync = false,
              oldHandler = root.onmessage;
          root.onmessage = function() {
            isAsync = true;
          };
          root.postMessage('', '*');
          root.onmessage = oldHandler;
          return isAsync;
        }
        if (isFunction(setImmediate)) {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            setImmediate(function() {
              runTask(id);
            });
            return id;
          };
        } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            process.nextTick(function() {
              runTask(id);
            });
            return id;
          };
        } else if (postMessageSupported()) {
          var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
          function onGlobalPostMessage(event) {
            if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
              runTask(event.data.substring(MSG_PREFIX.length));
            }
          }
          if (root.addEventListener) {
            root.addEventListener('message', onGlobalPostMessage, false);
          } else if (root.attachEvent) {
            root.attachEvent('onmessage', onGlobalPostMessage);
          } else {
            root.onmessage = onGlobalPostMessage;
          }
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            root.postMessage(MSG_PREFIX + currentId, '*');
            return id;
          };
        } else if (!!root.MessageChannel) {
          var channel = new root.MessageChannel();
          channel.port1.onmessage = function(e) {
            runTask(e.data);
          };
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            channel.port2.postMessage(id);
            return id;
          };
        } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
          scheduleMethod = function(action) {
            var scriptElement = root.document.createElement('script');
            var id = nextHandle++;
            tasksByHandle[id] = action;
            scriptElement.onreadystatechange = function() {
              runTask(id);
              scriptElement.onreadystatechange = null;
              scriptElement.parentNode.removeChild(scriptElement);
              scriptElement = null;
            };
            root.document.documentElement.appendChild(scriptElement);
            return id;
          };
        } else {
          scheduleMethod = function(action) {
            var id = nextHandle++;
            tasksByHandle[id] = action;
            localSetTimeout(function() {
              runTask(id);
            }, 0);
            return id;
          };
        }
      }());
      var timeoutScheduler = Scheduler.timeout = Scheduler['default'] = (function() {
        function scheduleNow(state, action) {
          var scheduler = this,
              disposable = new SingleAssignmentDisposable();
          var id = scheduleMethod(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          });
          return new CompositeDisposable(disposable, disposableCreate(function() {
            clearMethod(id);
          }));
        }
        function scheduleRelative(state, dueTime, action) {
          var scheduler = this,
              dt = Scheduler.normalize(dueTime),
              disposable = new SingleAssignmentDisposable();
          if (dt === 0) {
            return scheduler.scheduleWithState(state, action);
          }
          var id = localSetTimeout(function() {
            !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
          }, dt);
          return new CompositeDisposable(disposable, disposableCreate(function() {
            localClearTimeout(id);
          }));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
      })();
      var CatchScheduler = (function(__super__) {
        function scheduleNow(state, action) {
          return this._scheduler.scheduleWithState(state, this._wrap(action));
        }
        function scheduleRelative(state, dueTime, action) {
          return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
        }
        function scheduleAbsolute(state, dueTime, action) {
          return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
        }
        inherits(CatchScheduler, __super__);
        function CatchScheduler(scheduler, handler) {
          this._scheduler = scheduler;
          this._handler = handler;
          this._recursiveOriginal = null;
          this._recursiveWrapper = null;
          __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
        }
        CatchScheduler.prototype._clone = function(scheduler) {
          return new CatchScheduler(scheduler, this._handler);
        };
        CatchScheduler.prototype._wrap = function(action) {
          var parent = this;
          return function(self, state) {
            try {
              return action(parent._getRecursiveWrapper(self), state);
            } catch (e) {
              if (!parent._handler(e)) {
                throw e;
              }
              return disposableEmpty;
            }
          };
        };
        CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
          if (this._recursiveOriginal !== scheduler) {
            this._recursiveOriginal = scheduler;
            var wrapper = this._clone(scheduler);
            wrapper._recursiveOriginal = scheduler;
            wrapper._recursiveWrapper = wrapper;
            this._recursiveWrapper = wrapper;
          }
          return this._recursiveWrapper;
        };
        CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
          var self = this,
              failed = false,
              d = new SingleAssignmentDisposable();
          d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
            if (failed) {
              return null;
            }
            try {
              return action(state1);
            } catch (e) {
              failed = true;
              if (!self._handler(e)) {
                throw e;
              }
              d.dispose();
              return null;
            }
          }));
          return d;
        };
        return CatchScheduler;
      }(Scheduler));
      var Notification = Rx.Notification = (function() {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
          this.kind = kind;
          this.value = value;
          this.exception = exception;
          this._accept = accept;
          this._acceptObservable = acceptObservable;
          this.toString = toString;
        }
        Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
          return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
        };
        Notification.prototype.toObservable = function(scheduler) {
          var self = this;
          isScheduler(scheduler) || (scheduler = immediateScheduler);
          return new AnonymousObservable(function(observer) {
            return scheduler.scheduleWithState(self, function(_, notification) {
              notification._acceptObservable(observer);
              notification.kind === 'N' && observer.onCompleted();
            });
          });
        };
        return Notification;
      })();
      var notificationCreateOnNext = Notification.createOnNext = (function() {
        function _accept(onNext) {
          return onNext(this.value);
        }
        function _acceptObservable(observer) {
          return observer.onNext(this.value);
        }
        function toString() {
          return 'OnNext(' + this.value + ')';
        }
        return function(value) {
          return new Notification('N', value, null, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnError = Notification.createOnError = (function() {
        function _accept(onNext, onError) {
          return onError(this.exception);
        }
        function _acceptObservable(observer) {
          return observer.onError(this.exception);
        }
        function toString() {
          return 'OnError(' + this.exception + ')';
        }
        return function(e) {
          return new Notification('E', null, e, _accept, _acceptObservable, toString);
        };
      }());
      var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
        function _accept(onNext, onError, onCompleted) {
          return onCompleted();
        }
        function _acceptObservable(observer) {
          return observer.onCompleted();
        }
        function toString() {
          return 'OnCompleted()';
        }
        return function() {
          return new Notification('C', null, null, _accept, _acceptObservable, toString);
        };
      }());
      var Observer = Rx.Observer = function() {};
      Observer.prototype.toNotifier = function() {
        var observer = this;
        return function(n) {
          return n.accept(observer);
        };
      };
      Observer.prototype.asObserver = function() {
        return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
      };
      Observer.prototype.checked = function() {
        return new CheckedObserver(this);
      };
      var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted);
      };
      Observer.fromNotifier = function(handler, thisArg) {
        return new AnonymousObserver(function(x) {
          return handler.call(thisArg, notificationCreateOnNext(x));
        }, function(e) {
          return handler.call(thisArg, notificationCreateOnError(e));
        }, function() {
          return handler.call(thisArg, notificationCreateOnCompleted());
        });
      };
      Observer.prototype.notifyOn = function(scheduler) {
        return new ObserveOnObserver(scheduler, this);
      };
      Observer.prototype.makeSafe = function(disposable) {
        return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
      };
      var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
        inherits(AbstractObserver, __super__);
        function AbstractObserver() {
          this.isStopped = false;
          __super__.call(this);
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function(value) {
          if (!this.isStopped) {
            this.next(value);
          }
        };
        AbstractObserver.prototype.onError = function(error) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(error);
          }
        };
        AbstractObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.completed();
          }
        };
        AbstractObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        AbstractObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.error(e);
            return true;
          }
          return false;
        };
        return AbstractObserver;
      }(Observer));
      var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
        inherits(AnonymousObserver, __super__);
        function AnonymousObserver(onNext, onError, onCompleted) {
          __super__.call(this);
          this._onNext = onNext;
          this._onError = onError;
          this._onCompleted = onCompleted;
        }
        AnonymousObserver.prototype.next = function(value) {
          this._onNext(value);
        };
        AnonymousObserver.prototype.error = function(error) {
          this._onError(error);
        };
        AnonymousObserver.prototype.completed = function() {
          this._onCompleted();
        };
        return AnonymousObserver;
      }(AbstractObserver));
      var CheckedObserver = (function(__super__) {
        inherits(CheckedObserver, __super__);
        function CheckedObserver(observer) {
          __super__.call(this);
          this._observer = observer;
          this._state = 0;
        }
        var CheckedObserverPrototype = CheckedObserver.prototype;
        CheckedObserverPrototype.onNext = function(value) {
          this.checkAccess();
          var res = tryCatch(this._observer.onNext).call(this._observer, value);
          this._state = 0;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onError = function(err) {
          this.checkAccess();
          var res = tryCatch(this._observer.onError).call(this._observer, err);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.onCompleted = function() {
          this.checkAccess();
          var res = tryCatch(this._observer.onCompleted).call(this._observer);
          this._state = 2;
          res === errorObj && thrower(res.e);
        };
        CheckedObserverPrototype.checkAccess = function() {
          if (this._state === 1) {
            throw new Error('Re-entrancy detected');
          }
          if (this._state === 2) {
            throw new Error('Observer completed');
          }
          if (this._state === 0) {
            this._state = 1;
          }
        };
        return CheckedObserver;
      }(Observer));
      var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
        inherits(ScheduledObserver, __super__);
        function ScheduledObserver(scheduler, observer) {
          __super__.call(this);
          this.scheduler = scheduler;
          this.observer = observer;
          this.isAcquired = false;
          this.hasFaulted = false;
          this.queue = [];
          this.disposable = new SerialDisposable();
        }
        ScheduledObserver.prototype.next = function(value) {
          var self = this;
          this.queue.push(function() {
            self.observer.onNext(value);
          });
        };
        ScheduledObserver.prototype.error = function(e) {
          var self = this;
          this.queue.push(function() {
            self.observer.onError(e);
          });
        };
        ScheduledObserver.prototype.completed = function() {
          var self = this;
          this.queue.push(function() {
            self.observer.onCompleted();
          });
        };
        ScheduledObserver.prototype.ensureActive = function() {
          var isOwner = false,
              parent = this;
          if (!this.hasFaulted && this.queue.length > 0) {
            isOwner = !this.isAcquired;
            this.isAcquired = true;
          }
          if (isOwner) {
            this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(self) {
              var work;
              if (parent.queue.length > 0) {
                work = parent.queue.shift();
              } else {
                parent.isAcquired = false;
                return ;
              }
              try {
                work();
              } catch (ex) {
                parent.queue = [];
                parent.hasFaulted = true;
                throw ex;
              }
              self();
            }));
          }
        };
        ScheduledObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.disposable.dispose();
        };
        return ScheduledObserver;
      }(AbstractObserver));
      var ObserveOnObserver = (function(__super__) {
        inherits(ObserveOnObserver, __super__);
        function ObserveOnObserver(scheduler, observer, cancel) {
          __super__.call(this, scheduler, observer);
          this._cancel = cancel;
        }
        ObserveOnObserver.prototype.next = function(value) {
          __super__.prototype.next.call(this, value);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.error = function(e) {
          __super__.prototype.error.call(this, e);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.completed = function() {
          __super__.prototype.completed.call(this);
          this.ensureActive();
        };
        ObserveOnObserver.prototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this._cancel && this._cancel.dispose();
          this._cancel = null;
        };
        return ObserveOnObserver;
      })(ScheduledObserver);
      var observableProto;
      var Observable = Rx.Observable = (function() {
        function Observable(subscribe) {
          if (Rx.config.longStackSupport && hasStacks) {
            try {
              throw new Error();
            } catch (e) {
              this.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
            var self = this;
            this._subscribe = function(observer) {
              var oldOnError = observer.onError.bind(observer);
              observer.onError = function(err) {
                makeStackTraceLong(err, self);
                oldOnError(err);
              };
              return subscribe.call(self, observer);
            };
          } else {
            this._subscribe = subscribe;
          }
        }
        observableProto = Observable.prototype;
        observableProto.subscribe = observableProto.forEach = function(observerOrOnNext, onError, onCompleted) {
          return this._subscribe(typeof observerOrOnNext === 'object' ? observerOrOnNext : observerCreate(observerOrOnNext, onError, onCompleted));
        };
        observableProto.subscribeOnNext = function(onNext, thisArg) {
          return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
            onNext.call(thisArg, x);
          } : onNext));
        };
        observableProto.subscribeOnError = function(onError, thisArg) {
          return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
            onError.call(thisArg, e);
          } : onError));
        };
        observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
          return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
            onCompleted.call(thisArg);
          } : onCompleted));
        };
        return Observable;
      })();
      var ObservableBase = Rx.ObservableBase = (function(__super__) {
        inherits(ObservableBase, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              self = state[1];
          var sub = tryCatch(self.subscribeCore).call(self, ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function subscribe(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, this];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        function ObservableBase() {
          __super__.call(this, subscribe);
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase;
      }(Observable));
      var Enumerable = Rx.internals.Enumerable = function() {};
      var ConcatEnumerableObservable = (function(__super__) {
        inherits(ConcatEnumerableObservable, __super__);
        function ConcatEnumerableObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatEnumerableObservable.prototype.subscribeCore = function(o) {
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(this.sources[$iterator$](), function(e, self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(new InnerObserver(o, self, e)));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        function InnerObserver(o, s, e) {
          this.o = o;
          this.s = s;
          this.e = e;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.s(this.e);
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
            return true;
          }
          return false;
        };
        return ConcatEnumerableObservable;
      }(ObservableBase));
      Enumerable.prototype.concat = function() {
        return new ConcatEnumerableObservable(this);
      };
      var CatchErrorObservable = (function(__super__) {
        inherits(CatchErrorObservable, __super__);
        function CatchErrorObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        CatchErrorObservable.prototype.subscribeCore = function(o) {
          var e = this.sources[$iterator$]();
          var isDisposed,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              return lastException !== null ? o.onError(lastException) : o.onCompleted();
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, self, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return CatchErrorObservable;
      }(ObservableBase));
      Enumerable.prototype.catchError = function() {
        return new CatchErrorObservable(this);
      };
      Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function(o) {
          var exceptions = new Subject(),
              notifier = new Subject(),
              handled = notificationHandler(exceptions),
              notificationDisposable = handled.subscribe(notifier);
          var e = sources[$iterator$]();
          var isDisposed,
              lastException,
              subscription = new SerialDisposable();
          var cancelable = immediateScheduler.scheduleRecursive(function(self) {
            if (isDisposed) {
              return ;
            }
            var currentItem = tryCatch(e.next).call(e);
            if (currentItem === errorObj) {
              return o.onError(currentItem.e);
            }
            if (currentItem.done) {
              if (lastException) {
                o.onError(lastException);
              } else {
                o.onCompleted();
              }
              return ;
            }
            var currentValue = currentItem.value;
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var outer = new SingleAssignmentDisposable();
            var inner = new SingleAssignmentDisposable();
            subscription.setDisposable(new CompositeDisposable(inner, outer));
            outer.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(exn) {
              inner.setDisposable(notifier.subscribe(self, function(ex) {
                o.onError(ex);
              }, function() {
                o.onCompleted();
              }));
              exceptions.onNext(exn);
            }, function() {
              o.onCompleted();
            }));
          });
          return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        });
      };
      var RepeatEnumerable = (function(__super__) {
        inherits(RepeatEnumerable, __super__);
        function RepeatEnumerable(v, c) {
          this.v = v;
          this.c = c == null ? -1 : c;
        }
        RepeatEnumerable.prototype[$iterator$] = function() {
          return new RepeatEnumerator(this);
        };
        function RepeatEnumerator(p) {
          this.v = p.v;
          this.l = p.c;
        }
        RepeatEnumerator.prototype.next = function() {
          if (this.l === 0) {
            return doneEnumerator;
          }
          if (this.l > 0) {
            this.l--;
          }
          return {
            done: false,
            value: this.v
          };
        };
        return RepeatEnumerable;
      }(Enumerable));
      var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
        return new RepeatEnumerable(value, repeatCount);
      };
      var OfEnumerable = (function(__super__) {
        inherits(OfEnumerable, __super__);
        function OfEnumerable(s, fn, thisArg) {
          this.s = s;
          this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
        }
        OfEnumerable.prototype[$iterator$] = function() {
          return new OfEnumerator(this);
        };
        function OfEnumerator(p) {
          this.i = -1;
          this.s = p.s;
          this.l = this.s.length;
          this.fn = p.fn;
        }
        OfEnumerator.prototype.next = function() {
          return ++this.i < this.l ? {
            done: false,
            value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)
          } : doneEnumerator;
        };
        return OfEnumerable;
      }(Enumerable));
      var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
        return new OfEnumerable(source, selector, thisArg);
      };
      observableProto.observeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(new ObserveOnObserver(scheduler, observer));
        }, source);
      };
      observableProto.subscribeOn = function(scheduler) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              d = new SerialDisposable();
          d.setDisposable(m);
          m.setDisposable(scheduler.schedule(function() {
            d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
          }));
          return d;
        }, source);
      };
      var FromPromiseObservable = (function(__super__) {
        inherits(FromPromiseObservable, __super__);
        function FromPromiseObservable(p) {
          this.p = p;
          __super__.call(this);
        }
        FromPromiseObservable.prototype.subscribeCore = function(o) {
          this.p.then(function(data) {
            o.onNext(data);
            o.onCompleted();
          }, function(err) {
            o.onError(err);
          });
          return disposableEmpty;
        };
        return FromPromiseObservable;
      }(ObservableBase));
      var observableFromPromise = Observable.fromPromise = function(promise) {
        return new FromPromiseObservable(promise);
      };
      observableProto.toPromise = function(promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) {
          throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
        }
        var source = this;
        return new promiseCtor(function(resolve, reject) {
          var value,
              hasValue = false;
          source.subscribe(function(v) {
            value = v;
            hasValue = true;
          }, reject, function() {
            hasValue && resolve(value);
          });
        });
      };
      var ToArrayObservable = (function(__super__) {
        inherits(ToArrayObservable, __super__);
        function ToArrayObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        ToArrayObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.a = [];
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.a.push(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onNext(this.a);
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return ToArrayObservable;
      }(ObservableBase));
      observableProto.toArray = function() {
        return new ToArrayObservable(this);
      };
      Observable.create = Observable.createWithDisposable = function(subscribe, parent) {
        return new AnonymousObservable(subscribe, parent);
      };
      var observableDefer = Observable.defer = function(observableFactory) {
        return new AnonymousObservable(function(observer) {
          var result;
          try {
            result = observableFactory();
          } catch (e) {
            return observableThrow(e).subscribe(observer);
          }
          isPromise(result) && (result = observableFromPromise(result));
          return result.subscribe(observer);
        });
      };
      var EmptyObservable = (function(__super__) {
        inherits(EmptyObservable, __super__);
        function EmptyObservable(scheduler) {
          this.scheduler = scheduler;
          __super__.call(this);
        }
        EmptyObservable.prototype.subscribeCore = function(observer) {
          var sink = new EmptySink(observer, this);
          return sink.run();
        };
        function EmptySink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          state.onCompleted();
        }
        EmptySink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState(this.observer, scheduleItem);
        };
        return EmptyObservable;
      }(ObservableBase));
      var observableEmpty = Observable.empty = function(scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new EmptyObservable(scheduler);
      };
      var FromObservable = (function(__super__) {
        inherits(FromObservable, __super__);
        function FromObservable(iterable, mapper, scheduler) {
          this.iterable = iterable;
          this.mapper = mapper;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromSink(observer, this);
          return sink.run();
        };
        return FromObservable;
      }(ObservableBase));
      var FromSink = (function() {
        function FromSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        FromSink.prototype.run = function() {
          var list = Object(this.parent.iterable),
              it = getIterable(list),
              observer = this.observer,
              mapper = this.parent.mapper;
          function loopRecursive(i, recurse) {
            try {
              var next = it.next();
            } catch (e) {
              return observer.onError(e);
            }
            if (next.done) {
              return observer.onCompleted();
            }
            var result = next.value;
            if (mapper) {
              try {
                result = mapper(result, i);
              } catch (e) {
                return observer.onError(e);
              }
            }
            observer.onNext(result);
            recurse(i + 1);
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return FromSink;
      }());
      var maxSafeInteger = Math.pow(2, 53) - 1;
      function StringIterable(str) {
        this._s = s;
      }
      StringIterable.prototype[$iterator$] = function() {
        return new StringIterator(this._s);
      };
      function StringIterator(str) {
        this._s = s;
        this._l = s.length;
        this._i = 0;
      }
      StringIterator.prototype[$iterator$] = function() {
        return this;
      };
      StringIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._s.charAt(this._i++)
        } : doneEnumerator;
      };
      function ArrayIterable(a) {
        this._a = a;
      }
      ArrayIterable.prototype[$iterator$] = function() {
        return new ArrayIterator(this._a);
      };
      function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0;
      }
      ArrayIterator.prototype[$iterator$] = function() {
        return this;
      };
      ArrayIterator.prototype.next = function() {
        return this._i < this._l ? {
          done: false,
          value: this._a[this._i++]
        } : doneEnumerator;
      };
      function numberIsFinite(value) {
        return typeof value === 'number' && root.isFinite(value);
      }
      function isNan(n) {
        return n !== n;
      }
      function getIterable(o) {
        var i = o[$iterator$],
            it;
        if (!i && typeof o === 'string') {
          it = new StringIterable(o);
          return it[$iterator$]();
        }
        if (!i && o.length !== undefined) {
          it = new ArrayIterable(o);
          return it[$iterator$]();
        }
        if (!i) {
          throw new TypeError('Object is not iterable');
        }
        return o[$iterator$]();
      }
      function sign(value) {
        var number = +value;
        if (number === 0) {
          return number;
        }
        if (isNaN(number)) {
          return number;
        }
        return number < 0 ? -1 : 1;
      }
      function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
          return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
          return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
          return 0;
        }
        if (len > maxSafeInteger) {
          return maxSafeInteger;
        }
        return len;
      }
      var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) {
          throw new Error('iterable cannot be null.');
        }
        if (mapFn && !isFunction(mapFn)) {
          throw new Error('mapFn when provided must be a function');
        }
        if (mapFn) {
          var mapper = bindCallback(mapFn, thisArg, 2);
        }
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler);
      };
      var FromArrayObservable = (function(__super__) {
        inherits(FromArrayObservable, __super__);
        function FromArrayObservable(args, scheduler) {
          this.args = args;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        FromArrayObservable.prototype.subscribeCore = function(observer) {
          var sink = new FromArraySink(observer, this);
          return sink.run();
        };
        return FromArrayObservable;
      }(ObservableBase));
      function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromArraySink.prototype.run = function() {
        var observer = this.observer,
            args = this.parent.args,
            len = args.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            observer.onNext(args[i]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      var observableFromArray = Observable.fromArray = function(array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      };
      Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new AnonymousObservable(function(o) {
          var first = true;
          return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
            var hasResult,
                result;
            try {
              if (first) {
                first = false;
              } else {
                state = iterate(state);
              }
              hasResult = condition(state);
              hasResult && (result = resultSelector(state));
            } catch (e) {
              return o.onError(e);
            }
            if (hasResult) {
              o.onNext(result);
              self(state);
            } else {
              o.onCompleted();
            }
          });
        });
      };
      var NeverObservable = (function(__super__) {
        inherits(NeverObservable, __super__);
        function NeverObservable() {
          __super__.call(this);
        }
        NeverObservable.prototype.subscribeCore = function(observer) {
          return disposableEmpty;
        };
        return NeverObservable;
      }(ObservableBase));
      var observableNever = Observable.never = function() {
        return new NeverObservable();
      };
      function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
      }
      Observable.of = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        return new FromArrayObservable(args, currentThreadScheduler);
      };
      Observable.ofWithScheduler = function(scheduler) {
        var len = arguments.length,
            args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }
        return new FromArrayObservable(args, scheduler);
      };
      var PairsObservable = (function(__super__) {
        inherits(PairsObservable, __super__);
        function PairsObservable(obj, scheduler) {
          this.obj = obj;
          this.keys = Object.keys(obj);
          this.scheduler = scheduler;
          __super__.call(this);
        }
        PairsObservable.prototype.subscribeCore = function(observer) {
          var sink = new PairsSink(observer, this);
          return sink.run();
        };
        return PairsObservable;
      }(ObservableBase));
      function PairsSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      PairsSink.prototype.run = function() {
        var observer = this.observer,
            obj = this.parent.obj,
            keys = this.parent.keys,
            len = keys.length;
        function loopRecursive(i, recurse) {
          if (i < len) {
            var key = keys[i];
            observer.onNext([key, obj[key]]);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      Observable.pairs = function(obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler);
      };
      var RangeObservable = (function(__super__) {
        inherits(RangeObservable, __super__);
        function RangeObservable(start, count, scheduler) {
          this.start = start;
          this.rangeCount = count;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RangeObservable.prototype.subscribeCore = function(observer) {
          var sink = new RangeSink(observer, this);
          return sink.run();
        };
        return RangeObservable;
      }(ObservableBase));
      var RangeSink = (function() {
        function RangeSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        RangeSink.prototype.run = function() {
          var start = this.parent.start,
              count = this.parent.rangeCount,
              observer = this.observer;
          function loopRecursive(i, recurse) {
            if (i < count) {
              observer.onNext(start + i);
              recurse(i + 1);
            } else {
              observer.onCompleted();
            }
          }
          return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return RangeSink;
      }());
      Observable.range = function(start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler);
      };
      var RepeatObservable = (function(__super__) {
        inherits(RepeatObservable, __super__);
        function RepeatObservable(value, repeatCount, scheduler) {
          this.value = value;
          this.repeatCount = repeatCount == null ? -1 : repeatCount;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        RepeatObservable.prototype.subscribeCore = function(observer) {
          var sink = new RepeatSink(observer, this);
          return sink.run();
        };
        return RepeatObservable;
      }(ObservableBase));
      function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RepeatSink.prototype.run = function() {
        var observer = this.observer,
            value = this.parent.value;
        function loopRecursive(i, recurse) {
          if (i === -1 || i > 0) {
            observer.onNext(value);
            i > 0 && i--;
          }
          if (i === 0) {
            return observer.onCompleted();
          }
          recurse(i);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive);
      };
      Observable.repeat = function(value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler);
      };
      var JustObservable = (function(__super__) {
        inherits(JustObservable, __super__);
        function JustObservable(value, scheduler) {
          this.value = value;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        JustObservable.prototype.subscribeCore = function(observer) {
          var sink = new JustSink(observer, this);
          return sink.run();
        };
        function JustSink(observer, parent) {
          this.observer = observer;
          this.parent = parent;
        }
        function scheduleItem(s, state) {
          var value = state[0],
              observer = state[1];
          observer.onNext(value);
          observer.onCompleted();
        }
        JustSink.prototype.run = function() {
          return this.parent.scheduler.scheduleWithState([this.parent.value, this.observer], scheduleItem);
        };
        return JustObservable;
      }(ObservableBase));
      var observableReturn = Observable['return'] = Observable.just = Observable.returnValue = function(value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler);
      };
      var ThrowObservable = (function(__super__) {
        inherits(ThrowObservable, __super__);
        function ThrowObservable(error, scheduler) {
          this.error = error;
          this.scheduler = scheduler;
          __super__.call(this);
        }
        ThrowObservable.prototype.subscribeCore = function(o) {
          var sink = new ThrowSink(o, this);
          return sink.run();
        };
        function ThrowSink(o, p) {
          this.o = o;
          this.p = p;
        }
        function scheduleItem(s, state) {
          var e = state[0],
              o = state[1];
          o.onError(e);
        }
        ThrowSink.prototype.run = function() {
          return this.p.scheduler.scheduleWithState([this.p.error, this.o], scheduleItem);
        };
        return ThrowObservable;
      }(ObservableBase));
      var observableThrow = Observable['throw'] = Observable.throwError = Observable.throwException = function(error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler);
      };
      Observable.using = function(resourceFactory, observableFactory) {
        return new AnonymousObservable(function(observer) {
          var disposable = disposableEmpty,
              resource,
              source;
          try {
            resource = resourceFactory();
            resource && (disposable = resource);
            source = observableFactory(resource);
          } catch (exception) {
            return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
          }
          return new CompositeDisposable(source.subscribe(observer), disposable);
        });
      };
      observableProto.amb = function(rightSource) {
        var leftSource = this;
        return new AnonymousObservable(function(observer) {
          var choice,
              leftChoice = 'L',
              rightChoice = 'R',
              leftSubscription = new SingleAssignmentDisposable(),
              rightSubscription = new SingleAssignmentDisposable();
          isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
          function choiceL() {
            if (!choice) {
              choice = leftChoice;
              rightSubscription.dispose();
            }
          }
          function choiceR() {
            if (!choice) {
              choice = rightChoice;
              leftSubscription.dispose();
            }
          }
          leftSubscription.setDisposable(leftSource.subscribe(function(left) {
            choiceL();
            choice === leftChoice && observer.onNext(left);
          }, function(err) {
            choiceL();
            choice === leftChoice && observer.onError(err);
          }, function() {
            choiceL();
            choice === leftChoice && observer.onCompleted();
          }));
          rightSubscription.setDisposable(rightSource.subscribe(function(right) {
            choiceR();
            choice === rightChoice && observer.onNext(right);
          }, function(err) {
            choiceR();
            choice === rightChoice && observer.onError(err);
          }, function() {
            choiceR();
            choice === rightChoice && observer.onCompleted();
          }));
          return new CompositeDisposable(leftSubscription, rightSubscription);
        });
      };
      Observable.amb = function() {
        var acc = observableNever(),
            items = [];
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            items.push(arguments[i]);
          }
        }
        function func(previous, current) {
          return previous.amb(current);
        }
        for (var i = 0,
            len = items.length; i < len; i++) {
          acc = func(acc, items[i]);
        }
        return acc;
      };
      function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function(o) {
          var d1 = new SingleAssignmentDisposable(),
              subscription = new SerialDisposable();
          subscription.setDisposable(d1);
          d1.setDisposable(source.subscribe(function(x) {
            o.onNext(x);
          }, function(e) {
            try {
              var result = handler(e);
            } catch (ex) {
              return o.onError(ex);
            }
            isPromise(result) && (result = observableFromPromise(result));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(result.subscribe(o));
          }, function(x) {
            o.onCompleted(x);
          }));
          return subscription;
        }, source);
      }
      observableProto['catch'] = observableProto.catchError = observableProto.catchException = function(handlerOrSecond) {
        return typeof handlerOrSecond === 'function' ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
      };
      var observableCatch = Observable.catchError = Observable['catch'] = Observable.catchException = function() {
        var items = [];
        if (Array.isArray(arguments[0])) {
          items = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            items.push(arguments[i]);
          }
        }
        return enumerableOf(items).catchError();
      };
      observableProto.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
          args[0].unshift(this);
        } else {
          args.unshift(this);
        }
        return combineLatest.apply(this, args);
      };
      var combineLatest = Observable.combineLatest = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop();
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              falseFactory = function() {
                return false;
              },
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              isDone = arrayInitialize(n, falseFactory),
              values = new Array(n);
          function next(i) {
            hasValue[i] = true;
            if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
              try {
                var res = resultSelector.apply(null, values);
              } catch (e) {
                return o.onError(e);
              }
              o.onNext(res);
            } else if (isDone.filter(function(x, j) {
              return j !== i;
            }).every(identity)) {
              o.onCompleted();
            }
          }
          function done(i) {
            isDone[i] = true;
            isDone.every(identity) && o.onCompleted();
          }
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                values[i] = x;
                next(i);
              }, function(e) {
                o.onError(e);
              }, function() {
                done(i);
              }));
              subscriptions[i] = sad;
            }(idx));
          }
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      observableProto.concat = function() {
        for (var args = [],
            i = 0,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        args.unshift(this);
        return observableConcat.apply(null, args);
      };
      var ConcatObservable = (function(__super__) {
        inherits(ConcatObservable, __super__);
        function ConcatObservable(sources) {
          this.sources = sources;
          __super__.call(this);
        }
        ConcatObservable.prototype.subscribeCore = function(o) {
          var sink = new ConcatSink(this.sources, o);
          return sink.run();
        };
        function ConcatSink(sources, o) {
          this.sources = sources;
          this.o = o;
        }
        ConcatSink.prototype.run = function() {
          var isDisposed,
              subscription = new SerialDisposable(),
              sources = this.sources,
              length = sources.length,
              o = this.o;
          var cancelable = immediateScheduler.scheduleRecursiveWithState(0, function(i, self) {
            if (isDisposed) {
              return ;
            }
            if (i === length) {
              return o.onCompleted();
            }
            var currentValue = sources[i];
            isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
            var d = new SingleAssignmentDisposable();
            subscription.setDisposable(d);
            d.setDisposable(currentValue.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              o.onError(e);
            }, function() {
              self(i + 1);
            }));
          });
          return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
            isDisposed = true;
          }));
        };
        return ConcatObservable;
      }(ObservableBase));
      var observableConcat = Observable.concat = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          args = new Array(arguments.length);
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        return new ConcatObservable(args);
      };
      observableProto.concatAll = observableProto.concatObservable = function() {
        return this.merge(1);
      };
      var MergeObservable = (function(__super__) {
        inherits(MergeObservable, __super__);
        function MergeObservable(source, maxConcurrent) {
          this.source = source;
          this.maxConcurrent = maxConcurrent;
          __super__.call(this);
        }
        MergeObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable();
          g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
          return g;
        };
        return MergeObservable;
      }(ObservableBase));
      var MergeObserver = (function() {
        function MergeObserver(o, max, g) {
          this.o = o;
          this.max = max;
          this.g = g;
          this.done = false;
          this.q = [];
          this.activeCount = 0;
          this.isStopped = false;
        }
        MergeObserver.prototype.handleSubscribe = function(xs) {
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(xs) && (xs = observableFromPromise(xs));
          sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
        };
        MergeObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          if (this.activeCount < this.max) {
            this.activeCount++;
            this.handleSubscribe(innerSource);
          } else {
            this.q.push(innerSource);
          }
        };
        MergeObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.activeCount === 0 && this.o.onCompleted();
          }
        };
        MergeObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, sad) {
          this.parent = parent;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var parent = this.parent;
            parent.g.remove(this.sad);
            if (parent.q.length > 0) {
              parent.handleSubscribe(parent.q.shift());
            } else {
              parent.activeCount--;
              parent.done && parent.activeCount === 0 && parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeObserver;
      }());
      observableProto.merge = function(maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
      };
      var observableMerge = Observable.merge = function() {
        var scheduler,
            sources = [],
            i,
            len = arguments.length;
        if (!arguments[0]) {
          scheduler = immediateScheduler;
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else if (isScheduler(arguments[0])) {
          scheduler = arguments[0];
          for (i = 1; i < len; i++) {
            sources.push(arguments[i]);
          }
        } else {
          scheduler = immediateScheduler;
          for (i = 0; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        if (Array.isArray(sources[0])) {
          sources = sources[0];
        }
        return observableOf(scheduler, sources).mergeAll();
      };
      var CompositeError = Rx.CompositeError = function(errors) {
        this.name = "NotImplementedError";
        this.innerErrors = errors;
        this.message = 'This contains multiple errors. Check the innerErrors';
        Error.call(this);
      };
      CompositeError.prototype = Error.prototype;
      Observable.mergeDelayError = function() {
        var args;
        if (Array.isArray(arguments[0])) {
          args = arguments[0];
        } else {
          var len = arguments.length;
          args = new Array(len);
          for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
          }
        }
        var source = observableOf(null, args);
        return new AnonymousObservable(function(o) {
          var group = new CompositeDisposable(),
              m = new SingleAssignmentDisposable(),
              isStopped = false,
              errors = [];
          function setCompletion() {
            if (errors.length === 0) {
              o.onCompleted();
            } else if (errors.length === 1) {
              o.onError(errors[0]);
            } else {
              o.onError(new CompositeError(errors));
            }
          }
          group.add(m);
          m.setDisposable(source.subscribe(function(innerSource) {
            var innerSubscription = new SingleAssignmentDisposable();
            group.add(innerSubscription);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            innerSubscription.setDisposable(innerSource.subscribe(function(x) {
              o.onNext(x);
            }, function(e) {
              errors.push(e);
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }, function() {
              group.remove(innerSubscription);
              isStopped && group.length === 1 && setCompletion();
            }));
          }, function(e) {
            errors.push(e);
            isStopped = true;
            group.length === 1 && setCompletion();
          }, function() {
            isStopped = true;
            group.length === 1 && setCompletion();
          }));
          return group;
        });
      };
      var MergeAllObservable = (function(__super__) {
        inherits(MergeAllObservable, __super__);
        function MergeAllObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        MergeAllObservable.prototype.subscribeCore = function(observer) {
          var g = new CompositeDisposable(),
              m = new SingleAssignmentDisposable();
          g.add(m);
          m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
          return g;
        };
        function MergeAllObserver(o, g) {
          this.o = o;
          this.g = g;
          this.isStopped = false;
          this.done = false;
        }
        MergeAllObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          var sad = new SingleAssignmentDisposable();
          this.g.add(sad);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          sad.setDisposable(innerSource.subscribe(new InnerObserver(this, this.g, sad)));
        };
        MergeAllObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        MergeAllObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.done = true;
            this.g.length === 1 && this.o.onCompleted();
          }
        };
        MergeAllObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        MergeAllObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, g, sad) {
          this.parent = parent;
          this.g = g;
          this.sad = sad;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (!this.isStopped) {
            this.parent.o.onNext(x);
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            var parent = this.parent;
            this.isStopped = true;
            parent.g.remove(this.sad);
            parent.done && parent.g.length === 1 && parent.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return MergeAllObservable;
      }(ObservableBase));
      observableProto.mergeAll = observableProto.mergeObservable = function() {
        return new MergeAllObservable(this);
      };
      observableProto.onErrorResumeNext = function(second) {
        if (!second) {
          throw new Error('Second observable is required');
        }
        return onErrorResumeNext([this, second]);
      };
      var onErrorResumeNext = Observable.onErrorResumeNext = function() {
        var sources = [];
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          for (var i = 0,
              len = arguments.length; i < len; i++) {
            sources.push(arguments[i]);
          }
        }
        return new AnonymousObservable(function(observer) {
          var pos = 0,
              subscription = new SerialDisposable(),
              cancelable = immediateScheduler.scheduleRecursive(function(self) {
                var current,
                    d;
                if (pos < sources.length) {
                  current = sources[pos++];
                  isPromise(current) && (current = observableFromPromise(current));
                  d = new SingleAssignmentDisposable();
                  subscription.setDisposable(d);
                  d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
                } else {
                  observer.onCompleted();
                }
              });
          return new CompositeDisposable(subscription, cancelable);
        });
      };
      observableProto.skipUntil = function(other) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var isOpen = false;
          var disposables = new CompositeDisposable(source.subscribe(function(left) {
            isOpen && o.onNext(left);
          }, function(e) {
            o.onError(e);
          }, function() {
            isOpen && o.onCompleted();
          }));
          isPromise(other) && (other = observableFromPromise(other));
          var rightSubscription = new SingleAssignmentDisposable();
          disposables.add(rightSubscription);
          rightSubscription.setDisposable(other.subscribe(function() {
            isOpen = true;
            rightSubscription.dispose();
          }, function(e) {
            o.onError(e);
          }, function() {
            rightSubscription.dispose();
          }));
          return disposables;
        }, source);
      };
      var SwitchObservable = (function(__super__) {
        inherits(SwitchObservable, __super__);
        function SwitchObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        SwitchObservable.prototype.subscribeCore = function(o) {
          var inner = new SerialDisposable(),
              s = this.source.subscribe(new SwitchObserver(o, inner));
          return new CompositeDisposable(s, inner);
        };
        function SwitchObserver(o, inner) {
          this.o = o;
          this.inner = inner;
          this.stopped = false;
          this.latest = 0;
          this.hasLatest = false;
          this.isStopped = false;
        }
        SwitchObserver.prototype.onNext = function(innerSource) {
          if (this.isStopped) {
            return ;
          }
          var d = new SingleAssignmentDisposable(),
              id = ++this.latest;
          this.hasLatest = true;
          this.inner.setDisposable(d);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
        };
        SwitchObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        SwitchObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.stopped = true;
            !this.hasLatest && this.o.onCompleted();
          }
        };
        SwitchObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        SwitchObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        function InnerObserver(parent, id) {
          this.parent = parent;
          this.id = id;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          this.parent.latest === this.id && this.parent.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.latest === this.id && this.parent.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            if (this.parent.latest === this.id) {
              this.parent.hasLatest = false;
              this.parent.isStopped && this.parent.o.onCompleted();
            }
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.parent.o.onError(e);
            return true;
          }
          return false;
        };
        return SwitchObservable;
      }(ObservableBase));
      observableProto['switch'] = observableProto.switchLatest = function() {
        return new SwitchObservable(this);
      };
      var TakeUntilObservable = (function(__super__) {
        inherits(TakeUntilObservable, __super__);
        function TakeUntilObservable(source, other) {
          this.source = source;
          this.other = isPromise(other) ? observableFromPromise(other) : other;
          __super__.call(this);
        }
        TakeUntilObservable.prototype.subscribeCore = function(o) {
          return new CompositeDisposable(this.source.subscribe(o), this.other.subscribe(new InnerObserver(o)));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          this.o.onCompleted();
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          !this.isStopped && (this.isStopped = true);
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TakeUntilObservable;
      }(ObservableBase));
      observableProto.takeUntil = function(other) {
        return new TakeUntilObservable(this, other);
      };
      function falseFactory() {
        return false;
      }
      observableProto.withLatestFrom = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var resultSelector = args.pop(),
            source = this;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function(observer) {
          var n = args.length,
              hasValue = arrayInitialize(n, falseFactory),
              hasValueAll = false,
              values = new Array(n);
          var subscriptions = new Array(n + 1);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var other = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(other) && (other = observableFromPromise(other));
              sad.setDisposable(other.subscribe(function(x) {
                values[i] = x;
                hasValue[i] = true;
                hasValueAll = hasValue.every(identity);
              }, function(e) {
                observer.onError(e);
              }, noop));
              subscriptions[i] = sad;
            }(idx));
          }
          var sad = new SingleAssignmentDisposable();
          sad.setDisposable(source.subscribe(function(x) {
            var allValues = [x].concat(values);
            if (!hasValueAll) {
              return ;
            }
            var res = tryCatch(resultSelector).apply(null, allValues);
            if (res === errorObj) {
              return observer.onError(res.e);
            }
            observer.onNext(res);
          }, function(e) {
            observer.onError(e);
          }, function() {
            observer.onCompleted();
          }));
          subscriptions[n] = sad;
          return new CompositeDisposable(subscriptions);
        }, this);
      };
      function zipArray(second, resultSelector) {
        var first = this;
        return new AnonymousObservable(function(o) {
          var index = 0,
              len = second.length;
          return first.subscribe(function(left) {
            if (index < len) {
              var right = second[index++],
                  res = tryCatch(resultSelector)(left, right);
              if (res === errorObj) {
                return o.onError(res.e);
              }
              o.onNext(res);
            } else {
              o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, first);
      }
      function falseFactory() {
        return false;
      }
      function emptyArrayFactory() {
        return [];
      }
      observableProto.zip = function() {
        if (Array.isArray(arguments[0])) {
          return zipArray.apply(this, arguments);
        }
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var parent = this,
            resultSelector = args.pop();
        args.unshift(parent);
        return new AnonymousObservable(function(o) {
          var n = args.length,
              queues = arrayInitialize(n, emptyArrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              var source = args[i],
                  sad = new SingleAssignmentDisposable();
              isPromise(source) && (source = observableFromPromise(source));
              sad.setDisposable(source.subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var queuedValues = queues.map(function(x) {
                    return x.shift();
                  }),
                      res = tryCatch(resultSelector).apply(parent, queuedValues);
                  if (res === errorObj) {
                    return o.onError(res.e);
                  }
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
              subscriptions[i] = sad;
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        }, parent);
      };
      Observable.zip = function() {
        var len = arguments.length,
            args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
        var first = args.shift();
        return first.zip.apply(first, args);
      };
      function falseFactory() {
        return false;
      }
      function arrayFactory() {
        return [];
      }
      Observable.zipArray = function() {
        var sources;
        if (Array.isArray(arguments[0])) {
          sources = arguments[0];
        } else {
          var len = arguments.length;
          sources = new Array(len);
          for (var i = 0; i < len; i++) {
            sources[i] = arguments[i];
          }
        }
        return new AnonymousObservable(function(o) {
          var n = sources.length,
              queues = arrayInitialize(n, arrayFactory),
              isDone = arrayInitialize(n, falseFactory);
          var subscriptions = new Array(n);
          for (var idx = 0; idx < n; idx++) {
            (function(i) {
              subscriptions[i] = new SingleAssignmentDisposable();
              subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
                queues[i].push(x);
                if (queues.every(function(x) {
                  return x.length > 0;
                })) {
                  var res = queues.map(function(x) {
                    return x.shift();
                  });
                  o.onNext(res);
                } else if (isDone.filter(function(x, j) {
                  return j !== i;
                }).every(identity)) {
                  return o.onCompleted();
                }
              }, function(e) {
                o.onError(e);
              }, function() {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
              }));
            })(idx);
          }
          return new CompositeDisposable(subscriptions);
        });
      };
      observableProto.asObservable = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(o);
        }, source);
      };
      observableProto.bufferWithCount = function(count, skip) {
        if (typeof skip !== 'number') {
          skip = count;
        }
        return this.windowWithCount(count, skip).selectMany(function(x) {
          return x.toArray();
        }).where(function(x) {
          return x.length > 0;
        });
      };
      observableProto.dematerialize = function() {
        var source = this;
        return new AnonymousObservable(function(o) {
          return source.subscribe(function(x) {
            return x.accept(o);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      observableProto.distinctUntilChanged = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hasCurrentKey = false,
              currentKey;
          return source.subscribe(function(value) {
            var key = value;
            if (keySelector) {
              key = tryCatch(keySelector)(value);
              if (key === errorObj) {
                return o.onError(key.e);
              }
            }
            if (hasCurrentKey) {
              var comparerEquals = tryCatch(comparer)(currentKey, key);
              if (comparerEquals === errorObj) {
                return o.onError(comparerEquals.e);
              }
            }
            if (!hasCurrentKey || !comparerEquals) {
              hasCurrentKey = true;
              currentKey = key;
              o.onNext(value);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var TapObservable = (function(__super__) {
        inherits(TapObservable, __super__);
        function TapObservable(source, observerOrOnNext, onError, onCompleted) {
          this.source = source;
          this.t = !observerOrOnNext || isFunction(observerOrOnNext) ? observerCreate(observerOrOnNext || noop, onError || noop, onCompleted || noop) : observerOrOnNext;
          __super__.call(this);
        }
        TapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.t));
        };
        function InnerObserver(o, t) {
          this.o = o;
          this.t = t;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var res = tryCatch(this.t.onNext).call(this.t, x);
          if (res === errorObj) {
            this.o.onError(res.e);
          }
          this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onError).call(this.t, err);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            var res = tryCatch(this.t.onCompleted).call(this.t);
            if (res === errorObj) {
              return this.o.onError(res.e);
            }
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return TapObservable;
      }(ObservableBase));
      observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
        return new TapObservable(this, observerOrOnNext, onError, onCompleted);
      };
      observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
        return this.tap(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext);
      };
      observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
        return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError);
      };
      observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted);
      };
      observableProto['finally'] = observableProto.ensure = function(action) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var subscription;
          try {
            subscription = source.subscribe(observer);
          } catch (e) {
            action();
            throw e;
          }
          return disposableCreate(function() {
            try {
              subscription.dispose();
            } catch (e) {
              throw e;
            } finally {
              action();
            }
          });
        }, this);
      };
      observableProto.finallyAction = function(action) {
        return this.ensure(action);
      };
      var IgnoreElementsObservable = (function(__super__) {
        inherits(IgnoreElementsObservable, __super__);
        function IgnoreElementsObservable(source) {
          this.source = source;
          __super__.call(this);
        }
        IgnoreElementsObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = noop;
        InnerObserver.prototype.onError = function(err) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(err);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.observer.onError(e);
            return true;
          }
          return false;
        };
        return IgnoreElementsObservable;
      }(ObservableBase));
      observableProto.ignoreElements = function() {
        return new IgnoreElementsObservable(this);
      };
      observableProto.materialize = function() {
        var source = this;
        return new AnonymousObservable(function(observer) {
          return source.subscribe(function(value) {
            observer.onNext(notificationCreateOnNext(value));
          }, function(e) {
            observer.onNext(notificationCreateOnError(e));
            observer.onCompleted();
          }, function() {
            observer.onNext(notificationCreateOnCompleted());
            observer.onCompleted();
          });
        }, source);
      };
      observableProto.repeat = function(repeatCount) {
        return enumerableRepeat(this, repeatCount).concat();
      };
      observableProto.retry = function(retryCount) {
        return enumerableRepeat(this, retryCount).catchError();
      };
      observableProto.retryWhen = function(notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier);
      };
      var ScanObservable = (function(__super__) {
        inherits(ScanObservable, __super__);
        function ScanObservable(source, accumulator, hasSeed, seed) {
          this.source = source;
          this.accumulator = accumulator;
          this.hasSeed = hasSeed;
          this.seed = seed;
          __super__.call(this);
        }
        ScanObservable.prototype.subscribeCore = function(observer) {
          return this.source.subscribe(new ScanObserver(observer, this));
        };
        return ScanObservable;
      }(ObservableBase));
      function ScanObserver(observer, parent) {
        this.observer = observer;
        this.accumulator = parent.accumulator;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.accumulation = null;
        this.hasValue = false;
        this.isStopped = false;
      }
      ScanObserver.prototype.onNext = function(x) {
        if (this.isStopped) {
          return ;
        }
        !this.hasValue && (this.hasValue = true);
        try {
          if (this.hasAccumulation) {
            this.accumulation = this.accumulator(this.accumulation, x);
          } else {
            this.accumulation = this.hasSeed ? this.accumulator(this.seed, x) : x;
            this.hasAccumulation = true;
          }
        } catch (e) {
          return this.observer.onError(e);
        }
        this.observer.onNext(this.accumulation);
      };
      ScanObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.observer.onError(e);
        }
      };
      ScanObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          !this.hasValue && this.hasSeed && this.observer.onNext(this.seed);
          this.observer.onCompleted();
        }
      };
      ScanObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      ScanObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.observer.onError(e);
          return true;
        }
        return false;
      };
      observableProto.scan = function() {
        var hasSeed = false,
            seed,
            accumulator,
            source = this;
        if (arguments.length === 2) {
          hasSeed = true;
          seed = arguments[0];
          accumulator = arguments[1];
        } else {
          accumulator = arguments[0];
        }
        return new ScanObservable(this, accumulator, hasSeed, seed);
      };
      observableProto.skipLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && o.onNext(q.shift());
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.startWith = function() {
        var values,
            scheduler,
            start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
          scheduler = arguments[0];
          start = 1;
        } else {
          scheduler = immediateScheduler;
        }
        for (var args = [],
            i = start,
            len = arguments.length; i < len; i++) {
          args.push(arguments[i]);
        }
        return enumerableOf([observableFromArray(args, scheduler), this]).concat();
      };
      observableProto.takeLast = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            while (q.length > 0) {
              o.onNext(q.shift());
            }
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeLastBuffer = function(count) {
        var source = this;
        return new AnonymousObservable(function(o) {
          var q = [];
          return source.subscribe(function(x) {
            q.push(x);
            q.length > count && q.shift();
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onNext(q);
            o.onCompleted();
          });
        }, source);
      };
      observableProto.windowWithCount = function(count, skip) {
        var source = this;
        +count || (count = 0);
        Math.abs(count) === Infinity && (count = 0);
        if (count <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        skip == null && (skip = count);
        +skip || (skip = 0);
        Math.abs(skip) === Infinity && (skip = 0);
        if (skip <= 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new AnonymousObservable(function(observer) {
          var m = new SingleAssignmentDisposable(),
              refCountDisposable = new RefCountDisposable(m),
              n = 0,
              q = [];
          function createWindow() {
            var s = new Subject();
            q.push(s);
            observer.onNext(addRef(s, refCountDisposable));
          }
          createWindow();
          m.setDisposable(source.subscribe(function(x) {
            for (var i = 0,
                len = q.length; i < len; i++) {
              q[i].onNext(x);
            }
            var c = n - count + 1;
            c >= 0 && c % skip === 0 && q.shift().onCompleted();
            ++n % skip === 0 && createWindow();
          }, function(e) {
            while (q.length > 0) {
              q.shift().onError(e);
            }
            observer.onError(e);
          }, function() {
            while (q.length > 0) {
              q.shift().onCompleted();
            }
            observer.onCompleted();
          }));
          return refCountDisposable;
        }, source);
      };
      function concatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
          var result = selectorFunc(x, i, source);
          isPromise(result) && (result = observableFromPromise(result));
          (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
          return result;
        }).concatAll();
      }
      observableProto.selectConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) {
          return this.concatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
              return resultSelector(x, y, i, i2);
            });
          });
        }
        return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function() {
          return selector;
        });
      };
      observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this,
            onNextFunc = bindCallback(onNext, thisArg, 2),
            onErrorFunc = bindCallback(onError, thisArg, 1),
            onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNextFunc(x, index++);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onErrorFunc(err);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompletedFunc();
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, this).concatAll();
      };
      observableProto.defaultIfEmpty = function(defaultValue) {
        var source = this;
        defaultValue === undefined && (defaultValue = null);
        return new AnonymousObservable(function(observer) {
          var found = false;
          return source.subscribe(function(x) {
            found = true;
            observer.onNext(x);
          }, function(e) {
            observer.onError(e);
          }, function() {
            !found && observer.onNext(defaultValue);
            observer.onCompleted();
          });
        }, source);
      };
      function arrayIndexOfComparer(array, item, comparer) {
        for (var i = 0,
            len = array.length; i < len; i++) {
          if (comparer(array[i], item)) {
            return i;
          }
        }
        return -1;
      }
      function HashSet(comparer) {
        this.comparer = comparer;
        this.set = [];
      }
      HashSet.prototype.push = function(value) {
        var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
        retValue && this.set.push(value);
        return retValue;
      };
      observableProto.distinct = function(keySelector, comparer) {
        var source = this;
        comparer || (comparer = defaultComparer);
        return new AnonymousObservable(function(o) {
          var hashSet = new HashSet(comparer);
          return source.subscribe(function(x) {
            var key = x;
            if (keySelector) {
              try {
                key = keySelector(x);
              } catch (e) {
                o.onError(e);
                return ;
              }
            }
            hashSet.push(key) && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, this);
      };
      var MapObservable = (function(__super__) {
        inherits(MapObservable, __super__);
        function MapObservable(source, selector, thisArg) {
          this.source = source;
          this.selector = bindCallback(selector, thisArg, 3);
          __super__.call(this);
        }
        function innerMap(selector, self) {
          return function(x, i, o) {
            return selector.call(this, self.selector(x, i, o), i, o);
          };
        }
        MapObservable.prototype.internalMap = function(selector, thisArg) {
          return new MapObservable(this.source, innerMap(selector, this), thisArg);
        };
        MapObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.selector, this));
        };
        function InnerObserver(o, selector, source) {
          this.o = o;
          this.selector = selector;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var result = tryCatch(this.selector)(x, this.i++, this.source);
          if (result === errorObj) {
            return this.o.onError(result.e);
          }
          this.o.onNext(result);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return MapObservable;
      }(ObservableBase));
      observableProto.map = observableProto.select = function(selector, thisArg) {
        var selectorFn = typeof selector === 'function' ? selector : function() {
          return selector;
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
      };
      observableProto.pluck = function() {
        var args = arguments,
            len = arguments.length;
        if (len === 0) {
          throw new Error('List of properties cannot be empty.');
        }
        return this.map(function(x) {
          var currentProp = x;
          for (var i = 0; i < len; i++) {
            var p = currentProp[args[i]];
            if (typeof p !== 'undefined') {
              currentProp = p;
            } else {
              return undefined;
            }
          }
          return currentProp;
        });
      };
      observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
        var source = this;
        return new AnonymousObservable(function(observer) {
          var index = 0;
          return source.subscribe(function(x) {
            var result;
            try {
              result = onNext.call(thisArg, x, index++);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
          }, function(err) {
            var result;
            try {
              result = onError.call(thisArg, err);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          }, function() {
            var result;
            try {
              result = onCompleted.call(thisArg);
            } catch (e) {
              observer.onError(e);
              return ;
            }
            isPromise(result) && (result = observableFromPromise(result));
            observer.onNext(result);
            observer.onCompleted();
          });
        }, source).mergeAll();
      };
      function flatMap(source, selector, thisArg) {
        var selectorFunc = bindCallback(selector, thisArg, 3);
        return source.map(function(x, i) {
          var result = selectorFunc(x, i, source);
          isPromise(result) && (result = observableFromPromise(result));
          (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
          return result;
        }).mergeAll();
      }
      observableProto.selectMany = observableProto.flatMap = function(selector, resultSelector, thisArg) {
        if (isFunction(selector) && isFunction(resultSelector)) {
          return this.flatMap(function(x, i) {
            var selectorResult = selector(x, i);
            isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
            (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
            return selectorResult.map(function(y, i2) {
              return resultSelector(x, y, i, i2);
            });
          }, thisArg);
        }
        return isFunction(selector) ? flatMap(this, selector, thisArg) : flatMap(this, function() {
          return selector;
        });
      };
      observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function(selector, thisArg) {
        return this.select(selector, thisArg).switchLatest();
      };
      var SkipObservable = (function(__super__) {
        inherits(SkipObservable, __super__);
        function SkipObservable(source, count) {
          this.source = source;
          this.skipCount = count;
          __super__.call(this);
        }
        SkipObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.skipCount));
        };
        function InnerObserver(o, c) {
          this.c = c;
          this.r = c;
          this.o = o;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          if (this.r <= 0) {
            this.o.onNext(x);
          } else {
            this.r--;
          }
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return SkipObservable;
      }(ObservableBase));
      observableProto.skip = function(count) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        return new SkipObservable(this, count);
      };
      observableProto.skipWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = false;
          return source.subscribe(function(x) {
            if (!running) {
              try {
                running = !callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return ;
              }
            }
            running && o.onNext(x);
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.take = function(count, scheduler) {
        if (count < 0) {
          throw new ArgumentOutOfRangeError();
        }
        if (count === 0) {
          return observableEmpty(scheduler);
        }
        var source = this;
        return new AnonymousObservable(function(o) {
          var remaining = count;
          return source.subscribe(function(x) {
            if (remaining-- > 0) {
              o.onNext(x);
              remaining <= 0 && o.onCompleted();
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      observableProto.takeWhile = function(predicate, thisArg) {
        var source = this,
            callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function(o) {
          var i = 0,
              running = true;
          return source.subscribe(function(x) {
            if (running) {
              try {
                running = callback(x, i++, source);
              } catch (e) {
                o.onError(e);
                return ;
              }
              if (running) {
                o.onNext(x);
              } else {
                o.onCompleted();
              }
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            o.onCompleted();
          });
        }, source);
      };
      var FilterObservable = (function(__super__) {
        inherits(FilterObservable, __super__);
        function FilterObservable(source, predicate, thisArg) {
          this.source = source;
          this.predicate = bindCallback(predicate, thisArg, 3);
          __super__.call(this);
        }
        FilterObservable.prototype.subscribeCore = function(o) {
          return this.source.subscribe(new InnerObserver(o, this.predicate, this));
        };
        function innerPredicate(predicate, self) {
          return function(x, i, o) {
            return self.predicate(x, i, o) && predicate.call(this, x, i, o);
          };
        }
        FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
          return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
        };
        function InnerObserver(o, predicate, source) {
          this.o = o;
          this.predicate = predicate;
          this.source = source;
          this.i = 0;
          this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function(x) {
          if (this.isStopped) {
            return ;
          }
          var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
          if (shouldYield === errorObj) {
            return this.o.onError(shouldYield.e);
          }
          shouldYield && this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
          }
        };
        InnerObserver.prototype.onCompleted = function() {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onCompleted();
          }
        };
        InnerObserver.prototype.dispose = function() {
          this.isStopped = true;
        };
        InnerObserver.prototype.fail = function(e) {
          if (!this.isStopped) {
            this.isStopped = true;
            this.o.onError(e);
            return true;
          }
          return false;
        };
        return FilterObservable;
      }(ObservableBase));
      observableProto.filter = observableProto.where = function(predicate, thisArg) {
        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
      };
      observableProto.transduce = function(transducer) {
        var source = this;
        function transformForObserver(o) {
          return {
            '@@transducer/init': function() {
              return o;
            },
            '@@transducer/step': function(obs, input) {
              return obs.onNext(input);
            },
            '@@transducer/result': function(obs) {
              return obs.onCompleted();
            }
          };
        }
        return new AnonymousObservable(function(o) {
          var xform = transducer(transformForObserver(o));
          return source.subscribe(function(v) {
            try {
              xform['@@transducer/step'](o, v);
            } catch (e) {
              o.onError(e);
            }
          }, function(e) {
            o.onError(e);
          }, function() {
            xform['@@transducer/result'](o);
          });
        }, source);
      };
      var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
        inherits(AnonymousObservable, __super__);
        function fixSubscriber(subscriber) {
          return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
          var ado = state[0],
              subscribe = state[1];
          var sub = tryCatch(subscribe)(ado);
          if (sub === errorObj) {
            if (!ado.fail(errorObj.e)) {
              return thrower(errorObj.e);
            }
          }
          ado.setDisposable(fixSubscriber(sub));
        }
        function AnonymousObservable(subscribe, parent) {
          this.source = parent;
          function s(observer) {
            var ado = new AutoDetachObserver(observer),
                state = [ado, subscribe];
            if (currentThreadScheduler.scheduleRequired()) {
              currentThreadScheduler.scheduleWithState(state, setDisposable);
            } else {
              setDisposable(null, state);
            }
            return ado;
          }
          __super__.call(this, s);
        }
        return AnonymousObservable;
      }(Observable));
      var AutoDetachObserver = (function(__super__) {
        inherits(AutoDetachObserver, __super__);
        function AutoDetachObserver(observer) {
          __super__.call(this);
          this.observer = observer;
          this.m = new SingleAssignmentDisposable();
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function(value) {
          var result = tryCatch(this.observer.onNext).call(this.observer, value);
          if (result === errorObj) {
            this.dispose();
            thrower(result.e);
          }
        };
        AutoDetachObserverPrototype.error = function(err) {
          var result = tryCatch(this.observer.onError).call(this.observer, err);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.completed = function() {
          var result = tryCatch(this.observer.onCompleted).call(this.observer);
          this.dispose();
          result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.setDisposable = function(value) {
          this.m.setDisposable(value);
        };
        AutoDetachObserverPrototype.getDisposable = function() {
          return this.m.getDisposable();
        };
        AutoDetachObserverPrototype.dispose = function() {
          __super__.prototype.dispose.call(this);
          this.m.dispose();
        };
        return AutoDetachObserver;
      }(AbstractObserver));
      var InnerSubscription = function(subject, observer) {
        this.subject = subject;
        this.observer = observer;
      };
      InnerSubscription.prototype.dispose = function() {
        if (!this.subject.isDisposed && this.observer !== null) {
          var idx = this.subject.observers.indexOf(this.observer);
          this.subject.observers.splice(idx, 1);
          this.observer = null;
        }
      };
      var Subject = Rx.Subject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
            return disposableEmpty;
          }
          observer.onCompleted();
          return disposableEmpty;
        }
        inherits(Subject, __super__);
        function Subject() {
          __super__.call(this, subscribe);
          this.isDisposed = false, this.isStopped = false, this.observers = [];
          this.hasError = false;
        }
        addProperties(Subject.prototype, Observer.prototype, {
          hasObservers: function() {
            return this.observers.length > 0;
          },
          onCompleted: function() {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onCompleted();
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.error = error;
              this.hasError = true;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (!this.isStopped) {
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onNext(value);
              }
            }
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
          }
        });
        Subject.create = function(observer, observable) {
          return new AnonymousSubject(observer, observable);
        };
        return Subject;
      }(Observable));
      var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
        function subscribe(observer) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.observers.push(observer);
            return new InnerSubscription(this, observer);
          }
          if (this.hasError) {
            observer.onError(this.error);
          } else if (this.hasValue) {
            observer.onNext(this.value);
            observer.onCompleted();
          } else {
            observer.onCompleted();
          }
          return disposableEmpty;
        }
        inherits(AsyncSubject, __super__);
        function AsyncSubject() {
          __super__.call(this, subscribe);
          this.isDisposed = false;
          this.isStopped = false;
          this.hasValue = false;
          this.observers = [];
          this.hasError = false;
        }
        addProperties(AsyncSubject.prototype, Observer, {
          hasObservers: function() {
            checkDisposed(this);
            return this.observers.length > 0;
          },
          onCompleted: function() {
            var i,
                len;
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              var os = cloneArray(this.observers),
                  len = os.length;
              if (this.hasValue) {
                for (i = 0; i < len; i++) {
                  var o = os[i];
                  o.onNext(this.value);
                  o.onCompleted();
                }
              } else {
                for (i = 0; i < len; i++) {
                  os[i].onCompleted();
                }
              }
              this.observers.length = 0;
            }
          },
          onError: function(error) {
            checkDisposed(this);
            if (!this.isStopped) {
              this.isStopped = true;
              this.hasError = true;
              this.error = error;
              for (var i = 0,
                  os = cloneArray(this.observers),
                  len = os.length; i < len; i++) {
                os[i].onError(error);
              }
              this.observers.length = 0;
            }
          },
          onNext: function(value) {
            checkDisposed(this);
            if (this.isStopped) {
              return ;
            }
            this.value = value;
            this.hasValue = true;
          },
          dispose: function() {
            this.isDisposed = true;
            this.observers = null;
            this.exception = null;
            this.value = null;
          }
        });
        return AsyncSubject;
      }(Observable));
      var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
        inherits(AnonymousSubject, __super__);
        function subscribe(observer) {
          return this.observable.subscribe(observer);
        }
        function AnonymousSubject(observer, observable) {
          this.observer = observer;
          this.observable = observable;
          __super__.call(this, subscribe);
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
          onCompleted: function() {
            this.observer.onCompleted();
          },
          onError: function(error) {
            this.observer.onError(error);
          },
          onNext: function(value) {
            this.observer.onNext(value);
          }
        });
        return AnonymousSubject;
      }(Observable));
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root.Rx = Rx;
        define(function() {
          return Rx;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = Rx).Rx = Rx;
        } else {
          freeExports.Rx = Rx;
        }
      } else {
        root.Rx = Rx;
      }
      var rEndingLine = captureLine();
    }.call(this));
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/get-iterator", ["npm:core-js@0.9.14/library/modules/web.dom.iterable", "npm:core-js@0.9.14/library/modules/es6.string.iterator", "npm:core-js@0.9.14/library/modules/core.iter-helpers", "npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/web.dom.iterable");
  require("npm:core-js@0.9.14/library/modules/es6.string.iterator");
  require("npm:core-js@0.9.14/library/modules/core.iter-helpers");
  module.exports = require("npm:core-js@0.9.14/library/modules/$").core.getIterator;
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3/index", ["npm:rx@2.5.3/dist/rx", "npm:rx@2.5.3/dist/rx.aggregates", "npm:rx@2.5.3/dist/rx.async", "npm:rx@2.5.3/dist/rx.backpressure", "npm:rx@2.5.3/dist/rx.binding", "npm:rx@2.5.3/dist/rx.coincidence", "npm:rx@2.5.3/dist/rx.experimental", "npm:rx@2.5.3/dist/rx.joinpatterns", "npm:rx@2.5.3/dist/rx.sorting", "npm:rx@2.5.3/dist/rx.virtualtime", "npm:rx@2.5.3/dist/rx.testing", "npm:rx@2.5.3/dist/rx.time"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var Rx = require("npm:rx@2.5.3/dist/rx");
  require("npm:rx@2.5.3/dist/rx.aggregates");
  require("npm:rx@2.5.3/dist/rx.async");
  require("npm:rx@2.5.3/dist/rx.backpressure");
  require("npm:rx@2.5.3/dist/rx.binding");
  require("npm:rx@2.5.3/dist/rx.coincidence");
  require("npm:rx@2.5.3/dist/rx.experimental");
  require("npm:rx@2.5.3/dist/rx.joinpatterns");
  require("npm:rx@2.5.3/dist/rx.sorting");
  require("npm:rx@2.5.3/dist/rx.virtualtime");
  require("npm:rx@2.5.3/dist/rx.testing");
  require("npm:rx@2.5.3/dist/rx.time");
  module.exports = Rx;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/get-iterator", ["npm:core-js@0.9.14/library/fn/get-iterator"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/get-iterator"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:rx@2.5.3", ["npm:rx@2.5.3/index"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:rx@2.5.3/index");
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.ctx", ["npm:core-js@0.9.14/library/modules/$.assert"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var assertFunction = require("npm:core-js@0.9.14/library/modules/$.assert").fn;
  module.exports = function(fn, that, length) {
    assertFunction(fn);
    if (~length && that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.iter-call", ["npm:core-js@0.9.14/library/modules/$.assert"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var assertObject = require("npm:core-js@0.9.14/library/modules/$.assert").obj;
  function close(iterator) {
    var ret = iterator['return'];
    if (ret !== undefined)
      assertObject(ret.call(iterator));
  }
  function call(iterator, fn, value, entries) {
    try {
      return entries ? fn(assertObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      close(iterator);
      throw e;
    }
  }
  call.close = close;
  module.exports = call;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.set-proto", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.assert", "npm:core-js@0.9.14/library/modules/$.ctx"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      assert = require("npm:core-js@0.9.14/library/modules/$.assert");
  function check(O, proto) {
    assert.obj(O);
    assert(proto === null || $.isObject(proto), proto, ": can't set as prototype!");
  }
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(buggy, set) {
      try {
        set = require("npm:core-js@0.9.14/library/modules/$.ctx")(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);
        set({}, []);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }() : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.same", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.species", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      SPECIES = require("npm:core-js@0.9.14/library/modules/$.wks")('species');
  module.exports = function(C) {
    if ($.DESC && !(SPECIES in C))
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: $.that
      });
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.invoke", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
      case 5:
        return un ? fn(args[0], args[1], args[2], args[3], args[4]) : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.dom-create", ["npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      document = $.g.document,
      isObject = $.isObject,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.mix", ["npm:core-js@0.9.14/library/modules/$.redef"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $redef = require("npm:core-js@0.9.14/library/modules/$.redef");
  module.exports = function(target, src) {
    for (var key in src)
      $redef(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.iter-detect", ["npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var SYMBOL_ITERATOR = require("npm:core-js@0.9.14/library/modules/$.wks")('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][SYMBOL_ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec) {
    if (!SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[SYMBOL_ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[SYMBOL_ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.for-of", ["npm:core-js@0.9.14/library/modules/$.ctx", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.iter-call"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var ctx = require("npm:core-js@0.9.14/library/modules/$.ctx"),
      get = require("npm:core-js@0.9.14/library/modules/$.iter").get,
      call = require("npm:core-js@0.9.14/library/modules/$.iter-call");
  module.exports = function(iterable, entries, fn, that) {
    var iterator = get(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        step;
    while (!(step = iterator.next()).done) {
      if (call(iterator, f, step.value, entries) === false) {
        return call.close(iterator);
      }
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.object.to-string", ["npm:core-js@0.9.14/library/modules/$.cof", "npm:core-js@0.9.14/library/modules/$.wks", "npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.redef"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var cof = require("npm:core-js@0.9.14/library/modules/$.cof"),
      tmp = {};
  tmp[require("npm:core-js@0.9.14/library/modules/$.wks")('toStringTag')] = 'z';
  if (require("npm:core-js@0.9.14/library/modules/$").FW && cof(tmp) != 'z') {
    require("npm:core-js@0.9.14/library/modules/$.redef")(Object.prototype, 'toString', function toString() {
      return '[object ' + cof.classof(this) + ']';
    }, true);
  }
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.task", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.ctx", "npm:core-js@0.9.14/library/modules/$.cof", "npm:core-js@0.9.14/library/modules/$.invoke", "npm:core-js@0.9.14/library/modules/$.dom-create", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = require("npm:core-js@0.9.14/library/modules/$"),
        ctx = require("npm:core-js@0.9.14/library/modules/$.ctx"),
        cof = require("npm:core-js@0.9.14/library/modules/$.cof"),
        invoke = require("npm:core-js@0.9.14/library/modules/$.invoke"),
        cel = require("npm:core-js@0.9.14/library/modules/$.dom-create"),
        global = $.g,
        isFunction = $.isFunction,
        html = $.html,
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        postMessage = global.postMessage,
        addEventListener = global.addEventListener,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    function run() {
      var id = +this;
      if ($.has(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    }
    function listner(event) {
      run.call(event.data);
    }
    if (!isFunction(setTask) || !isFunction(clearTask)) {
      setTask = function(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(isFunction(fn) ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function(id) {
        delete queue[id];
      };
      if (cof(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (addEventListener && isFunction(postMessage) && !global.importScripts) {
        defer = function(id) {
          postMessage(id, '*');
        };
        addEventListener('message', listner, false);
      } else if (isFunction(MessageChannel)) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.promise", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.ctx", "npm:core-js@0.9.14/library/modules/$.cof", "npm:core-js@0.9.14/library/modules/$.def", "npm:core-js@0.9.14/library/modules/$.assert", "npm:core-js@0.9.14/library/modules/$.for-of", "npm:core-js@0.9.14/library/modules/$.set-proto", "npm:core-js@0.9.14/library/modules/$.same", "npm:core-js@0.9.14/library/modules/$.species", "npm:core-js@0.9.14/library/modules/$.wks", "npm:core-js@0.9.14/library/modules/$.uid", "npm:core-js@0.9.14/library/modules/$.task", "npm:core-js@0.9.14/library/modules/$.mix", "npm:core-js@0.9.14/library/modules/$.iter-detect", "github:jspm/nodelibs-process@0.1.1"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = require("npm:core-js@0.9.14/library/modules/$"),
        ctx = require("npm:core-js@0.9.14/library/modules/$.ctx"),
        cof = require("npm:core-js@0.9.14/library/modules/$.cof"),
        $def = require("npm:core-js@0.9.14/library/modules/$.def"),
        assert = require("npm:core-js@0.9.14/library/modules/$.assert"),
        forOf = require("npm:core-js@0.9.14/library/modules/$.for-of"),
        setProto = require("npm:core-js@0.9.14/library/modules/$.set-proto").set,
        same = require("npm:core-js@0.9.14/library/modules/$.same"),
        species = require("npm:core-js@0.9.14/library/modules/$.species"),
        SPECIES = require("npm:core-js@0.9.14/library/modules/$.wks")('species'),
        RECORD = require("npm:core-js@0.9.14/library/modules/$.uid").safe('record'),
        PROMISE = 'Promise',
        global = $.g,
        process = global.process,
        asap = process && process.nextTick || require("npm:core-js@0.9.14/library/modules/$.task").set,
        P = global[PROMISE],
        isFunction = $.isFunction,
        isObject = $.isObject,
        assertFunction = assert.fn,
        assertObject = assert.obj,
        Wrapper;
    function testResolve(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    }
    var useNative = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = isFunction(P) && isFunction(P.resolve) && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    function isPromise(it) {
      return isObject(it) && (useNative ? cof.classof(it) == 'Promise' : RECORD in it);
    }
    function sameConstructor(a, b) {
      if (!$.FW && a === P && b === Wrapper)
        return true;
      return same(a, b);
    }
    function getConstructor(C) {
      var S = assertObject(C)[SPECIES];
      return S != undefined ? S : C;
    }
    function isThenable(it) {
      var then;
      if (isObject(it))
        then = it.then;
      return isFunction(then) ? then : false;
    }
    function notify(record) {
      var chain = record.c;
      if (chain.length)
        asap(function() {
          var value = record.v,
              ok = record.s == 1,
              i = 0;
          function run(react) {
            var cb = ok ? react.ok : react.fail,
                ret,
                then;
            try {
              if (cb) {
                if (!ok)
                  record.h = true;
                ret = cb === true ? value : cb(value);
                if (ret === react.P) {
                  react.rej(TypeError('Promise-chain cycle'));
                } else if (then = isThenable(ret)) {
                  then.call(ret, react.res, react.rej);
                } else
                  react.res(ret);
              } else
                react.rej(value);
            } catch (err) {
              react.rej(err);
            }
          }
          while (chain.length > i)
            run(chain[i++]);
          chain.length = 0;
        });
    }
    function isUnhandled(promise) {
      var record = promise[RECORD],
          chain = record.a || record.c,
          i = 0,
          react;
      if (record.h)
        return false;
      while (chain.length > i) {
        react = chain[i++];
        if (react.fail || !isUnhandled(react.P))
          return false;
      }
      return true;
    }
    function $reject(value) {
      var record = this,
          promise;
      if (record.d)
        return ;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      setTimeout(function() {
        asap(function() {
          if (isUnhandled(promise = record.p)) {
            if (cof(process) == 'process') {
              process.emit('unhandledRejection', value, promise);
            } else if (global.console && isFunction(console.error)) {
              console.error('Unhandled promise rejection', value);
            }
          }
          record.a = undefined;
        });
      }, 1);
      notify(record);
    }
    function $resolve(value) {
      var record = this,
          then,
          wrapper;
      if (record.d)
        return ;
      record.d = true;
      record = record.r || record;
      try {
        if (then = isThenable(value)) {
          wrapper = {
            r: record,
            d: false
          };
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch (err) {
        $reject.call(wrapper || {
          r: record,
          d: false
        }, err);
      }
    }
    if (!useNative) {
      P = function Promise(executor) {
        assertFunction(executor);
        var record = {
          p: assert.inst(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false
        };
        $.hide(this, RECORD, record);
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      require("npm:core-js@0.9.14/library/modules/$.mix")(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var S = assertObject(assertObject(this).constructor)[SPECIES];
          var react = {
            ok: isFunction(onFulfilled) ? onFulfilled : true,
            fail: isFunction(onRejected) ? onRejected : false
          };
          var promise = react.P = new (S != undefined ? S : P)(function(res, rej) {
            react.res = assertFunction(res);
            react.rej = assertFunction(rej);
          });
          var record = this[RECORD];
          record.c.push(react);
          if (record.a)
            record.a.push(react);
          if (record.s)
            notify(record);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $def($def.G + $def.W + $def.F * !useNative, {Promise: P});
    cof.set(P, PROMISE);
    species(P);
    species(Wrapper = $.core[PROMISE]);
    $def($def.S + $def.F * !useNative, PROMISE, {reject: function reject(r) {
        return new (getConstructor(this))(function(res, rej) {
          rej(r);
        });
      }});
    $def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        return isPromise(x) && sameConstructor(x.constructor, this) ? x : new this(function(res) {
          res(x);
        });
      }});
    $def($def.S + $def.F * !(useNative && require("npm:core-js@0.9.14/library/modules/$.iter-detect")(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            values = [];
        return new C(function(res, rej) {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              C.resolve(promise).then(function(value) {
                results[index] = value;
                --remaining || res(results);
              }, rej);
            });
          else
            res(results);
        });
      },
      race: function race(iterable) {
        var C = getConstructor(this);
        return new C(function(res, rej) {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(res, rej);
          });
        });
      }
    });
  })(require("github:jspm/nodelibs-process@0.1.1"));
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/promise", ["npm:core-js@0.9.14/library/modules/es6.object.to-string", "npm:core-js@0.9.14/library/modules/es6.string.iterator", "npm:core-js@0.9.14/library/modules/web.dom.iterable", "npm:core-js@0.9.14/library/modules/es6.promise", "npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/es6.object.to-string");
  require("npm:core-js@0.9.14/library/modules/es6.string.iterator");
  require("npm:core-js@0.9.14/library/modules/web.dom.iterable");
  require("npm:core-js@0.9.14/library/modules/es6.promise");
  module.exports = require("npm:core-js@0.9.14/library/modules/$").core.Promise;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/promise", ["npm:core-js@0.9.14/library/fn/promise"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/promise"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.collection-to-json", ["npm:core-js@0.9.14/library/modules/$.def", "npm:core-js@0.9.14/library/modules/$.for-of"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  var $def = require("npm:core-js@0.9.14/library/modules/$.def"),
      forOf = require("npm:core-js@0.9.14/library/modules/$.for-of");
  module.exports = function(NAME) {
    $def($def.P, NAME, {toJSON: function toJSON() {
        var arr = [];
        forOf(this, false, arr.push, arr);
        return arr;
      }});
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/symbol/iterator", ["npm:core-js@0.9.14/library/modules/es6.string.iterator", "npm:core-js@0.9.14/library/modules/web.dom.iterable", "npm:core-js@0.9.14/library/modules/$.wks"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/es6.string.iterator");
  require("npm:core-js@0.9.14/library/modules/web.dom.iterable");
  module.exports = require("npm:core-js@0.9.14/library/modules/$.wks")('iterator');
  global.define = __define;
  return module.exports;
});

System.register("angular2/src/core/compiler/interfaces", [], false, function(__require, __exports, __module) {
  System.get("@@global-helpers").prepareGlobal(__module.id, []);
  (function() {}).call(System.global);
  return System.get("@@global-helpers").retrieveGlobal(__module.id, false);
});

System.register("npm:core-js@0.9.14/library/modules/$.collection", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.def", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.for-of", "npm:core-js@0.9.14/library/modules/$.species", "npm:core-js@0.9.14/library/modules/$.assert", "npm:core-js@0.9.14/library/modules/$.redef", "npm:core-js@0.9.14/library/modules/$.mix", "npm:core-js@0.9.14/library/modules/$.iter-detect", "npm:core-js@0.9.14/library/modules/$.cof"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      $def = require("npm:core-js@0.9.14/library/modules/$.def"),
      BUGGY = require("npm:core-js@0.9.14/library/modules/$.iter").BUGGY,
      forOf = require("npm:core-js@0.9.14/library/modules/$.for-of"),
      species = require("npm:core-js@0.9.14/library/modules/$.species"),
      assertInstance = require("npm:core-js@0.9.14/library/modules/$.assert").inst;
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = $.g[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    function fixMethod(KEY) {
      if ($.FW) {
        var fn = proto[KEY];
        require("npm:core-js@0.9.14/library/modules/$.redef")(proto, KEY, KEY == 'delete' ? function(a) {
          return fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'has' ? function has(a) {
          return fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'get' ? function get(a) {
          return fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'add' ? function add(a) {
          fn.call(this, a === 0 ? 0 : a);
          return this;
        } : function set(a, b) {
          fn.call(this, a === 0 ? 0 : a, b);
          return this;
        });
      }
    }
    if (!$.isFunction(C) || !(IS_WEAK || !BUGGY && proto.forEach && proto.entries)) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      require("npm:core-js@0.9.14/library/modules/$.mix")(C.prototype, methods);
      C.prototype.constructor = C;
    } else {
      var inst = new C,
          chain = inst[ADDER](IS_WEAK ? {} : -0, 1),
          buggyZero;
      if (!require("npm:core-js@0.9.14/library/modules/$.iter-detect")(function(iter) {
        new C(iter);
      })) {
        C = wrapper(function(target, iterable) {
          assertInstance(target, C, NAME);
          var that = new Base;
          if (iterable != undefined)
            forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        if ($.FW)
          proto.constructor = C;
      }
      IS_WEAK || inst.forEach(function(val, key) {
        buggyZero = 1 / key === -Infinity;
      });
      if (buggyZero) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (buggyZero || chain !== inst)
        fixMethod(ADDER);
    }
    require("npm:core-js@0.9.14/library/modules/$.cof").set(C, NAME);
    O[NAME] = C;
    $def($def.G + $def.W + $def.F * (C != Base), O);
    species(C);
    species($.core[NAME]);
    if (!IS_WEAK)
      common.setIter(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es7.map.to-json", ["npm:core-js@0.9.14/library/modules/$.collection-to-json"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/$.collection-to-json")('Map');
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/symbol/iterator", ["npm:core-js@0.9.14/library/fn/symbol/iterator"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/symbol/iterator"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/$.collection-strong", ["npm:core-js@0.9.14/library/modules/$", "npm:core-js@0.9.14/library/modules/$.ctx", "npm:core-js@0.9.14/library/modules/$.uid", "npm:core-js@0.9.14/library/modules/$.assert", "npm:core-js@0.9.14/library/modules/$.for-of", "npm:core-js@0.9.14/library/modules/$.iter", "npm:core-js@0.9.14/library/modules/$.mix", "npm:core-js@0.9.14/library/modules/$.iter-define"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = require("npm:core-js@0.9.14/library/modules/$"),
      ctx = require("npm:core-js@0.9.14/library/modules/$.ctx"),
      safe = require("npm:core-js@0.9.14/library/modules/$.uid").safe,
      assert = require("npm:core-js@0.9.14/library/modules/$.assert"),
      forOf = require("npm:core-js@0.9.14/library/modules/$.for-of"),
      step = require("npm:core-js@0.9.14/library/modules/$.iter").step,
      $has = $.has,
      set = $.set,
      isObject = $.isObject,
      hide = $.hide,
      isExtensible = Object.isExtensible || isObject,
      ID = safe('id'),
      O1 = safe('O1'),
      LAST = safe('last'),
      FIRST = safe('first'),
      ITER = safe('iter'),
      SIZE = $.DESC ? safe('size') : 'size',
      id = 0;
  function fastKey(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  }
  function getEntry(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that[O1][index];
    for (entry = that[FIRST]; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  }
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        assert.inst(that, C, NAME);
        set(that, O1, $.create(null));
        set(that, SIZE, 0);
        set(that, LAST, undefined);
        set(that, FIRST, undefined);
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      require("npm:core-js@0.9.14/library/modules/$.mix")(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that[O1],
              entry = that[FIRST]; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that[FIRST] = that[LAST] = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that[O1][entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that[FIRST] == entry)
              that[FIRST] = next;
            if (that[LAST] == entry)
              that[LAST] = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments[1], 3),
              entry;
          while (entry = entry ? entry.n : this[FIRST]) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if ($.DESC)
        $.setDesc(C.prototype, 'size', {get: function() {
            return assert.def(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that[LAST] = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that[LAST],
          n: undefined,
          r: false
        };
        if (!that[FIRST])
          that[FIRST] = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that[O1][index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setIter: function(C, NAME, IS_MAP) {
      require("npm:core-js@0.9.14/library/modules/$.iter-define")(C, NAME, function(iterated, kind) {
        set(this, ITER, {
          o: iterated,
          k: kind
        });
      }, function() {
        var iter = this[ITER],
            kind = iter.k,
            entry = iter.l;
        while (entry && entry.r)
          entry = entry.p;
        if (!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])) {
          iter.o = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
    }
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/modules/es6.map", ["npm:core-js@0.9.14/library/modules/$.collection-strong", "npm:core-js@0.9.14/library/modules/$.collection"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var strong = require("npm:core-js@0.9.14/library/modules/$.collection-strong");
  require("npm:core-js@0.9.14/library/modules/$.collection")('Map', function(get) {
    return function Map() {
      return get(this, arguments[0]);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/map", ["npm:core-js@0.9.14/library/modules/es6.object.to-string", "npm:core-js@0.9.14/library/modules/es6.string.iterator", "npm:core-js@0.9.14/library/modules/web.dom.iterable", "npm:core-js@0.9.14/library/modules/es6.map", "npm:core-js@0.9.14/library/modules/es7.map.to-json", "npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/es6.object.to-string");
  require("npm:core-js@0.9.14/library/modules/es6.string.iterator");
  require("npm:core-js@0.9.14/library/modules/web.dom.iterable");
  require("npm:core-js@0.9.14/library/modules/es6.map");
  require("npm:core-js@0.9.14/library/modules/es7.map.to-json");
  module.exports = require("npm:core-js@0.9.14/library/modules/$").core.Map;
  global.define = __define;
  return module.exports;
});

System.register("npm:core-js@0.9.14/library/fn/is-iterable", ["npm:core-js@0.9.14/library/modules/web.dom.iterable", "npm:core-js@0.9.14/library/modules/es6.string.iterator", "npm:core-js@0.9.14/library/modules/core.iter-helpers", "npm:core-js@0.9.14/library/modules/$"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  require("npm:core-js@0.9.14/library/modules/web.dom.iterable");
  require("npm:core-js@0.9.14/library/modules/es6.string.iterator");
  require("npm:core-js@0.9.14/library/modules/core.iter-helpers");
  module.exports = require("npm:core-js@0.9.14/library/modules/$").core.isIterable;
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/map", ["npm:core-js@0.9.14/library/fn/map"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/map"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/core-js/is-iterable", ["npm:core-js@0.9.14/library/fn/is-iterable"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": require("npm:core-js@0.9.14/library/fn/is-iterable"),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("npm:babel-runtime@5.4.7/helpers/sliced-to-array", ["npm:babel-runtime@5.4.7/core-js/is-iterable", "npm:babel-runtime@5.4.7/core-js/get-iterator"], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _isIterable = require("npm:babel-runtime@5.4.7/core-js/is-iterable")["default"];
  var _getIterator = require("npm:babel-runtime@5.4.7/core-js/get-iterator")["default"];
  exports["default"] = function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (_isIterable(Object(arr))) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register('angular2/src/facade/lang', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/core-js/number/is-integer'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, _Number$isInteger, _global, Type, BaseException, Math, Date, assertionsEnabled_, StringWrapper, StringJoiner, NumberParseError, NumberWrapper, RegExp, RegExpWrapper, RegExpMatcherWrapper, FunctionWrapper, Json, DateWrapper;

    function assertionsEnabled() {
        return assertionsEnabled_;
    }

    // This function is needed only to properly support Dart's const expressions
    // see https://github.com/angular/ts2dart/pull/151 for more info

    function CONST_EXPR(expr) {
        return expr;
    }

    function CONST() {
        return function (target) {
            return target;
        };
    }

    function ABSTRACT() {
        return function (t) {
            return t;
        };
    }

    // Note: This is only a marker annotation needed for ts2dart.
    // This is written so that is can be used as a Traceur annotation
    // or a Typescript decorator.

    function IMPLEMENTS(_) {
        return function (t) {
            return t;
        };
    }

    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }

    function isBlank(obj) {
        return obj === undefined || obj === null;
    }

    function isString(obj) {
        return typeof obj === 'string';
    }

    function isFunction(obj) {
        return typeof obj === 'function';
    }

    function isType(obj) {
        return isFunction(obj);
    }

    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.name) {
            return token.name;
        }
        return token.toString();
    }

    // JS has NaN !== NaN

    function looseIdentical(a, b) {
        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
    }

    // JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map

    function getMapKey(value) {
        return value;
    }

    function normalizeBlank(obj) {
        return isBlank(obj) ? null : obj;
    }

    function normalizeBool(obj) {
        return isBlank(obj) ? false : obj;
    }

    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }

    function print(obj) {
        if (obj instanceof Error) {
            console.log(obj.stack);
        } else {
            console.log(obj);
        }
    }

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547CoreJsNumberIsInteger) {
            _Number$isInteger = _npmBabelRuntime547CoreJsNumberIsInteger['default'];
        }],
        execute: function () {
            'use strict';

            _export('assertionsEnabled', assertionsEnabled);

            _export('CONST_EXPR', CONST_EXPR);

            _export('CONST', CONST);

            _export('ABSTRACT', ABSTRACT);

            _export('IMPLEMENTS', IMPLEMENTS);

            _export('isPresent', isPresent);

            _export('isBlank', isBlank);

            _export('isString', isString);

            _export('isFunction', isFunction);

            _export('isType', isType);

            _export('stringify', stringify);

            _export('looseIdentical', looseIdentical);

            _export('getMapKey', getMapKey);

            _export('normalizeBlank', normalizeBlank);

            _export('normalizeBool', normalizeBool);

            _export('isJsObject', isJsObject);

            _export('print', print);

            _global = typeof window === 'undefined' ? global : window;

            _export('global', _global);

            Type = Function;

            _export('Type', Type);

            BaseException = (function (_Error) {
                function BaseException(message) {
                    _classCallCheck(this, BaseException);

                    _get(Object.getPrototypeOf(BaseException.prototype), 'constructor', this).call(this, message);
                    this.message = message;
                    this.stack = new Error().stack;
                }

                _inherits(BaseException, _Error);

                _createClass(BaseException, [{
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return BaseException;
            })(Error);

            _export('BaseException', BaseException);

            Math = _global.Math;

            _export('Math', Math);

            Date = _global.Date;

            _export('Date', Date);

            assertionsEnabled_ = typeof _global['assert'] !== 'undefined';

            // TODO: remove calls to assert in production environment
            // Note: Can't just export this and import in in other files
            // as `assert` is a reserved keyword in Dart
            _global.assert = function assert(condition) {
                if (assertionsEnabled_) {
                    _global['assert'].call(condition);
                }
            };
            StringWrapper = (function () {
                function StringWrapper() {
                    _classCallCheck(this, StringWrapper);
                }

                _createClass(StringWrapper, null, [{
                    key: 'fromCharCode',
                    value: function fromCharCode(code) {
                        return String.fromCharCode(code);
                    }
                }, {
                    key: 'charCodeAt',
                    value: function charCodeAt(s, index) {
                        return s.charCodeAt(index);
                    }
                }, {
                    key: 'split',
                    value: function split(s, regExp) {
                        return s.split(regExp);
                    }
                }, {
                    key: 'equals',
                    value: function equals(s, s2) {
                        return s === s2;
                    }
                }, {
                    key: 'replace',
                    value: function replace(s, from, _replace) {
                        return s.replace(from, _replace);
                    }
                }, {
                    key: 'replaceAll',
                    value: function replaceAll(s, from, replace) {
                        return s.replace(from, replace);
                    }
                }, {
                    key: 'toUpperCase',
                    value: function toUpperCase(s) {
                        return s.toUpperCase();
                    }
                }, {
                    key: 'toLowerCase',
                    value: function toLowerCase(s) {
                        return s.toLowerCase();
                    }
                }, {
                    key: 'startsWith',
                    value: function startsWith(s, start) {
                        return s.startsWith(start);
                    }
                }, {
                    key: 'substring',
                    value: function substring(s, start) {
                        var end = arguments[2] === undefined ? null : arguments[2];

                        return s.substring(start, end === null ? undefined : end);
                    }
                }, {
                    key: 'replaceAllMapped',
                    value: function replaceAllMapped(s, from, cb) {
                        return s.replace(from, function () {
                            for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
                                matches[_key] = arguments[_key];
                            }

                            // Remove offset & string from the result array
                            matches.splice(-2, 2);
                            // The callback receives match, p1, ..., pn
                            return cb(matches);
                        });
                    }
                }, {
                    key: 'contains',
                    value: function contains(s, substr) {
                        return s.indexOf(substr) != -1;
                    }
                }]);

                return StringWrapper;
            })();

            _export('StringWrapper', StringWrapper);

            StringJoiner = (function () {
                function StringJoiner() {
                    var parts = arguments[0] === undefined ? [] : arguments[0];

                    _classCallCheck(this, StringJoiner);

                    this.parts = parts;
                }

                _createClass(StringJoiner, [{
                    key: 'add',
                    value: function add(part) {
                        this.parts.push(part);
                    }
                }, {
                    key: 'toString',
                    value: function toString() {
                        return this.parts.join('');
                    }
                }]);

                return StringJoiner;
            })();

            _export('StringJoiner', StringJoiner);

            NumberParseError = (function (_BaseException) {
                function NumberParseError(message) {
                    _classCallCheck(this, NumberParseError);

                    _get(Object.getPrototypeOf(NumberParseError.prototype), 'constructor', this).call(this);
                    this.message = message;
                }

                _inherits(NumberParseError, _BaseException);

                _createClass(NumberParseError, [{
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return NumberParseError;
            })(BaseException);

            _export('NumberParseError', NumberParseError);

            NumberWrapper = (function () {
                function NumberWrapper() {
                    _classCallCheck(this, NumberWrapper);
                }

                _createClass(NumberWrapper, null, [{
                    key: 'toFixed',
                    value: function toFixed(n, fractionDigits) {
                        return n.toFixed(fractionDigits);
                    }
                }, {
                    key: 'equal',
                    value: function equal(a, b) {
                        return a === b;
                    }
                }, {
                    key: 'parseIntAutoRadix',
                    value: function parseIntAutoRadix(text) {
                        var result = parseInt(text);
                        if (isNaN(result)) {
                            throw new NumberParseError('Invalid integer literal when parsing ' + text);
                        }
                        return result;
                    }
                }, {
                    key: 'parseInt',
                    value: (function (_parseInt) {
                        function parseInt(_x3, _x4) {
                            return _parseInt.apply(this, arguments);
                        }

                        parseInt.toString = function () {
                            return _parseInt.toString();
                        };

                        return parseInt;
                    })(function (text, radix) {
                        if (radix == 10) {
                            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                                return parseInt(text, radix);
                            }
                        } else if (radix == 16) {
                            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                                return parseInt(text, radix);
                            }
                        } else {
                            var result = parseInt(text, radix);
                            if (!isNaN(result)) {
                                return result;
                            }
                        }
                        throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
                    })
                }, {
                    key: 'parseFloat',

                    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
                    value: (function (_parseFloat) {
                        function parseFloat(_x5) {
                            return _parseFloat.apply(this, arguments);
                        }

                        parseFloat.toString = function () {
                            return _parseFloat.toString();
                        };

                        return parseFloat;
                    })(function (text) {
                        return parseFloat(text);
                    })
                }, {
                    key: 'NaN',
                    get: function () {
                        return NaN;
                    }
                }, {
                    key: 'isNaN',
                    value: (function (_isNaN) {
                        function isNaN(_x6) {
                            return _isNaN.apply(this, arguments);
                        }

                        isNaN.toString = function () {
                            return _isNaN.toString();
                        };

                        return isNaN;
                    })(function (value) {
                        return isNaN(value);
                    })
                }, {
                    key: 'isInteger',
                    value: function isInteger(value) {
                        return _Number$isInteger(value);
                    }
                }]);

                return NumberWrapper;
            })();

            _export('NumberWrapper', NumberWrapper);

            RegExp = _global.RegExp;

            _export('RegExp', RegExp);

            RegExpWrapper = (function () {
                function RegExpWrapper() {
                    _classCallCheck(this, RegExpWrapper);
                }

                _createClass(RegExpWrapper, null, [{
                    key: 'create',
                    value: function create(regExpStr) {
                        var flags = arguments[1] === undefined ? '' : arguments[1];

                        flags = flags.replace(/g/g, '');
                        return new _global.RegExp(regExpStr, flags + 'g');
                    }
                }, {
                    key: 'firstMatch',
                    value: function firstMatch(regExp, input) {
                        // Reset multimatch regex state
                        regExp.lastIndex = 0;
                        return regExp.exec(input);
                    }
                }, {
                    key: 'test',
                    value: function test(regExp, input) {
                        return regExp.test(input);
                    }
                }, {
                    key: 'matcher',
                    value: function matcher(regExp, input) {
                        // Reset regex state for the case
                        // someone did not loop over all matches
                        // last time.
                        regExp.lastIndex = 0;
                        return { re: regExp, input: input };
                    }
                }]);

                return RegExpWrapper;
            })();

            _export('RegExpWrapper', RegExpWrapper);

            RegExpMatcherWrapper = (function () {
                function RegExpMatcherWrapper() {
                    _classCallCheck(this, RegExpMatcherWrapper);
                }

                _createClass(RegExpMatcherWrapper, null, [{
                    key: 'next',
                    value: function next(matcher) {
                        return matcher.re.exec(matcher.input);
                    }
                }]);

                return RegExpMatcherWrapper;
            })();

            _export('RegExpMatcherWrapper', RegExpMatcherWrapper);

            FunctionWrapper = (function () {
                function FunctionWrapper() {
                    _classCallCheck(this, FunctionWrapper);
                }

                _createClass(FunctionWrapper, null, [{
                    key: 'apply',
                    value: function apply(fn, posArgs) {
                        return fn.apply(null, posArgs);
                    }
                }]);

                return FunctionWrapper;
            })();

            _export('FunctionWrapper', FunctionWrapper);

            // Can't be all uppercase as our transpiler would think it is a special directive...

            Json = (function () {
                function Json() {
                    _classCallCheck(this, Json);
                }

                _createClass(Json, null, [{
                    key: 'parse',
                    value: function parse(s) {
                        return _global.JSON.parse(s);
                    }
                }, {
                    key: 'stringify',
                    value: function stringify(data) {
                        // Dart doesn't take 3 arguments
                        return _global.JSON.stringify(data, null, 2);
                    }
                }]);

                return Json;
            })();

            _export('Json', Json);

            DateWrapper = (function () {
                function DateWrapper() {
                    _classCallCheck(this, DateWrapper);
                }

                _createClass(DateWrapper, null, [{
                    key: 'fromMillis',
                    value: function fromMillis(ms) {
                        return new Date(ms);
                    }
                }, {
                    key: 'toMillis',
                    value: function toMillis(date) {
                        return date.getTime();
                    }
                }, {
                    key: 'now',
                    value: function now() {
                        return new Date();
                    }
                }, {
                    key: 'toJson',
                    value: function toJson(date) {
                        return date.toJSON();
                    }
                }]);

                return DateWrapper;
            })();

            _export('DateWrapper', DateWrapper);
        }
    };
});


System.register('angular2/src/facade/async', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'angular2/src/facade/lang', 'npm:rx@2.5.3'], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, global, Rx, Promise, PromiseWrapper, TimerWrapper, ObservableWrapper, Observable, EventEmitter;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_angular2SrcFacadeLang) {
            global = _angular2SrcFacadeLang.global;
        }, function (_npmRx253) {
            Rx = _npmRx253;
        }],
        execute: function () {
            /// <reference path="../../typings/es6-promise/es6-promise.d.ts" />
            /// <reference path="../../typings/rx/rx.all.d.ts" />
            'use strict';

            Promise = global.Promise;

            _export('Promise', Promise);

            PromiseWrapper = (function () {
                function PromiseWrapper() {
                    _classCallCheck(this, PromiseWrapper);
                }

                _createClass(PromiseWrapper, null, [{
                    key: 'resolve',
                    value: function resolve(obj) {
                        return Promise.resolve(obj);
                    }
                }, {
                    key: 'reject',
                    value: function reject(obj, _) {
                        return Promise.reject(obj);
                    }
                }, {
                    key: 'catchError',

                    // Note: We can't rename this method into `catch`, as this is not a valid
                    // method name in Dart.
                    value: function catchError(promise, onError) {
                        return promise['catch'](onError);
                    }
                }, {
                    key: 'all',
                    value: function all(promises) {
                        if (promises.length == 0) return Promise.resolve([]);
                        return Promise.all(promises);
                    }
                }, {
                    key: 'then',
                    value: function then(promise, success, rejection) {
                        return promise.then(success, rejection);
                    }
                }, {
                    key: 'completer',
                    value: function completer() {
                        var resolve;
                        var reject;
                        var p = new Promise(function (res, rej) {
                            resolve = res;
                            reject = rej;
                        });
                        return { promise: p, resolve: resolve, reject: reject };
                    }
                }, {
                    key: 'isPromise',
                    value: function isPromise(maybePromise) {
                        return maybePromise instanceof Promise;
                    }
                }]);

                return PromiseWrapper;
            })();

            _export('PromiseWrapper', PromiseWrapper);

            TimerWrapper = (function () {
                function TimerWrapper() {
                    _classCallCheck(this, TimerWrapper);
                }

                _createClass(TimerWrapper, null, [{
                    key: 'setTimeout',
                    value: function setTimeout(fn, millis) {
                        return global.setTimeout(fn, millis);
                    }
                }, {
                    key: 'clearTimeout',
                    value: function clearTimeout(id) {
                        global.clearTimeout(id);
                    }
                }, {
                    key: 'setInterval',
                    value: function setInterval(fn, millis) {
                        return global.setInterval(fn, millis);
                    }
                }, {
                    key: 'clearInterval',
                    value: function clearInterval(id) {
                        global.clearInterval(id);
                    }
                }]);

                return TimerWrapper;
            })();

            _export('TimerWrapper', TimerWrapper);

            ObservableWrapper = (function () {
                function ObservableWrapper() {
                    _classCallCheck(this, ObservableWrapper);
                }

                _createClass(ObservableWrapper, null, [{
                    key: 'subscribe',
                    value: function subscribe(emitter, onNext) {
                        var onThrow = arguments[2] === undefined ? null : arguments[2];
                        var onReturn = arguments[3] === undefined ? null : arguments[3];

                        return emitter.observer({ next: onNext, 'throw': onThrow, 'return': onReturn });
                    }
                }, {
                    key: 'isObservable',
                    value: function isObservable(obs) {
                        return obs instanceof Observable;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose(subscription) {
                        subscription.dispose();
                    }
                }, {
                    key: 'callNext',
                    value: function callNext(emitter, value) {
                        emitter.next(value);
                    }
                }, {
                    key: 'callThrow',
                    value: function callThrow(emitter, error) {
                        emitter['throw'](error);
                    }
                }, {
                    key: 'callReturn',
                    value: function callReturn(emitter) {
                        emitter['return'](null);
                    }
                }]);

                return ObservableWrapper;
            })();

            _export('ObservableWrapper', ObservableWrapper);

            // TODO: vsavkin change to interface

            Observable = (function () {
                function Observable() {
                    _classCallCheck(this, Observable);
                }

                _createClass(Observable, [{
                    key: 'observer',
                    value: function observer(generator) {
                        return null;
                    }
                }]);

                return Observable;
            })();

            _export('Observable', Observable);

            /**
             * Use Rx.Observable but provides an adapter to make it work as specified here:
             * https://github.com/jhusain/observable-spec
             *
             * Once a reference implementation of the spec is available, switch to it.
             */

            EventEmitter = (function (_Observable) {
                function EventEmitter() {
                    _classCallCheck(this, EventEmitter);

                    _get(Object.getPrototypeOf(EventEmitter.prototype), 'constructor', this).call(this);
                    // System creates a different object for import * than Typescript es5 emit.
                    if (Rx.hasOwnProperty('default')) {
                        this._subject = new Rx['default'].Rx.Subject();
                        this._immediateScheduler = Rx['default'].Rx.Scheduler.immediate;
                    } else {
                        this._subject = new Rx.Subject();
                        this._immediateScheduler = Rx.Scheduler.immediate;
                    }
                }

                _inherits(EventEmitter, _Observable);

                _createClass(EventEmitter, [{
                    key: 'observer',
                    value: function observer(generator) {
                        return this._subject.observeOn(this._immediateScheduler).subscribe(function (value) {
                            setTimeout(function () {
                                return generator.next(value);
                            });
                        }, function (error) {
                            return generator['throw'] ? generator['throw'](error) : null;
                        }, function () {
                            return generator['return'] ? generator['return']() : null;
                        });
                    }
                }, {
                    key: 'toRx',
                    value: function toRx() {
                        return this._subject;
                    }
                }, {
                    key: 'next',
                    value: function next(value) {
                        this._subject.onNext(value);
                    }
                }, {
                    key: 'throw',
                    value: function _throw(error) {
                        this._subject.onError(error);
                    }
                }, {
                    key: 'return',
                    value: function _return(value) {
                        this._subject.onCompleted();
                    }
                }]);

                return EventEmitter;
            })(Observable);

            _export('EventEmitter', EventEmitter);
        }
    };
});


System.register("angular2/src/di/annotations_impl", ["npm:babel-runtime@5.4.7/helpers/class-call-check", "npm:babel-runtime@5.4.7/helpers/create-class", "angular2/src/facade/lang"], function (_export) {
    var _classCallCheck, _createClass, CONST, __decorate, __metadata, Inject, InjectPromise, InjectLazy, Optional, DependencyAnnotation, Injectable;

    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * A parameter annotation that specifies a dependency.
             *
             * ```
             * class AComponent {
             *   constructor(@Inject(MyService) aService:MyService) {}
             * }
             * ```
             *
             * @exportedAs angular2/di_annotations
             */

            Inject = (function () {
                var _class = function Inject(token) {
                    _classCallCheck(this, _class);

                    this.token = token;
                };

                return _class;
            })();

            _export("Inject", Inject);

            _export("Inject", Inject = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Inject));
            /**
             * A parameter annotation that specifies a `Promise` of a dependency.
             *
             * ```
             * class AComponent {
             *   constructor(@InjectPromise(MyService) aServicePromise:Promise<MyService>) {
             *     aServicePromise.then(aService:MyService => ...);
             *   }
             * }
             * ```
             *
             * @exportedAs angular2/di_annotations
             */

            InjectPromise = (function () {
                var _class2 = function InjectPromise(token) {
                    _classCallCheck(this, _class2);

                    this.token = token;
                };

                return _class2;
            })();

            _export("InjectPromise", InjectPromise);

            _export("InjectPromise", InjectPromise = __decorate([CONST(), __metadata("design:paramtypes", [Object])], InjectPromise));
            /**
             * A parameter annotation that creates a synchronous lazy dependency.
             *
             * ```
             * class AComponent {
             *   constructor(@InjectLazy(MyService) aServiceFn:Function) {
             *     var aService:MyService = aServiceFn();
             *   }
             * }
             * ```
             *
             * @exportedAs angular2/di_annotations
             */

            InjectLazy = (function () {
                var _class3 = function InjectLazy(token) {
                    _classCallCheck(this, _class3);

                    this.token = token;
                };

                return _class3;
            })();

            _export("InjectLazy", InjectLazy);

            _export("InjectLazy", InjectLazy = __decorate([CONST(), __metadata("design:paramtypes", [Object])], InjectLazy));
            /**
             * A parameter annotation that marks a dependency as optional. {@link Injector} provides `null` if
             * the dependency is not found.
             *
             * ```
             * class AComponent {
             *   constructor(@Optional() aService:MyService) {
             *     this.aService = aService;
             *   }
             * }
             * ```
             *
             * @exportedAs angular2/di_annotations
             */

            Optional = (function () {
                var _class4 = function Optional() {
                    _classCallCheck(this, _class4);
                };

                return _class4;
            })();

            _export("Optional", Optional);

            _export("Optional", Optional = __decorate([CONST(), __metadata("design:paramtypes", [])], Optional));
            /**
             * `DependencyAnnotation` is used by the framework to extend DI.
             *
             * Only annotations implementing `DependencyAnnotation` are added to the list of dependency
             * properties.
             *
             * For example:
             *
             * ```
             * class Parent extends DependencyAnnotation {}
             * class NotDependencyProperty {}
             *
             * class AComponent {
             *   constructor(@Parent @NotDependencyProperty aService:AService) {}
             * }
             * ```
             *
             * will create the following dependency:
             *
             * ```
             * new Dependency(Key.get(AService), [new Parent()])
             * ```
             *
             * The framework can use `new Parent()` to handle the `aService` dependency
             * in a specific way.
             *
             * @exportedAs angular2/di_annotations
             */

            DependencyAnnotation = (function () {
                var _class5 = function DependencyAnnotation() {
                    _classCallCheck(this, _class5);
                };

                _createClass(_class5, [{
                    key: "token",
                    get: function () {
                        return null;
                    }
                }]);

                return _class5;
            })();

            _export("DependencyAnnotation", DependencyAnnotation);

            _export("DependencyAnnotation", DependencyAnnotation = __decorate([CONST(), __metadata("design:paramtypes", [])], DependencyAnnotation));
            /**
             * A marker annotation that marks a class as available to `Injector` for creation. Used by tooling
             * for generating constructor stubs.
             *
             * ```
             * class NeedsService {
             *   constructor(svc:UsefulService) {}
             * }
             *
             * @Injectable
             * class UsefulService {}
             * ```
             * @exportedAs angular2/di_annotations
             */

            Injectable = (function () {
                var _class6 = function Injectable() {
                    _classCallCheck(this, _class6);
                };

                return _class6;
            })();

            _export("Injectable", Injectable);

            _export("Injectable", Injectable = __decorate([CONST(), __metadata("design:paramtypes", [])], Injectable));
            
        }
    };
});
System.register('angular2/src/di/annotations', ['angular2/src/di/annotations_impl'], function (_export) {
  /**
   * This indirection is needed to free up Component, etc symbols in the public API
   * to be used by the decorator versions of these annotations.
   */
  'use strict';

  
  return {
    setters: [function (_angular2SrcDiAnnotations_impl) {
      _export('InjectAnnotation', _angular2SrcDiAnnotations_impl.Inject);

      _export('InjectPromiseAnnotation', _angular2SrcDiAnnotations_impl.InjectPromise);

      _export('InjectLazyAnnotation', _angular2SrcDiAnnotations_impl.InjectLazy);

      _export('OptionalAnnotation', _angular2SrcDiAnnotations_impl.Optional);

      _export('InjectableAnnotation', _angular2SrcDiAnnotations_impl.Injectable);

      _export('DependencyAnnotation', _angular2SrcDiAnnotations_impl.DependencyAnnotation);
    }],
    execute: function () {}
  };
});
System.register('angular2/src/util/decorators', ['npm:babel-runtime@5.4.7/core-js/object/create', 'angular2/src/facade/lang'], function (_export) {
    var _Object$create, global;

    function makeDecorator(annotationCls) {
        return function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var Reflect = global.Reflect;
            if (!(Reflect && Reflect.getMetadata)) {
                throw 'reflect-metadata shim is required when using class decorators';
            }
            var annotationInstance = _Object$create(annotationCls.prototype);
            annotationCls.apply(annotationInstance, args);
            return function (cls) {
                var annotations = Reflect.getMetadata('annotations', cls);
                annotations = annotations || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, cls);
                return cls;
            };
        };
    }

    function makeParamDecorator(annotationCls) {
        return function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
            }

            var Reflect = global.Reflect;
            if (!(Reflect && Reflect.getMetadata)) {
                throw 'reflect-metadata shim is required when using parameter decorators';
            }
            var annotationInstance = _Object$create(annotationCls.prototype);
            annotationCls.apply(annotationInstance, args);
            return function (cls, unusedKey, index) {
                var parameters = Reflect.getMetadata('parameters', cls);
                parameters = parameters || [];
                // there might be gaps if some in between parameters do not have annotations.
                // we pad with nulls.
                while (parameters.length <= index) {
                    parameters.push(null);
                }
                parameters[index] = parameters[index] || [];
                var annotationsForParam = parameters[index];
                annotationsForParam.push(annotationInstance);
                Reflect.defineMetadata('parameters', parameters, cls);
                return cls;
            };
        };
    }
    

    return {
        setters: [function (_npmBabelRuntime547CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime547CoreJsObjectCreate['default'];
        }, function (_angular2SrcFacadeLang) {
            global = _angular2SrcFacadeLang.global;
        }],
        execute: function () {
            'use strict';

            _export('makeDecorator', makeDecorator);

            _export('makeParamDecorator', makeParamDecorator);
        }
    };
});
System.register('angular2/src/reflection/reflector', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, isPresent, MapWrapper, StringMapWrapper, Reflector;

    function _mergeMaps(target, config) {
        StringMapWrapper.forEach(config, function (v, k) {
            return MapWrapper.set(target, k, v);
        });
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }],
        execute: function () {
            'use strict';

            Reflector = (function () {
                function Reflector(reflectionCapabilities) {
                    _classCallCheck(this, Reflector);

                    this._typeInfo = MapWrapper.create();
                    this._getters = MapWrapper.create();
                    this._setters = MapWrapper.create();
                    this._methods = MapWrapper.create();
                    this.reflectionCapabilities = reflectionCapabilities;
                }

                _createClass(Reflector, [{
                    key: 'registerType',
                    value: function registerType(type, typeInfo) {
                        MapWrapper.set(this._typeInfo, type, typeInfo);
                    }
                }, {
                    key: 'registerGetters',
                    value: function registerGetters(getters) {
                        _mergeMaps(this._getters, getters);
                    }
                }, {
                    key: 'registerSetters',
                    value: function registerSetters(setters) {
                        _mergeMaps(this._setters, setters);
                    }
                }, {
                    key: 'registerMethods',
                    value: function registerMethods(methods) {
                        _mergeMaps(this._methods, methods);
                    }
                }, {
                    key: 'factory',
                    value: function factory(type) {
                        if (this._containsTypeInfo(type)) {
                            return this._getTypeInfoField(type, 'factory', null);
                        } else {
                            return this.reflectionCapabilities.factory(type);
                        }
                    }
                }, {
                    key: 'parameters',
                    value: function parameters(typeOrFunc) {
                        if (MapWrapper.contains(this._typeInfo, typeOrFunc)) {
                            return this._getTypeInfoField(typeOrFunc, 'parameters', []);
                        } else {
                            return this.reflectionCapabilities.parameters(typeOrFunc);
                        }
                    }
                }, {
                    key: 'annotations',
                    value: function annotations(typeOrFunc) {
                        if (MapWrapper.contains(this._typeInfo, typeOrFunc)) {
                            return this._getTypeInfoField(typeOrFunc, 'annotations', []);
                        } else {
                            return this.reflectionCapabilities.annotations(typeOrFunc);
                        }
                    }
                }, {
                    key: 'interfaces',
                    value: function interfaces(type) {
                        if (MapWrapper.contains(this._typeInfo, type)) {
                            return this._getTypeInfoField(type, 'interfaces', []);
                        } else {
                            return this.reflectionCapabilities.interfaces(type);
                        }
                    }
                }, {
                    key: 'getter',
                    value: function getter(name) {
                        if (MapWrapper.contains(this._getters, name)) {
                            return MapWrapper.get(this._getters, name);
                        } else {
                            return this.reflectionCapabilities.getter(name);
                        }
                    }
                }, {
                    key: 'setter',
                    value: function setter(name) {
                        if (MapWrapper.contains(this._setters, name)) {
                            return MapWrapper.get(this._setters, name);
                        } else {
                            return this.reflectionCapabilities.setter(name);
                        }
                    }
                }, {
                    key: 'method',
                    value: function method(name) {
                        if (MapWrapper.contains(this._methods, name)) {
                            return MapWrapper.get(this._methods, name);
                        } else {
                            return this.reflectionCapabilities.method(name);
                        }
                    }
                }, {
                    key: '_getTypeInfoField',
                    value: function _getTypeInfoField(typeOrFunc, key, defaultValue) {
                        var res = MapWrapper.get(this._typeInfo, typeOrFunc)[key];
                        return isPresent(res) ? res : defaultValue;
                    }
                }, {
                    key: '_containsTypeInfo',
                    value: function _containsTypeInfo(typeOrFunc) {
                        return MapWrapper.contains(this._typeInfo, typeOrFunc);
                    }
                }]);

                return Reflector;
            })();

            _export('Reflector', Reflector);
        }
    };
});
System.register('angular2/src/reflection/reflection_capabilities', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, isPresent, global, stringify, BaseException, ListWrapper, ReflectionCapabilities;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            global = _angular2SrcFacadeLang.global;
            stringify = _angular2SrcFacadeLang.stringify;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            'use strict';

            ReflectionCapabilities = (function () {
                function ReflectionCapabilities(reflect) {
                    _classCallCheck(this, ReflectionCapabilities);

                    this._reflect = isPresent(reflect) ? reflect : global.Reflect;
                }

                _createClass(ReflectionCapabilities, [{
                    key: 'factory',
                    value: function factory(t) {
                        switch (t.length) {
                            case 0:
                                return function () {
                                    return new t();
                                };
                            case 1:
                                return function (a1) {
                                    return new t(a1);
                                };
                            case 2:
                                return function (a1, a2) {
                                    return new t(a1, a2);
                                };
                            case 3:
                                return function (a1, a2, a3) {
                                    return new t(a1, a2, a3);
                                };
                            case 4:
                                return function (a1, a2, a3, a4) {
                                    return new t(a1, a2, a3, a4);
                                };
                            case 5:
                                return function (a1, a2, a3, a4, a5) {
                                    return new t(a1, a2, a3, a4, a5);
                                };
                            case 6:
                                return function (a1, a2, a3, a4, a5, a6) {
                                    return new t(a1, a2, a3, a4, a5, a6);
                                };
                            case 7:
                                return function (a1, a2, a3, a4, a5, a6, a7) {
                                    return new t(a1, a2, a3, a4, a5, a6, a7);
                                };
                            case 8:
                                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
                                    return new t(a1, a2, a3, a4, a5, a6, a7, a8);
                                };
                            case 9:
                                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
                                };
                            case 10:
                                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                                };
                        }
                        ;
                        throw new Error('Cannot create a factory for \'' + stringify(t) + '\' because its constructor has more than 10 arguments');
                    }
                }, {
                    key: '_zipTypesAndAnnotaions',
                    value: function _zipTypesAndAnnotaions(paramTypes, paramAnnotations) {
                        var result;
                        if (typeof paramTypes === 'undefined') {
                            result = ListWrapper.createFixedSize(paramAnnotations.length);
                        } else {
                            result = ListWrapper.createFixedSize(paramTypes.length);
                        }
                        for (var i = 0; i < result.length; i++) {
                            // TS outputs Object for parameters without types, while Traceur omits
                            // the annotations. For now we preserve the Traceur behavior to aid
                            // migration, but this can be revisited.
                            if (typeof paramTypes === 'undefined') {
                                result[i] = [];
                            } else if (paramTypes[i] != Object) {
                                result[i] = [paramTypes[i]];
                            } else {
                                result[i] = [];
                            }
                            if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {
                                result[i] = result[i].concat(paramAnnotations[i]);
                            }
                        }
                        return result;
                    }
                }, {
                    key: 'parameters',
                    value: function parameters(typeOfFunc) {
                        // Prefer the direct API.
                        if (isPresent(typeOfFunc.parameters)) {
                            return typeOfFunc.parameters;
                        }
                        if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
                            var paramAnnotations = this._reflect.getMetadata('parameters', typeOfFunc);
                            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOfFunc);
                            if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
                                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
                            }
                        }
                        return ListWrapper.createFixedSize(typeOfFunc.length);
                    }
                }, {
                    key: 'annotations',
                    value: function annotations(typeOfFunc) {
                        // Prefer the direct API.
                        if (isPresent(typeOfFunc.annotations)) {
                            return typeOfFunc.annotations;
                        }
                        if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
                            var annotations = this._reflect.getMetadata('annotations', typeOfFunc);
                            if (isPresent(annotations)) return annotations;
                        }
                        return [];
                    }
                }, {
                    key: 'interfaces',
                    value: function interfaces(type) {
                        throw new BaseException('JavaScript does not support interfaces');
                    }
                }, {
                    key: 'getter',
                    value: function getter(name) {
                        return new Function('o', 'return o.' + name + ';');
                    }
                }, {
                    key: 'setter',
                    value: function setter(name) {
                        return new Function('o', 'v', 'return o.' + name + ' = v;');
                    }
                }, {
                    key: 'method',
                    value: function method(name) {
                        var functionBody = 'if (!o.' + name + ') throw new Error(\'"' + name + '" is undefined\');\n        return o.' + name + '.apply(o, args);';
                        return new Function('o', 'args', functionBody);
                    }
                }]);

                return ReflectionCapabilities;
            })();

            _export('ReflectionCapabilities', ReflectionCapabilities);
        }
    };
});


System.register('angular2/src/change_detection/parser/locals', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, isPresent, BaseException, MapWrapper, Locals;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }],
        execute: function () {
            'use strict';

            Locals = (function () {
                function Locals(parent, current) {
                    _classCallCheck(this, Locals);

                    this.parent = parent;
                    this.current = current;
                }

                _createClass(Locals, [{
                    key: 'contains',
                    value: function contains(name) {
                        if (MapWrapper.contains(this.current, name)) {
                            return true;
                        }
                        if (isPresent(this.parent)) {
                            return this.parent.contains(name);
                        }
                        return false;
                    }
                }, {
                    key: 'get',
                    value: function get(name) {
                        if (MapWrapper.contains(this.current, name)) {
                            return MapWrapper.get(this.current, name);
                        }
                        if (isPresent(this.parent)) {
                            return this.parent.get(name);
                        }
                        throw new BaseException('Cannot find \'' + name + '\'');
                    }
                }, {
                    key: 'set',
                    value: function set(name, value) {
                        // TODO(rado): consider removing this check if we can guarantee this is not
                        // exposed to the public API.
                        // TODO: vsavkin maybe it should check only the local map
                        if (MapWrapper.contains(this.current, name)) {
                            MapWrapper.set(this.current, name, value);
                        } else {
                            throw new BaseException('Setting of new keys post-construction is not supported.');
                        }
                    }
                }, {
                    key: 'clearValues',
                    value: function clearValues() {
                        MapWrapper.clearValues(this.current);
                    }
                }]);

                return Locals;
            })();

            _export('Locals', Locals);
        }
    };
});


System.register("angular2/src/change_detection/exceptions", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, BaseException, ExpressionChangedAfterItHasBeenChecked, ChangeDetectionError;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            "use strict";

            ExpressionChangedAfterItHasBeenChecked = (function (_BaseException) {
                function ExpressionChangedAfterItHasBeenChecked(proto, change) {
                    _classCallCheck(this, ExpressionChangedAfterItHasBeenChecked);

                    _get(Object.getPrototypeOf(ExpressionChangedAfterItHasBeenChecked.prototype), "constructor", this).call(this);
                    this.message = "Expression '" + proto.expressionAsString + "' has changed after it was checked. " + ("Previous value: '" + change.previousValue + "'. Current value: '" + change.currentValue + "'");
                }

                _inherits(ExpressionChangedAfterItHasBeenChecked, _BaseException);

                _createClass(ExpressionChangedAfterItHasBeenChecked, [{
                    key: "toString",
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return ExpressionChangedAfterItHasBeenChecked;
            })(BaseException);

            _export("ExpressionChangedAfterItHasBeenChecked", ExpressionChangedAfterItHasBeenChecked);

            ChangeDetectionError = (function (_BaseException2) {
                function ChangeDetectionError(proto, originalException) {
                    _classCallCheck(this, ChangeDetectionError);

                    _get(Object.getPrototypeOf(ChangeDetectionError.prototype), "constructor", this).call(this);
                    this.originalException = originalException;
                    this.location = proto.expressionAsString;
                    this.message = "" + this.originalException + " in [" + this.location + "]";
                }

                _inherits(ChangeDetectionError, _BaseException2);

                _createClass(ChangeDetectionError, [{
                    key: "toString",
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return ChangeDetectionError;
            })(BaseException);

            _export("ChangeDetectionError", ChangeDetectionError);
        }
    };
});


System.register("angular2/src/change_detection/interfaces", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, ProtoChangeDetector, ChangeDetection, ChangeDispatcher, ChangeDetector, ChangeDetectorDefinition;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            ProtoChangeDetector = (function () {
                function ProtoChangeDetector() {
                    _classCallCheck(this, ProtoChangeDetector);
                }

                _createClass(ProtoChangeDetector, [{
                    key: "instantiate",
                    value: function instantiate(dispatcher) {
                        return null;
                    }
                }]);

                return ProtoChangeDetector;
            })();

            _export("ProtoChangeDetector", ProtoChangeDetector);

            /**
             * Interface used by Angular to control the change detection strategy for an application.
             *
             * Angular implements the following change detection strategies by default:
             *
             * - {@link DynamicChangeDetection}: slower, but does not require `eval()`.
             * - {@link JitChangeDetection}: faster, but requires `eval()`.
             *
             * In JavaScript, you should always use `JitChangeDetection`, unless you are in an environment that
             *has
             * [CSP](https://developer.mozilla.org/en-US/docs/Web/Security/CSP), such as a Chrome Extension.
             *
             * In Dart, use `DynamicChangeDetection` during development. The Angular transformer generates an
             *analog to the
             * `JitChangeDetection` strategy at compile time.
             *
             *
             * See: {@link DynamicChangeDetection}, {@link JitChangeDetection}
             *
             * # Example
             * ```javascript
             * bootstrap(MyApp, [bind(ChangeDetection).toClass(DynamicChangeDetection)]);
             * ```
             * @exportedAs angular2/change_detection
             */

            ChangeDetection = (function () {
                function ChangeDetection() {
                    _classCallCheck(this, ChangeDetection);
                }

                _createClass(ChangeDetection, [{
                    key: "createProtoChangeDetector",
                    value: function createProtoChangeDetector(definition) {
                        return null;
                    }
                }]);

                return ChangeDetection;
            })();

            _export("ChangeDetection", ChangeDetection);

            ChangeDispatcher = (function () {
                function ChangeDispatcher() {
                    _classCallCheck(this, ChangeDispatcher);
                }

                _createClass(ChangeDispatcher, [{
                    key: "notifyOnBinding",
                    value: function notifyOnBinding(bindingRecord, value) {}
                }]);

                return ChangeDispatcher;
            })();

            _export("ChangeDispatcher", ChangeDispatcher);

            ChangeDetector = (function () {
                function ChangeDetector() {
                    _classCallCheck(this, ChangeDetector);
                }

                _createClass(ChangeDetector, [{
                    key: "addChild",
                    value: function addChild(cd) {}
                }, {
                    key: "addShadowDomChild",
                    value: function addShadowDomChild(cd) {}
                }, {
                    key: "removeChild",
                    value: function removeChild(cd) {}
                }, {
                    key: "removeShadowDomChild",
                    value: function removeShadowDomChild(cd) {}
                }, {
                    key: "remove",
                    value: function remove() {}
                }, {
                    key: "hydrate",
                    value: function hydrate(context, locals, directives) {}
                }, {
                    key: "dehydrate",
                    value: function dehydrate() {}
                }, {
                    key: "markPathToRootAsCheckOnce",
                    value: function markPathToRootAsCheckOnce() {}
                }, {
                    key: "detectChanges",
                    value: function detectChanges() {}
                }, {
                    key: "checkNoChanges",
                    value: function checkNoChanges() {}
                }]);

                return ChangeDetector;
            })();

            _export("ChangeDetector", ChangeDetector);

            ChangeDetectorDefinition = function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, directiveRecords) {
                _classCallCheck(this, ChangeDetectorDefinition);

                this.id = id;
                this.strategy = strategy;
                this.variableNames = variableNames;
                this.bindingRecords = bindingRecords;
                this.directiveRecords = directiveRecords;
            };

            _export("ChangeDetectorDefinition", ChangeDetectorDefinition);
        }
    };
});


System.register("angular2/src/change_detection/constants", [], function (_export) {
  // TODO:vsavkin Use enums after switching to TypeScript
  /**
   * CHECK_ONCE means that after calling detectChanges the mode of the change detector
   * will become CHECKED.
   */
  "use strict";

  var CHECK_ONCE, CHECKED, CHECK_ALWAYS, DETACHED, ON_PUSH, DEFAULT;
  return {
    setters: [],
    execute: function () {
      CHECK_ONCE = "CHECK_ONCE";

      _export("CHECK_ONCE", CHECK_ONCE);

      /**
       * CHECKED means that the change detector should be skipped until its mode changes to
       * CHECK_ONCE or CHECK_ALWAYS.
       */
      CHECKED = "CHECKED";

      _export("CHECKED", CHECKED);

      /**
       * CHECK_ALWAYS means that after calling detectChanges the mode of the change detector
       * will remain CHECK_ALWAYS.
       */
      CHECK_ALWAYS = "ALWAYS_CHECK";

      _export("CHECK_ALWAYS", CHECK_ALWAYS);

      /**
       * DETACHED means that the change detector sub tree is not a part of the main tree and
       * should be skipped.
       */
      DETACHED = "DETACHED";

      _export("DETACHED", DETACHED);

      /**
       * ON_PUSH means that the change detector's mode will be set to CHECK_ONCE during hydration.
       */
      ON_PUSH = "ON_PUSH";

      _export("ON_PUSH", ON_PUSH);

      /**
       * DEFAULT means that the change detector's mode will be set to CHECK_ALWAYS during hydration.
       */
      DEFAULT = "DEFAULT";

      

      _export("DEFAULT", DEFAULT);
    }
  };
});
System.register("angular2/src/change_detection/pipes/pipe", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, BaseException, CONST, __decorate, __metadata, WrappedValue, _wrappedValues, _wrappedIndex, Pipe, PipeFactory;

    function _abstract() {
        throw new BaseException("This method is abstract");
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
            CONST = _angular2SrcFacadeLang.CONST;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Indicates that the result of a {@link Pipe} transformation has changed even though the reference
             *has not changed.
             *
             * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
             *
             * @exportedAs angular2/pipes
             */

            WrappedValue = (function () {
                function WrappedValue(wrapped) {
                    _classCallCheck(this, WrappedValue);

                    this.wrapped = wrapped;
                }

                _createClass(WrappedValue, null, [{
                    key: "wrap",
                    value: function wrap(value) {
                        var w = _wrappedValues[_wrappedIndex++ % 5];
                        w.wrapped = value;
                        return w;
                    }
                }]);

                return WrappedValue;
            })();

            _export("WrappedValue", WrappedValue);

            _wrappedValues = [new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null)];
            _wrappedIndex = 0;

            /**
             * An interface for extending the list of pipes known to Angular.
             *
             * If you are writing a custom {@link Pipe}, you must extend this interface.
             *
             * #Example
             *
             * ```
             * class DoublePipe extends Pipe {
             *  supports(obj) {
             *    return true;
             *  }
             *
             *  transform(value) {
             *    return `${value}${value}`;
             *  }
             * }
             * ```
             *
             * @exportedAs angular2/pipes
             */

            Pipe = (function () {
                function Pipe() {
                    _classCallCheck(this, Pipe);
                }

                _createClass(Pipe, [{
                    key: "supports",
                    value: function supports(obj) {
                        return false;
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {}
                }, {
                    key: "transform",
                    value: function transform(value) {
                        return null;
                    }
                }]);

                return Pipe;
            })();

            _export("Pipe", Pipe);

            // TODO: vsavkin: make it an interface

            PipeFactory = (function () {
                var _class = function PipeFactory() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "supports",
                    value: function supports(obs) {
                        _abstract();
                        return false;
                    }
                }, {
                    key: "create",
                    value: function create(cdRef) {
                        _abstract();
                        return null;
                    }
                }]);

                return _class;
            })();

            _export("PipeFactory", PipeFactory);

            _export("PipeFactory", PipeFactory = __decorate([CONST(), __metadata("design:paramtypes", [])], PipeFactory));
        }
    };
});
System.register('angular2/src/change_detection/change_detector_ref', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/change_detection/constants'], function (_export) {
  var _createClass, _classCallCheck, DETACHED, CHECK_ALWAYS, ChangeDetectorRef;

  return {
    setters: [function (_npmBabelRuntime547HelpersCreateClass) {
      _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
    }, function (_npmBabelRuntime547HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
    }, function (_angular2SrcChange_detectionConstants) {
      DETACHED = _angular2SrcChange_detectionConstants.DETACHED;
      CHECK_ALWAYS = _angular2SrcChange_detectionConstants.CHECK_ALWAYS;
    }],
    execute: function () {
      'use strict';

      /**
       * Controls change detection.
       *
       * {@link ChangeDetectorRef} allows requesting checks for detectors that rely on observables. It
       *also allows detaching and
       * attaching change detector subtrees.
       *
       * @exportedAs angular2/change_detection
       */

      ChangeDetectorRef = (function () {
        function ChangeDetectorRef(_cd) {
          _classCallCheck(this, ChangeDetectorRef);

          this._cd = _cd;
        }

        _createClass(ChangeDetectorRef, [{
          key: 'requestCheck',

          /**
           * Request to check all ON_PUSH ancestors.
           */
          value: function requestCheck() {
            this._cd.markPathToRootAsCheckOnce();
          }
        }, {
          key: 'detach',

          /**
           * Detaches the change detector from the change detector tree.
           *
           * The detached change detector will not be checked until it is reattached.
           */
          value: function detach() {
            this._cd.mode = DETACHED;
          }
        }, {
          key: 'reattach',

          /**
           * Reattach the change detector to the change detector tree.
           *
           * This also requests a check of this change detector. This reattached change detector will be
           *checked during the
           * next change detection run.
           */
          value: function reattach() {
            this._cd.mode = CHECK_ALWAYS;
            this.requestCheck();
          }
        }]);

        return ChangeDetectorRef;
      })();

      _export('ChangeDetectorRef', ChangeDetectorRef);
    }
  };
});


System.register("angular2/src/change_detection/proto_record", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, RECORD_TYPE_SELF, RECORD_TYPE_CONST, RECORD_TYPE_PRIMITIVE_OP, RECORD_TYPE_PROPERTY, RECORD_TYPE_LOCAL, RECORD_TYPE_INVOKE_METHOD, RECORD_TYPE_INVOKE_CLOSURE, RECORD_TYPE_KEYED_ACCESS, RECORD_TYPE_PIPE, RECORD_TYPE_BINDING_PIPE, RECORD_TYPE_INTERPOLATE, RECORD_TYPE_SAFE_PROPERTY, RECORD_TYPE_SAFE_INVOKE_METHOD, RECORD_TYPE_DIRECTIVE_LIFECYCLE, ProtoRecord;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            RECORD_TYPE_SELF = 0;

            _export("RECORD_TYPE_SELF", RECORD_TYPE_SELF);

            RECORD_TYPE_CONST = 1;

            _export("RECORD_TYPE_CONST", RECORD_TYPE_CONST);

            RECORD_TYPE_PRIMITIVE_OP = 2;

            _export("RECORD_TYPE_PRIMITIVE_OP", RECORD_TYPE_PRIMITIVE_OP);

            RECORD_TYPE_PROPERTY = 3;

            _export("RECORD_TYPE_PROPERTY", RECORD_TYPE_PROPERTY);

            RECORD_TYPE_LOCAL = 4;

            _export("RECORD_TYPE_LOCAL", RECORD_TYPE_LOCAL);

            RECORD_TYPE_INVOKE_METHOD = 5;

            _export("RECORD_TYPE_INVOKE_METHOD", RECORD_TYPE_INVOKE_METHOD);

            RECORD_TYPE_INVOKE_CLOSURE = 6;

            _export("RECORD_TYPE_INVOKE_CLOSURE", RECORD_TYPE_INVOKE_CLOSURE);

            RECORD_TYPE_KEYED_ACCESS = 7;

            _export("RECORD_TYPE_KEYED_ACCESS", RECORD_TYPE_KEYED_ACCESS);

            RECORD_TYPE_PIPE = 8;

            _export("RECORD_TYPE_PIPE", RECORD_TYPE_PIPE);

            RECORD_TYPE_BINDING_PIPE = 9;

            _export("RECORD_TYPE_BINDING_PIPE", RECORD_TYPE_BINDING_PIPE);

            RECORD_TYPE_INTERPOLATE = 10;

            _export("RECORD_TYPE_INTERPOLATE", RECORD_TYPE_INTERPOLATE);

            RECORD_TYPE_SAFE_PROPERTY = 11;

            _export("RECORD_TYPE_SAFE_PROPERTY", RECORD_TYPE_SAFE_PROPERTY);

            RECORD_TYPE_SAFE_INVOKE_METHOD = 12;

            _export("RECORD_TYPE_SAFE_INVOKE_METHOD", RECORD_TYPE_SAFE_INVOKE_METHOD);

            RECORD_TYPE_DIRECTIVE_LIFECYCLE = 13;

            _export("RECORD_TYPE_DIRECTIVE_LIFECYCLE", RECORD_TYPE_DIRECTIVE_LIFECYCLE);

            ProtoRecord = (function () {
                function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, expressionAsString, lastInBinding, lastInDirective) {
                    _classCallCheck(this, ProtoRecord);

                    this.mode = mode;
                    this.name = name;
                    this.funcOrValue = funcOrValue;
                    this.args = args;
                    this.fixedArgs = fixedArgs;
                    this.contextIndex = contextIndex;
                    this.directiveIndex = directiveIndex;
                    this.selfIndex = selfIndex;
                    this.bindingRecord = bindingRecord;
                    this.expressionAsString = expressionAsString;
                    this.lastInBinding = lastInBinding;
                    this.lastInDirective = lastInDirective;
                }

                _createClass(ProtoRecord, [{
                    key: "isPureFunction",
                    value: function isPureFunction() {
                        return this.mode === RECORD_TYPE_INTERPOLATE || this.mode === RECORD_TYPE_PRIMITIVE_OP;
                    }
                }, {
                    key: "isPipeRecord",
                    value: function isPipeRecord() {
                        return this.mode === RECORD_TYPE_PIPE || this.mode === RECORD_TYPE_BINDING_PIPE;
                    }
                }, {
                    key: "isLifeCycleRecord",
                    value: function isLifeCycleRecord() {
                        return this.mode === RECORD_TYPE_DIRECTIVE_LIFECYCLE;
                    }
                }]);

                return ProtoRecord;
            })();

            _export("ProtoRecord", ProtoRecord);
        }
    };
});


System.register('angular2/src/change_detection/change_detection_jit_generator', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/change_detection/abstract_change_detector', 'angular2/src/change_detection/change_detection_util', 'angular2/src/change_detection/proto_record'], function (_export) {
    var _createClass, _classCallCheck, BaseException, ListWrapper, AbstractChangeDetector, ChangeDetectionUtil, RECORD_TYPE_SELF, RECORD_TYPE_PROPERTY, RECORD_TYPE_LOCAL, RECORD_TYPE_INVOKE_METHOD, RECORD_TYPE_CONST, RECORD_TYPE_INVOKE_CLOSURE, RECORD_TYPE_PRIMITIVE_OP, RECORD_TYPE_KEYED_ACCESS, RECORD_TYPE_PIPE, RECORD_TYPE_BINDING_PIPE, RECORD_TYPE_INTERPOLATE, RECORD_TYPE_SAFE_PROPERTY, RECORD_TYPE_SAFE_INVOKE_METHOD, ABSTRACT_CHANGE_DETECTOR, UTIL, DISPATCHER_ACCESSOR, PIPE_REGISTRY_ACCESSOR, PROTOS_ACCESSOR, DIRECTIVES_ACCESSOR, CONTEXT_ACCESSOR, IS_CHANGED_LOCAL, CHANGES_LOCAL, LOCALS_ACCESSOR, MODE_ACCESSOR, CURRENT_PROTO, ALREADY_CHECKED_ACCESSOR, ChangeDetectorJITGenerator;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcChange_detectionAbstract_change_detector) {
            AbstractChangeDetector = _angular2SrcChange_detectionAbstract_change_detector.AbstractChangeDetector;
        }, function (_angular2SrcChange_detectionChange_detection_util) {
            ChangeDetectionUtil = _angular2SrcChange_detectionChange_detection_util.ChangeDetectionUtil;
        }, function (_angular2SrcChange_detectionProto_record) {
            RECORD_TYPE_SELF = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SELF;
            RECORD_TYPE_PROPERTY = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PROPERTY;
            RECORD_TYPE_LOCAL = _angular2SrcChange_detectionProto_record.RECORD_TYPE_LOCAL;
            RECORD_TYPE_INVOKE_METHOD = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INVOKE_METHOD;
            RECORD_TYPE_CONST = _angular2SrcChange_detectionProto_record.RECORD_TYPE_CONST;
            RECORD_TYPE_INVOKE_CLOSURE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INVOKE_CLOSURE;
            RECORD_TYPE_PRIMITIVE_OP = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PRIMITIVE_OP;
            RECORD_TYPE_KEYED_ACCESS = _angular2SrcChange_detectionProto_record.RECORD_TYPE_KEYED_ACCESS;
            RECORD_TYPE_PIPE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PIPE;
            RECORD_TYPE_BINDING_PIPE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_BINDING_PIPE;
            RECORD_TYPE_INTERPOLATE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INTERPOLATE;
            RECORD_TYPE_SAFE_PROPERTY = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SAFE_PROPERTY;
            RECORD_TYPE_SAFE_INVOKE_METHOD = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SAFE_INVOKE_METHOD;
        }],
        execute: function () {
            'use strict';

            /**
             * The code generator takes a list of proto records and creates a function/class
             * that "emulates" what the developer would write by hand to implement the same
             * kind of behaviour.
             *
             * This code should be kept in sync with the Dart transformer's
             * `angular2.transform.template_compiler.change_detector_codegen` library. If you make updates
             * here, please make equivalent changes there.
            */
            ABSTRACT_CHANGE_DETECTOR = 'AbstractChangeDetector';
            UTIL = 'ChangeDetectionUtil';
            DISPATCHER_ACCESSOR = 'this.dispatcher';
            PIPE_REGISTRY_ACCESSOR = 'this.pipeRegistry';
            PROTOS_ACCESSOR = 'this.protos';
            DIRECTIVES_ACCESSOR = 'this.directiveRecords';
            CONTEXT_ACCESSOR = 'this.context';
            IS_CHANGED_LOCAL = 'isChanged';
            CHANGES_LOCAL = 'changes';
            LOCALS_ACCESSOR = 'this.locals';
            MODE_ACCESSOR = 'this.mode';
            CURRENT_PROTO = 'currentProto';
            ALREADY_CHECKED_ACCESSOR = 'this.alreadyChecked';

            ChangeDetectorJITGenerator = (function () {
                function ChangeDetectorJITGenerator(typeName, changeDetectionStrategy, records, directiveRecords) {
                    _classCallCheck(this, ChangeDetectorJITGenerator);

                    this.typeName = typeName;
                    this.changeDetectionStrategy = changeDetectionStrategy;
                    this.records = records;
                    this.directiveRecords = directiveRecords;
                    this._localNames = this._getLocalNames(records);
                    this._changeNames = this._getChangeNames(this._localNames);
                    this._fieldNames = this._getFieldNames(this._localNames);
                    this._pipeNames = this._getPipeNames(this._localNames);
                }

                _createClass(ChangeDetectorJITGenerator, [{
                    key: '_getLocalNames',
                    value: function _getLocalNames(records) {
                        var index = 0;
                        var names = records.map(function (r) {
                            var sanitizedName = r.name.replace(new RegExp('\\W', 'g'), '');
                            return '' + sanitizedName + '' + index++;
                        });
                        return ['context'].concat(names);
                    }
                }, {
                    key: '_getChangeNames',
                    value: function _getChangeNames(_localNames) {
                        return _localNames.map(function (n) {
                            return 'change_' + n;
                        });
                    }
                }, {
                    key: '_getFieldNames',
                    value: function _getFieldNames(_localNames) {
                        return _localNames.map(function (n) {
                            return 'this.' + n;
                        });
                    }
                }, {
                    key: '_getPipeNames',
                    value: function _getPipeNames(_localNames) {
                        return _localNames.map(function (n) {
                            return 'this.' + n + '_pipe';
                        });
                    }
                }, {
                    key: 'generate',
                    value: function generate() {
                        var _this = this;

                        var classDefinition = '\n      var ' + this.typeName + ' = function ' + this.typeName + '(dispatcher, pipeRegistry, protos, directiveRecords) {\n        ' + ABSTRACT_CHANGE_DETECTOR + '.call(this);\n        ' + DISPATCHER_ACCESSOR + ' = dispatcher;\n        ' + PIPE_REGISTRY_ACCESSOR + ' = pipeRegistry;\n        ' + PROTOS_ACCESSOR + ' = protos;\n        ' + DIRECTIVES_ACCESSOR + ' = directiveRecords;\n        ' + LOCALS_ACCESSOR + ' = null;\n        ' + ALREADY_CHECKED_ACCESSOR + ' = false;\n        ' + this._genFieldDefinitions() + '\n      }\n\n      ' + this.typeName + '.prototype = Object.create(' + ABSTRACT_CHANGE_DETECTOR + '.prototype);\n\n      ' + this.typeName + '.prototype.detectChangesInRecords = function(throwOnChange) {\n        ' + this._genLocalDefinitions() + '\n        ' + this._genChangeDefinitions() + '\n        var ' + IS_CHANGED_LOCAL + ' = false;\n        var ' + CURRENT_PROTO + ';\n        var ' + CHANGES_LOCAL + ' = null;\n\n        context = ' + CONTEXT_ACCESSOR + ';\n\n        ' + this.records.map(function (r) {
                            return _this._genRecord(r);
                        }).join('\n') + '\n\n        ' + ALREADY_CHECKED_ACCESSOR + ' = true;\n      }\n\n      ' + this.typeName + '.prototype.callOnAllChangesDone = function() {\n        ' + this._genCallOnAllChangesDoneBody() + '\n      }\n\n      ' + this.typeName + '.prototype.hydrate = function(context, locals, directives) {\n        ' + MODE_ACCESSOR + ' = "' + ChangeDetectionUtil.changeDetectionMode(this.changeDetectionStrategy) + '";\n        ' + CONTEXT_ACCESSOR + ' = context;\n        ' + LOCALS_ACCESSOR + ' = locals;\n        ' + this._genHydrateDirectives() + '\n        ' + this._genHydrateDetectors() + '\n        ' + ALREADY_CHECKED_ACCESSOR + ' = false;\n      }\n\n      ' + this.typeName + '.prototype.dehydrate = function() {\n        ' + this._genPipeOnDestroy() + '\n        ' + this._genFieldDefinitions() + '\n        ' + LOCALS_ACCESSOR + ' = null;\n      }\n\n      ' + this.typeName + '.prototype.hydrated = function() {\n        return ' + CONTEXT_ACCESSOR + ' !== ' + UTIL + '.uninitialized();\n      }\n\n      return function(dispatcher, pipeRegistry) {\n        return new ' + this.typeName + '(dispatcher, pipeRegistry, protos, directiveRecords);\n      }\n    ';
                        return new Function('AbstractChangeDetector', 'ChangeDetectionUtil', 'protos', 'directiveRecords', classDefinition)(AbstractChangeDetector, ChangeDetectionUtil, this.records, this.directiveRecords);
                    }
                }, {
                    key: '_genGetDirectiveFieldNames',
                    value: function _genGetDirectiveFieldNames() {
                        var _this2 = this;

                        return this.directiveRecords.map(function (d) {
                            return _this2._genGetDirective(d.directiveIndex);
                        });
                    }
                }, {
                    key: '_genGetDetectorFieldNames',
                    value: function _genGetDetectorFieldNames() {
                        var _this3 = this;

                        return this.directiveRecords.filter(function (r) {
                            return r.isOnPushChangeDetection();
                        }).map(function (d) {
                            return _this3._genGetDetector(d.directiveIndex);
                        });
                    }
                }, {
                    key: '_genGetDirective',
                    value: function _genGetDirective(d) {
                        return 'this.directive_' + d.name;
                    }
                }, {
                    key: '_genGetDetector',
                    value: function _genGetDetector(d) {
                        return 'this.detector_' + d.name;
                    }
                }, {
                    key: '_getNonNullPipeNames',
                    value: function _getNonNullPipeNames() {
                        var _this4 = this;

                        var pipes = [];
                        this.records.forEach(function (r) {
                            if (r.mode === RECORD_TYPE_PIPE || r.mode === RECORD_TYPE_BINDING_PIPE) {
                                pipes.push(_this4._pipeNames[r.selfIndex]);
                            }
                        });
                        return pipes;
                    }
                }, {
                    key: '_genFieldDefinitions',
                    value: function _genFieldDefinitions() {
                        var fields = [];
                        fields = fields.concat(this._fieldNames);
                        fields = fields.concat(this._getNonNullPipeNames());
                        fields = fields.concat(this._genGetDirectiveFieldNames());
                        fields = fields.concat(this._genGetDetectorFieldNames());
                        return fields.map(function (n) {
                            return '' + n + ' = ' + UTIL + '.uninitialized();';
                        }).join('\n');
                    }
                }, {
                    key: '_genHydrateDirectives',
                    value: function _genHydrateDirectives() {
                        var directiveFieldNames = this._genGetDirectiveFieldNames();
                        var lines = ListWrapper.createFixedSize(directiveFieldNames.length);
                        for (var i = 0, iLen = directiveFieldNames.length; i < iLen; ++i) {
                            lines[i] = '' + directiveFieldNames[i] + ' = directives.getDirectiveFor(' + DIRECTIVES_ACCESSOR + '[' + i + '].directiveIndex);';
                        }
                        return lines.join('\n');
                    }
                }, {
                    key: '_genHydrateDetectors',
                    value: function _genHydrateDetectors() {
                        var detectorFieldNames = this._genGetDetectorFieldNames();
                        var lines = ListWrapper.createFixedSize(detectorFieldNames.length);
                        for (var i = 0, iLen = detectorFieldNames.length; i < iLen; ++i) {
                            lines[i] = '' + detectorFieldNames[i] + ' =\n          directives.getDetectorFor(' + DIRECTIVES_ACCESSOR + '[' + i + '].directiveIndex);';
                        }
                        return lines.join('\n');
                    }
                }, {
                    key: '_genPipeOnDestroy',
                    value: function _genPipeOnDestroy() {
                        return this._getNonNullPipeNames().map(function (p) {
                            return '' + p + '.onDestroy();';
                        }).join('\n');
                    }
                }, {
                    key: '_genCallOnAllChangesDoneBody',
                    value: function _genCallOnAllChangesDoneBody() {
                        var notifications = [];
                        var dirs = this.directiveRecords;
                        for (var i = dirs.length - 1; i >= 0; --i) {
                            var dir = dirs[i];
                            if (dir.callOnAllChangesDone) {
                                notifications.push('' + this._genGetDirective(dir.directiveIndex) + '.onAllChangesDone();');
                            }
                        }
                        return notifications.join('\n');
                    }
                }, {
                    key: '_genLocalDefinitions',
                    value: function _genLocalDefinitions() {
                        return this._localNames.map(function (n) {
                            return 'var ' + n + ';';
                        }).join('\n');
                    }
                }, {
                    key: '_genChangeDefinitions',
                    value: function _genChangeDefinitions() {
                        return this._changeNames.map(function (n) {
                            return 'var ' + n + ' = false;';
                        }).join('\n');
                    }
                }, {
                    key: '_genRecord',
                    value: function _genRecord(r) {
                        var rec;
                        if (r.isLifeCycleRecord()) {
                            rec = this._genDirectiveLifecycle(r);
                        } else if (r.isPipeRecord()) {
                            rec = this._genPipeCheck(r);
                        } else {
                            rec = this._genReferenceCheck(r);
                        }
                        return '' + rec + '' + this._genLastInDirective(r);
                    }
                }, {
                    key: '_genDirectiveLifecycle',
                    value: function _genDirectiveLifecycle(r) {
                        if (r.name === 'onCheck') {
                            return this._genOnCheck(r);
                        } else if (r.name === 'onInit') {
                            return this._genOnInit(r);
                        } else if (r.name === 'onChange') {
                            return this._genOnChange(r);
                        } else {
                            throw new BaseException('Unknown lifecycle event \'' + r.name + '\'');
                        }
                    }
                }, {
                    key: '_genPipeCheck',
                    value: function _genPipeCheck(r) {
                        var context = this._localNames[r.contextIndex];
                        var oldValue = this._fieldNames[r.selfIndex];
                        var newValue = this._localNames[r.selfIndex];
                        var change = this._changeNames[r.selfIndex];
                        var pipe = this._pipeNames[r.selfIndex];
                        var cdRef = r.mode === RECORD_TYPE_BINDING_PIPE ? 'this.ref' : 'null';
                        var protoIndex = r.selfIndex - 1;
                        var pipeType = r.name;
                        return '\n      ' + CURRENT_PROTO + ' = ' + PROTOS_ACCESSOR + '[' + protoIndex + '];\n      if (' + pipe + ' === ' + UTIL + '.uninitialized()) {\n        ' + pipe + ' = ' + PIPE_REGISTRY_ACCESSOR + '.get(\'' + pipeType + '\', ' + context + ', ' + cdRef + ');\n      } else if (!' + pipe + '.supports(' + context + ')) {\n        ' + pipe + '.onDestroy();\n        ' + pipe + ' = ' + PIPE_REGISTRY_ACCESSOR + '.get(\'' + pipeType + '\', ' + context + ', ' + cdRef + ');\n      }\n\n      ' + newValue + ' = ' + pipe + '.transform(' + context + ');\n      if (' + oldValue + ' !== ' + newValue + ') {\n        ' + newValue + ' = ' + UTIL + '.unwrapValue(' + newValue + ');\n        ' + change + ' = true;\n        ' + this._genUpdateDirectiveOrElement(r) + '\n        ' + this._genAddToChanges(r) + '\n        ' + oldValue + ' = ' + newValue + ';\n      }\n    ';
                    }
                }, {
                    key: '_genReferenceCheck',
                    value: function _genReferenceCheck(r) {
                        var oldValue = this._fieldNames[r.selfIndex];
                        var newValue = this._localNames[r.selfIndex];
                        var protoIndex = r.selfIndex - 1;
                        var check = '\n      ' + CURRENT_PROTO + ' = ' + PROTOS_ACCESSOR + '[' + protoIndex + '];\n      ' + this._genUpdateCurrentValue(r) + '\n      if (' + newValue + ' !== ' + oldValue + ') {\n        ' + this._changeNames[r.selfIndex] + ' = true;\n        ' + this._genUpdateDirectiveOrElement(r) + '\n        ' + this._genAddToChanges(r) + '\n        ' + oldValue + ' = ' + newValue + ';\n      }\n    ';
                        if (r.isPureFunction()) {
                            var condition = '' + this._changeNames.join(' || ');
                            return 'if (' + condition + ') { ' + check + ' }';
                        } else {
                            return check;
                        }
                    }
                }, {
                    key: '_genUpdateCurrentValue',
                    value: function _genUpdateCurrentValue(r) {
                        var _this5 = this;

                        var context = r.contextIndex == -1 ? this._genGetDirective(r.directiveIndex) : this._localNames[r.contextIndex];
                        var newValue = this._localNames[r.selfIndex];
                        var argString = r.args.map(function (arg) {
                            return _this5._localNames[arg];
                        }).join(', ');
                        var rhs;
                        switch (r.mode) {
                            case RECORD_TYPE_SELF:
                                rhs = context;
                                break;
                            case RECORD_TYPE_CONST:
                                rhs = JSON.stringify(r.funcOrValue);
                                break;
                            case RECORD_TYPE_PROPERTY:
                                rhs = '' + context + '.' + r.name;
                                break;
                            case RECORD_TYPE_SAFE_PROPERTY:
                                rhs = '' + UTIL + '.isValueBlank(' + context + ') ? null : ' + context + '.' + r.name;
                                break;
                            case RECORD_TYPE_LOCAL:
                                rhs = '' + LOCALS_ACCESSOR + '.get(\'' + r.name + '\')';
                                break;
                            case RECORD_TYPE_INVOKE_METHOD:
                                rhs = '' + context + '.' + r.name + '(' + argString + ')';
                                break;
                            case RECORD_TYPE_SAFE_INVOKE_METHOD:
                                rhs = '' + UTIL + '.isValueBlank(' + context + ') ? null : ' + context + '.' + r.name + '(' + argString + ')';
                                break;
                            case RECORD_TYPE_INVOKE_CLOSURE:
                                rhs = '' + context + '(' + argString + ')';
                                break;
                            case RECORD_TYPE_PRIMITIVE_OP:
                                rhs = '' + UTIL + '.' + r.name + '(' + argString + ')';
                                break;
                            case RECORD_TYPE_INTERPOLATE:
                                rhs = this._genInterpolation(r);
                                break;
                            case RECORD_TYPE_KEYED_ACCESS:
                                rhs = '' + context + '[' + this._localNames[r.args[0]] + ']';
                                break;
                            default:
                                throw new BaseException('Unknown operation ' + r.mode);
                        }
                        return '' + newValue + ' = ' + rhs;
                    }
                }, {
                    key: '_genInterpolation',
                    value: function _genInterpolation(r) {
                        var res = '';
                        for (var i = 0; i < r.args.length; ++i) {
                            res += JSON.stringify(r.fixedArgs[i]);
                            res += ' + ';
                            res += this._localNames[r.args[i]];
                            res += ' + ';
                        }
                        res += JSON.stringify(r.fixedArgs[r.args.length]);
                        return res;
                    }
                }, {
                    key: '_genUpdateDirectiveOrElement',
                    value: function _genUpdateDirectiveOrElement(r) {
                        if (!r.lastInBinding) return '';
                        var newValue = this._localNames[r.selfIndex];
                        var oldValue = this._fieldNames[r.selfIndex];
                        var br = r.bindingRecord;
                        if (br.isDirective()) {
                            var directiveProperty = '' + this._genGetDirective(br.directiveRecord.directiveIndex) + '.' + br.propertyName;
                            return '\n        ' + this._genThrowOnChangeCheck(oldValue, newValue) + '\n        ' + directiveProperty + ' = ' + newValue + ';\n        ' + IS_CHANGED_LOCAL + ' = true;\n      ';
                        } else {
                            return '\n        ' + this._genThrowOnChangeCheck(oldValue, newValue) + '\n        ' + DISPATCHER_ACCESSOR + '.notifyOnBinding(' + CURRENT_PROTO + '.bindingRecord, ' + newValue + ');\n      ';
                        }
                    }
                }, {
                    key: '_genThrowOnChangeCheck',
                    value: function _genThrowOnChangeCheck(oldValue, newValue) {
                        return '\n      if(throwOnChange) {\n        ' + UTIL + '.throwOnChange(' + CURRENT_PROTO + ', ' + UTIL + '.simpleChange(' + oldValue + ', ' + newValue + '));\n      }\n      ';
                    }
                }, {
                    key: '_genAddToChanges',
                    value: function _genAddToChanges(r) {
                        var newValue = this._localNames[r.selfIndex];
                        var oldValue = this._fieldNames[r.selfIndex];
                        if (!r.bindingRecord.callOnChange()) return '';
                        return '\n      ' + CHANGES_LOCAL + ' = ' + UTIL + '.addChange(\n          ' + CHANGES_LOCAL + ', ' + CURRENT_PROTO + '.bindingRecord.propertyName,\n          ' + UTIL + '.simpleChange(' + oldValue + ', ' + newValue + '));\n    ';
                    }
                }, {
                    key: '_genLastInDirective',
                    value: function _genLastInDirective(r) {
                        if (!r.lastInDirective) return '';
                        return '\n      ' + CHANGES_LOCAL + ' = null;\n      ' + this._genNotifyOnPushDetectors(r) + '\n      ' + IS_CHANGED_LOCAL + ' = false;\n    ';
                    }
                }, {
                    key: '_genOnCheck',
                    value: function _genOnCheck(r) {
                        var br = r.bindingRecord;
                        return 'if (!throwOnChange) ' + this._genGetDirective(br.directiveRecord.directiveIndex) + '.onCheck();';
                    }
                }, {
                    key: '_genOnInit',
                    value: function _genOnInit(r) {
                        var br = r.bindingRecord;
                        return 'if (!throwOnChange && !' + ALREADY_CHECKED_ACCESSOR + ') ' + this._genGetDirective(br.directiveRecord.directiveIndex) + '.onInit();';
                    }
                }, {
                    key: '_genOnChange',
                    value: function _genOnChange(r) {
                        var br = r.bindingRecord;
                        return 'if (!throwOnChange && ' + CHANGES_LOCAL + ') ' + this._genGetDirective(br.directiveRecord.directiveIndex) + '.onChange(' + CHANGES_LOCAL + ');';
                    }
                }, {
                    key: '_genNotifyOnPushDetectors',
                    value: function _genNotifyOnPushDetectors(r) {
                        var br = r.bindingRecord;
                        if (!r.lastInDirective || !br.isOnPushChangeDetection()) return '';
                        var retVal = '\n      if(' + IS_CHANGED_LOCAL + ') {\n        ' + this._genGetDetector(br.directiveRecord.directiveIndex) + '.markAsCheckOnce();\n      }\n    ';
                        return retVal;
                    }
                }]);

                return ChangeDetectorJITGenerator;
            })();

            _export('ChangeDetectorJITGenerator', ChangeDetectorJITGenerator);
        }
    };
});


System.register('angular2/src/change_detection/directive_record', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/change_detection/constants', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, ON_PUSH, StringWrapper, normalizeBool, DirectiveIndex, DirectiveRecord;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcChange_detectionConstants) {
            ON_PUSH = _angular2SrcChange_detectionConstants.ON_PUSH;
        }, function (_angular2SrcFacadeLang) {
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            normalizeBool = _angular2SrcFacadeLang.normalizeBool;
        }],
        execute: function () {
            'use strict';

            DirectiveIndex = (function () {
                function DirectiveIndex(elementIndex, directiveIndex) {
                    _classCallCheck(this, DirectiveIndex);

                    this.elementIndex = elementIndex;
                    this.directiveIndex = directiveIndex;
                }

                _createClass(DirectiveIndex, [{
                    key: 'name',
                    get: function () {
                        return '' + this.elementIndex + '_' + this.directiveIndex;
                    }
                }]);

                return DirectiveIndex;
            })();

            _export('DirectiveIndex', DirectiveIndex);

            DirectiveRecord = (function () {
                function DirectiveRecord() {
                    var _ref = arguments[0] === undefined ? {} : arguments[0];

                    var directiveIndex = _ref.directiveIndex;
                    var callOnAllChangesDone = _ref.callOnAllChangesDone;
                    var callOnChange = _ref.callOnChange;
                    var callOnCheck = _ref.callOnCheck;
                    var callOnInit = _ref.callOnInit;
                    var changeDetection = _ref.changeDetection;

                    _classCallCheck(this, DirectiveRecord);

                    this.directiveIndex = directiveIndex;
                    this.callOnAllChangesDone = normalizeBool(callOnAllChangesDone);
                    this.callOnChange = normalizeBool(callOnChange);
                    this.callOnCheck = normalizeBool(callOnCheck);
                    this.callOnInit = normalizeBool(callOnInit);
                    this.changeDetection = changeDetection;
                }

                _createClass(DirectiveRecord, [{
                    key: 'isOnPushChangeDetection',
                    value: function isOnPushChangeDetection() {
                        return StringWrapper.equals(this.changeDetection, ON_PUSH);
                    }
                }]);

                return DirectiveRecord;
            })();

            _export('DirectiveRecord', DirectiveRecord);
        }
    };
});


System.register('angular2/src/change_detection/coalesce', ['angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/change_detection/proto_record'], function (_export) {
    'use strict';

    var isPresent, ListWrapper, MapWrapper, RECORD_TYPE_SELF, RECORD_TYPE_DIRECTIVE_LIFECYCLE, ProtoRecord;

    _export('coalesce', coalesce);

    /**
     * Removes "duplicate" records. It assuming that record evaluation does not
     * have side-effects.
     *
     * Records that are not last in bindings are removed and all the indices
     * of the records that depend on them are updated.
     *
     * Records that are last in bindings CANNOT be removed, and instead are
     * replaced with very cheap SELF records.
     */

    function coalesce(records) {
        var res = ListWrapper.create();
        var indexMap = MapWrapper.create();
        for (var i = 0; i < records.length; ++i) {
            var r = records[i];
            var record = _replaceIndices(r, res.length + 1, indexMap);
            var matchingRecord = _findMatching(record, res);
            if (isPresent(matchingRecord) && record.lastInBinding) {
                ListWrapper.push(res, _selfRecord(record, matchingRecord.selfIndex, res.length + 1));
                MapWrapper.set(indexMap, r.selfIndex, matchingRecord.selfIndex);
            } else if (isPresent(matchingRecord) && !record.lastInBinding) {
                MapWrapper.set(indexMap, r.selfIndex, matchingRecord.selfIndex);
            } else {
                ListWrapper.push(res, record);
                MapWrapper.set(indexMap, r.selfIndex, record.selfIndex);
            }
        }
        return res;
    }

    function _selfRecord(r, contextIndex, selfIndex) {
        return new ProtoRecord(RECORD_TYPE_SELF, 'self', null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.expressionAsString, r.lastInBinding, r.lastInDirective);
    }
    function _findMatching(r, rs) {
        return ListWrapper.find(rs, function (rr) {
            return rr.mode !== RECORD_TYPE_DIRECTIVE_LIFECYCLE && rr.mode === r.mode && rr.funcOrValue === r.funcOrValue && rr.contextIndex === r.contextIndex && ListWrapper.equals(rr.args, r.args);
        });
    }
    function _replaceIndices(r, selfIndex, indexMap) {
        var args = ListWrapper.map(r.args, function (a) {
            return _map(indexMap, a);
        });
        var contextIndex = _map(indexMap, r.contextIndex);
        return new ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.expressionAsString, r.lastInBinding, r.lastInDirective);
    }
    function _map(indexMap, value) {
        var r = MapWrapper.get(indexMap, value);
        return isPresent(r) ? r : value;
    }
    
    return {
        setters: [function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcChange_detectionProto_record) {
            RECORD_TYPE_SELF = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SELF;
            RECORD_TYPE_DIRECTIVE_LIFECYCLE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_DIRECTIVE_LIFECYCLE;
            ProtoRecord = _angular2SrcChange_detectionProto_record.ProtoRecord;
        }],
        execute: function () {}
    };
});
System.register("angular2/src/change_detection/binding_record", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, isPresent, DIRECTIVE, DIRECTIVE_LIFECYCLE, ELEMENT, TEXT_NODE, BindingRecord;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {
            "use strict";

            DIRECTIVE = "directive";
            DIRECTIVE_LIFECYCLE = "directiveLifecycle";
            ELEMENT = "element";
            TEXT_NODE = "textNode";

            BindingRecord = (function () {
                function BindingRecord(mode, implicitReceiver, ast, elementIndex, propertyName, setter, lifecycleEvent, directiveRecord) {
                    _classCallCheck(this, BindingRecord);

                    this.mode = mode;
                    this.implicitReceiver = implicitReceiver;
                    this.ast = ast;
                    this.elementIndex = elementIndex;
                    this.propertyName = propertyName;
                    this.setter = setter;
                    this.lifecycleEvent = lifecycleEvent;
                    this.directiveRecord = directiveRecord;
                }

                _createClass(BindingRecord, [{
                    key: "callOnChange",
                    value: function callOnChange() {
                        return isPresent(this.directiveRecord) && this.directiveRecord.callOnChange;
                    }
                }, {
                    key: "isOnPushChangeDetection",
                    value: function isOnPushChangeDetection() {
                        return isPresent(this.directiveRecord) && this.directiveRecord.isOnPushChangeDetection();
                    }
                }, {
                    key: "isDirective",
                    value: function isDirective() {
                        return this.mode === DIRECTIVE;
                    }
                }, {
                    key: "isDirectiveLifecycle",
                    value: function isDirectiveLifecycle() {
                        return this.mode === DIRECTIVE_LIFECYCLE;
                    }
                }, {
                    key: "isElement",
                    value: function isElement() {
                        return this.mode === ELEMENT;
                    }
                }, {
                    key: "isTextNode",
                    value: function isTextNode() {
                        return this.mode === TEXT_NODE;
                    }
                }], [{
                    key: "createForDirective",
                    value: function createForDirective(ast, propertyName, setter, directiveRecord) {
                        return new BindingRecord(DIRECTIVE, 0, ast, 0, propertyName, setter, null, directiveRecord);
                    }
                }, {
                    key: "createDirectiveOnCheck",
                    value: function createDirectiveOnCheck(directiveRecord) {
                        return new BindingRecord(DIRECTIVE_LIFECYCLE, 0, null, 0, null, null, "onCheck", directiveRecord);
                    }
                }, {
                    key: "createDirectiveOnInit",
                    value: function createDirectiveOnInit(directiveRecord) {
                        return new BindingRecord(DIRECTIVE_LIFECYCLE, 0, null, 0, null, null, "onInit", directiveRecord);
                    }
                }, {
                    key: "createDirectiveOnChange",
                    value: function createDirectiveOnChange(directiveRecord) {
                        return new BindingRecord(DIRECTIVE_LIFECYCLE, 0, null, 0, null, null, "onChange", directiveRecord);
                    }
                }, {
                    key: "createForElement",
                    value: function createForElement(ast, elementIndex, propertyName) {
                        return new BindingRecord(ELEMENT, 0, ast, elementIndex, propertyName, null, null, null);
                    }
                }, {
                    key: "createForHostProperty",
                    value: function createForHostProperty(directiveIndex, ast, propertyName) {
                        return new BindingRecord(ELEMENT, directiveIndex, ast, directiveIndex.elementIndex, propertyName, null, null, null);
                    }
                }, {
                    key: "createForTextNode",
                    value: function createForTextNode(ast, elementIndex) {
                        return new BindingRecord(TEXT_NODE, 0, ast, elementIndex, null, null, null, null);
                    }
                }]);

                return BindingRecord;
            })();

            _export("BindingRecord", BindingRecord);
        }
    };
});


System.register("angular2/src/change_detection/pipes/pipe_registry", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/di/decorators"], function (_export) {
    var _createClass, _classCallCheck, ListWrapper, isBlank, BaseException, Injectable, __decorate, __metadata, PipeRegistry;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcDiDecorators) {
            Injectable = _angular2SrcDiDecorators.Injectable;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            PipeRegistry = (function () {
                var _class = function PipeRegistry(config) {
                    _classCallCheck(this, _class);

                    this.config = config;
                };

                _createClass(_class, [{
                    key: "get",
                    value: function get(type, obj, cdRef) {
                        var listOfConfigs = this.config[type];
                        if (isBlank(listOfConfigs)) {
                            throw new BaseException("Cannot find '" + type + "' pipe supporting object '" + obj + "'");
                        }
                        var matchingConfig = ListWrapper.find(listOfConfigs, function (pipeConfig) {
                            return pipeConfig.supports(obj);
                        });
                        if (isBlank(matchingConfig)) {
                            throw new BaseException("Cannot find '" + type + "' pipe supporting object '" + obj + "'");
                        }
                        return matchingConfig.create(cdRef);
                    }
                }]);

                return _class;
            })();

            _export("PipeRegistry", PipeRegistry);

            _export("PipeRegistry", PipeRegistry = __decorate([Injectable(), __metadata("design:paramtypes", [Object])], PipeRegistry));
            
        }
    };
});
System.register("angular2/src/change_detection/pipes/null_pipe", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, isBlank, CONST, Pipe, WrappedValue, PipeFactory, __decorate, __metadata, NullPipeFactory, NullPipe;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            CONST = _angular2SrcFacadeLang.CONST;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
            WrappedValue = _angular2SrcChange_detectionPipesPipe.WrappedValue;
            PipeFactory = _angular2SrcChange_detectionPipesPipe.PipeFactory;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * @exportedAs angular2/pipes
             */

            NullPipeFactory = (function (_PipeFactory) {
                var _class = function NullPipeFactory() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                };

                _inherits(_class, _PipeFactory);

                _createClass(_class, [{
                    key: "supports",
                    value: function supports(obj) {
                        return NullPipe.supportsObj(obj);
                    }
                }, {
                    key: "create",
                    value: function create(cdRef) {
                        return new NullPipe();
                    }
                }]);

                return _class;
            })(PipeFactory);

            _export("NullPipeFactory", NullPipeFactory);

            _export("NullPipeFactory", NullPipeFactory = __decorate([CONST(), __metadata("design:paramtypes", [])], NullPipeFactory));
            /**
             * @exportedAs angular2/pipes
             */

            NullPipe = (function (_Pipe) {
                function NullPipe() {
                    _classCallCheck(this, NullPipe);

                    _get(Object.getPrototypeOf(NullPipe.prototype), "constructor", this).call(this);
                    this.called = false;
                }

                _inherits(NullPipe, _Pipe);

                _createClass(NullPipe, [{
                    key: "supports",
                    value: function supports(obj) {
                        return NullPipe.supportsObj(obj);
                    }
                }, {
                    key: "transform",
                    value: function transform(value) {
                        if (!this.called) {
                            this.called = true;
                            return WrappedValue.wrap(null);
                        } else {
                            return null;
                        }
                    }
                }], [{
                    key: "supportsObj",
                    value: function supportsObj(obj) {
                        return isBlank(obj);
                    }
                }]);

                return NullPipe;
            })(Pipe);

            _export("NullPipe", NullPipe);
        }
    };
});


System.register("angular2/src/change_detection/pipes/iterable_changes", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/pipes/pipe"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, CONST, isBlank, isPresent, stringify, getMapKey, looseIdentical, isListLikeIterable, iterateListLike, ListWrapper, MapWrapper, WrappedValue, Pipe, PipeFactory, __decorate, __metadata, IterableChangesFactory, IterableChanges, CollectionChangeRecord, _DuplicateItemRecordList, _DuplicateMap;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            stringify = _angular2SrcFacadeLang.stringify;
            getMapKey = _angular2SrcFacadeLang.getMapKey;
            looseIdentical = _angular2SrcFacadeLang.looseIdentical;
        }, function (_angular2SrcFacadeCollection) {
            isListLikeIterable = _angular2SrcFacadeCollection.isListLikeIterable;
            iterateListLike = _angular2SrcFacadeCollection.iterateListLike;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            WrappedValue = _angular2SrcChange_detectionPipesPipe.WrappedValue;
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
            PipeFactory = _angular2SrcChange_detectionPipesPipe.PipeFactory;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IterableChangesFactory = (function (_PipeFactory) {
                var _class = function IterableChangesFactory() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                };

                _inherits(_class, _PipeFactory);

                _createClass(_class, [{
                    key: "supports",
                    value: function supports(obj) {
                        return IterableChanges.supportsObj(obj);
                    }
                }, {
                    key: "create",
                    value: function create(cdRef) {
                        return new IterableChanges();
                    }
                }]);

                return _class;
            })(PipeFactory);

            _export("IterableChangesFactory", IterableChangesFactory);

            _export("IterableChangesFactory", IterableChangesFactory = __decorate([CONST(), __metadata("design:paramtypes", [])], IterableChangesFactory));
            /**
             * @exportedAs angular2/pipes
             */

            IterableChanges = (function (_Pipe) {
                function IterableChanges() {
                    _classCallCheck(this, IterableChanges);

                    _get(Object.getPrototypeOf(IterableChanges.prototype), "constructor", this).call(this);
                    this._collection = null;
                    this._length = null;
                    /// Keeps track of the used records at any point in time (during & across `_check()` calls)
                    this._linkedRecords = null;
                    /// Keeps track of the removed records at any point in time during `_check()` calls.
                    this._unlinkedRecords = null;
                    this._previousItHead = null;
                    this._itHead = null;
                    this._itTail = null;
                    this._additionsHead = null;
                    this._additionsTail = null;
                    this._movesHead = null;
                    this._movesTail = null;
                    this._removalsHead = null;
                    this._removalsTail = null;
                }

                _inherits(IterableChanges, _Pipe);

                _createClass(IterableChanges, [{
                    key: "supports",
                    value: function supports(obj) {
                        return IterableChanges.supportsObj(obj);
                    }
                }, {
                    key: "collection",
                    get: function () {
                        return this._collection;
                    }
                }, {
                    key: "length",
                    get: function () {
                        return this._length;
                    }
                }, {
                    key: "forEachItem",
                    value: function forEachItem(fn) {
                        var record;
                        for (record = this._itHead; record !== null; record = record._next) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachPreviousItem",
                    value: function forEachPreviousItem(fn) {
                        var record;
                        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachAddedItem",
                    value: function forEachAddedItem(fn) {
                        var record;
                        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachMovedItem",
                    value: function forEachMovedItem(fn) {
                        var record;
                        for (record = this._movesHead; record !== null; record = record._nextMoved) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachRemovedItem",
                    value: function forEachRemovedItem(fn) {
                        var record;
                        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                            fn(record);
                        }
                    }
                }, {
                    key: "transform",
                    value: function transform(collection) {
                        if (this.check(collection)) {
                            return WrappedValue.wrap(this);
                        } else {
                            return this;
                        }
                    }
                }, {
                    key: "check",

                    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
                    value: function check(collection) {
                        var _this = this;

                        this._reset();
                        var record = this._itHead;
                        var mayBeDirty = false;
                        var index;
                        var item;
                        if (ListWrapper.isList(collection)) {
                            var list = collection;
                            this._length = collection.length;
                            for (index = 0; index < this._length; index++) {
                                item = list[index];
                                if (record === null || !looseIdentical(record.item, item)) {
                                    record = this._mismatch(record, item, index);
                                    mayBeDirty = true;
                                } else if (mayBeDirty) {
                                    // TODO(misko): can we limit this to duplicates only?
                                    record = this._verifyReinsertion(record, item, index);
                                }
                                record = record._next;
                            }
                        } else {
                            index = 0;
                            iterateListLike(collection, function (item) {
                                if (record === null || !looseIdentical(record.item, item)) {
                                    record = _this._mismatch(record, item, index);
                                    mayBeDirty = true;
                                } else if (mayBeDirty) {
                                    // TODO(misko): can we limit this to duplicates only?
                                    record = _this._verifyReinsertion(record, item, index);
                                }
                                record = record._next;
                                index++;
                            });
                            this._length = index;
                        }
                        this._truncate(record);
                        this._collection = collection;
                        return this.isDirty;
                    }
                }, {
                    key: "isDirty",

                    // CollectionChanges is considered dirty if it has any additions, moves or removals.
                    get: function () {
                        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
                    }
                }, {
                    key: "_reset",

                    /**
                     * Reset the state of the change objects to show no changes. This means set previousKey to
                     * currentKey, and clear all of the queues (additions, moves, removals).
                     * Set the previousIndexes of moved and added items to their currentIndexes
                     * Reset the list of additions, moves and removals
                     */
                    value: function _reset() {
                        if (this.isDirty) {
                            var record;
                            var nextRecord;
                            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                                record._nextPrevious = record._next;
                            }
                            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                                record.previousIndex = record.currentIndex;
                            }
                            this._additionsHead = this._additionsTail = null;
                            for (record = this._movesHead; record !== null; record = nextRecord) {
                                record.previousIndex = record.currentIndex;
                                nextRecord = record._nextMoved;
                            }
                            this._movesHead = this._movesTail = null;
                            this._removalsHead = this._removalsTail = null;
                        }
                    }
                }, {
                    key: "_mismatch",

                    /**
                     * This is the core function which handles differences between collections.
                     *
                     * - `record` is the record which we saw at this position last time. If null then it is a new
                     *   item.
                     * - `item` is the current item in the collection
                     * - `index` is the position of the item in the collection
                     */
                    value: function _mismatch(record, item, index) {
                        // The previous record after which we will append the current one.
                        var previousRecord;
                        if (record === null) {
                            previousRecord = this._itTail;
                        } else {
                            previousRecord = record._prev;
                            // Remove the record from the collection since we know it does not match the item.
                            this._remove(record);
                        }
                        // Attempt to see if we have seen the item before.
                        record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
                        if (record !== null) {
                            // We have seen this before, we need to move it forward in the collection.
                            this._moveAfter(record, previousRecord, index);
                        } else {
                            // Never seen it, check evicted list.
                            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
                            if (record !== null) {
                                // It is an item which we have evicted earlier: reinsert it back into the list.
                                this._reinsertAfter(record, previousRecord, index);
                            } else {
                                // It is a new item: add it.
                                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
                            }
                        }
                        return record;
                    }
                }, {
                    key: "_verifyReinsertion",

                    /**
                     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
                     *
                     * Use case: `[a, a]` => `[b, a, a]`
                     *
                     * If we did not have this check then the insertion of `b` would:
                     *   1) evict first `a`
                     *   2) insert `b` at `0` index.
                     *   3) leave `a` at index `1` as is. <-- this is wrong!
                     *   3) reinsert `a` at index 2. <-- this is wrong!
                     *
                     * The correct behavior is:
                     *   1) evict first `a`
                     *   2) insert `b` at `0` index.
                     *   3) reinsert `a` at index 1.
                     *   3) move `a` at from `1` to `2`.
                     *
                     *
                     * Double check that we have not evicted a duplicate item. We need to check if the item type may
                     * have already been removed:
                     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
                     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
                     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
                     * at the end.
                     */
                    value: function _verifyReinsertion(record, item, index) {
                        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
                        if (reinsertRecord !== null) {
                            record = this._reinsertAfter(reinsertRecord, record._prev, index);
                        } else if (record.currentIndex != index) {
                            record.currentIndex = index;
                            this._addToMoves(record, index);
                        }
                        return record;
                    }
                }, {
                    key: "_truncate",

                    /**
                     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
                     *
                     * - `record` The first excess {@link CollectionChangeRecord}.
                     */
                    value: function _truncate(record) {
                        // Anything after that needs to be removed;
                        while (record !== null) {
                            var nextRecord = record._next;
                            this._addToRemovals(this._unlink(record));
                            record = nextRecord;
                        }
                        if (this._unlinkedRecords !== null) {
                            this._unlinkedRecords.clear();
                        }
                        if (this._additionsTail !== null) {
                            this._additionsTail._nextAdded = null;
                        }
                        if (this._movesTail !== null) {
                            this._movesTail._nextMoved = null;
                        }
                        if (this._itTail !== null) {
                            this._itTail._next = null;
                        }
                        if (this._removalsTail !== null) {
                            this._removalsTail._nextRemoved = null;
                        }
                    }
                }, {
                    key: "_reinsertAfter",
                    value: function _reinsertAfter(record, prevRecord, index) {
                        if (this._unlinkedRecords !== null) {
                            this._unlinkedRecords.remove(record);
                        }
                        var prev = record._prevRemoved;
                        var next = record._nextRemoved;
                        if (prev === null) {
                            this._removalsHead = next;
                        } else {
                            prev._nextRemoved = next;
                        }
                        if (next === null) {
                            this._removalsTail = prev;
                        } else {
                            next._prevRemoved = prev;
                        }
                        this._insertAfter(record, prevRecord, index);
                        this._addToMoves(record, index);
                        return record;
                    }
                }, {
                    key: "_moveAfter",
                    value: function _moveAfter(record, prevRecord, index) {
                        this._unlink(record);
                        this._insertAfter(record, prevRecord, index);
                        this._addToMoves(record, index);
                        return record;
                    }
                }, {
                    key: "_addAfter",
                    value: function _addAfter(record, prevRecord, index) {
                        this._insertAfter(record, prevRecord, index);
                        if (this._additionsTail === null) {
                            // todo(vicb)
                            // assert(this._additionsHead === null);
                            this._additionsTail = this._additionsHead = record;
                        } else {
                            // todo(vicb)
                            // assert(_additionsTail._nextAdded === null);
                            // assert(record._nextAdded === null);
                            this._additionsTail = this._additionsTail._nextAdded = record;
                        }
                        return record;
                    }
                }, {
                    key: "_insertAfter",
                    value: function _insertAfter(record, prevRecord, index) {
                        // todo(vicb)
                        // assert(record != prevRecord);
                        // assert(record._next === null);
                        // assert(record._prev === null);
                        var next = prevRecord === null ? this._itHead : prevRecord._next;
                        // todo(vicb)
                        // assert(next != record);
                        // assert(prevRecord != record);
                        record._next = next;
                        record._prev = prevRecord;
                        if (next === null) {
                            this._itTail = record;
                        } else {
                            next._prev = record;
                        }
                        if (prevRecord === null) {
                            this._itHead = record;
                        } else {
                            prevRecord._next = record;
                        }
                        if (this._linkedRecords === null) {
                            this._linkedRecords = new _DuplicateMap();
                        }
                        this._linkedRecords.put(record);
                        record.currentIndex = index;
                        return record;
                    }
                }, {
                    key: "_remove",
                    value: function _remove(record) {
                        return this._addToRemovals(this._unlink(record));
                    }
                }, {
                    key: "_unlink",
                    value: function _unlink(record) {
                        if (this._linkedRecords !== null) {
                            this._linkedRecords.remove(record);
                        }
                        var prev = record._prev;
                        var next = record._next;
                        // todo(vicb)
                        // assert((record._prev = null) === null);
                        // assert((record._next = null) === null);
                        if (prev === null) {
                            this._itHead = next;
                        } else {
                            prev._next = next;
                        }
                        if (next === null) {
                            this._itTail = prev;
                        } else {
                            next._prev = prev;
                        }
                        return record;
                    }
                }, {
                    key: "_addToMoves",
                    value: function _addToMoves(record, toIndex) {
                        // todo(vicb)
                        // assert(record._nextMoved === null);
                        if (record.previousIndex === toIndex) {
                            return record;
                        }
                        if (this._movesTail === null) {
                            // todo(vicb)
                            // assert(_movesHead === null);
                            this._movesTail = this._movesHead = record;
                        } else {
                            // todo(vicb)
                            // assert(_movesTail._nextMoved === null);
                            this._movesTail = this._movesTail._nextMoved = record;
                        }
                        return record;
                    }
                }, {
                    key: "_addToRemovals",
                    value: function _addToRemovals(record) {
                        if (this._unlinkedRecords === null) {
                            this._unlinkedRecords = new _DuplicateMap();
                        }
                        this._unlinkedRecords.put(record);
                        record.currentIndex = null;
                        record._nextRemoved = null;
                        if (this._removalsTail === null) {
                            // todo(vicb)
                            // assert(_removalsHead === null);
                            this._removalsTail = this._removalsHead = record;
                            record._prevRemoved = null;
                        } else {
                            // todo(vicb)
                            // assert(_removalsTail._nextRemoved === null);
                            // assert(record._nextRemoved === null);
                            record._prevRemoved = this._removalsTail;
                            this._removalsTail = this._removalsTail._nextRemoved = record;
                        }
                        return record;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var record;
                        var list = [];
                        for (record = this._itHead; record !== null; record = record._next) {
                            ListWrapper.push(list, record);
                        }
                        var previous = [];
                        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                            ListWrapper.push(previous, record);
                        }
                        var additions = [];
                        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                            ListWrapper.push(additions, record);
                        }
                        var moves = [];
                        for (record = this._movesHead; record !== null; record = record._nextMoved) {
                            ListWrapper.push(moves, record);
                        }
                        var removals = [];
                        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                            ListWrapper.push(removals, record);
                        }
                        return "collection: " + list.join(", ") + "\n" + "previous: " + previous.join(", ") + "\n" + "additions: " + additions.join(", ") + "\n" + "moves: " + moves.join(", ") + "\n" + "removals: " + removals.join(", ") + "\n";
                    }
                }], [{
                    key: "supportsObj",
                    value: function supportsObj(obj) {
                        return isListLikeIterable(obj);
                    }
                }]);

                return IterableChanges;
            })(Pipe);

            _export("IterableChanges", IterableChanges);

            /**
             * @exportedAs angular2/pipes
             */

            CollectionChangeRecord = (function () {
                function CollectionChangeRecord(item) {
                    _classCallCheck(this, CollectionChangeRecord);

                    this.currentIndex = null;
                    this.previousIndex = null;
                    this.item = item;
                    this._nextPrevious = null;
                    this._prev = null;
                    this._next = null;
                    this._prevDup = null;
                    this._nextDup = null;
                    this._prevRemoved = null;
                    this._nextRemoved = null;
                    this._nextAdded = null;
                    this._nextMoved = null;
                }

                _createClass(CollectionChangeRecord, [{
                    key: "toString",
                    value: function toString() {
                        return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + "[" + stringify(this.previousIndex) + "->" + stringify(this.currentIndex) + "]";
                    }
                }]);

                return CollectionChangeRecord;
            })();

            _export("CollectionChangeRecord", CollectionChangeRecord);

            // A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item

            _DuplicateItemRecordList = (function () {
                function _DuplicateItemRecordList() {
                    _classCallCheck(this, _DuplicateItemRecordList);

                    this._head = null;
                    this._tail = null;
                }

                _createClass(_DuplicateItemRecordList, [{
                    key: "add",

                    /**
                     * Append the record to the list of duplicates.
                     *
                     * Note: by design all records in the list of duplicates hold the same value in record.item.
                     */
                    value: function add(record) {
                        if (this._head === null) {
                            this._head = this._tail = record;
                            record._nextDup = null;
                            record._prevDup = null;
                        } else {
                            // todo(vicb)
                            // assert(record.item ==  _head.item ||
                            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
                            this._tail._nextDup = record;
                            record._prevDup = this._tail;
                            record._nextDup = null;
                            this._tail = record;
                        }
                    }
                }, {
                    key: "get",

                    // Returns a CollectionChangeRecord having CollectionChangeRecord.item == item and
                    // CollectionChangeRecord.currentIndex >= afterIndex
                    value: function get(item, afterIndex) {
                        var record;
                        for (record = this._head; record !== null; record = record._nextDup) {
                            if ((afterIndex === null || afterIndex < record.currentIndex) && looseIdentical(record.item, item)) {
                                return record;
                            }
                        }
                        return null;
                    }
                }, {
                    key: "remove",

                    /**
                     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
                     *
                     * Returns whether the list of duplicates is empty.
                     */
                    value: function remove(record) {
                        // todo(vicb)
                        // assert(() {
                        //  // verify that the record being removed is in the list.
                        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
                        //    if (identical(cursor, record)) return true;
                        //  }
                        //  return false;
                        //});
                        var prev = record._prevDup;
                        var next = record._nextDup;
                        if (prev === null) {
                            this._head = next;
                        } else {
                            prev._nextDup = next;
                        }
                        if (next === null) {
                            this._tail = prev;
                        } else {
                            next._prevDup = prev;
                        }
                        return this._head === null;
                    }
                }]);

                return _DuplicateItemRecordList;
            })();

            _DuplicateMap = (function () {
                function _DuplicateMap() {
                    _classCallCheck(this, _DuplicateMap);

                    this.map = MapWrapper.create();
                }

                _createClass(_DuplicateMap, [{
                    key: "put",
                    value: function put(record) {
                        // todo(vicb) handle corner cases
                        var key = getMapKey(record.item);
                        var duplicates = MapWrapper.get(this.map, key);
                        if (!isPresent(duplicates)) {
                            duplicates = new _DuplicateItemRecordList();
                            MapWrapper.set(this.map, key, duplicates);
                        }
                        duplicates.add(record);
                    }
                }, {
                    key: "get",

                    /**
                     * Retrieve the `value` using key. Because the CollectionChangeRecord value maybe one which we
                     * have already iterated over, we use the afterIndex to pretend it is not there.
                     *
                     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
                     * have any more `a`s needs to return the last `a` not the first or second.
                     */
                    value: function get(value) {
                        var afterIndex = arguments[1] === undefined ? null : arguments[1];

                        var key = getMapKey(value);
                        var recordList = MapWrapper.get(this.map, key);
                        return isBlank(recordList) ? null : recordList.get(value, afterIndex);
                    }
                }, {
                    key: "remove",

                    /**
                     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
                     *
                     * The list of duplicates also is removed from the map if it gets empty.
                     */
                    value: function remove(record) {
                        var key = getMapKey(record.item);
                        // todo(vicb)
                        // assert(this.map.containsKey(key));
                        var recordList = MapWrapper.get(this.map, key);
                        // Remove the list of duplicates when it gets empty
                        if (recordList.remove(record)) {
                            MapWrapper["delete"](this.map, key);
                        }
                        return record;
                    }
                }, {
                    key: "isEmpty",
                    get: function () {
                        return MapWrapper.size(this.map) === 0;
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        MapWrapper.clear(this.map);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "_DuplicateMap(" + stringify(this.map) + ")";
                    }
                }]);

                return _DuplicateMap;
            })();
        }
    };
});


System.register('angular2/src/change_detection/pipes/promise_pipe', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/async', 'angular2/src/facade/lang', 'angular2/src/change_detection/pipes/pipe'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, PromiseWrapper, isBlank, isPresent, Pipe, WrappedValue, PromisePipe, PromisePipeFactory;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
            WrappedValue = _angular2SrcChange_detectionPipesPipe.WrappedValue;
        }],
        execute: function () {
            'use strict';

            /**
             * Implements async bindings to Promise.
             *
             * # Example
             *
             * In this example we bind the description promise to the DOM.
             * The async pipe will convert a promise to the value with which it is resolved. It will also
             * request a change detection check when the promise is resolved.
             *
             *  ```
             * @Component({
             *   selector: "task-cmp",
             *   changeDetection: ON_PUSH
             * })
             * @View({
             *   template: "Task Description {{ description | async }}"
             * })
             * class Task {
             *   description:Promise<string>;
             * }
             *
             * ```
             *
             * @exportedAs angular2/pipes
             */

            PromisePipe = (function (_Pipe) {
                function PromisePipe(ref) {
                    _classCallCheck(this, PromisePipe);

                    _get(Object.getPrototypeOf(PromisePipe.prototype), 'constructor', this).call(this);
                    this._ref = ref;
                    this._latestValue = null;
                    this._latestReturnedValue = null;
                }

                _inherits(PromisePipe, _Pipe);

                _createClass(PromisePipe, [{
                    key: 'supports',
                    value: function supports(promise) {
                        return PromiseWrapper.isPromise(promise);
                    }
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        if (isPresent(this._sourcePromise)) {
                            this._latestValue = null;
                            this._latestReturnedValue = null;
                            this._sourcePromise = null;
                        }
                    }
                }, {
                    key: 'transform',
                    value: function transform(promise) {
                        var _this = this;

                        if (isBlank(this._sourcePromise)) {
                            this._sourcePromise = promise;
                            promise.then(function (val) {
                                if (_this._sourcePromise === promise) {
                                    _this._updateLatestValue(val);
                                }
                            });
                            return null;
                        }
                        if (promise !== this._sourcePromise) {
                            this._sourcePromise = null;
                            return this.transform(promise);
                        }
                        if (this._latestValue === this._latestReturnedValue) {
                            return this._latestReturnedValue;
                        } else {
                            this._latestReturnedValue = this._latestValue;
                            return WrappedValue.wrap(this._latestValue);
                        }
                    }
                }, {
                    key: '_updateLatestValue',
                    value: function _updateLatestValue(value) {
                        this._latestValue = value;
                        this._ref.requestCheck();
                    }
                }]);

                return PromisePipe;
            })(Pipe);

            _export('PromisePipe', PromisePipe);

            /**
             * Provides a factory for [PromisePipe].
             *
             * @exportedAs angular2/pipes
             */

            PromisePipeFactory = (function () {
                function PromisePipeFactory() {
                    _classCallCheck(this, PromisePipeFactory);
                }

                _createClass(PromisePipeFactory, [{
                    key: 'supports',
                    value: function supports(promise) {
                        return PromiseWrapper.isPromise(promise);
                    }
                }, {
                    key: 'create',
                    value: function create(cdRef) {
                        return new PromisePipe(cdRef);
                    }
                }]);

                return PromisePipeFactory;
            })();

            _export('PromisePipeFactory', PromisePipeFactory);
        }
    };
});


System.register('angular2/src/change_detection/pipes/uppercase_pipe', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/change_detection/pipes/pipe'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, isString, StringWrapper, Pipe, UpperCasePipe, UpperCaseFactory;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isString = _angular2SrcFacadeLang.isString;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
        }],
        execute: function () {
            'use strict';

            /**
             * Implements uppercase transforms to text.
             *
             * # Example
             *
             * In this example we transform the user text uppercase.
             *
             *  ```
             * @Component({
             *   selector: "username-cmp"
             * })
             * @View({
             *   template: "Username: {{ user | uppercase }}"
             * })
             * class Username {
             *   user:string;
             * }
             *
             * ```
             *
             * @exportedAs angular2/pipes
             */

            UpperCasePipe = (function (_Pipe) {
                function UpperCasePipe() {
                    _classCallCheck(this, UpperCasePipe);

                    _get(Object.getPrototypeOf(UpperCasePipe.prototype), 'constructor', this).call(this);
                    this._latestValue = null;
                }

                _inherits(UpperCasePipe, _Pipe);

                _createClass(UpperCasePipe, [{
                    key: 'supports',
                    value: function supports(str) {
                        return isString(str);
                    }
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        this._latestValue = null;
                    }
                }, {
                    key: 'transform',
                    value: function transform(value) {
                        if (this._latestValue !== value) {
                            this._latestValue = value;
                            return StringWrapper.toUpperCase(value);
                        } else {
                            return this._latestValue;
                        }
                    }
                }]);

                return UpperCasePipe;
            })(Pipe);

            _export('UpperCasePipe', UpperCasePipe);

            /**
             * @exportedAs angular2/pipes
             */

            UpperCaseFactory = (function () {
                function UpperCaseFactory() {
                    _classCallCheck(this, UpperCaseFactory);
                }

                _createClass(UpperCaseFactory, [{
                    key: 'supports',
                    value: function supports(str) {
                        return isString(str);
                    }
                }, {
                    key: 'create',
                    value: function create() {
                        return new UpperCasePipe();
                    }
                }]);

                return UpperCaseFactory;
            })();

            _export('UpperCaseFactory', UpperCaseFactory);
        }
    };
});


System.register('angular2/src/change_detection/pipes/lowercase_pipe', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/change_detection/pipes/pipe'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, isString, StringWrapper, Pipe, LowerCasePipe, LowerCaseFactory;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isString = _angular2SrcFacadeLang.isString;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
        }],
        execute: function () {
            'use strict';

            /**
             * Implements lowercase transforms to text.
             *
             * # Example
             *
             * In this example we transform the user text lowercase.
             *
             *  ```
             * @Component({
             *   selector: "username-cmp"
             * })
             * @View({
             *   template: "Username: {{ user | lowercase }}"
             * })
             * class Username {
             *   user:string;
             * }
             *
             * ```
             *
             * @exportedAs angular2/pipes
             */

            LowerCasePipe = (function (_Pipe) {
                function LowerCasePipe() {
                    _classCallCheck(this, LowerCasePipe);

                    _get(Object.getPrototypeOf(LowerCasePipe.prototype), 'constructor', this).call(this);
                    this._latestValue = null;
                }

                _inherits(LowerCasePipe, _Pipe);

                _createClass(LowerCasePipe, [{
                    key: 'supports',
                    value: function supports(str) {
                        return isString(str);
                    }
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        this._latestValue = null;
                    }
                }, {
                    key: 'transform',
                    value: function transform(value) {
                        if (this._latestValue !== value) {
                            this._latestValue = value;
                            return StringWrapper.toLowerCase(value);
                        } else {
                            return this._latestValue;
                        }
                    }
                }]);

                return LowerCasePipe;
            })(Pipe);

            _export('LowerCasePipe', LowerCasePipe);

            /**
             * @exportedAs angular2/pipes
             */

            LowerCaseFactory = (function () {
                function LowerCaseFactory() {
                    _classCallCheck(this, LowerCaseFactory);
                }

                _createClass(LowerCaseFactory, [{
                    key: 'supports',
                    value: function supports(str) {
                        return isString(str);
                    }
                }, {
                    key: 'create',
                    value: function create() {
                        return new LowerCasePipe();
                    }
                }]);

                return LowerCaseFactory;
            })();

            _export('LowerCaseFactory', LowerCaseFactory);
        }
    };
});


System.register("angular2/src/change_detection/pipes/json_pipe", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, isPresent, CONST, Json, Pipe, PipeFactory, __decorate, __metadata, JsonPipe, JsonPipeFactory;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            CONST = _angular2SrcFacadeLang.CONST;
            Json = _angular2SrcFacadeLang.Json;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
            PipeFactory = _angular2SrcChange_detectionPipesPipe.PipeFactory;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Implements json transforms to any object.
             *
             * # Example
             *
             * In this example we transform the user object to json.
             *
             *  ```
             * @Component({
             *   selector: "user-cmp"
             * })
             * @View({
             *   template: "User: {{ user | json }}"
             * })
             * class Username {
             *  user:Object
             *  constructor() {
             *    this.user = { name: "PatrickJS" };
             *  }
             * }
             *
             * ```
             *
             * @exportedAs angular2/pipes
             */

            JsonPipe = (function (_Pipe) {
                function JsonPipe() {
                    _classCallCheck(this, JsonPipe);

                    _get(Object.getPrototypeOf(JsonPipe.prototype), "constructor", this).call(this);
                    this._latestRef = null;
                    this._latestValue = null;
                }

                _inherits(JsonPipe, _Pipe);

                _createClass(JsonPipe, [{
                    key: "onDestroy",
                    value: function onDestroy() {
                        if (isPresent(this._latestValue)) {
                            this._latestRef = null;
                            this._latestValue = null;
                        }
                    }
                }, {
                    key: "supports",
                    value: function supports(obj) {
                        return true;
                    }
                }, {
                    key: "transform",
                    value: function transform(value) {
                        if (value === this._latestRef) {
                            return this._latestValue;
                        } else {
                            return this._prettyPrint(value);
                        }
                    }
                }, {
                    key: "_prettyPrint",
                    value: function _prettyPrint(value) {
                        this._latestRef = value;
                        this._latestValue = Json.stringify(value);
                        return this._latestValue;
                    }
                }]);

                return JsonPipe;
            })(Pipe);

            _export("JsonPipe", JsonPipe);

            /**
             * Provides a factory for [JsonPipeFactory].
             *
             * @exportedAs angular2/pipes
             */

            JsonPipeFactory = (function (_PipeFactory) {
                var _class = function JsonPipeFactory() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                };

                _inherits(_class, _PipeFactory);

                _createClass(_class, [{
                    key: "supports",
                    value: function supports(obj) {
                        return true;
                    }
                }, {
                    key: "create",
                    value: function create(cdRef) {
                        return new JsonPipe();
                    }
                }]);

                return _class;
            })(PipeFactory);

            _export("JsonPipeFactory", JsonPipeFactory);

            _export("JsonPipeFactory", JsonPipeFactory = __decorate([CONST(), __metadata("design:paramtypes", [])], JsonPipeFactory));
            
        }
    };
});
System.register("angular2/src/core/annotations_impl/visibility", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/di/annotations_impl"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, CONST, isBlank, DependencyAnnotation, __decorate, __metadata, Visibility, Self, self, Parent, Ancestor, Unbounded;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
            isBlank = _angular2SrcFacadeLang.isBlank;
        }, function (_angular2SrcDiAnnotations_impl) {
            DependencyAnnotation = _angular2SrcDiAnnotations_impl.DependencyAnnotation;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Visibility = (function (_DependencyAnnotation) {
                var _class = function Visibility(depth, crossComponentBoundaries, _includeSelf) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this.depth = depth;
                    this.crossComponentBoundaries = crossComponentBoundaries;
                    this._includeSelf = _includeSelf;
                };

                _inherits(_class, _DependencyAnnotation);

                _createClass(_class, [{
                    key: "includeSelf",
                    get: function () {
                        return isBlank(this._includeSelf) ? false : this._includeSelf;
                    }
                }]);

                return _class;
            })(DependencyAnnotation);

            _export("Visibility", Visibility);

            _export("Visibility", Visibility = __decorate([CONST(), __metadata("design:paramtypes", [Number, Boolean, Boolean])], Visibility));
            /**
             * Specifies that an injector should retrieve a dependency from its element.
             *
             * ## Example
             *
             * Here is a simple directive that retrieves a dependency from its element.
             *
             * ```
             * @Directive({
             *   selector: '[dependency]',
             *   properties: [
             *     'id: dependency'
             *   ]
             * })
             * class Dependency {
             *   id:string;
             * }
             *
             *
             * @Directive({
             *   selector: '[my-directive]'
             * })
             * class Dependency {
             *   constructor(@Self() dependency:Dependency) {
             *     expect(dependency.id).toEqual(1);
             *   };
             * }
             * ```
             *
             * We use this with the following HTML template:
             *
             * ```
             *<div dependency="1" my-directive></div>
             * ```
             *
             * @exportedAs angular2/annotations
             */

            Self = (function (_Visibility) {
                var _class2 = function Self() {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, 0, false, true);
                };

                _inherits(_class2, _Visibility);

                return _class2;
            })(Visibility);

            _export("Self", Self);

            _export("Self", Self = __decorate([CONST(), __metadata("design:paramtypes", [])], Self));
            // make constants after switching to ts2dart
            self = new Self();

            _export("self", self);

            /**
             * Specifies that an injector should retrieve a dependency from the direct parent.
             *
             * ## Example
             *
             * Here is a simple directive that retrieves a dependency from its parent element.
             *
             * ```
             * @Directive({
             *   selector: '[dependency]',
             *   properties: [
             *     'id: dependency'
             *   ]
             * })
             * class Dependency {
             *   id:string;
             * }
             *
             *
             * @Directive({
             *   selector: '[my-directive]'
             * })
             * class Dependency {
             *   constructor(@Parent() dependency:Dependency) {
             *     expect(dependency.id).toEqual(1);
             *   };
             * }
             * ```
             *
             * We use this with the following HTML template:
             *
             * ```
             * <div dependency="1">
             *   <div dependency="2" my-directive></div>
             * </div>
             * ```
             * The `@Parent()` annotation in our constructor forces the injector to retrieve the dependency from
             * the
             * parent element (even thought the current element could resolve it): Angular injects
             * `dependency=1`.
             *
             * @exportedAs angular2/annotations
             */

            Parent = (function (_Visibility2) {
                var _class3 = function Parent() {
                    var _ref = arguments[0] === undefined ? {} : arguments[0];

                    var self = _ref.self;

                    _classCallCheck(this, _class3);

                    _get(Object.getPrototypeOf(_class3.prototype), "constructor", this).call(this, 1, false, self);
                };

                _inherits(_class3, _Visibility2);

                return _class3;
            })(Visibility);

            _export("Parent", Parent);

            _export("Parent", Parent = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Parent));
            /**
             * Specifies that an injector should retrieve a dependency from any ancestor element within the same
             * shadow boundary.
             *
             * An ancestor is any element between the parent element and shadow root.
             *
             *
             * ## Example
             *
             * Here is a simple directive that retrieves a dependency from an ancestor element.
             *
             * ```
             * @Directive({
             *   selector: '[dependency]',
             *   properties: [
             *     'id: dependency'
             *   ]
             * })
             * class Dependency {
             *   id:string;
             * }
             *
             *
             * @Directive({
             *   selector: '[my-directive]'
             * })
             * class Dependency {
             *   constructor(@Ancestor() dependency:Dependency) {
             *     expect(dependency.id).toEqual(2);
             *   };
             * }
             * ```
             *
             *  We use this with the following HTML template:
             *
             * ```
             * <div dependency="1">
             *   <div dependency="2">
             *     <div>
             *       <div dependency="3" my-directive></div>
             *     </div>
             *   </div>
             * </div>
             * ```
             *
             * The `@Ancestor()` annotation in our constructor forces the injector to retrieve the dependency
             * from the
             * nearest ancestor element:
             * - The current element `dependency="3"` is skipped because it is not an ancestor.
             * - Next parent has no directives `<div>`
             * - Next parent has the `Dependency` directive and so the dependency is satisfied.
             *
             * Angular injects `dependency=2`.
             *
             * @exportedAs angular2/annotations
             */

            Ancestor = (function (_Visibility3) {
                var _class4 = function Ancestor() {
                    var _ref2 = arguments[0] === undefined ? {} : arguments[0];

                    var self = _ref2.self;

                    _classCallCheck(this, _class4);

                    _get(Object.getPrototypeOf(_class4.prototype), "constructor", this).call(this, 999999, false, self);
                };

                _inherits(_class4, _Visibility3);

                return _class4;
            })(Visibility);

            _export("Ancestor", Ancestor);

            _export("Ancestor", Ancestor = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Ancestor));
            /**
             * Specifies that an injector should retrieve a dependency from any ancestor element.
             *
             * An ancestor is any element between the parent element and shadow root.
             *
             *
             * ## Example
             *
             * Here is a simple directive that retrieves a dependency from an ancestor element.
             *
             * ```
             * @Directive({
             *   selector: '[dependency]',
             *   properties: [
             *     'id: dependency'
             *   ]
             * })
             * class Dependency {
             *   id:string;
             * }
             *
             *
             * @Directive({
             *   selector: '[my-directive]'
             * })
             * class Dependency {
             *   constructor(@Unbounded() dependency:Dependency) {
             *     expect(dependency.id).toEqual(2);
             *   };
             * }
             * ```
             *
             * @exportedAs angular2/annotations
             */

            Unbounded = (function (_Visibility4) {
                var _class5 = function Unbounded() {
                    var _ref3 = arguments[0] === undefined ? {} : arguments[0];

                    var self = _ref3.self;

                    _classCallCheck(this, _class5);

                    _get(Object.getPrototypeOf(_class5.prototype), "constructor", this).call(this, 999999, true, self);
                };

                _inherits(_class5, _Visibility4);

                return _class5;
            })(Visibility);

            _export("Unbounded", Unbounded);

            _export("Unbounded", Unbounded = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Unbounded));
            
        }
    };
});
System.register("angular2/src/core/annotations_impl/view", ["npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang"], function (_export) {
    var _classCallCheck, CONST, __decorate, __metadata, View;

    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Declares the available HTML templates for an application.
             *
             * Each angular component requires a single `@Component` and at least one `@View` annotation. The
             * @View
             * annotation specifies the HTML template to use, and lists the directives that are active within
             * the template.
             *
             * When a component is instantiated, the template is loaded into the component's shadow root, and
             * the
             * expressions and statements in the template are evaluated against the component.
             *
             * For details on the `@Component` annotation, see {@link Component}.
             *
             * ## Example
             *
             * ```
             * @Component({
             *   selector: 'greet'
             * })
             * @View({
             *   template: 'Hello {{name}}!',
             *   directives: [GreetUser, Bold]
             * })
             * class Greet {
             *   name: string;
             *
             *   constructor() {
             *     this.name = 'World';
             *   }
             * }
             * ```
             *
             * @exportedAs angular2/annotations
             */

            View = (function () {
                var _class = function View() {
                    var _ref = arguments[0] === undefined ? {} : arguments[0];

                    var templateUrl = _ref.templateUrl;
                    var template = _ref.template;
                    var directives = _ref.directives;
                    var renderer = _ref.renderer;

                    _classCallCheck(this, _class);

                    this.templateUrl = templateUrl;
                    this.template = template;
                    this.directives = directives;
                    this.renderer = renderer;
                };

                return _class;
            })();

            _export("View", View);

            _export("View", View = __decorate([CONST(), __metadata("design:paramtypes", [Object])], View));
            
        }
    };
});
System.register('angular2/src/di/forward_ref', [], function (_export) {
    /**
     * Allows to refer to references which are not yet defined.
     *
     * This situation arises when the key which we need te refer to for the purposes of DI is declared,
     * but not yet defined.
     *
     * ## Example:
     *
     * ```
     * class Door {
     *   // Incorrect way to refer to a reference which is defined later.
     *   // This fails because `Lock` is undefined at this point.
     *   constructor(lock:Lock) { }
     *
     *   // Correct way to refer to a reference which is defined later.
     *   // The reference needs to be captured in a closure.
     *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }
     * }
     *
     * // Only at this point the lock is defined.
     * class Lock {
     * }
     * ```
     *
     * @exportedAs angular2/di
     */
    'use strict';

    var FORWARD_REF;

    _export('forwardRef', forwardRef);

    _export('resolveForwardRef', resolveForwardRef);

    function forwardRef(forwardRefFn) {
        forwardRefFn.__forward_ref__ = forwardRef;
        return forwardRefFn;
    }

    /**
     * Lazily retrieve the reference value.
     *
     * See: {@link forwardRef}
     *
     * @exportedAs angular2/di
     */

    function resolveForwardRef(type) {
        if (typeof type == 'function' && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
            return type();
        } else {
            return type;
        }
    }
    

    return {
        setters: [],
        execute: function () {
            FORWARD_REF = forwardRef;

            _export('FORWARD_REF', FORWARD_REF);
        }
    };
});
System.register("angular2/src/di/type_literal", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
  var _createClass, _classCallCheck, TypeLiteral;

  return {
    setters: [function (_npmBabelRuntime547HelpersCreateClass) {
      _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
    }, function (_npmBabelRuntime547HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
    }],
    execute: function () {
      /**
       * Type literals is a Dart-only feature. This is here only so we can x-compile
       * to multiple languages.
       */
      "use strict";

      TypeLiteral = (function () {
        function TypeLiteral() {
          _classCallCheck(this, TypeLiteral);
        }

        _createClass(TypeLiteral, [{
          key: "type",
          get: function () {
            throw new Error("Type literals are only supported in Dart");
          }
        }]);

        return TypeLiteral;
      })();

      _export("TypeLiteral", TypeLiteral);
    }
  };
});


System.register('angular2/src/di/exceptions', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, ListWrapper, stringify, BaseException, AbstractBindingError, NoBindingError, AsyncBindingError, CyclicDependencyError, InstantiationError, InvalidBindingError, NoAnnotationError;

    function findFirstClosedCycle(keys) {
        var res = [];
        for (var i = 0; i < keys.length; ++i) {
            if (ListWrapper.contains(res, keys[i])) {
                ListWrapper.push(res, keys[i]);
                return res;
            } else {
                ListWrapper.push(res, keys[i]);
            }
        }
        return res;
    }
    function constructResolvingPath(keys) {
        if (keys.length > 1) {
            var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
            var tokenStrs = ListWrapper.map(reversed, function (k) {
                return stringify(k.token);
            });
            return ' (' + tokenStrs.join(' -> ') + ')';
        } else {
            return '';
        }
    }
    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            stringify = _angular2SrcFacadeLang.stringify;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            'use strict';

            /**
             * Base class for all errors arising from misconfigured bindings.
             *
             * @exportedAs angular2/di_errors
             */

            AbstractBindingError = (function (_BaseException) {
                // TODO(tbosch): Can't do key:Key as this results in a circular dependency!

                function AbstractBindingError(key, constructResolvingMessage) {
                    _classCallCheck(this, AbstractBindingError);

                    _get(Object.getPrototypeOf(AbstractBindingError.prototype), 'constructor', this).call(this);
                    this.keys = [key];
                    this.constructResolvingMessage = constructResolvingMessage;
                    this.message = this.constructResolvingMessage(this.keys);
                }

                _inherits(AbstractBindingError, _BaseException);

                _createClass(AbstractBindingError, [{
                    key: 'addKey',

                    // TODO(tbosch): Can't do key:Key as this results in a circular dependency!
                    value: function addKey(key) {
                        ListWrapper.push(this.keys, key);
                        this.message = this.constructResolvingMessage(this.keys);
                    }
                }, {
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return AbstractBindingError;
            })(BaseException);

            _export('AbstractBindingError', AbstractBindingError);

            /**
             * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
             * {@link Injector} does not have a {@link Binding} for {@link Key}.
             *
             * @exportedAs angular2/di_errors
             */

            NoBindingError = (function (_AbstractBindingError) {
                // TODO(tbosch): Can't do key:Key as this results in a circular dependency!

                function NoBindingError(key) {
                    _classCallCheck(this, NoBindingError);

                    _get(Object.getPrototypeOf(NoBindingError.prototype), 'constructor', this).call(this, key, function (keys) {
                        var first = stringify(ListWrapper.first(keys).token);
                        return 'No provider for ' + first + '!' + constructResolvingPath(keys);
                    });
                }

                _inherits(NoBindingError, _AbstractBindingError);

                return NoBindingError;
            })(AbstractBindingError);

            _export('NoBindingError', NoBindingError);

            /**
             * Thrown when trying to retrieve an async {@link Binding} using the sync API.
             *
             * ## Example
             *
             * ```javascript
             * var injector = Injector.resolveAndCreate([
             *   bind(Number).toAsyncFactory(() => {
             *     return new Promise((resolve) => resolve(1 + 2));
             *   }),
             *   bind(String).toFactory((v) => { return "Value: " + v; }, [String])
             * ]);
             *
             * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));
             * expect(() => {
             *   injector.get(String);
             * }).toThrowError(AsycBindingError);
             * ```
             *
             * The above example throws because `String` depends on `Number` which is async. If any binding in
             * the dependency graph is async then the graph can only be retrieved using the `asyncGet` API.
             *
             * @exportedAs angular2/di_errors
             */

            AsyncBindingError = (function (_AbstractBindingError2) {
                // TODO(tbosch): Can't do key:Key as this results in a circular dependency!

                function AsyncBindingError(key) {
                    _classCallCheck(this, AsyncBindingError);

                    _get(Object.getPrototypeOf(AsyncBindingError.prototype), 'constructor', this).call(this, key, function (keys) {
                        var first = stringify(ListWrapper.first(keys).token);
                        return 'Cannot instantiate ' + first + ' synchronously. It is provided as a promise!' + constructResolvingPath(keys);
                    });
                }

                _inherits(AsyncBindingError, _AbstractBindingError2);

                return AsyncBindingError;
            })(AbstractBindingError);

            _export('AsyncBindingError', AsyncBindingError);

            /**
             * Thrown when dependencies form a cycle.
             *
             * ## Example:
             *
             * ```javascript
             * class A {
             *   constructor(b:B) {}
             * }
             * class B {
             *   constructor(a:A) {}
             * }
             * ```
             *
             * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
             *
             * @exportedAs angular2/di_errors
             */

            CyclicDependencyError = (function (_AbstractBindingError3) {
                // TODO(tbosch): Can't do key:Key as this results in a circular dependency!

                function CyclicDependencyError(key) {
                    _classCallCheck(this, CyclicDependencyError);

                    _get(Object.getPrototypeOf(CyclicDependencyError.prototype), 'constructor', this).call(this, key, function (keys) {
                        return 'Cannot instantiate cyclic dependency!' + constructResolvingPath(keys);
                    });
                }

                _inherits(CyclicDependencyError, _AbstractBindingError3);

                return CyclicDependencyError;
            })(AbstractBindingError);

            _export('CyclicDependencyError', CyclicDependencyError);

            /**
             * Thrown when a constructing type returns with an Error.
             *
             * The `InstantiationError` class contains the original error plus the dependency graph which caused
             * this object to be instantiated.
             *
             * @exportedAs angular2/di_errors
             */

            InstantiationError = (function (_AbstractBindingError4) {
                // TODO(tbosch): Can't do key:Key as this results in a circular dependency!

                function InstantiationError(cause, key) {
                    _classCallCheck(this, InstantiationError);

                    _get(Object.getPrototypeOf(InstantiationError.prototype), 'constructor', this).call(this, key, function (keys) {
                        var first = stringify(ListWrapper.first(keys).token);
                        return 'Error during instantiation of ' + first + '!' + constructResolvingPath(keys) + '. ORIGINAL ERROR: ' + cause;
                    });
                    this.cause = cause;
                    this.causeKey = key;
                }

                _inherits(InstantiationError, _AbstractBindingError4);

                return InstantiationError;
            })(AbstractBindingError);

            _export('InstantiationError', InstantiationError);

            /**
             * Thrown when an object other then {@link Binding} (or `Type`) is passed to {@link Injector}
             * creation.
             *
             * @exportedAs angular2/di_errors
             */

            InvalidBindingError = (function (_BaseException2) {
                function InvalidBindingError(binding) {
                    _classCallCheck(this, InvalidBindingError);

                    _get(Object.getPrototypeOf(InvalidBindingError.prototype), 'constructor', this).call(this);
                    this.message = 'Invalid binding - only instances of Binding and Type are allowed, got: ' + binding.toString();
                }

                _inherits(InvalidBindingError, _BaseException2);

                _createClass(InvalidBindingError, [{
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return InvalidBindingError;
            })(BaseException);

            _export('InvalidBindingError', InvalidBindingError);

            /**
             * Thrown when the class has no annotation information.
             *
             * Lack of annotation information prevents the {@link Injector} from determining which dependencies
             * need to be injected into the constructor.
             *
             * @exportedAs angular2/di_errors
             */

            NoAnnotationError = (function (_BaseException3) {
                function NoAnnotationError(typeOrFunc) {
                    _classCallCheck(this, NoAnnotationError);

                    _get(Object.getPrototypeOf(NoAnnotationError.prototype), 'constructor', this).call(this);
                    this.message = 'Cannot resolve all parameters for ' + stringify(typeOrFunc) + '. ' + 'Make sure they all have valid type or annotations.';
                }

                _inherits(NoAnnotationError, _BaseException3);

                _createClass(NoAnnotationError, [{
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return NoAnnotationError;
            })(BaseException);

            _export('NoAnnotationError', NoAnnotationError);
        }
    };
});


System.register("angular2/src/di/opaque_token", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, CONST, __decorate, __metadata, OpaqueToken;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             *
             *
             * @exportedAs angular2/di
             */

            OpaqueToken = (function () {
                var _class = function OpaqueToken(desc) {
                    _classCallCheck(this, _class);

                    this._desc = "Token(" + desc + ")";
                };

                _createClass(_class, [{
                    key: "toString",
                    value: function toString() {
                        return this._desc;
                    }
                }]);

                return _class;
            })();

            _export("OpaqueToken", OpaqueToken);

            _export("OpaqueToken", OpaqueToken = __decorate([CONST(), __metadata("design:paramtypes", [String])], OpaqueToken));
            
        }
    };
});
System.register('angular2/src/dom/dom_adapter', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, BaseException, isBlank, DOM, DomAdapter;

    function setRootDomAdapter(adapter) {
        if (isBlank(DOM)) {
            _export('DOM', DOM = adapter);
        }
    }

    function _abstract() {
        return new BaseException('This method is abstract');
    }
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
            isBlank = _angular2SrcFacadeLang.isBlank;
        }],
        execute: function () {
            'use strict';

            _export('setRootDomAdapter', setRootDomAdapter);

            _export('DOM', DOM);

            /**
             * Provides DOM operations in an environment-agnostic way.
             */

            DomAdapter = (function () {
                function DomAdapter() {
                    _classCallCheck(this, DomAdapter);
                }

                _createClass(DomAdapter, [{
                    key: 'logError',
                    value: function logError(error) {
                        throw _abstract();
                    }
                }, {
                    key: 'attrToPropMap',

                    /**
                     * Maps attribute names to their corresponding property names for cases
                     * where attribute name doesn't match property name.
                     */
                    get: function () {
                        throw _abstract();
                    }
                }, {
                    key: 'parse',
                    value: function parse(templateHtml) {
                        throw _abstract();
                    }
                }, {
                    key: 'query',
                    value: function query(selector) {
                        throw _abstract();
                    }
                }, {
                    key: 'querySelector',
                    value: function querySelector(el, selector) {
                        throw _abstract();
                    }
                }, {
                    key: 'querySelectorAll',
                    value: function querySelectorAll(el, selector) {
                        throw _abstract();
                    }
                }, {
                    key: 'on',
                    value: function on(el, evt, listener) {
                        throw _abstract();
                    }
                }, {
                    key: 'onAndCancel',
                    value: function onAndCancel(el, evt, listener) {
                        throw _abstract();
                    }
                }, {
                    key: 'dispatchEvent',
                    value: function dispatchEvent(el, evt) {
                        throw _abstract();
                    }
                }, {
                    key: 'createMouseEvent',
                    value: function createMouseEvent(eventType) {
                        throw _abstract();
                    }
                }, {
                    key: 'createEvent',
                    value: function createEvent(eventType) {
                        throw _abstract();
                    }
                }, {
                    key: 'preventDefault',
                    value: function preventDefault(evt) {
                        throw _abstract();
                    }
                }, {
                    key: 'getInnerHTML',
                    value: function getInnerHTML(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'getOuterHTML',
                    value: function getOuterHTML(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'nodeName',
                    value: function nodeName(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'nodeValue',
                    value: function nodeValue(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'type',
                    value: function type(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'content',
                    value: function content(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'firstChild',
                    value: function firstChild(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'nextSibling',
                    value: function nextSibling(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'parentElement',
                    value: function parentElement(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'childNodes',
                    value: function childNodes(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'childNodesAsList',
                    value: function childNodesAsList(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'clearNodes',
                    value: function clearNodes(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'appendChild',
                    value: function appendChild(el, node) {
                        throw _abstract();
                    }
                }, {
                    key: 'removeChild',
                    value: function removeChild(el, node) {
                        throw _abstract();
                    }
                }, {
                    key: 'replaceChild',
                    value: function replaceChild(el, newNode, oldNode) {
                        throw _abstract();
                    }
                }, {
                    key: 'remove',
                    value: function remove(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'insertBefore',
                    value: function insertBefore(el, node) {
                        throw _abstract();
                    }
                }, {
                    key: 'insertAllBefore',
                    value: function insertAllBefore(el, nodes) {
                        throw _abstract();
                    }
                }, {
                    key: 'insertAfter',
                    value: function insertAfter(el, node) {
                        throw _abstract();
                    }
                }, {
                    key: 'setInnerHTML',
                    value: function setInnerHTML(el, value) {
                        throw _abstract();
                    }
                }, {
                    key: 'getText',
                    value: function getText(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'setText',
                    value: function setText(el, value) {
                        throw _abstract();
                    }
                }, {
                    key: 'getValue',
                    value: function getValue(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'setValue',
                    value: function setValue(el, value) {
                        throw _abstract();
                    }
                }, {
                    key: 'getChecked',
                    value: function getChecked(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'setChecked',
                    value: function setChecked(el, value) {
                        throw _abstract();
                    }
                }, {
                    key: 'createTemplate',
                    value: function createTemplate(html) {
                        throw _abstract();
                    }
                }, {
                    key: 'createElement',
                    value: function createElement(tagName) {
                        var doc = arguments[1] === undefined ? null : arguments[1];
                        throw _abstract();
                    }
                }, {
                    key: 'createTextNode',
                    value: function createTextNode(text) {
                        var doc = arguments[1] === undefined ? null : arguments[1];
                        throw _abstract();
                    }
                }, {
                    key: 'createScriptTag',
                    value: function createScriptTag(attrName, attrValue) {
                        var doc = arguments[2] === undefined ? null : arguments[2];
                        throw _abstract();
                    }
                }, {
                    key: 'createStyleElement',
                    value: function createStyleElement(css) {
                        var doc = arguments[1] === undefined ? null : arguments[1];
                        throw _abstract();
                    }
                }, {
                    key: 'createShadowRoot',
                    value: function createShadowRoot(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'getShadowRoot',
                    value: function getShadowRoot(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'getHost',
                    value: function getHost(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'getDistributedNodes',
                    value: function getDistributedNodes(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'clone',
                    value: function clone(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'hasProperty',
                    value: function hasProperty(element, name) {
                        throw _abstract();
                    }
                }, {
                    key: 'getElementsByClassName',
                    value: function getElementsByClassName(element, name) {
                        throw _abstract();
                    }
                }, {
                    key: 'getElementsByTagName',
                    value: function getElementsByTagName(element, name) {
                        throw _abstract();
                    }
                }, {
                    key: 'classList',
                    value: function classList(element) {
                        throw _abstract();
                    }
                }, {
                    key: 'addClass',
                    value: function addClass(element, classname) {
                        throw _abstract();
                    }
                }, {
                    key: 'removeClass',
                    value: function removeClass(element, classname) {
                        throw _abstract();
                    }
                }, {
                    key: 'hasClass',
                    value: function hasClass(element, classname) {
                        throw _abstract();
                    }
                }, {
                    key: 'setStyle',
                    value: function setStyle(element, stylename, stylevalue) {
                        throw _abstract();
                    }
                }, {
                    key: 'removeStyle',
                    value: function removeStyle(element, stylename) {
                        throw _abstract();
                    }
                }, {
                    key: 'getStyle',
                    value: function getStyle(element, stylename) {
                        throw _abstract();
                    }
                }, {
                    key: 'tagName',
                    value: function tagName(element) {
                        throw _abstract();
                    }
                }, {
                    key: 'attributeMap',
                    value: function attributeMap(element) {
                        throw _abstract();
                    }
                }, {
                    key: 'hasAttribute',
                    value: function hasAttribute(element, attribute) {
                        throw _abstract();
                    }
                }, {
                    key: 'getAttribute',
                    value: function getAttribute(element, attribute) {
                        throw _abstract();
                    }
                }, {
                    key: 'setAttribute',
                    value: function setAttribute(element, name, value) {
                        throw _abstract();
                    }
                }, {
                    key: 'removeAttribute',
                    value: function removeAttribute(element, attribute) {
                        throw _abstract();
                    }
                }, {
                    key: 'templateAwareRoot',
                    value: function templateAwareRoot(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'createHtmlDocument',
                    value: function createHtmlDocument() {
                        throw _abstract();
                    }
                }, {
                    key: 'defaultDoc',
                    value: function defaultDoc() {
                        throw _abstract();
                    }
                }, {
                    key: 'getBoundingClientRect',
                    value: function getBoundingClientRect(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'getTitle',
                    value: function getTitle() {
                        throw _abstract();
                    }
                }, {
                    key: 'setTitle',
                    value: function setTitle(newTitle) {
                        throw _abstract();
                    }
                }, {
                    key: 'elementMatches',
                    value: function elementMatches(n, selector) {
                        throw _abstract();
                    }
                }, {
                    key: 'isTemplateElement',
                    value: function isTemplateElement(el) {
                        throw _abstract();
                    }
                }, {
                    key: 'isTextNode',
                    value: function isTextNode(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'isCommentNode',
                    value: function isCommentNode(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'isElementNode',
                    value: function isElementNode(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'hasShadowRoot',
                    value: function hasShadowRoot(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'isShadowRoot',
                    value: function isShadowRoot(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'importIntoDoc',
                    value: function importIntoDoc(node) {
                        throw _abstract();
                    }
                }, {
                    key: 'isPageRule',
                    value: function isPageRule(rule) {
                        throw _abstract();
                    }
                }, {
                    key: 'isStyleRule',
                    value: function isStyleRule(rule) {
                        throw _abstract();
                    }
                }, {
                    key: 'isMediaRule',
                    value: function isMediaRule(rule) {
                        throw _abstract();
                    }
                }, {
                    key: 'isKeyframesRule',
                    value: function isKeyframesRule(rule) {
                        throw _abstract();
                    }
                }, {
                    key: 'getHref',
                    value: function getHref(element) {
                        throw _abstract();
                    }
                }, {
                    key: 'getEventKey',
                    value: function getEventKey(event) {
                        throw _abstract();
                    }
                }, {
                    key: 'resolveAndSetHref',
                    value: function resolveAndSetHref(element, baseUrl, href) {
                        throw _abstract();
                    }
                }, {
                    key: 'cssToRules',
                    value: function cssToRules(css) {
                        throw _abstract();
                    }
                }, {
                    key: 'supportsDOMEvents',
                    value: function supportsDOMEvents() {
                        throw _abstract();
                    }
                }, {
                    key: 'supportsNativeShadowDOM',
                    value: function supportsNativeShadowDOM() {
                        throw _abstract();
                    }
                }, {
                    key: 'getGlobalEventTarget',
                    value: function getGlobalEventTarget(target) {
                        throw _abstract();
                    }
                }, {
                    key: 'getHistory',
                    value: function getHistory() {
                        throw _abstract();
                    }
                }, {
                    key: 'getLocation',
                    value: function getLocation() {
                        throw _abstract();
                    }
                }, {
                    key: 'getBaseHref',
                    value: function getBaseHref() {
                        throw _abstract();
                    }
                }, {
                    key: 'getUserAgent',
                    value: function getUserAgent() {
                        throw _abstract();
                    }
                }, {
                    key: 'setData',
                    value: function setData(element, name, value) {
                        throw _abstract();
                    }
                }, {
                    key: 'getData',
                    value: function getData(element, name) {
                        throw _abstract();
                    }
                }, {
                    key: 'setGlobalVar',
                    value: function setGlobalVar(name, value) {
                        throw _abstract();
                    }
                }]);

                return DomAdapter;
            })();

            _export('DomAdapter', DomAdapter);
        }
    };
});


System.register('angular2/src/dom/generic_browser_adapter', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/dom/dom_adapter'], function (_export) {
    var _inherits, _createClass, _classCallCheck, ListWrapper, isPresent, isFunction, DomAdapter, GenericBrowserDomAdapter;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isFunction = _angular2SrcFacadeLang.isFunction;
        }, function (_angular2SrcDomDom_adapter) {
            DomAdapter = _angular2SrcDomDom_adapter.DomAdapter;
        }],
        execute: function () {
            'use strict';

            /**
             * Provides DOM operations in any browser environment.
             */

            GenericBrowserDomAdapter = (function (_DomAdapter) {
                function GenericBrowserDomAdapter() {
                    _classCallCheck(this, GenericBrowserDomAdapter);

                    if (_DomAdapter != null) {
                        _DomAdapter.apply(this, arguments);
                    }
                }

                _inherits(GenericBrowserDomAdapter, _DomAdapter);

                _createClass(GenericBrowserDomAdapter, [{
                    key: 'getDistributedNodes',
                    value: function getDistributedNodes(el) {
                        return el.getDistributedNodes();
                    }
                }, {
                    key: 'resolveAndSetHref',
                    value: function resolveAndSetHref(el, baseUrl, href) {
                        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
                    }
                }, {
                    key: 'cssToRules',
                    value: function cssToRules(css) {
                        var style = this.createStyleElement(css);
                        this.appendChild(this.defaultDoc().head, style);
                        var rules = ListWrapper.create();
                        if (isPresent(style.sheet)) {
                            // TODO(sorvell): Firefox throws when accessing the rules of a stylesheet
                            // with an @import
                            // https://bugzilla.mozilla.org/show_bug.cgi?id=625013
                            try {
                                var rawRules = style.sheet.cssRules;
                                rules = ListWrapper.createFixedSize(rawRules.length);
                                for (var i = 0; i < rawRules.length; i++) {
                                    rules[i] = rawRules[i];
                                }
                            } catch (e) {}
                        } else {}
                        this.remove(style);
                        return rules;
                    }
                }, {
                    key: 'supportsDOMEvents',
                    value: function supportsDOMEvents() {
                        return true;
                    }
                }, {
                    key: 'supportsNativeShadowDOM',
                    value: function supportsNativeShadowDOM() {
                        return isFunction(this.defaultDoc().body.createShadowRoot);
                    }
                }]);

                return GenericBrowserDomAdapter;
            })(DomAdapter);

            _export('GenericBrowserDomAdapter', GenericBrowserDomAdapter);
        }
    };
});


System.register("angular2/src/core/compiler/directive_resolver", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/core/annotations_impl/annotations", "angular2/src/reflection/reflection"], function (_export) {
    var _createClass, _classCallCheck, resolveForwardRef, Injectable, isPresent, BaseException, stringify, Directive, reflector, __decorate, __metadata, DirectiveResolver;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            resolveForwardRef = _angular2Di.resolveForwardRef;
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
            stringify = _angular2SrcFacadeLang.stringify;
        }, function (_angular2SrcCoreAnnotations_implAnnotations) {
            Directive = _angular2SrcCoreAnnotations_implAnnotations.Directive;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            DirectiveResolver = (function () {
                var _class = function DirectiveResolver() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "resolve",
                    value: function resolve(type) {
                        var annotations = reflector.annotations(resolveForwardRef(type));
                        if (isPresent(annotations)) {
                            for (var i = 0; i < annotations.length; i++) {
                                var annotation = annotations[i];
                                if (annotation instanceof Directive) {
                                    return annotation;
                                }
                            }
                        }
                        throw new BaseException("No Directive annotation found on " + stringify(type));
                    }
                }]);

                return _class;
            })();

            _export("DirectiveResolver", DirectiveResolver);

            _export("DirectiveResolver", DirectiveResolver = __decorate([Injectable(), __metadata("design:paramtypes", [])], DirectiveResolver));
            
        }
    };
});
System.register('angular2/src/core/compiler/view_ref', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, isPresent, ViewRef, ProtoViewRef;

    // This is a workaround for privacy in Dart as we don't have library parts

    function internalView(viewRef) {
        return viewRef._view;
    }

    // This is a workaround for privacy in Dart as we don't have library parts

    function internalProtoView(protoViewRef) {
        return isPresent(protoViewRef) ? protoViewRef._protoView : null;
    }

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {
            'use strict';

            _export('internalView', internalView);

            _export('internalProtoView', internalProtoView);

            /**
             * @exportedAs angular2/view
             */

            ViewRef = (function () {
                function ViewRef(view) {
                    _classCallCheck(this, ViewRef);

                    this._view = view;
                }

                _createClass(ViewRef, [{
                    key: 'render',
                    get: function () {
                        return this._view.render;
                    }
                }, {
                    key: 'setLocal',
                    value: function setLocal(contextName, value) {
                        this._view.setLocal(contextName, value);
                    }
                }]);

                return ViewRef;
            })();

            _export('ViewRef', ViewRef);

            /**
             * @exportedAs angular2/view
             */

            ProtoViewRef = function ProtoViewRef(protoView) {
                _classCallCheck(this, ProtoViewRef);

                this._protoView = protoView;
            };

            _export('ProtoViewRef', ProtoViewRef);
        }
    };
});


System.register("angular2/src/core/annotations_impl/di", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/di/annotations_impl"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, CONST, DependencyAnnotation, __decorate, __metadata, Attribute, Query;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
        }, function (_angular2SrcDiAnnotations_impl) {
            DependencyAnnotation = _angular2SrcDiAnnotations_impl.DependencyAnnotation;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Specifies that a constant attribute value should be injected.
             *
             * The directive can inject constant string literals of host element attributes.
             *
             * ## Example
             *
             * Suppose we have an `<input>` element and want to know its `type`.
             *
             * ```html
             * <input type="text">
             * ```
             *
             * A decorator can inject string literal `text` like so:
             *
             * ```javascript
             * @Directive({
             *   selector: `input'
             * })
             * class InputDirective {
             *   constructor(@Attribute('type') type) {
             *     // type would be `text` in this example
             *   }
             * }
             * ```
             *
             * @exportedAs angular2/annotations
             */

            Attribute = (function (_DependencyAnnotation) {
                var _class = function Attribute(attributeName) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this.attributeName = attributeName;
                };

                _inherits(_class, _DependencyAnnotation);

                _createClass(_class, [{
                    key: "token",
                    get: function () {
                        // Normally one would default a token to a type of an injected value but here
                        // the type of a variable is "string" and we can't use primitive type as a return value
                        // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
                        // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
                        // account.
                        return this;
                    }
                }]);

                return _class;
            })(DependencyAnnotation);

            _export("Attribute", Attribute);

            _export("Attribute", Attribute = __decorate([CONST(), __metadata("design:paramtypes", [String])], Attribute));
            /**
             * Specifies that a {@link QueryList} should be injected.
             *
             * See {@link QueryList} for usage and example.
             *
             * @exportedAs angular2/annotations
             */

            Query = (function (_DependencyAnnotation2) {
                var _class2 = function Query(directive) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this);
                    this.directive = directive;
                };

                _inherits(_class2, _DependencyAnnotation2);

                return _class2;
            })(DependencyAnnotation);

            _export("Query", Query);

            _export("Query", Query = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Query));
            
        }
    };
});
System.register('angular2/src/render/api', ['npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/create-class', 'angular2/src/facade/lang'], function (_export) {
  var _classCallCheck, _createClass, isPresent, EventBinding, ElementBinder, DirectiveBinder, ProtoViewDto, DirectiveMetadata, RenderProtoViewRef, RenderViewRef, ViewDefinition, RenderCompiler, Renderer;

  return {
    setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
    }, function (_npmBabelRuntime547HelpersCreateClass) {
      _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
    }, function (_angular2SrcFacadeLang) {
      isPresent = _angular2SrcFacadeLang.isPresent;
    }],
    execute: function () {
      'use strict';

      /**
       * General notes:
       *
       * The methods for creating / destroying views in this API are used in the AppViewHydrator
       * and RenderViewHydrator as well.
       *
       * We are already parsing expressions on the render side:
       * - this makes the ElementBinders more compact
       *   (e.g. no need to distinguish interpolations from regular expressions from literals)
       * - allows to retrieve which properties should be accessed from the event
       *   by looking at the expression
       * - we need the parse at least for the `template` attribute to match
       *   directives in it
       * - render compiler is not on the critical path as
       *   its output will be stored in precompiled templates.
       */

      EventBinding = function EventBinding(fullName, source) {
        _classCallCheck(this, EventBinding);

        this.fullName = fullName;
        this.source = source;
      };

      _export('EventBinding', EventBinding);

      ElementBinder = function ElementBinder() {
        var _ref = arguments[0] === undefined ? {} : arguments[0];

        var index = _ref.index;
        var parentIndex = _ref.parentIndex;
        var distanceToParent = _ref.distanceToParent;
        var directives = _ref.directives;
        var nestedProtoView = _ref.nestedProtoView;
        var propertyBindings = _ref.propertyBindings;
        var variableBindings = _ref.variableBindings;
        var eventBindings = _ref.eventBindings;
        var textBindings = _ref.textBindings;
        var readAttributes = _ref.readAttributes;

        _classCallCheck(this, ElementBinder);

        this.index = index;
        this.parentIndex = parentIndex;
        this.distanceToParent = distanceToParent;
        this.directives = directives;
        this.nestedProtoView = nestedProtoView;
        this.propertyBindings = propertyBindings;
        this.variableBindings = variableBindings;
        this.eventBindings = eventBindings;
        this.textBindings = textBindings;
        this.readAttributes = readAttributes;
      };

      _export('ElementBinder', ElementBinder);

      DirectiveBinder = function DirectiveBinder(_ref2) {
        var directiveIndex = _ref2.directiveIndex;
        var propertyBindings = _ref2.propertyBindings;
        var eventBindings = _ref2.eventBindings;
        var hostPropertyBindings = _ref2.hostPropertyBindings;

        _classCallCheck(this, DirectiveBinder);

        this.directiveIndex = directiveIndex;
        this.propertyBindings = propertyBindings;
        this.eventBindings = eventBindings;
        this.hostPropertyBindings = hostPropertyBindings;
      };

      _export('DirectiveBinder', DirectiveBinder);

      ProtoViewDto = (function () {
        function ProtoViewDto(_ref3) {
          var render = _ref3.render;
          var elementBinders = _ref3.elementBinders;
          var variableBindings = _ref3.variableBindings;
          var type = _ref3.type;

          _classCallCheck(this, ProtoViewDto);

          this.render = render;
          this.elementBinders = elementBinders;
          this.variableBindings = variableBindings;
          this.type = type;
        }

        _createClass(ProtoViewDto, null, [{
          key: 'HOST_VIEW_TYPE',

          // A view that contains the host element with bound
          // component directive.
          // Contains a view of type #COMPONENT_VIEW_TYPE.
          get: function () {
            return 0;
          }
        }, {
          key: 'COMPONENT_VIEW_TYPE',

          // The view of the component
          // Can contain 0 to n views of type #EMBEDDED_VIEW_TYPE
          get: function () {
            return 1;
          }
        }, {
          key: 'EMBEDDED_VIEW_TYPE',

          // A view that is embedded into another View via a <template> element
          // inside of a component view
          get: function () {
            return 2;
          }
        }]);

        return ProtoViewDto;
      })();

      _export('ProtoViewDto', ProtoViewDto);

      DirectiveMetadata = (function () {
        function DirectiveMetadata(_ref4) {
          var id = _ref4.id;
          var selector = _ref4.selector;
          var compileChildren = _ref4.compileChildren;
          var events = _ref4.events;
          var hostListeners = _ref4.hostListeners;
          var hostProperties = _ref4.hostProperties;
          var hostAttributes = _ref4.hostAttributes;
          var hostActions = _ref4.hostActions;
          var properties = _ref4.properties;
          var readAttributes = _ref4.readAttributes;
          var type = _ref4.type;
          var callOnDestroy = _ref4.callOnDestroy;
          var callOnChange = _ref4.callOnChange;
          var callOnCheck = _ref4.callOnCheck;
          var callOnInit = _ref4.callOnInit;
          var callOnAllChangesDone = _ref4.callOnAllChangesDone;
          var changeDetection = _ref4.changeDetection;

          _classCallCheck(this, DirectiveMetadata);

          this.id = id;
          this.selector = selector;
          this.compileChildren = isPresent(compileChildren) ? compileChildren : true;
          this.events = events;
          this.hostListeners = hostListeners;
          this.hostProperties = hostProperties;
          this.hostAttributes = hostAttributes;
          this.hostActions = hostActions;
          this.properties = properties;
          this.readAttributes = readAttributes;
          this.type = type;
          this.callOnDestroy = callOnDestroy;
          this.callOnChange = callOnChange;
          this.callOnCheck = callOnCheck;
          this.callOnInit = callOnInit;
          this.callOnAllChangesDone = callOnAllChangesDone;
          this.changeDetection = changeDetection;
        }

        _createClass(DirectiveMetadata, null, [{
          key: 'DIRECTIVE_TYPE',
          get: function () {
            return 0;
          }
        }, {
          key: 'COMPONENT_TYPE',
          get: function () {
            return 1;
          }
        }]);

        return DirectiveMetadata;
      })();

      _export('DirectiveMetadata', DirectiveMetadata);

      // An opaque reference to a DomProtoView

      RenderProtoViewRef = function RenderProtoViewRef() {
        _classCallCheck(this, RenderProtoViewRef);
      };

      _export('RenderProtoViewRef', RenderProtoViewRef);

      // An opaque reference to a DomView

      RenderViewRef = function RenderViewRef() {
        _classCallCheck(this, RenderViewRef);
      };

      _export('RenderViewRef', RenderViewRef);

      ViewDefinition = function ViewDefinition(_ref5) {
        var componentId = _ref5.componentId;
        var absUrl = _ref5.absUrl;
        var template = _ref5.template;
        var directives = _ref5.directives;

        _classCallCheck(this, ViewDefinition);

        this.componentId = componentId;
        this.absUrl = absUrl;
        this.template = template;
        this.directives = directives;
      };

      _export('ViewDefinition', ViewDefinition);

      RenderCompiler = (function () {
        function RenderCompiler() {
          _classCallCheck(this, RenderCompiler);
        }

        _createClass(RenderCompiler, [{
          key: 'compileHost',

          /**
           * Creats a ProtoViewDto that contains a single nested component with the given componentId.
           */
          value: function compileHost(directiveMetadata) {
            return null;
          }
        }, {
          key: 'compile',

          /**
           * Compiles a single DomProtoView. Non recursive so that
           * we don't need to serialize all possible components over the wire,
           * but only the needed ones based on previous calls.
           */
          value: function compile(template) {
            return null;
          }
        }]);

        return RenderCompiler;
      })();

      _export('RenderCompiler', RenderCompiler);

      Renderer = (function () {
        function Renderer() {
          _classCallCheck(this, Renderer);
        }

        _createClass(Renderer, [{
          key: 'createRootHostView',

          /**
           * Creates a root host view that includes the given element.
           * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type
           * ProtoViewDto.HOST_VIEW_TYPE
           * @param {any} hostElementSelector css selector for the host element (will be queried against the
           * main document)
           * @return {RenderViewRef} the created view
           */
          value: function createRootHostView(hostProtoViewRef, hostElementSelector) {
            return null;
          }
        }, {
          key: 'detachFreeHostView',

          /**
           * Detaches a free host view's element from the DOM.
           */
          value: function detachFreeHostView(parentHostViewRef, hostViewRef) {}
        }, {
          key: 'createView',

          /**
           * Creates a regular view out of the given ProtoView
           */
          value: function createView(protoViewRef) {
            return null;
          }
        }, {
          key: 'destroyView',

          /**
           * Destroys the given view after it has been dehydrated and detached
           */
          value: function destroyView(viewRef) {}
        }, {
          key: 'attachComponentView',

          /**
           * Attaches a componentView into the given hostView at the given element
           */
          value: function attachComponentView(hostViewRef, elementIndex, componentViewRef) {}
        }, {
          key: 'detachComponentView',

          /**
           * Detaches a componentView into the given hostView at the given element
           */
          value: function detachComponentView(hostViewRef, boundElementIndex, componentViewRef) {}
        }, {
          key: 'attachViewInContainer',

          /**
           * Attaches a view into a ViewContainer (in the given parentView at the given element) at the
           * given index.
           */
          value: function attachViewInContainer(parentViewRef, boundElementIndex, atIndex, viewRef) {}
        }, {
          key: 'detachViewInContainer',

          /**
           * Detaches a view into a ViewContainer (in the given parentView at the given element) at the
           * given index.
           */
          // TODO(tbosch): this should return a promise as it can be animated!
          value: function detachViewInContainer(parentViewRef, boundElementIndex, atIndex, viewRef) {}
        }, {
          key: 'hydrateView',

          /**
           * Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views
           * inside of the view pool.
           */
          value: function hydrateView(viewRef) {}
        }, {
          key: 'dehydrateView',

          /**
           * Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views
           * inside of the view pool.
           */
          value: function dehydrateView(viewRef) {}
        }, {
          key: 'setElementProperty',

          /**
           * Sets a property on an element.
           * Note: This will fail if the property was not mentioned previously as a host property
           * in the ProtoView
           */
          value: function setElementProperty(viewRef, elementIndex, propertyName, propertyValue) {}
        }, {
          key: 'callAction',

          /**
           * Calls an action.
           * Note: This will fail if the action was not mentioned previously as a host action
           * in the ProtoView
           */
          value: function callAction(viewRef, elementIndex, actionExpression, actionArgs) {}
        }, {
          key: 'setText',

          /**
           * Sets the value of a text node.
           */
          value: function setText(viewRef, textNodeIndex, text) {}
        }, {
          key: 'setEventDispatcher',

          /**
           * Sets the dispatcher for all events of the given view
           */
          value: function setEventDispatcher(viewRef, dispatcher) {}
        }]);

        return Renderer;
      })();

      _export('Renderer', Renderer);
    }
  };
});


System.register('angular2/src/core/compiler/element_binder', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, isBlank, isPresent, BaseException, ElementBinder;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            'use strict';

            ElementBinder = (function () {
                function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective) {
                    _classCallCheck(this, ElementBinder);

                    this.index = index;
                    this.parent = parent;
                    this.distanceToParent = distanceToParent;
                    this.protoElementInjector = protoElementInjector;
                    this.componentDirective = componentDirective;
                    if (isBlank(index)) {
                        throw new BaseException('null index not allowed.');
                    }
                    // updated later when events are bound
                    this.hostListeners = null;
                    // updated later, so we are able to resolve cycles
                    this.nestedProtoView = null;
                }

                _createClass(ElementBinder, [{
                    key: 'hasStaticComponent',
                    value: function hasStaticComponent() {
                        return isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
                    }
                }, {
                    key: 'hasDynamicComponent',
                    value: function hasDynamicComponent() {
                        return isPresent(this.componentDirective) && isBlank(this.nestedProtoView);
                    }
                }, {
                    key: 'hasEmbeddedProtoView',
                    value: function hasEmbeddedProtoView() {
                        return !isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
                    }
                }]);

                return ElementBinder;
            })();

            _export('ElementBinder', ElementBinder);
        }
    };
});


System.register("angular2/src/core/compiler/view_pool", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, Inject, Injectable, OpaqueToken, ListWrapper, MapWrapper, isPresent, isBlank, CONST_EXPR, __decorate, __metadata, __param, APP_VIEW_POOL_CAPACITY, AppViewPool;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Inject = _angular2Di.Inject;
            Injectable = _angular2Di.Injectable;
            OpaqueToken = _angular2Di.OpaqueToken;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            APP_VIEW_POOL_CAPACITY = CONST_EXPR(new OpaqueToken("AppViewPool.viewPoolCapacity"));

            _export("APP_VIEW_POOL_CAPACITY", APP_VIEW_POOL_CAPACITY);

            AppViewPool = (function () {
                var _class = function AppViewPool(poolCapacityPerProtoView) {
                    _classCallCheck(this, _class);

                    this._poolCapacityPerProtoView = poolCapacityPerProtoView;
                    this._pooledViewsPerProtoView = MapWrapper.create();
                };

                _createClass(_class, [{
                    key: "getView",
                    value: function getView(protoView) {
                        var pooledViews = MapWrapper.get(this._pooledViewsPerProtoView, protoView);
                        if (isPresent(pooledViews) && pooledViews.length > 0) {
                            return ListWrapper.removeLast(pooledViews);
                        }
                        return null;
                    }
                }, {
                    key: "returnView",
                    value: function returnView(view) {
                        var protoView = view.proto;
                        var pooledViews = MapWrapper.get(this._pooledViewsPerProtoView, protoView);
                        if (isBlank(pooledViews)) {
                            pooledViews = [];
                            MapWrapper.set(this._pooledViewsPerProtoView, protoView, pooledViews);
                        }
                        var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
                        if (haveRemainingCapacity) {
                            ListWrapper.push(pooledViews, view);
                        }
                        return haveRemainingCapacity;
                    }
                }]);

                return _class;
            })();

            _export("AppViewPool", AppViewPool);

            _export("AppViewPool", AppViewPool = __decorate([Injectable(), __param(0, Inject(APP_VIEW_POOL_CAPACITY)), __metadata("design:paramtypes", [Object])], AppViewPool));
            
        }
    };
});
System.register("angular2/src/core/compiler/view_listener", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di"], function (_export) {
    var _createClass, _classCallCheck, Injectable, __decorate, __metadata, AppViewListener;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Listener for view creation / destruction.
             */

            AppViewListener = (function () {
                var _class = function AppViewListener() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "viewCreated",
                    value: function viewCreated(view) {}
                }, {
                    key: "viewDestroyed",
                    value: function viewDestroyed(view) {}
                }]);

                return _class;
            })();

            _export("AppViewListener", AppViewListener);

            _export("AppViewListener", AppViewListener = __decorate([Injectable(), __metadata("design:paramtypes", [])], AppViewListener));
            
        }
    };
});
System.register('angular2/src/core/compiler/view_container_ref', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/core/compiler/view_ref'], function (_export) {
    var _createClass, _classCallCheck, ListWrapper, isPresent, ViewRef, internalView, ViewContainerRef;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcCoreCompilerView_ref) {
            ViewRef = _angular2SrcCoreCompilerView_ref.ViewRef;
            internalView = _angular2SrcCoreCompilerView_ref.internalView;
        }],
        execute: function () {
            'use strict';

            /**
             * @exportedAs angular2/core
             */

            ViewContainerRef = (function () {
                function ViewContainerRef(viewManager, element) {
                    _classCallCheck(this, ViewContainerRef);

                    this.viewManager = viewManager;
                    this.element = element;
                }

                _createClass(ViewContainerRef, [{
                    key: '_getViews',
                    value: function _getViews() {
                        var vc = internalView(this.element.parentView).viewContainers[this.element.boundElementIndex];
                        return isPresent(vc) ? vc.views : [];
                    }
                }, {
                    key: 'clear',
                    value: function clear() {
                        for (var i = this.length - 1; i >= 0; i--) {
                            this.remove(i);
                        }
                    }
                }, {
                    key: 'get',
                    value: function get(index) {
                        return new ViewRef(this._getViews()[index]);
                    }
                }, {
                    key: 'length',
                    get: function () {
                        return this._getViews().length;
                    }
                }, {
                    key: 'create',

                    // TODO(rado): profile and decide whether bounds checks should be added
                    // to the methods below.
                    value: function create() {
                        var protoViewRef = arguments[0] === undefined ? null : arguments[0];
                        var atIndex = arguments[1] === undefined ? -1 : arguments[1];
                        var context = arguments[2] === undefined ? null : arguments[2];
                        var injector = arguments[3] === undefined ? null : arguments[3];

                        if (atIndex == -1) atIndex = this.length;
                        return this.viewManager.createViewInContainer(this.element, atIndex, protoViewRef, context, injector);
                    }
                }, {
                    key: 'insert',
                    value: function insert(viewRef) {
                        var atIndex = arguments[1] === undefined ? -1 : arguments[1];

                        if (atIndex == -1) atIndex = this.length;
                        return this.viewManager.attachViewInContainer(this.element, atIndex, viewRef);
                    }
                }, {
                    key: 'indexOf',
                    value: function indexOf(viewRef) {
                        return ListWrapper.indexOf(this._getViews(), internalView(viewRef));
                    }
                }, {
                    key: 'remove',
                    value: function remove() {
                        var atIndex = arguments[0] === undefined ? -1 : arguments[0];

                        if (atIndex == -1) atIndex = this.length - 1;
                        this.viewManager.destroyViewInContainer(this.element, atIndex);
                        // view is intentionally not returned to the client.
                    }
                }, {
                    key: 'detach',

                    /**
                     * The method can be used together with insert to implement a view move, i.e.
                     * moving the dom nodes while the directives in the view stay intact.
                     */
                    value: function detach() {
                        var atIndex = arguments[0] === undefined ? -1 : arguments[0];

                        if (atIndex == -1) atIndex = this.length - 1;
                        return this.viewManager.detachViewInContainer(this.element, atIndex);
                    }
                }]);

                return ViewContainerRef;
            })();

            _export('ViewContainerRef', ViewContainerRef);
        }
    };
});


System.register('angular2/src/render/dom/view/view', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/create-class', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/collection', 'angular2/change_detection', 'angular2/src/facade/lang', 'angular2/src/render/api'], function (_export) {
    var _inherits, _get, _classCallCheck, _createClass, DOM, ListWrapper, MapWrapper, Locals, isPresent, RenderViewRef, DomViewRef, NG_BINDING_CLASS, DomView;

    function resolveInternalDomView(viewRef) {
        return viewRef._view;
    }

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2Change_detection) {
            Locals = _angular2Change_detection.Locals;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcRenderApi) {
            RenderViewRef = _angular2SrcRenderApi.RenderViewRef;
        }],
        execute: function () {
            'use strict';

            _export('resolveInternalDomView', resolveInternalDomView);

            DomViewRef = (function (_RenderViewRef) {
                function DomViewRef(view) {
                    _classCallCheck(this, DomViewRef);

                    _get(Object.getPrototypeOf(DomViewRef.prototype), 'constructor', this).call(this);
                    this._view = view;
                }

                _inherits(DomViewRef, _RenderViewRef);

                return DomViewRef;
            })(RenderViewRef);

            _export('DomViewRef', DomViewRef);

            NG_BINDING_CLASS = 'ng-binding';

            /**
             * Const of making objects: http://jsperf.com/instantiate-size-of-object
             */

            DomView = (function () {
                function DomView(proto, rootNodes, boundTextNodes, boundElements, contentTags) {
                    _classCallCheck(this, DomView);

                    this.proto = proto;
                    this.rootNodes = rootNodes;
                    this.boundTextNodes = boundTextNodes;
                    this.boundElements = boundElements;
                    this.contentTags = contentTags;
                    this.viewContainers = ListWrapper.createFixedSize(boundElements.length);
                    this.lightDoms = ListWrapper.createFixedSize(boundElements.length);
                    this.hostLightDom = null;
                    this.hydrated = false;
                    this.eventHandlerRemovers = [];
                    this.eventDispatcher = null;
                    this.shadowRoot = null;
                }

                _createClass(DomView, [{
                    key: 'getDirectParentLightDom',
                    value: function getDirectParentLightDom(boundElementIndex) {
                        var binder = this.proto.elementBinders[boundElementIndex];
                        var destLightDom = null;
                        if (binder.parentIndex !== -1 && binder.distanceToParent === 1) {
                            destLightDom = this.lightDoms[binder.parentIndex];
                        }
                        return destLightDom;
                    }
                }, {
                    key: 'setElementProperty',
                    value: function setElementProperty(elementIndex, propertyName, value) {
                        var setter = MapWrapper.get(this.proto.elementBinders[elementIndex].propertySetters, propertyName);
                        setter(this.boundElements[elementIndex], value);
                    }
                }, {
                    key: 'callAction',
                    value: function callAction(elementIndex, actionExpression, actionArgs) {
                        var binder = this.proto.elementBinders[elementIndex];
                        var hostAction = MapWrapper.get(binder.hostActions, actionExpression);
                        hostAction.eval(this.boundElements[elementIndex], this._localsWithAction(actionArgs));
                    }
                }, {
                    key: '_localsWithAction',
                    value: function _localsWithAction(action) {
                        var map = MapWrapper.create();
                        MapWrapper.set(map, '$action', action);
                        return new Locals(null, map);
                    }
                }, {
                    key: 'setText',
                    value: function setText(textIndex, value) {
                        DOM.setText(this.boundTextNodes[textIndex], value);
                    }
                }, {
                    key: 'dispatchEvent',
                    value: function dispatchEvent(elementIndex, eventName, event) {
                        var allowDefaultBehavior = true;
                        if (isPresent(this.eventDispatcher)) {
                            var evalLocals = MapWrapper.create();
                            MapWrapper.set(evalLocals, '$event', event);
                            // TODO(tbosch): reenable this when we are parsing element properties
                            // out of action expressions
                            // var localValues = this.proto.elementBinders[elementIndex].eventLocals.eval(null, new
                            // Locals(null, evalLocals));
                            // this.eventDispatcher.dispatchEvent(elementIndex, eventName, localValues);
                            allowDefaultBehavior = this.eventDispatcher.dispatchEvent(elementIndex, eventName, evalLocals);
                            if (!allowDefaultBehavior) {
                                event.preventDefault();
                            }
                        }
                        return allowDefaultBehavior;
                    }
                }]);

                return DomView;
            })();

            _export('DomView', DomView);
        }
    };
});


System.register('angular2/src/core/compiler/directive_lifecycle_reflector', ['angular2/src/facade/lang'], function (_export) {
    'use strict';

    var Type, isPresent;

    _export('hasLifecycleHook', hasLifecycleHook);

    function hasLifecycleHook(e, type, annotation) {
        if (isPresent(annotation.lifecycle)) {
            return annotation.lifecycle.indexOf(e) !== -1;
        } else {
            if (!(type instanceof Type)) return false;
            return e.name in type.prototype;
        }
    }
    

    return {
        setters: [function (_angular2SrcFacadeLang) {
            Type = _angular2SrcFacadeLang.Type;
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {}
    };
});
System.register("angular2/src/core/compiler/template_resolver", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/core/annotations_impl/view", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection"], function (_export) {
    var _createClass, _classCallCheck, Injectable, View, isBlank, MapWrapper, reflector, __decorate, __metadata, TemplateResolver;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcCoreAnnotations_implView) {
            View = _angular2SrcCoreAnnotations_implView.View;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            TemplateResolver = (function () {
                var _class = function TemplateResolver() {
                    _classCallCheck(this, _class);

                    this._cache = MapWrapper.create();
                };

                _createClass(_class, [{
                    key: "resolve",
                    value: function resolve(component) {
                        var view = MapWrapper.get(this._cache, component);
                        if (isBlank(view)) {
                            view = this._resolve(component);
                            MapWrapper.set(this._cache, component, view);
                        }
                        return view;
                    }
                }, {
                    key: "_resolve",
                    value: function _resolve(component) {
                        var annotations = reflector.annotations(component);
                        for (var i = 0; i < annotations.length; i++) {
                            var annotation = annotations[i];
                            if (annotation instanceof View) {
                                return annotation;
                            }
                        }
                        // No annotation = dynamic component!
                        return null;
                    }
                }]);

                return _class;
            })();

            _export("TemplateResolver", TemplateResolver);

            _export("TemplateResolver", TemplateResolver = __decorate([Injectable(), __metadata("design:paramtypes", [])], TemplateResolver));
            
        }
    };
});
System.register("angular2/src/core/compiler/component_url_mapper", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, Injectable, isPresent, MapWrapper, __decorate, __metadata, ComponentUrlMapper, RuntimeComponentUrlMapper;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ComponentUrlMapper = (function () {
                var _class = function ComponentUrlMapper() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "getUrl",

                    // Returns the base URL to the component source file.
                    // The returned URL could be:
                    // - an absolute URL,
                    // - a path relative to the application
                    value: function getUrl(component) {
                        return "./";
                    }
                }]);

                return _class;
            })();

            _export("ComponentUrlMapper", ComponentUrlMapper);

            _export("ComponentUrlMapper", ComponentUrlMapper = __decorate([Injectable(), __metadata("design:paramtypes", [])], ComponentUrlMapper));

            RuntimeComponentUrlMapper = (function (_ComponentUrlMapper) {
                function RuntimeComponentUrlMapper() {
                    _classCallCheck(this, RuntimeComponentUrlMapper);

                    _get(Object.getPrototypeOf(RuntimeComponentUrlMapper.prototype), "constructor", this).call(this);
                    this._componentUrls = MapWrapper.create();
                }

                _inherits(RuntimeComponentUrlMapper, _ComponentUrlMapper);

                _createClass(RuntimeComponentUrlMapper, [{
                    key: "setComponentUrl",
                    value: function setComponentUrl(component, url) {
                        MapWrapper.set(this._componentUrls, component, url);
                    }
                }, {
                    key: "getUrl",
                    value: function getUrl(component) {
                        var url = MapWrapper.get(this._componentUrls, component);
                        if (isPresent(url)) return url;
                        return _get(Object.getPrototypeOf(RuntimeComponentUrlMapper.prototype), "getUrl", this).call(this, component);
                    }
                }]);

                return RuntimeComponentUrlMapper;
            })(ComponentUrlMapper);

            _export("RuntimeComponentUrlMapper", RuntimeComponentUrlMapper);
        }
    };
});


System.register("angular2/src/core/compiler/proto_view_factory", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/reflection/reflection", "angular2/change_detection", "angular2/src/render/api", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_injector"], function (_export) {
    var _createClass, _classCallCheck, Injectable, ListWrapper, MapWrapper, isPresent, isBlank, reflector, ChangeDetection, DirectiveIndex, BindingRecord, DirectiveRecord, DEFAULT, ChangeDetectorDefinition, renderApi, AppProtoView, ProtoElementInjector, __decorate, __metadata, BindingRecordsCreator, ProtoViewFactory, RenderProtoViewWithIndex, ParentProtoElementInjectorWithDistance;

    /**
     * Returns the data needed to create ChangeDetectors
     * for the given ProtoView and all nested ProtoViews.
     */

    function getChangeDetectorDefinitions(hostComponentMetadata, rootRenderProtoView, allRenderDirectiveMetadata) {
        var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
        var nestedPvVariableBindings = _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex);
        var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex, nestedPvVariableBindings);
        return _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata);
    }

    function _collectNestedProtoViews(renderProtoView) {
        var parentIndex = arguments[1] === undefined ? null : arguments[1];
        var boundElementIndex = arguments[2] === undefined ? null : arguments[2];
        var result = arguments[3] === undefined ? null : arguments[3];

        if (isBlank(result)) {
            result = [];
        }
        ListWrapper.push(result, new RenderProtoViewWithIndex(renderProtoView, result.length, parentIndex, boundElementIndex));
        var currentIndex = result.length - 1;
        var childBoundElementIndex = 0;
        ListWrapper.forEach(renderProtoView.elementBinders, function (elementBinder) {
            if (isPresent(elementBinder.nestedProtoView)) {
                _collectNestedProtoViews(elementBinder.nestedProtoView, currentIndex, childBoundElementIndex, result);
            }
            childBoundElementIndex++;
        });
        return result;
    }
    function _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata) {
        return ListWrapper.map(nestedPvsWithIndex, function (pvWithIndex) {
            var elementBinders = pvWithIndex.renderProtoView.elementBinders;
            var bindingRecordsCreator = new BindingRecordsCreator();
            var bindingRecords = bindingRecordsCreator.getBindingRecords(elementBinders, allRenderDirectiveMetadata);
            var directiveRecords = bindingRecordsCreator.getDirectiveRecords(elementBinders, allRenderDirectiveMetadata);
            var strategyName = DEFAULT;
            var typeString;
            if (pvWithIndex.renderProtoView.type === renderApi.ProtoViewDto.COMPONENT_VIEW_TYPE) {
                strategyName = hostComponentMetadata.changeDetection;
                typeString = "comp";
            } else if (pvWithIndex.renderProtoView.type === renderApi.ProtoViewDto.HOST_VIEW_TYPE) {
                typeString = "host";
            } else {
                typeString = "embedded";
            }
            var id = "" + hostComponentMetadata.id + "_" + typeString + "_" + pvWithIndex.index;
            var variableNames = nestedPvVariableNames[pvWithIndex.index];
            return new ChangeDetectorDefinition(id, strategyName, variableNames, bindingRecords, directiveRecords);
        });
    }
    function _createAppProtoView(renderProtoView, protoChangeDetector, variableBindings, allDirectives) {
        var elementBinders = renderProtoView.elementBinders;
        var protoView = new AppProtoView(renderProtoView.render, protoChangeDetector, variableBindings);
        // TODO: vsavkin refactor to pass element binders into proto view
        _createElementBinders(protoView, elementBinders, allDirectives);
        _bindDirectiveEvents(protoView, elementBinders);
        return protoView;
    }
    function _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex) {
        return ListWrapper.map(nestedPvsWithIndex, function (pvWithIndex) {
            return _createVariableBindings(pvWithIndex.renderProtoView);
        });
    }
    function _createVariableBindings(renderProtoView) {
        var variableBindings = MapWrapper.create();
        MapWrapper.forEach(renderProtoView.variableBindings, function (mappedName, varName) {
            MapWrapper.set(variableBindings, varName, mappedName);
        });
        ListWrapper.forEach(renderProtoView.elementBinders, function (binder) {
            MapWrapper.forEach(binder.variableBindings, function (mappedName, varName) {
                MapWrapper.set(variableBindings, varName, mappedName);
            });
        });
        return variableBindings;
    }
    function _collectNestedProtoViewsVariableNames(nestedPvsWithIndex, nestedPvVariableBindings) {
        var nestedPvVariableNames = ListWrapper.createFixedSize(nestedPvsWithIndex.length);
        ListWrapper.forEach(nestedPvsWithIndex, function (pvWithIndex) {
            var parentVariableNames = isPresent(pvWithIndex.parentIndex) ? nestedPvVariableNames[pvWithIndex.parentIndex] : null;
            nestedPvVariableNames[pvWithIndex.index] = _createVariableNames(parentVariableNames, nestedPvVariableBindings[pvWithIndex.index]);
        });
        return nestedPvVariableNames;
    }
    function _createVariableNames(parentVariableNames, variableBindings) {
        var variableNames = isPresent(parentVariableNames) ? ListWrapper.clone(parentVariableNames) : [];
        MapWrapper.forEach(variableBindings, function (local, v) {
            ListWrapper.push(variableNames, local);
        });
        return variableNames;
    }
    function _createElementBinders(protoView, elementBinders, allDirectiveBindings) {
        for (var i = 0; i < elementBinders.length; i++) {
            var renderElementBinder = elementBinders[i];
            var dirs = elementBinders[i].directives;
            var parentPeiWithDistance = _findParentProtoElementInjectorWithDistance(i, protoView.elementBinders, elementBinders);
            var directiveBindings = ListWrapper.map(dirs, function (dir) {
                return allDirectiveBindings[dir.directiveIndex];
            });
            var componentDirectiveBinding = null;
            if (directiveBindings.length > 0) {
                if (directiveBindings[0].metadata.type === renderApi.DirectiveMetadata.COMPONENT_TYPE) {
                    componentDirectiveBinding = directiveBindings[0];
                }
            }
            var protoElementInjector = _createProtoElementInjector(i, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings);
            _createElementBinder(protoView, i, renderElementBinder, protoElementInjector, componentDirectiveBinding);
        }
    }
    function _findParentProtoElementInjectorWithDistance(binderIndex, elementBinders, renderElementBinders) {
        var distance = 0;
        do {
            var renderElementBinder = renderElementBinders[binderIndex];
            binderIndex = renderElementBinder.parentIndex;
            if (binderIndex !== -1) {
                distance += renderElementBinder.distanceToParent;
                var elementBinder = elementBinders[binderIndex];
                if (isPresent(elementBinder.protoElementInjector)) {
                    return new ParentProtoElementInjectorWithDistance(elementBinder.protoElementInjector, distance);
                }
            }
        } while (binderIndex !== -1);
        return new ParentProtoElementInjectorWithDistance(null, -1);
    }
    function _createProtoElementInjector(binderIndex, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings) {
        var protoElementInjector = null;
        // Create a protoElementInjector for any element that either has bindings *or* has one
        // or more var- defined. Elements with a var- defined need a their own element injector
        // so that, when hydrating, $implicit can be set to the element.
        var hasVariables = MapWrapper.size(renderElementBinder.variableBindings) > 0;
        if (directiveBindings.length > 0 || hasVariables) {
            protoElementInjector = ProtoElementInjector.create(parentPeiWithDistance.protoElementInjector, binderIndex, directiveBindings, isPresent(componentDirectiveBinding), parentPeiWithDistance.distance);
            protoElementInjector.attributes = renderElementBinder.readAttributes;
            if (hasVariables) {
                protoElementInjector.exportComponent = isPresent(componentDirectiveBinding);
                protoElementInjector.exportElement = isBlank(componentDirectiveBinding);
                // experiment
                var exportImplicitName = MapWrapper.get(renderElementBinder.variableBindings, "$implicit");
                if (isPresent(exportImplicitName)) {
                    protoElementInjector.exportImplicitName = exportImplicitName;
                }
            }
        }
        return protoElementInjector;
    }
    function _createElementBinder(protoView, boundElementIndex, renderElementBinder, protoElementInjector, componentDirectiveBinding) {
        var parent = null;
        if (renderElementBinder.parentIndex !== -1) {
            parent = protoView.elementBinders[renderElementBinder.parentIndex];
        }
        var elBinder = protoView.bindElement(parent, renderElementBinder.distanceToParent, protoElementInjector, componentDirectiveBinding);
        protoView.bindEvent(renderElementBinder.eventBindings, boundElementIndex, -1);
        // variables
        // The view's locals needs to have a full set of variable names at construction time
        // in order to prevent new variables from being set later in the lifecycle. Since we don't want
        // to actually create variable bindings for the $implicit bindings, add to the
        // protoLocals manually.
        MapWrapper.forEach(renderElementBinder.variableBindings, function (mappedName, varName) {
            MapWrapper.set(protoView.protoLocals, mappedName, null);
        });
        return elBinder;
    }
    function _bindDirectiveEvents(protoView, elementBinders) {
        for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; ++boundElementIndex) {
            var dirs = elementBinders[boundElementIndex].directives;
            for (var i = 0; i < dirs.length; i++) {
                var directiveBinder = dirs[i];
                // directive events
                protoView.bindEvent(directiveBinder.eventBindings, boundElementIndex, i);
            }
        }
    }
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
        }, function (_angular2Change_detection) {
            ChangeDetection = _angular2Change_detection.ChangeDetection;
            DirectiveIndex = _angular2Change_detection.DirectiveIndex;
            BindingRecord = _angular2Change_detection.BindingRecord;
            DirectiveRecord = _angular2Change_detection.DirectiveRecord;
            DEFAULT = _angular2Change_detection.DEFAULT;
            ChangeDetectorDefinition = _angular2Change_detection.ChangeDetectorDefinition;
        }, function (_angular2SrcRenderApi) {
            renderApi = _angular2SrcRenderApi;
        }, function (_angular2SrcCoreCompilerView) {
            AppProtoView = _angular2SrcCoreCompilerView.AppProtoView;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            ProtoElementInjector = _angular2SrcCoreCompilerElement_injector.ProtoElementInjector;
        }],
        execute: function () {
            "use strict";

            _export("getChangeDetectorDefinitions", getChangeDetectorDefinitions);

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            BindingRecordsCreator = (function () {
                function BindingRecordsCreator() {
                    _classCallCheck(this, BindingRecordsCreator);

                    this._directiveRecordsMap = MapWrapper.create();
                    this._textNodeIndex = 0;
                }

                _createClass(BindingRecordsCreator, [{
                    key: "getBindingRecords",
                    value: function getBindingRecords(elementBinders, allDirectiveMetadatas) {
                        var bindings = [];
                        for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
                            var renderElementBinder = elementBinders[boundElementIndex];
                            this._createTextNodeRecords(bindings, renderElementBinder);
                            this._createElementPropertyRecords(bindings, boundElementIndex, renderElementBinder);
                            this._createDirectiveRecords(bindings, boundElementIndex, renderElementBinder.directives, allDirectiveMetadatas);
                        }
                        return bindings;
                    }
                }, {
                    key: "getDirectiveRecords",
                    value: function getDirectiveRecords(elementBinders, allDirectiveMetadatas) {
                        var directiveRecords = [];
                        for (var elementIndex = 0; elementIndex < elementBinders.length; ++elementIndex) {
                            var dirs = elementBinders[elementIndex].directives;
                            for (var dirIndex = 0; dirIndex < dirs.length; ++dirIndex) {
                                ListWrapper.push(directiveRecords, this._getDirectiveRecord(elementIndex, dirIndex, allDirectiveMetadatas[dirs[dirIndex].directiveIndex]));
                            }
                        }
                        return directiveRecords;
                    }
                }, {
                    key: "_createTextNodeRecords",
                    value: function _createTextNodeRecords(bindings, renderElementBinder) {
                        var _this = this;

                        if (isBlank(renderElementBinder.textBindings)) return;
                        ListWrapper.forEach(renderElementBinder.textBindings, function (b) {
                            ListWrapper.push(bindings, BindingRecord.createForTextNode(b, _this._textNodeIndex++));
                        });
                    }
                }, {
                    key: "_createElementPropertyRecords",
                    value: function _createElementPropertyRecords(bindings, boundElementIndex, renderElementBinder) {
                        MapWrapper.forEach(renderElementBinder.propertyBindings, function (astWithSource, propertyName) {
                            ListWrapper.push(bindings, BindingRecord.createForElement(astWithSource, boundElementIndex, propertyName));
                        });
                    }
                }, {
                    key: "_createDirectiveRecords",
                    value: function _createDirectiveRecords(bindings, boundElementIndex, directiveBinders, allDirectiveMetadatas) {
                        for (var i = 0; i < directiveBinders.length; i++) {
                            var directiveBinder = directiveBinders[i];
                            var directiveMetadata = allDirectiveMetadatas[directiveBinder.directiveIndex];
                            var directiveRecord = this._getDirectiveRecord(boundElementIndex, i, directiveMetadata);
                            // directive properties
                            MapWrapper.forEach(directiveBinder.propertyBindings, function (astWithSource, propertyName) {
                                // TODO: these setters should eventually be created by change detection, to make
                                // it monomorphic!
                                var setter = reflector.setter(propertyName);
                                ListWrapper.push(bindings, BindingRecord.createForDirective(astWithSource, propertyName, setter, directiveRecord));
                            });
                            if (directiveRecord.callOnChange) {
                                ListWrapper.push(bindings, BindingRecord.createDirectiveOnChange(directiveRecord));
                            }
                            if (directiveRecord.callOnInit) {
                                ListWrapper.push(bindings, BindingRecord.createDirectiveOnInit(directiveRecord));
                            }
                            if (directiveRecord.callOnCheck) {
                                ListWrapper.push(bindings, BindingRecord.createDirectiveOnCheck(directiveRecord));
                            }
                            // host properties
                            MapWrapper.forEach(directiveBinder.hostPropertyBindings, function (astWithSource, propertyName) {
                                var dirIndex = new DirectiveIndex(boundElementIndex, i);
                                ListWrapper.push(bindings, BindingRecord.createForHostProperty(dirIndex, astWithSource, propertyName));
                            });
                        }
                    }
                }, {
                    key: "_getDirectiveRecord",
                    value: function _getDirectiveRecord(boundElementIndex, directiveIndex, directiveMetadata) {
                        var id = boundElementIndex * 100 + directiveIndex;
                        if (!MapWrapper.contains(this._directiveRecordsMap, id)) {
                            MapWrapper.set(this._directiveRecordsMap, id, new DirectiveRecord({
                                directiveIndex: new DirectiveIndex(boundElementIndex, directiveIndex),
                                callOnAllChangesDone: directiveMetadata.callOnAllChangesDone,
                                callOnChange: directiveMetadata.callOnChange,
                                callOnCheck: directiveMetadata.callOnCheck,
                                callOnInit: directiveMetadata.callOnInit,
                                changeDetection: directiveMetadata.changeDetection
                            }));
                        }
                        return MapWrapper.get(this._directiveRecordsMap, id);
                    }
                }]);

                return BindingRecordsCreator;
            })();

            ProtoViewFactory = (function () {
                var _class = function ProtoViewFactory(changeDetection) {
                    _classCallCheck(this, _class);

                    this._changeDetection = changeDetection;
                };

                _createClass(_class, [{
                    key: "createAppProtoViews",
                    value: function createAppProtoViews(hostComponentBinding, rootRenderProtoView, allDirectives) {
                        var _this2 = this;

                        var allRenderDirectiveMetadata = ListWrapper.map(allDirectives, function (directiveBinding) {
                            return directiveBinding.metadata;
                        });
                        var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
                        var nestedPvVariableBindings = _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex);
                        var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex, nestedPvVariableBindings);
                        var changeDetectorDefs = _getChangeDetectorDefinitions(hostComponentBinding.metadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata);
                        var protoChangeDetectors = ListWrapper.map(changeDetectorDefs, function (changeDetectorDef) {
                            return _this2._changeDetection.createProtoChangeDetector(changeDetectorDef);
                        });
                        var appProtoViews = ListWrapper.createFixedSize(nestedPvsWithIndex.length);
                        ListWrapper.forEach(nestedPvsWithIndex, function (pvWithIndex) {
                            var appProtoView = _createAppProtoView(pvWithIndex.renderProtoView, protoChangeDetectors[pvWithIndex.index], nestedPvVariableBindings[pvWithIndex.index], allDirectives);
                            if (isPresent(pvWithIndex.parentIndex)) {
                                var parentView = appProtoViews[pvWithIndex.parentIndex];
                                parentView.elementBinders[pvWithIndex.boundElementIndex].nestedProtoView = appProtoView;
                            }
                            appProtoViews[pvWithIndex.index] = appProtoView;
                        });
                        return appProtoViews;
                    }
                }]);

                return _class;
            })();

            _export("ProtoViewFactory", ProtoViewFactory);

            _export("ProtoViewFactory", ProtoViewFactory = __decorate([Injectable(), __metadata("design:paramtypes", [ChangeDetection])], ProtoViewFactory));
            RenderProtoViewWithIndex = function RenderProtoViewWithIndex(renderProtoView, index, parentIndex, boundElementIndex) {
                _classCallCheck(this, RenderProtoViewWithIndex);

                this.renderProtoView = renderProtoView;
                this.index = index;
                this.parentIndex = parentIndex;
                this.boundElementIndex = boundElementIndex;
            };

            ParentProtoElementInjectorWithDistance = function ParentProtoElementInjectorWithDistance(protoElementInjector, distance) {
                _classCallCheck(this, ParentProtoElementInjectorWithDistance);

                this.protoElementInjector = protoElementInjector;
                this.distance = distance;
            };
        }
    };
});


System.register("angular2/src/services/url_resolver", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function (_export) {
    var _createClass, _classCallCheck, Injectable, isPresent, isBlank, RegExpWrapper, BaseException, DOM, __decorate, __metadata, _UrlResolver, _schemeRe;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _UrlResolver = (function () {
                var _class = function UrlResolver() {
                    _classCallCheck(this, _class);

                    if (isBlank(_UrlResolver.a)) {
                        _UrlResolver.a = DOM.createElement("a");
                    }
                };

                _createClass(_class, [{
                    key: "resolve",

                    /**
                     * Resolves the `url` given the `baseUrl`.
                     *
                     * ## When the `baseUrl` is null
                     *
                     * `url` is resolved in the context of the current document.
                     * If the document location is 'http://www.foo.com/base' and the `url` is 'path/to/here', the
                     * resolved url will be
                     * 'http://www.foo.com/base/path/to/here'
                     *
                     * ## When the `baseUrl` is not null
                     *
                     * - when the `url` is null, the `baseUrl` is returned,
                     * - due to a limitation in the process used to resolve urls (a HTMLLinkElement), `url` must not
                     * start with a `/`,
                     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
                     * `baseUrl` and `url`,
                     * - if `url` is absolute (it has a scheme: 'http://', 'https://'), the `url` is returned
                     * (ignoring the `baseUrl`)
                     *
                     * @param {string} baseUrl
                     * @param {string} url
                     * @returns {string} the resolved URL
                     */
                    value: function resolve(baseUrl, url) {
                        if (isBlank(baseUrl)) {
                            DOM.resolveAndSetHref(_UrlResolver.a, url, null);
                            return DOM.getHref(_UrlResolver.a);
                        }
                        if (isBlank(url) || url == "") return baseUrl;
                        if (url[0] == "/") {
                            // The `HTMLLinkElement` does not allow resolving this case (the `url` would be interpreted as
                            // relative):
                            // - `baseUrl` = 'http://www.foo.com/base'
                            // - `url` = '/absolute/path/to/here'
                            // - the result would be 'http://www.foo.com/base/absolute/path/to/here' while
                            // 'http://www.foo.com/absolute/path/to/here'
                            // is expected (without the 'base' segment).
                            throw new BaseException("Could not resolve the url " + url + " from " + baseUrl);
                        }
                        var m = RegExpWrapper.firstMatch(_schemeRe, url);
                        if (isPresent(m[1])) {
                            return url;
                        }
                        DOM.resolveAndSetHref(_UrlResolver.a, baseUrl, url);
                        return DOM.getHref(_UrlResolver.a);
                    }
                }]);

                return _class;
            })();

            _export("UrlResolver", _UrlResolver);

            _UrlResolver = __decorate([Injectable(), __metadata("design:paramtypes", [])], _UrlResolver);
            _schemeRe = RegExpWrapper.create("^([^:/?#]+:)?");

            
        }
    };
});
System.register("angular2/src/core/exception_handler", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter"], function (_export) {
    var _createClass, _classCallCheck, Injectable, isPresent, ListWrapper, isListLikeIterable, DOM, __decorate, __metadata, ExceptionHandler;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            isListLikeIterable = _angular2SrcFacadeCollection.isListLikeIterable;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Provides a hook for centralized exception handling.
             *
             * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
             * intercept error handling,
             * write a custom exception handler that replaces this default as appropriate for your app.
             *
             * # Example
             *
             * ```javascript
             * @Component({
             *   selector: 'my-app',
             *   appInjector: [
             *     bind(ExceptionHandler).toClass(MyExceptionHandler)
             *   ]
             * })
             * @View(...)
             * class MyApp { ... }
             *
             *
             * class MyExceptionHandler implements ExceptionHandler {
             *   call(error, stackTrace = null, reason = null) {
             *     // do something with the exception
             *   }
             * }
             *
             * ```
             *
             * @exportedAs angular2/core
             */

            ExceptionHandler = (function () {
                var _class = function ExceptionHandler() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "call",
                    value: function call(error) {
                        var stackTrace = arguments[1] === undefined ? null : arguments[1];
                        var reason = arguments[2] === undefined ? null : arguments[2];

                        var longStackTrace = isListLikeIterable(stackTrace) ? ListWrapper.join(stackTrace, "\n\n") : stackTrace;
                        var reasonStr = isPresent(reason) ? "\n" + reason : "";
                        DOM.logError("" + error + "" + reasonStr + "\nSTACKTRACE:\n" + longStackTrace);
                    }
                }]);

                return _class;
            })();

            _export("ExceptionHandler", ExceptionHandler);

            _export("ExceptionHandler", ExceptionHandler = __decorate([Injectable(), __metadata("design:paramtypes", [])], ExceptionHandler));
            
        }
    };
});
System.register("angular2/src/services/xhr", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, XHR;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            XHR = (function () {
                function XHR() {
                    _classCallCheck(this, XHR);
                }

                _createClass(XHR, [{
                    key: "get",
                    value: function get(url) {
                        return null;
                    }
                }]);

                return XHR;
            })();

            _export("XHR", XHR);
        }
    };
});


System.register('angular2/src/core/zone/ng_zone', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, StringMapWrapper, normalizeBlank, isPresent, global, NgZone;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2SrcFacadeLang) {
            normalizeBlank = _angular2SrcFacadeLang.normalizeBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            global = _angular2SrcFacadeLang.global;
        }],
        execute: function () {
            'use strict';

            /**
             * A wrapper around zones that lets you schedule tasks after it has executed a task.
             *
             * The wrapper maintains an "inner" and an "mount" `Zone`. The application code will executes
             * in the "inner" zone unless `runOutsideAngular` is explicitely called.
             *
             * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root
             * `Zone`. The default `onTurnDone` runs the Angular change detection.
             *
             * @exportedAs angular2/core
             */

            NgZone = (function () {
                /**
                 * Associates with this
                 *
                 * - a "root" zone, which the one that instantiated this.
                 * - an "inner" zone, which is a child of the root zone.
                 *
                 * @param {bool} enableLongStackTrace whether to enable long stack trace. They should only be
                 *               enabled in development mode as they significantly impact perf.
                 */

                function NgZone(_ref) {
                    var enableLongStackTrace = _ref.enableLongStackTrace;

                    _classCallCheck(this, NgZone);

                    this._onTurnStart = null;
                    this._onTurnDone = null;
                    this._onErrorHandler = null;
                    this._pendingMicrotasks = 0;
                    this._hasExecutedCodeInInnerZone = false;
                    this._nestedRun = 0;
                    if (global.zone) {
                        this._disabled = false;
                        this._mountZone = global.zone;
                        this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);
                    } else {
                        this._disabled = true;
                        this._mountZone = null;
                    }
                }

                _createClass(NgZone, [{
                    key: 'initCallbacks',

                    /**
                     * Initializes the zone hooks.
                     *
                     * @param {() => void} onTurnStart called before code executes in the inner zone for each VM turn
                     * @param {() => void} onTurnDone called at the end of a VM turn if code has executed in the inner
                     * zone
                     * @param {(error, stack) => void} onErrorHandler called when an exception is thrown by a macro or
                     * micro task
                     */
                    value: function initCallbacks() {
                        var _ref2 = arguments[0] === undefined ? {} : arguments[0];

                        var onTurnStart = _ref2.onTurnStart;
                        var onTurnDone = _ref2.onTurnDone;
                        var onErrorHandler = _ref2.onErrorHandler;

                        this._onTurnStart = normalizeBlank(onTurnStart);
                        this._onTurnDone = normalizeBlank(onTurnDone);
                        this._onErrorHandler = normalizeBlank(onErrorHandler);
                    }
                }, {
                    key: 'run',

                    /**
                     * Runs `fn` in the inner zone and returns whatever it returns.
                     *
                     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the
                     * Angular's auto digest mechanism.
                     *
                     * ```
                     * var zone: NgZone = [ref to the application zone];
                     *
                     * zone.run(() => {
                     *   // the change detection will run after this function and the microtasks it enqueues have
                     * executed.
                     * });
                     * ```
                     */
                    value: function run(fn) {
                        if (this._disabled) {
                            return fn();
                        } else {
                            return this._innerZone.run(fn);
                        }
                    }
                }, {
                    key: 'runOutsideAngular',

                    /**
                     * Runs `fn` in the outer zone and returns whatever it returns.
                     *
                     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's
                     * auto-digest mechanism.
                     *
                     * ```
                     * var zone: NgZone = [ref to the application zone];
                     *
                     * zone.runOusideAngular(() => {
                     *   element.onClick(() => {
                     *     // Clicking on the element would not trigger the change detection
                     *   });
                     * });
                     * ```
                     */
                    value: function runOutsideAngular(fn) {
                        if (this._disabled) {
                            return fn();
                        } else {
                            return this._mountZone.run(fn);
                        }
                    }
                }, {
                    key: '_createInnerZone',
                    value: function _createInnerZone(zone, enableLongStackTrace) {
                        var ngZone = this;
                        var errorHandling;
                        if (enableLongStackTrace) {
                            errorHandling = StringMapWrapper.merge(Zone.longStackTraceZone, { onError: function onError(e) {
                                    ngZone._onError(this, e);
                                } });
                        } else {
                            errorHandling = {
                                onError: function onError(e) {
                                    ngZone._onError(this, e);
                                }
                            };
                        }
                        return zone.fork(errorHandling).fork({
                            '$run': function $run(parentRun) {
                                return function () {
                                    try {
                                        ngZone._nestedRun++;
                                        if (!ngZone._hasExecutedCodeInInnerZone) {
                                            ngZone._hasExecutedCodeInInnerZone = true;
                                            if (ngZone._onTurnStart) {
                                                parentRun.call(ngZone._innerZone, ngZone._onTurnStart);
                                            }
                                        }
                                        return parentRun.apply(this, arguments);
                                    } finally {
                                        ngZone._nestedRun--;
                                        // If there are no more pending microtasks, we are at the end of a VM turn (or in
                                        // onTurnStart)
                                        // _nestedRun will be 0 at the end of a macrotasks (it could be > 0 when there are
                                        // nested calls
                                        // to run()).
                                        if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0) {
                                            if (ngZone._onTurnDone && ngZone._hasExecutedCodeInInnerZone) {
                                                try {
                                                    parentRun.call(ngZone._innerZone, ngZone._onTurnDone);
                                                } finally {
                                                    ngZone._hasExecutedCodeInInnerZone = false;
                                                }
                                            }
                                        }
                                    }
                                };
                            },
                            '$scheduleMicrotask': function $scheduleMicrotask(parentScheduleMicrotask) {
                                return function (fn) {
                                    ngZone._pendingMicrotasks++;
                                    var microtask = function microtask() {
                                        try {
                                            fn();
                                        } finally {
                                            ngZone._pendingMicrotasks--;
                                        }
                                    };
                                    parentScheduleMicrotask.call(this, microtask);
                                };
                            },
                            _innerZone: true
                        });
                    }
                }, {
                    key: '_onError',
                    value: function _onError(zone, e) {
                        if (isPresent(this._onErrorHandler)) {
                            var trace = [normalizeBlank(e.stack)];
                            while (zone && zone.constructedAtException) {
                                trace.push(zone.constructedAtException.get());
                                zone = zone.parent;
                            }
                            this._onErrorHandler(e, trace);
                        } else {
                            console.log('## _onError ##');
                            console.log(e.stack);
                            throw e;
                        }
                    }
                }]);

                return NgZone;
            })();

            _export('NgZone', NgZone);
        }
    };
});


System.register("angular2/src/core/life_cycle/life_cycle", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/change_detection", "angular2/src/core/exception_handler", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, Injectable, ChangeDetector, ExceptionHandler, isPresent, __decorate, __metadata, LifeCycle;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2Change_detection) {
            ChangeDetector = _angular2Change_detection.ChangeDetector;
        }, function (_angular2SrcCoreException_handler) {
            ExceptionHandler = _angular2SrcCoreException_handler.ExceptionHandler;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Provides access to explicitly trigger change detection in an application.
             *
             * By default, `Zone` triggers change detection in Angular on each virtual machine (VM) turn. When
             * testing, or in some
             * limited application use cases, a developer can also trigger change detection with the
             * `lifecycle.tick()` method.
             *
             * Each Angular application has a single `LifeCycle` instance.
             *
             * # Example
             *
             * This is a contrived example, since the bootstrap automatically runs inside of the `Zone`, which
             * invokes
             * `lifecycle.tick()` on your behalf.
             *
             * ```javascript
             * bootstrap(MyApp).then((ref:ComponentRef) => {
             *   var lifeCycle = ref.injector.get(LifeCycle);
             *   var myApp = ref.instance;
             *
             *   ref.doSomething();
             *   lifecycle.tick();
             * });
             * ```
             * @exportedAs angular2/change_detection
             */

            LifeCycle = (function () {
                var _class = function LifeCycle(exceptionHandler) {
                    var changeDetector = arguments[1] === undefined ? null : arguments[1];
                    var enforceNoNewChanges = arguments[2] === undefined ? false : arguments[2];

                    _classCallCheck(this, _class);

                    this._errorHandler = function (exception, stackTrace) {
                        exceptionHandler.call(exception, stackTrace);
                        throw exception;
                    };
                    this._changeDetector = changeDetector; // may be null when instantiated from application bootstrap
                    this._enforceNoNewChanges = enforceNoNewChanges;
                };

                _createClass(_class, [{
                    key: "registerWith",

                    /**
                     * @private
                     */
                    value: function registerWith(zone) {
                        var _this = this;

                        var changeDetector = arguments[1] === undefined ? null : arguments[1];

                        if (isPresent(changeDetector)) {
                            this._changeDetector = changeDetector;
                        }
                        zone.initCallbacks({ onErrorHandler: this._errorHandler, onTurnDone: function onTurnDone() {
                                return _this.tick();
                            } });
                    }
                }, {
                    key: "tick",

                    /**
                     *  Invoke this method to explicitly process change detection and its side-effects.
                     *
                     *  In development mode, `tick()` also performs a second change detection cycle to ensure that no
                     * further
                     *  changes are detected. If additional changes are picked up during this second cycle, bindings
                     * in
                     * the app have
                     *  side-effects that cannot be resolved in a single change detection pass. In this case, Angular
                     * throws an error,
                     *  since an Angular application can only have one change detection pass during which all change
                     * detection must
                     *  complete.
                     *
                     */
                    value: function tick() {
                        this._changeDetector.detectChanges();
                        if (this._enforceNoNewChanges) {
                            this._changeDetector.checkNoChanges();
                        }
                    }
                }]);

                return _class;
            })();

            _export("LifeCycle", LifeCycle);

            _export("LifeCycle", LifeCycle = __decorate([Injectable(), __metadata("design:paramtypes", [ExceptionHandler, ChangeDetector, Boolean])], LifeCycle));
            
        }
    };
});
System.register("angular2/src/render/dom/shadow_dom/shadow_dom_strategy", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
  var _createClass, _classCallCheck, ShadowDomStrategy;

  return {
    setters: [function (_npmBabelRuntime547HelpersCreateClass) {
      _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
    }, function (_npmBabelRuntime547HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
    }],
    execute: function () {
      "use strict";

      ShadowDomStrategy = (function () {
        function ShadowDomStrategy() {
          _classCallCheck(this, ShadowDomStrategy);
        }

        _createClass(ShadowDomStrategy, [{
          key: "hasNativeContentElement",
          value: function hasNativeContentElement() {
            return true;
          }
        }, {
          key: "prepareShadowRoot",

          /**
           * Prepares and returns the shadow root for the given element.
           */
          value: function prepareShadowRoot(el) {
            return null;
          }
        }, {
          key: "constructLightDom",
          value: function constructLightDom(lightDomView, el) {
            return null;
          }
        }, {
          key: "processStyleElement",

          /**
           * An optional step that can modify the template style elements.
           */
          value: function processStyleElement(hostComponentId, templateUrl, styleElement) {
            return null;
          }
        }, {
          key: "processElement",

          /**
           * An optional step that can modify the template elements (style elements exlcuded).
           */
          value: function processElement(hostComponentId, elementComponentId, element) {}
        }]);

        return ShadowDomStrategy;
      })();

      _export("ShadowDomStrategy", ShadowDomStrategy);
    }
  };
});


System.register('angular2/src/render/dom/shadow_dom/light_dom', ['npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/create-class', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/collection', 'angular2/src/facade/lang'], function (_export) {
    var _classCallCheck, _createClass, DOM, ListWrapper, isPresent, DestinationLightDom, _Root, LightDom;

    // Projects the light DOM into the shadow DOM
    function redistributeNodes(contents, nodes) {
        for (var i = 0; i < contents.length; ++i) {
            var content = contents[i];
            var select = content.select;
            // Empty selector is identical to <content/>
            if (select.length === 0) {
                content.insert(ListWrapper.clone(nodes));
                ListWrapper.clear(nodes);
            } else {
                var matchSelector = function matchSelector(n) {
                    return DOM.elementMatches(n, select);
                };
                var matchingNodes = ListWrapper.filter(nodes, matchSelector);
                content.insert(matchingNodes);
                ListWrapper.removeAll(nodes, matchingNodes);
            }
        }
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (isPresent(node.parentNode)) {
                DOM.remove(nodes[i]);
            }
        }
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {
            'use strict';

            DestinationLightDom = function DestinationLightDom() {
                _classCallCheck(this, DestinationLightDom);
            };

            _export('DestinationLightDom', DestinationLightDom);

            _Root = function _Root(node, boundElementIndex) {
                _classCallCheck(this, _Root);

                this.node = node;
                this.boundElementIndex = boundElementIndex;
            };

            // TODO: LightDom should implement DestinationLightDom
            // once interfaces are supported

            LightDom = (function () {
                function LightDom(lightDomView, element) {
                    _classCallCheck(this, LightDom);

                    this.lightDomView = lightDomView;
                    this.nodes = DOM.childNodesAsList(element);
                    this._roots = null;
                    this.shadowDomView = null;
                }

                _createClass(LightDom, [{
                    key: 'attachShadowDomView',
                    value: function attachShadowDomView(shadowDomView) {
                        this.shadowDomView = shadowDomView;
                    }
                }, {
                    key: 'detachShadowDomView',
                    value: function detachShadowDomView() {
                        this.shadowDomView = null;
                    }
                }, {
                    key: 'redistribute',
                    value: function redistribute() {
                        redistributeNodes(this.contentTags(), this.expandedDomNodes());
                    }
                }, {
                    key: 'contentTags',
                    value: function contentTags() {
                        if (isPresent(this.shadowDomView)) {
                            return this._collectAllContentTags(this.shadowDomView, []);
                        } else {
                            return [];
                        }
                    }
                }, {
                    key: '_collectAllContentTags',

                    // Collects the Content directives from the view and all its child views
                    value: function _collectAllContentTags(view, acc) {
                        var _this = this;

                        var contentTags = view.contentTags;
                        var vcs = view.viewContainers;
                        for (var i = 0; i < vcs.length; i++) {
                            var vc = vcs[i];
                            var contentTag = contentTags[i];
                            if (isPresent(contentTag)) {
                                ListWrapper.push(acc, contentTag);
                            }
                            if (isPresent(vc)) {
                                ListWrapper.forEach(vc.contentTagContainers(), function (view) {
                                    _this._collectAllContentTags(view, acc);
                                });
                            }
                        }
                        return acc;
                    }
                }, {
                    key: 'expandedDomNodes',

                    // Collects the nodes of the light DOM by merging:
                    // - nodes from enclosed ViewContainers,
                    // - nodes from enclosed content tags,
                    // - plain DOM nodes
                    value: function expandedDomNodes() {
                        var res = [];
                        var roots = this._findRoots();
                        for (var i = 0; i < roots.length; ++i) {
                            var root = roots[i];
                            if (isPresent(root.boundElementIndex)) {
                                var vc = this.lightDomView.viewContainers[root.boundElementIndex];
                                var content = this.lightDomView.contentTags[root.boundElementIndex];
                                if (isPresent(vc)) {
                                    res = ListWrapper.concat(res, vc.nodes());
                                } else if (isPresent(content)) {
                                    res = ListWrapper.concat(res, content.nodes());
                                } else {
                                    ListWrapper.push(res, root.node);
                                }
                            } else {
                                ListWrapper.push(res, root.node);
                            }
                        }
                        return res;
                    }
                }, {
                    key: '_findRoots',

                    // Returns a list of Roots for all the nodes of the light DOM.
                    // The Root object contains the DOM node and its corresponding boundElementIndex
                    value: function _findRoots() {
                        if (isPresent(this._roots)) return this._roots;
                        var boundElements = this.lightDomView.boundElements;
                        this._roots = ListWrapper.map(this.nodes, function (n) {
                            var boundElementIndex = null;
                            for (var i = 0; i < boundElements.length; i++) {
                                var boundEl = boundElements[i];
                                if (isPresent(boundEl) && boundEl === n) {
                                    boundElementIndex = i;
                                    break;
                                }
                            }
                            return new _Root(n, boundElementIndex);
                        });
                        return this._roots;
                    }
                }]);

                return LightDom;
            })();

            _export('LightDom', LightDom);
        }
    };
});
System.register('angular2/src/render/dom/shadow_dom/shadow_css', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/collection', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, DOM, ListWrapper, StringWrapper, RegExpWrapper, RegExpMatcherWrapper, isPresent, isBlank, ShadowCss, _cssContentNextSelectorRe, _cssContentRuleRe, _cssContentUnscopedRuleRe, _polyfillHost, _polyfillHostContext, _parenSuffix, _cssColonHostRe, _cssColonHostContextRe, _polyfillHostNoCombinator, _shadowDOMSelectorsRe, _selectorReSuffix, _polyfillHostRe, _colonHostRe, _colonHostContextRe;

    function _cssToRules(cssText) {
        return DOM.cssToRules(cssText);
    }
    function _withCssRules(cssText, callback) {
        // Difference from webcomponentjs: remove the workaround for an old bug in Chrome
        if (isBlank(callback)) return;
        var rules = _cssToRules(cssText);
        callback(rules);
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            RegExpMatcherWrapper = _angular2SrcFacadeLang.RegExpMatcherWrapper;
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
        }],
        execute: function () {
            'use strict';

            /**
             * This file is a port of shadowCSS from webcomponents.js to AtScript.
             *
             * Please make sure to keep to edits in sync with the source file.
             *
             * Source:
             * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
             *
             * The original file level comment is reproduced below
             */
            /*
              This is a limited shim for ShadowDOM css styling.
              https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles
            
              The intention here is to support only the styling features which can be
              relatively simply implemented. The goal is to allow users to avoid the
              most obvious pitfalls and do so without compromising performance significantly.
              For ShadowDOM styling that's not covered here, a set of best practices
              can be provided that should allow users to accomplish more complex styling.
            
              The following is a list of specific ShadowDOM styling features and a brief
              discussion of the approach used to shim.
            
              Shimmed features:
            
              * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
              element using the :host rule. To shim this feature, the :host styles are
              reformatted and prefixed with a given scope name and promoted to a
              document level stylesheet.
              For example, given a scope name of .foo, a rule like this:
            
                :host {
                    background: red;
                  }
                }
            
              becomes:
            
                .foo {
                  background: red;
                }
            
              * encapsultion: Styles defined within ShadowDOM, apply only to
              dom inside the ShadowDOM. Polymer uses one of two techniques to imlement
              this feature.
            
              By default, rules are prefixed with the host element tag name
              as a descendant selector. This ensures styling does not leak out of the 'top'
              of the element's ShadowDOM. For example,
            
              div {
                  font-weight: bold;
                }
            
              becomes:
            
              x-foo div {
                  font-weight: bold;
                }
            
              becomes:
            
            
              Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
              selectors are scoped by adding an attribute selector suffix to each
              simple selector that contains the host element tag name. Each element
              in the element's ShadowDOM template is also given the scope attribute.
              Thus, these rules match only elements that have the scope attribute.
              For example, given a scope name of x-foo, a rule like this:
            
                div {
                  font-weight: bold;
                }
            
              becomes:
            
                div[x-foo] {
                  font-weight: bold;
                }
            
              Note that elements that are dynamically added to a scope must have the scope
              selector added to them manually.
            
              * upper/lower bound encapsulation: Styles which are defined outside a
              shadowRoot should not cross the ShadowDOM boundary and should not apply
              inside a shadowRoot.
            
              This styling behavior is not emulated. Some possible ways to do this that
              were rejected due to complexity and/or performance concerns include: (1) reset
              every possible property for every possible selector for a given scope name;
              (2) re-implement css in javascript.
            
              As an alternative, users should make sure to use selectors
              specific to the scope in which they are working.
            
              * ::distributed: This behavior is not emulated. It's often not necessary
              to style the contents of a specific insertion point and instead, descendants
              of the host element can be styled selectively. Users can also create an
              extra node around an insertion point and style that node's contents
              via descendent selectors. For example, with a shadowRoot like this:
            
                <style>
                  ::content(div) {
                    background: red;
                  }
                </style>
                <content></content>
            
              could become:
            
                <style>
                  / *@polyfill .content-container div * /
                  ::content(div) {
                    background: red;
                  }
                </style>
                <div class="content-container">
                  <content></content>
                </div>
            
              Note the use of @polyfill in the comment above a ShadowDOM specific style
              declaration. This is a directive to the styling shim to use the selector
              in comments in lieu of the next selector when running under polyfill.
            */

            ShadowCss = (function () {
                function ShadowCss() {
                    _classCallCheck(this, ShadowCss);

                    this.strictStyling = true;
                }

                _createClass(ShadowCss, [{
                    key: 'shimStyle',

                    /*
                    * Shim a style element with the given selector. Returns cssText that can
                    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
                    */
                    value: function shimStyle(style, selector) {
                        var hostSelector = arguments[2] === undefined ? '' : arguments[2];

                        var cssText = DOM.getText(style);
                        return this.shimCssText(cssText, selector, hostSelector);
                    }
                }, {
                    key: 'shimCssText',

                    /*
                    * Shim some cssText with the given selector. Returns cssText that can
                    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
                    *
                    * When strictStyling is true:
                    * - selector is the attribute added to all elements inside the host,
                    * - hostSelector is the attribute added to the host itself.
                    */
                    value: function shimCssText(cssText, selector) {
                        var hostSelector = arguments[2] === undefined ? '' : arguments[2];

                        cssText = this._insertDirectives(cssText);
                        return this._scopeCssText(cssText, selector, hostSelector);
                    }
                }, {
                    key: '_insertDirectives',
                    value: function _insertDirectives(cssText) {
                        cssText = this._insertPolyfillDirectivesInCssText(cssText);
                        return this._insertPolyfillRulesInCssText(cssText);
                    }
                }, {
                    key: '_insertPolyfillDirectivesInCssText',

                    /*
                     * Process styles to convert native ShadowDOM rules that will trip
                     * up the css parser; we rely on decorating the stylesheet with inert rules.
                     *
                     * For example, we convert this rule:
                     *
                     * polyfill-next-selector { content: ':host menu-item'; }
                     * ::content menu-item {
                     *
                     * to this:
                     *
                     * scopeName menu-item {
                     *
                    **/
                    value: function _insertPolyfillDirectivesInCssText(cssText) {
                        // Difference with webcomponents.js: does not handle comments
                        return StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m) {
                            return m[1] + '{';
                        });
                    }
                }, {
                    key: '_insertPolyfillRulesInCssText',

                    /*
                     * Process styles to add rules which will only apply under the polyfill
                     *
                     * For example, we convert this rule:
                     *
                     * polyfill-rule {
                     *   content: ':host menu-item';
                     * ...
                     * }
                     *
                     * to this:
                     *
                     * scopeName menu-item {...}
                     *
                    **/
                    value: function _insertPolyfillRulesInCssText(cssText) {
                        // Difference with webcomponents.js: does not handle comments
                        return StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function (m) {
                            var rule = m[0];
                            rule = StringWrapper.replace(rule, m[1], '');
                            rule = StringWrapper.replace(rule, m[2], '');
                            return m[3] + rule;
                        });
                    }
                }, {
                    key: '_scopeCssText',

                    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
                     *
                     *  .foo {... }
                     *
                     *  and converts this to
                     *
                     *  scopeName .foo { ... }
                    */
                    value: function _scopeCssText(cssText, scopeSelector, hostSelector) {
                        var _this = this;

                        var unscoped = this._extractUnscopedRulesFromCssText(cssText);
                        cssText = this._insertPolyfillHostInCssText(cssText);
                        cssText = this._convertColonHost(cssText);
                        cssText = this._convertColonHostContext(cssText);
                        cssText = this._convertShadowDOMSelectors(cssText);
                        if (isPresent(scopeSelector)) {
                            _withCssRules(cssText, function (rules) {
                                cssText = _this._scopeRules(rules, scopeSelector, hostSelector);
                            });
                        }
                        cssText = cssText + '\n' + unscoped;
                        return cssText.trim();
                    }
                }, {
                    key: '_extractUnscopedRulesFromCssText',

                    /*
                     * Process styles to add rules which will only apply under the polyfill
                     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
                     * occasions, e.g. -webkit-calc on Safari.)
                     * For example, we convert this rule:
                     *
                     * @polyfill-unscoped-rule {
                     *   content: 'menu-item';
                     * ... }
                     *
                     * to this:
                     *
                     * menu-item {...}
                     *
                    **/
                    value: function _extractUnscopedRulesFromCssText(cssText) {
                        // Difference with webcomponents.js: does not handle comments
                        var r = '',
                            m;
                        var matcher = RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
                        while (isPresent(m = RegExpMatcherWrapper.next(matcher))) {
                            var rule = m[0];
                            rule = StringWrapper.replace(rule, m[2], '');
                            rule = StringWrapper.replace(rule, m[1], m[3]);
                            r = rule + '\n\n';
                        }
                        return r;
                    }
                }, {
                    key: '_convertColonHost',

                    /*
                     * convert a rule like :host(.foo) > .bar { }
                     *
                     * to
                     *
                     * scopeName.foo > .bar
                    */
                    value: function _convertColonHost(cssText) {
                        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
                    }
                }, {
                    key: '_convertColonHostContext',

                    /*
                     * convert a rule like :host-context(.foo) > .bar { }
                     *
                     * to
                     *
                     * scopeName.foo > .bar, .foo scopeName > .bar { }
                     *
                     * and
                     *
                     * :host-context(.foo:host) .bar { ... }
                     *
                     * to
                     *
                     * scopeName.foo .bar { ... }
                    */
                    value: function _convertColonHostContext(cssText) {
                        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
                    }
                }, {
                    key: '_convertColonRule',
                    value: function _convertColonRule(cssText, regExp, partReplacer) {
                        // p1 = :host, p2 = contents of (), p3 rest of rule
                        return StringWrapper.replaceAllMapped(cssText, regExp, function (m) {
                            if (isPresent(m[2])) {
                                var parts = m[2].split(','),
                                    r = [];
                                for (var i = 0; i < parts.length; i++) {
                                    var p = parts[i];
                                    if (isBlank(p)) break;
                                    p = p.trim();
                                    ListWrapper.push(r, partReplacer(_polyfillHostNoCombinator, p, m[3]));
                                }
                                return r.join(',');
                            } else {
                                return _polyfillHostNoCombinator + m[3];
                            }
                        });
                    }
                }, {
                    key: '_colonHostContextPartReplacer',
                    value: function _colonHostContextPartReplacer(host, part, suffix) {
                        if (StringWrapper.contains(part, _polyfillHost)) {
                            return this._colonHostPartReplacer(host, part, suffix);
                        } else {
                            return host + part + suffix + ', ' + part + ' ' + host + suffix;
                        }
                    }
                }, {
                    key: '_colonHostPartReplacer',
                    value: function _colonHostPartReplacer(host, part, suffix) {
                        return host + StringWrapper.replace(part, _polyfillHost, '') + suffix;
                    }
                }, {
                    key: '_convertShadowDOMSelectors',

                    /*
                     * Convert combinators like ::shadow and pseudo-elements like ::content
                     * by replacing with space.
                    */
                    value: function _convertShadowDOMSelectors(cssText) {
                        for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
                            cssText = StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
                        }
                        return cssText;
                    }
                }, {
                    key: '_scopeRules',

                    // change a selector like 'div' to 'name div'
                    value: function _scopeRules(cssRules, scopeSelector, hostSelector) {
                        var cssText = '';
                        if (isPresent(cssRules)) {
                            for (var i = 0; i < cssRules.length; i++) {
                                var rule = cssRules[i];
                                if (DOM.isStyleRule(rule) || DOM.isPageRule(rule)) {
                                    cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) + ' {\n';
                                    cssText += this._propertiesFromRule(rule) + '\n}\n\n';
                                } else if (DOM.isMediaRule(rule)) {
                                    cssText += '@media ' + rule.media.mediaText + ' {\n';
                                    cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
                                    cssText += '\n}\n\n';
                                } else {
                                    // KEYFRAMES_RULE in IE throws when we query cssText
                                    // when it contains a -webkit- property.
                                    // if this happens, we fallback to constructing the rule
                                    // from the CSSRuleSet
                                    // https://connect.microsoft.com/IE/feedbackdetail/view/955703/accessing-csstext-of-a-keyframe-rule-that-contains-a-webkit-property-via-cssom-generates-exception
                                    try {
                                        if (isPresent(rule.cssText)) {
                                            cssText += rule.cssText + '\n\n';
                                        }
                                    } catch (x) {
                                        if (DOM.isKeyframesRule(rule) && isPresent(rule.cssRules)) {
                                            cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
                                        }
                                    }
                                }
                            }
                        }
                        return cssText;
                    }
                }, {
                    key: '_ieSafeCssTextFromKeyFrameRule',
                    value: function _ieSafeCssTextFromKeyFrameRule(rule) {
                        var cssText = '@keyframes ' + rule.name + ' {';
                        for (var i = 0; i < rule.cssRules.length; i++) {
                            var r = rule.cssRules[i];
                            cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
                        }
                        cssText += ' }';
                        return cssText;
                    }
                }, {
                    key: '_scopeSelector',
                    value: function _scopeSelector(selector, scopeSelector, hostSelector, strict) {
                        var r = [],
                            parts = selector.split(',');
                        for (var i = 0; i < parts.length; i++) {
                            var p = parts[i];
                            p = p.trim();
                            if (this._selectorNeedsScoping(p, scopeSelector)) {
                                p = strict && !StringWrapper.contains(p, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(p, scopeSelector) : this._applySelectorScope(p, scopeSelector, hostSelector);
                            }
                            ListWrapper.push(r, p);
                        }
                        return r.join(', ');
                    }
                }, {
                    key: '_selectorNeedsScoping',
                    value: function _selectorNeedsScoping(selector, scopeSelector) {
                        var re = this._makeScopeMatcher(scopeSelector);
                        return !isPresent(RegExpWrapper.firstMatch(re, selector));
                    }
                }, {
                    key: '_makeScopeMatcher',
                    value: function _makeScopeMatcher(scopeSelector) {
                        var lre = RegExpWrapper.create('\\[');
                        var rre = RegExpWrapper.create('\\]');
                        scopeSelector = StringWrapper.replaceAll(scopeSelector, lre, '\\[');
                        scopeSelector = StringWrapper.replaceAll(scopeSelector, rre, '\\]');
                        return RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
                    }
                }, {
                    key: '_applySelectorScope',
                    value: function _applySelectorScope(selector, scopeSelector, hostSelector) {
                        // Difference from webcomponentsjs: scopeSelector could not be an array
                        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
                    }
                }, {
                    key: '_applySimpleSelectorScope',

                    // scope via name and [is=name]
                    value: function _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
                        if (isPresent(RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
                            var replaceBy = this.strictStyling ? '[' + hostSelector + ']' : scopeSelector;
                            selector = StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
                            return StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
                        } else {
                            return scopeSelector + ' ' + selector;
                        }
                    }
                }, {
                    key: '_applyStrictSelectorScope',

                    // return a selector with [name] suffix on each simple selector
                    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]
                    value: function _applyStrictSelectorScope(selector, scopeSelector) {
                        var isRe = RegExpWrapper.create('\\[is=([^\\]]*)\\]');
                        scopeSelector = StringWrapper.replaceAllMapped(scopeSelector, isRe, function (m) {
                            return m[1];
                        });
                        var splits = [' ', '>', '+', '~'],
                            scoped = selector,
                            attrName = '[' + scopeSelector + ']';
                        for (var i = 0; i < splits.length; i++) {
                            var sep = splits[i];
                            var parts = scoped.split(sep);
                            scoped = ListWrapper.map(parts, function (p) {
                                // remove :host since it should be unnecessary
                                var t = StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                                if (t.length > 0 && !ListWrapper.contains(splits, t) && !StringWrapper.contains(t, attrName)) {
                                    var re = RegExpWrapper.create('([^:]*)(:*)(.*)');
                                    var m = RegExpWrapper.firstMatch(re, t);
                                    if (isPresent(m)) {
                                        p = m[1] + attrName + m[2] + m[3];
                                    }
                                }
                                return p;
                            }).join(sep);
                        }
                        return scoped;
                    }
                }, {
                    key: '_insertPolyfillHostInCssText',
                    value: function _insertPolyfillHostInCssText(selector) {
                        selector = StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
                        selector = StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
                        return selector;
                    }
                }, {
                    key: '_propertiesFromRule',
                    value: function _propertiesFromRule(rule) {
                        var cssText = rule.style.cssText;
                        // TODO(sorvell): Safari cssom incorrectly removes quotes from the content
                        // property. (https://bugs.webkit.org/show_bug.cgi?id=118045)
                        // don't replace attr rules
                        var attrRe = RegExpWrapper.create('[\'"]+|attr');
                        if (rule.style.content.length > 0 && !isPresent(RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
                            var contentRe = RegExpWrapper.create('content:[^;]*;');
                            cssText = StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
                        }
                        // TODO(sorvell): we can workaround this issue here, but we need a list
                        // of troublesome properties to fix https://github.com/Polymer/platform/issues/53
                        //
                        // inherit rules can be omitted from cssText
                        // TODO(sorvell): remove when Blink bug is fixed:
                        // https://code.google.com/p/chromium/issues/detail?id=358273
                        // var style = rule.style;
                        // for (var i = 0; i < style.length; i++) {
                        //  var name = style.item(i);
                        //  var value = style.getPropertyValue(name);
                        //  if (value == 'initial') {
                        //    cssText += name + ': initial; ';
                        //  }
                        //}
                        return cssText;
                    }
                }]);

                return ShadowCss;
            })();

            _export('ShadowCss', ShadowCss);

            _cssContentNextSelectorRe = RegExpWrapper.create('polyfill-next-selector[^}]*content:[\\s]*?[\'"](.*?)[\'"][;\\s]*}([^{]*?){', 'im');
            _cssContentRuleRe = RegExpWrapper.create('(polyfill-rule)[^}]*(content:[\\s]*[\'"](.*?)[\'"])[;\\s]*[^}]*}', 'im');
            _cssContentUnscopedRuleRe = RegExpWrapper.create('(polyfill-unscoped-rule)[^}]*(content:[\\s]*[\'"](.*?)[\'"])[;\\s]*[^}]*}', 'im');
            _polyfillHost = '-shadowcsshost';

            // note: :host-context pre-processed to -shadowcsshostcontext.
            _polyfillHostContext = '-shadowcsscontext';
            _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
            _cssColonHostRe = RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
            _cssColonHostContextRe = RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
            _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
            _shadowDOMSelectorsRe = [RegExpWrapper.create('>>>'), RegExpWrapper.create('::shadow'), RegExpWrapper.create('::content'),
            // Deprecated selectors
            RegExpWrapper.create('/deep/'), RegExpWrapper.create('/shadow-deep/'), RegExpWrapper.create('/shadow/')];
            _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
            _polyfillHostRe = RegExpWrapper.create(_polyfillHost, 'im');
            _colonHostRe = RegExpWrapper.create(':host', 'im');
            _colonHostContextRe = RegExpWrapper.create(':host-context', 'im');
        }
    };
});
System.register("angular2/src/services/xhr_impl", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/async", "angular2/src/services/xhr"], function (_export) {
    var _inherits, _createClass, _classCallCheck, Injectable, PromiseWrapper, XHR, __decorate, __metadata, XHRImpl;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcServicesXhr) {
            XHR = _angular2SrcServicesXhr.XHR;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            XHRImpl = (function (_XHR) {
                var _class = function XHRImpl() {
                    _classCallCheck(this, _class);

                    if (_XHR != null) {
                        _XHR.apply(this, arguments);
                    }
                };

                _inherits(_class, _XHR);

                _createClass(_class, [{
                    key: "get",
                    value: function get(url) {
                        var completer = PromiseWrapper.completer();
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", url, true);
                        xhr.responseType = "text";
                        xhr.onload = function () {
                            var status = xhr.status;
                            if (200 <= status && status <= 300) {
                                completer.resolve(xhr.responseText);
                            } else {
                                completer.reject("Failed to load " + url, null);
                            }
                        };
                        xhr.onerror = function () {
                            completer.reject("Failed to load " + url, null);
                        };
                        xhr.send();
                        return completer.promise;
                    }
                }]);

                return _class;
            })(XHR);

            _export("XHRImpl", XHRImpl);

            _export("XHRImpl", XHRImpl = __decorate([Injectable(), __metadata("design:paramtypes", [])], XHRImpl));
            
        }
    };
});
System.register('angular2/src/render/dom/events/event_manager', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'angular2/src/facade/lang', 'angular2/src/dom/dom_adapter'], function (_export) {
    var _createClass, _classCallCheck, _inherits, BaseException, StringWrapper, DOM, BUBBLE_SYMBOL, EventManager, EventManagerPlugin, DomEventsPlugin;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }],
        execute: function () {
            'use strict';

            BUBBLE_SYMBOL = '^';

            EventManager = (function () {
                function EventManager(plugins, zone) {
                    _classCallCheck(this, EventManager);

                    this._zone = zone;
                    this._plugins = plugins;
                    for (var i = 0; i < plugins.length; i++) {
                        plugins[i].manager = this;
                    }
                }

                _createClass(EventManager, [{
                    key: 'addEventListener',
                    value: function addEventListener(element, eventName, handler) {
                        var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
                        var plugin = this._findPluginFor(withoutBubbleSymbol);
                        plugin.addEventListener(element, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
                    }
                }, {
                    key: 'addGlobalEventListener',
                    value: function addGlobalEventListener(target, eventName, handler) {
                        var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
                        var plugin = this._findPluginFor(withoutBubbleSymbol);
                        return plugin.addGlobalEventListener(target, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
                    }
                }, {
                    key: 'getZone',
                    value: function getZone() {
                        return this._zone;
                    }
                }, {
                    key: '_findPluginFor',
                    value: function _findPluginFor(eventName) {
                        var plugins = this._plugins;
                        for (var i = 0; i < plugins.length; i++) {
                            var plugin = plugins[i];
                            if (plugin.supports(eventName)) {
                                return plugin;
                            }
                        }
                        throw new BaseException('No event manager plugin found for event ' + eventName);
                    }
                }, {
                    key: '_removeBubbleSymbol',
                    value: function _removeBubbleSymbol(eventName) {
                        return eventName[0] == BUBBLE_SYMBOL ? StringWrapper.substring(eventName, 1) : eventName;
                    }
                }]);

                return EventManager;
            })();

            _export('EventManager', EventManager);

            EventManagerPlugin = (function () {
                function EventManagerPlugin() {
                    _classCallCheck(this, EventManagerPlugin);
                }

                _createClass(EventManagerPlugin, [{
                    key: 'supports',

                    // We are assuming here that all plugins support bubbled and non-bubbled events.
                    // That is equivalent to having supporting $event.target
                    // The bubbling flag (currently ^) is stripped before calling the supports and
                    // addEventListener methods.
                    value: function supports(eventName) {
                        return false;
                    }
                }, {
                    key: 'addEventListener',
                    value: function addEventListener(element, eventName, handler, shouldSupportBubble) {
                        throw 'not implemented';
                    }
                }, {
                    key: 'addGlobalEventListener',
                    value: function addGlobalEventListener(element, eventName, handler, shouldSupportBubble) {
                        throw 'not implemented';
                    }
                }]);

                return EventManagerPlugin;
            })();

            _export('EventManagerPlugin', EventManagerPlugin);

            DomEventsPlugin = (function (_EventManagerPlugin) {
                function DomEventsPlugin() {
                    _classCallCheck(this, DomEventsPlugin);

                    if (_EventManagerPlugin != null) {
                        _EventManagerPlugin.apply(this, arguments);
                    }
                }

                _inherits(DomEventsPlugin, _EventManagerPlugin);

                _createClass(DomEventsPlugin, [{
                    key: 'supports',

                    // This plugin should come last in the list of plugins, because it accepts all
                    // events.
                    value: function supports(eventName) {
                        return true;
                    }
                }, {
                    key: 'addEventListener',
                    value: function addEventListener(element, eventName, handler, shouldSupportBubble) {
                        var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
                        this.manager._zone.runOutsideAngular(function () {
                            DOM.on(element, eventName, outsideHandler);
                        });
                    }
                }, {
                    key: 'addGlobalEventListener',
                    value: function addGlobalEventListener(target, eventName, handler, shouldSupportBubble) {
                        var element = DOM.getGlobalEventTarget(target);
                        var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
                        return this.manager._zone.runOutsideAngular(function () {
                            return DOM.onAndCancel(element, eventName, outsideHandler);
                        });
                    }
                }, {
                    key: '_getOutsideHandler',
                    value: function _getOutsideHandler(shouldSupportBubble, element, handler, zone) {
                        return shouldSupportBubble ? DomEventsPlugin.bubbleCallback(element, handler, zone) : DomEventsPlugin.sameElementCallback(element, handler, zone);
                    }
                }], [{
                    key: 'sameElementCallback',
                    value: function sameElementCallback(element, handler, zone) {
                        return function (event) {
                            if (event.target === element) {
                                zone.run(function () {
                                    return handler(event);
                                });
                            }
                        };
                    }
                }, {
                    key: 'bubbleCallback',
                    value: function bubbleCallback(element, handler, zone) {
                        return function (event) {
                            return zone.run(function () {
                                return handler(event);
                            });
                        };
                    }
                }]);

                return DomEventsPlugin;
            })(EventManagerPlugin);

            _export('DomEventsPlugin', DomEventsPlugin);
        }
    };
});


System.register('angular2/src/render/dom/events/key_events', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/render/dom/events/event_manager'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, DOM, isPresent, StringWrapper, StringMapWrapper, ListWrapper, EventManagerPlugin, modifierKeys, modifierKeyGetters, KeyEventsPlugin;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcRenderDomEventsEvent_manager) {
            EventManagerPlugin = _angular2SrcRenderDomEventsEvent_manager.EventManagerPlugin;
        }],
        execute: function () {
            'use strict';

            modifierKeys = ['alt', 'control', 'meta', 'shift'];
            modifierKeyGetters = {
                'alt': function alt(event) {
                    return event.altKey;
                },
                'control': function control(event) {
                    return event.ctrlKey;
                },
                'meta': function meta(event) {
                    return event.metaKey;
                },
                'shift': function shift(event) {
                    return event.shiftKey;
                }
            };

            KeyEventsPlugin = (function (_EventManagerPlugin) {
                function KeyEventsPlugin() {
                    _classCallCheck(this, KeyEventsPlugin);

                    _get(Object.getPrototypeOf(KeyEventsPlugin.prototype), 'constructor', this).call(this);
                }

                _inherits(KeyEventsPlugin, _EventManagerPlugin);

                _createClass(KeyEventsPlugin, [{
                    key: 'supports',
                    value: function supports(eventName) {
                        return isPresent(KeyEventsPlugin.parseEventName(eventName));
                    }
                }, {
                    key: 'addEventListener',
                    value: function addEventListener(element, eventName, handler, shouldSupportBubble) {
                        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
                        var outsideHandler = KeyEventsPlugin.eventCallback(element, shouldSupportBubble, StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
                        this.manager.getZone().runOutsideAngular(function () {
                            DOM.on(element, StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
                        });
                    }
                }], [{
                    key: 'parseEventName',
                    value: function parseEventName(eventName) {
                        var parts = eventName.toLowerCase().split('.');
                        var domEventName = ListWrapper.removeAt(parts, 0);
                        if (parts.length === 0 || !(StringWrapper.equals(domEventName, 'keydown') || StringWrapper.equals(domEventName, 'keyup'))) {
                            return null;
                        }
                        var key = KeyEventsPlugin._normalizeKey(ListWrapper.removeLast(parts));
                        var fullKey = '';
                        ListWrapper.forEach(modifierKeys, function (modifierName) {
                            if (ListWrapper.contains(parts, modifierName)) {
                                ListWrapper.remove(parts, modifierName);
                                fullKey += modifierName + '.';
                            }
                        });
                        fullKey += key;
                        if (parts.length != 0 || key.length === 0) {
                            // returning null instead of throwing to let another plugin process the event
                            return null;
                        }
                        return { 'domEventName': domEventName, 'fullKey': fullKey };
                    }
                }, {
                    key: 'getEventFullKey',
                    value: function getEventFullKey(event) {
                        var fullKey = '';
                        var key = DOM.getEventKey(event);
                        key = key.toLowerCase();
                        if (StringWrapper.equals(key, ' ')) {
                            key = 'space'; // for readability
                        } else if (StringWrapper.equals(key, '.')) {
                            key = 'dot'; // because '.' is used as a separator in event names
                        }
                        ListWrapper.forEach(modifierKeys, function (modifierName) {
                            if (modifierName != key) {
                                var modifierGetter = StringMapWrapper.get(modifierKeyGetters, modifierName);
                                if (modifierGetter(event)) {
                                    fullKey += modifierName + '.';
                                }
                            }
                        });
                        fullKey += key;
                        return fullKey;
                    }
                }, {
                    key: 'eventCallback',
                    value: function eventCallback(element, shouldSupportBubble, fullKey, handler, zone) {
                        return function (event) {
                            var correctElement = shouldSupportBubble || event.target === element;
                            if (correctElement && KeyEventsPlugin.getEventFullKey(event) === fullKey) {
                                zone.run(function () {
                                    return handler(event);
                                });
                            }
                        };
                    }
                }, {
                    key: '_normalizeKey',
                    value: function _normalizeKey(keyName) {
                        // TODO: switch to a StringMap if the mapping grows too much
                        switch (keyName) {
                            case 'esc':
                                return 'escape';
                            default:
                                return keyName;
                        }
                    }
                }]);

                return KeyEventsPlugin;
            })(EventManagerPlugin);

            _export('KeyEventsPlugin', KeyEventsPlugin);
        }
    };
});


System.register('angular2/src/render/dom/events/hammer_common', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/render/dom/events/event_manager', 'angular2/src/facade/collection'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, EventManagerPlugin, StringMapWrapper, _eventNames, HammerGesturesPluginCommon;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcRenderDomEventsEvent_manager) {
            EventManagerPlugin = _angular2SrcRenderDomEventsEvent_manager.EventManagerPlugin;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }],
        execute: function () {
            'use strict';

            _eventNames = {
                // pan
                'pan': true,
                'panstart': true,
                'panmove': true,
                'panend': true,
                'pancancel': true,
                'panleft': true,
                'panright': true,
                'panup': true,
                'pandown': true,
                // pinch
                'pinch': true,
                'pinchstart': true,
                'pinchmove': true,
                'pinchend': true,
                'pinchcancel': true,
                'pinchin': true,
                'pinchout': true,
                // press
                'press': true,
                'pressup': true,
                // rotate
                'rotate': true,
                'rotatestart': true,
                'rotatemove': true,
                'rotateend': true,
                'rotatecancel': true,
                // swipe
                'swipe': true,
                'swipeleft': true,
                'swiperight': true,
                'swipeup': true,
                'swipedown': true,
                // tap
                'tap': true };

            HammerGesturesPluginCommon = (function (_EventManagerPlugin) {
                function HammerGesturesPluginCommon() {
                    _classCallCheck(this, HammerGesturesPluginCommon);

                    _get(Object.getPrototypeOf(HammerGesturesPluginCommon.prototype), 'constructor', this).call(this);
                }

                _inherits(HammerGesturesPluginCommon, _EventManagerPlugin);

                _createClass(HammerGesturesPluginCommon, [{
                    key: 'supports',
                    value: function supports(eventName) {
                        eventName = eventName.toLowerCase();
                        return StringMapWrapper.contains(_eventNames, eventName);
                    }
                }]);

                return HammerGesturesPluginCommon;
            })(EventManagerPlugin);

            _export('HammerGesturesPluginCommon', HammerGesturesPluginCommon);
        }
    };
});


System.register("angular2/src/render/dom/shadow_dom/style_url_resolver", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/services/url_resolver"], function (_export) {
    var _createClass, _classCallCheck, Injectable, RegExpWrapper, StringWrapper, UrlResolver, __decorate, __metadata, StyleUrlResolver, _cssUrlRe, _cssImportRe, _quoteRe;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcServicesUrl_resolver) {
            UrlResolver = _angular2SrcServicesUrl_resolver.UrlResolver;
        }],
        execute: function () {
            // Some of the code comes from WebComponents.JS
            // https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Rewrites URLs by resolving '@import' and 'url()' URLs from the given base URL.
             */

            StyleUrlResolver = (function () {
                var _class = function StyleUrlResolver(resolver) {
                    _classCallCheck(this, _class);

                    this._resolver = resolver;
                };

                _createClass(_class, [{
                    key: "resolveUrls",
                    value: function resolveUrls(cssText, baseUrl) {
                        cssText = this._replaceUrls(cssText, _cssUrlRe, baseUrl);
                        cssText = this._replaceUrls(cssText, _cssImportRe, baseUrl);
                        return cssText;
                    }
                }, {
                    key: "_replaceUrls",
                    value: function _replaceUrls(cssText, re, baseUrl) {
                        var _this = this;

                        return StringWrapper.replaceAllMapped(cssText, re, function (m) {
                            var pre = m[1];
                            var url = StringWrapper.replaceAll(m[2], _quoteRe, "");
                            var post = m[3];
                            var resolvedUrl = _this._resolver.resolve(baseUrl, url);
                            return pre + "'" + resolvedUrl + "'" + post;
                        });
                    }
                }]);

                return _class;
            })();

            _export("StyleUrlResolver", StyleUrlResolver);

            _export("StyleUrlResolver", StyleUrlResolver = __decorate([Injectable(), __metadata("design:paramtypes", [UrlResolver])], StyleUrlResolver));
            _cssUrlRe = RegExpWrapper.create("(url\\()([^)]*)(\\))");
            _cssImportRe = RegExpWrapper.create("(@import[\\s]+(?!url\\())['\"]([^'\"]*)['\"](.*;)");
            _quoteRe = RegExpWrapper.create("['\"]");

            
        }
    };
});
System.register("angular2/src/render/dom/shadow_dom/style_inliner", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/services/xhr", "angular2/src/facade/collection", "angular2/src/services/url_resolver", "angular2/src/render/dom/shadow_dom/style_url_resolver", "angular2/src/facade/lang", "angular2/src/facade/async"], function (_export) {
    var _createClass, _classCallCheck, Injectable, XHR, ListWrapper, UrlResolver, StyleUrlResolver, isBlank, isPresent, RegExpWrapper, StringWrapper, PromiseWrapper, __decorate, __metadata, StyleInliner, _importRe, _urlRe, _mediaQueryRe;

    // Extracts the url from an import rule, supported formats:
    // - 'url' / "url",
    // - url(url) / url('url') / url("url")
    function _extractUrl(importRule) {
        var match = RegExpWrapper.firstMatch(_urlRe, importRule);
        if (isBlank(match)) return null;
        return isPresent(match[1]) ? match[1] : match[2];
    }
    // Extracts the media query from an import rule.
    // Returns null when there is no media query.
    function _extractMediaQuery(importRule) {
        var match = RegExpWrapper.firstMatch(_mediaQueryRe, importRule);
        if (isBlank(match)) return null;
        var mediaQuery = match[1].trim();
        return mediaQuery.length > 0 ? mediaQuery : null;
    }
    // Wraps the css in a media rule when the media query is not null
    function _wrapInMediaRule(css, query) {
        return isBlank(query) ? css : "@media " + query + " {\n" + css + "\n}";
    }
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcServicesXhr) {
            XHR = _angular2SrcServicesXhr.XHR;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcServicesUrl_resolver) {
            UrlResolver = _angular2SrcServicesUrl_resolver.UrlResolver;
        }, function (_angular2SrcRenderDomShadow_domStyle_url_resolver) {
            StyleUrlResolver = _angular2SrcRenderDomShadow_domStyle_url_resolver.StyleUrlResolver;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Inline @import rules in the given CSS.
             *
             * When an @import rules is inlined, it's url are rewritten.
             */

            StyleInliner = (function () {
                var _class = function StyleInliner(xhr, styleUrlResolver, urlResolver) {
                    _classCallCheck(this, _class);

                    this._xhr = xhr;
                    this._urlResolver = urlResolver;
                    this._styleUrlResolver = styleUrlResolver;
                };

                _createClass(_class, [{
                    key: "inlineImports",

                    /**
                     * Inline the @imports rules in the given CSS text.
                     *
                     * The baseUrl is required to rewrite URLs in the inlined content.
                     *
                     * @param {string} cssText
                     * @param {string} baseUrl
                     * @returns {*} a Promise<string> when @import rules are present, a string otherwise
                     */
                    value: function inlineImports(cssText, baseUrl) {
                        return this._inlineImports(cssText, baseUrl, []);
                    }
                }, {
                    key: "_inlineImports",
                    value: function _inlineImports(cssText, baseUrl, inlinedUrls) {
                        var _this = this;

                        var partIndex = 0;
                        var parts = StringWrapper.split(cssText, _importRe);
                        if (parts.length === 1) {
                            // no @import rule found, return the original css
                            return cssText;
                        }
                        var promises = [];
                        while (partIndex < parts.length - 1) {
                            // prefix is the content before the @import rule
                            var prefix = parts[partIndex];
                            // rule is the parameter of the @import rule
                            var rule = parts[partIndex + 1];
                            var url = _extractUrl(rule);
                            if (isPresent(url)) {
                                url = this._urlResolver.resolve(baseUrl, url);
                            }
                            var mediaQuery = _extractMediaQuery(rule);
                            var promise;
                            if (isBlank(url)) {
                                promise = PromiseWrapper.resolve("/* Invalid import rule: \"@import " + rule + ";\" */");
                            } else if (ListWrapper.contains(inlinedUrls, url)) {
                                // The current import rule has already been inlined, return the prefix only
                                // Importing again might cause a circular dependency
                                promise = PromiseWrapper.resolve(prefix);
                            } else {
                                ListWrapper.push(inlinedUrls, url);
                                promise = PromiseWrapper.then(this._xhr.get(url), function (rawCss) {
                                    // resolve nested @import rules
                                    var inlinedCss = _this._inlineImports(rawCss, url, inlinedUrls);
                                    if (PromiseWrapper.isPromise(inlinedCss)) {
                                        // wait until nested @import are inlined
                                        return inlinedCss.then(function (css) {
                                            return prefix + _this._transformImportedCss(css, mediaQuery, url) + "\n";
                                        });
                                    } else {
                                        // there are no nested @import, return the css
                                        return prefix + _this._transformImportedCss(inlinedCss, mediaQuery, url) + "\n";
                                    }
                                }, function (error) {
                                    return "/* failed to import " + url + " */\n";
                                });
                            }
                            ListWrapper.push(promises, promise);
                            partIndex += 2;
                        }
                        return PromiseWrapper.all(promises).then(function (cssParts) {
                            var cssText = cssParts.join("");
                            if (partIndex < parts.length) {
                                // append then content located after the last @import rule
                                cssText += parts[partIndex];
                            }
                            return cssText;
                        });
                    }
                }, {
                    key: "_transformImportedCss",
                    value: function _transformImportedCss(css, mediaQuery, url) {
                        css = this._styleUrlResolver.resolveUrls(css, url);
                        return _wrapInMediaRule(css, mediaQuery);
                    }
                }]);

                return _class;
            })();

            _export("StyleInliner", StyleInliner);

            _export("StyleInliner", StyleInliner = __decorate([Injectable(), __metadata("design:paramtypes", [XHR, StyleUrlResolver, UrlResolver])], StyleInliner));_importRe = RegExpWrapper.create("@import\\s+([^;]+);");
            _urlRe = RegExpWrapper.create("url\\(\\s*?['\"]?([^'\")]+)['\"]?|" + "['\"]([^'\")]+)['\"]" // "url" or 'url'
            );
            _mediaQueryRe = RegExpWrapper.create("['\"][^'\"]+['\"]\\s*\\)?\\s*(.*)");

            
        }
    };
});
System.register("angular2/src/core/compiler/dynamic_component_loader", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/core/compiler/compiler", "angular2/src/facade/lang", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/element_ref"], function (_export) {
    var _createClass, _classCallCheck, Binding, bind, Injectable, Compiler, BaseException, AppViewManager, ElementRef, __decorate, __metadata, ComponentRef, DynamicComponentLoader;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Binding = _angular2Di.Binding;
            bind = _angular2Di.bind;
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcCoreCompilerCompiler) {
            Compiler = _angular2SrcCoreCompilerCompiler.Compiler;
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_angular2SrcCoreCompilerElement_ref) {
            ElementRef = _angular2SrcCoreCompilerElement_ref.ElementRef;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * @exportedAs angular2/view
             */

            ComponentRef = (function () {
                function ComponentRef(location, instance, dispose) {
                    _classCallCheck(this, ComponentRef);

                    this.location = location;
                    this.instance = instance;
                    this.dispose = dispose;
                }

                _createClass(ComponentRef, [{
                    key: "hostView",
                    get: function () {
                        return this.location.parentView;
                    }
                }]);

                return ComponentRef;
            })();

            _export("ComponentRef", ComponentRef);

            /**
             * Service for dynamically loading a Component into an arbitrary position in the internal Angular
             * application tree.
             *
             * @exportedAs angular2/view
             */

            DynamicComponentLoader = (function () {
                var _class = function DynamicComponentLoader(compiler, viewManager) {
                    _classCallCheck(this, _class);

                    this._compiler = compiler;
                    this._viewManager = viewManager;
                };

                _createClass(_class, [{
                    key: "loadIntoExistingLocation",

                    /**
                     * Loads a component into the location given by the provided ElementRef. The loaded component
                     * receives injection as if it in the place of the provided ElementRef.
                     */
                    value: function loadIntoExistingLocation(typeOrBinding, location) {
                        var _this = this;

                        var injector = arguments[2] === undefined ? null : arguments[2];

                        var binding = this._getBinding(typeOrBinding);
                        return this._compiler.compile(binding.token).then(function (componentProtoViewRef) {
                            _this._viewManager.createDynamicComponentView(location, componentProtoViewRef, binding, injector);
                            var component = _this._viewManager.getComponent(location);
                            var dispose = function dispose() {
                                throw new BaseException("Not implemented");
                            };
                            return new ComponentRef(location, component, dispose);
                        });
                    }
                }, {
                    key: "loadAsRoot",

                    /**
                     * Loads a root component that is placed at the first element that matches the
                     * component's selector.
                     * The loaded component receives injection normally as a hosted view.
                     */
                    value: function loadAsRoot(typeOrBinding) {
                        var _this2 = this;

                        var overrideSelector = arguments[1] === undefined ? null : arguments[1];
                        var injector = arguments[2] === undefined ? null : arguments[2];

                        return this._compiler.compileInHost(this._getBinding(typeOrBinding)).then(function (hostProtoViewRef) {
                            var hostViewRef = _this2._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
                            var newLocation = new ElementRef(hostViewRef, 0);
                            var component = _this2._viewManager.getComponent(newLocation);
                            var dispose = function dispose() {
                                _this2._viewManager.destroyRootHostView(hostViewRef);
                            };
                            return new ComponentRef(newLocation, component, dispose);
                        });
                    }
                }, {
                    key: "loadIntoNewLocation",

                    /**
                     * Loads a component into a free host view that is not yet attached to
                     * a parent on the render side, although it is attached to a parent in the injector hierarchy.
                     * The loaded component receives injection normally as a hosted view.
                     */
                    value: function loadIntoNewLocation(typeOrBinding, parentComponentLocation) {
                        var _this3 = this;

                        var injector = arguments[2] === undefined ? null : arguments[2];

                        return this._compiler.compileInHost(this._getBinding(typeOrBinding)).then(function (hostProtoViewRef) {
                            var hostViewRef = _this3._viewManager.createFreeHostView(parentComponentLocation, hostProtoViewRef, injector);
                            var newLocation = new ElementRef(hostViewRef, 0);
                            var component = _this3._viewManager.getComponent(newLocation);
                            var dispose = function dispose() {
                                _this3._viewManager.destroyFreeHostView(parentComponentLocation, hostViewRef);
                            };
                            return new ComponentRef(newLocation, component, dispose);
                        });
                    }
                }, {
                    key: "loadNextToExistingLocation",

                    /**
                     * Loads a component next to the provided ElementRef. The loaded component receives
                     * injection normally as a hosted view.
                     */
                    value: function loadNextToExistingLocation(typeOrBinding, location) {
                        var _this4 = this;

                        var injector = arguments[2] === undefined ? null : arguments[2];

                        var binding = this._getBinding(typeOrBinding);
                        return this._compiler.compileInHost(binding).then(function (hostProtoViewRef) {
                            var viewContainer = _this4._viewManager.getViewContainer(location);
                            var hostViewRef = viewContainer.create(hostProtoViewRef, viewContainer.length, null, injector);
                            var newLocation = new ElementRef(hostViewRef, 0);
                            var component = _this4._viewManager.getComponent(newLocation);
                            var dispose = function dispose() {
                                var index = viewContainer.indexOf(hostViewRef);
                                viewContainer.remove(index);
                            };
                            return new ComponentRef(newLocation, component, dispose);
                        });
                    }
                }, {
                    key: "_getBinding",
                    value: function _getBinding(typeOrBinding) {
                        var binding;
                        if (typeOrBinding instanceof Binding) {
                            binding = typeOrBinding;
                        } else {
                            binding = bind(typeOrBinding).toClass(typeOrBinding);
                        }
                        return binding;
                    }
                }]);

                return _class;
            })();

            _export("DynamicComponentLoader", DynamicComponentLoader);

            _export("DynamicComponentLoader", DynamicComponentLoader = __decorate([Injectable(), __metadata("design:paramtypes", [Compiler, AppViewManager])], DynamicComponentLoader));
            
        }
    };
});
System.register('angular2/src/core/testability/get_testability', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, global, PublicTestability, GetTestability;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            global = _angular2SrcFacadeLang.global;
        }],
        execute: function () {
            'use strict';

            PublicTestability = (function () {
                function PublicTestability(testability) {
                    _classCallCheck(this, PublicTestability);

                    this._testability = testability;
                }

                _createClass(PublicTestability, [{
                    key: 'whenStable',
                    value: function whenStable(callback) {
                        this._testability.whenStable(callback);
                    }
                }, {
                    key: 'findBindings',
                    value: function findBindings(using, binding, exactMatch) {
                        return this._testability.findBindings(using, binding, exactMatch);
                    }
                }]);

                return PublicTestability;
            })();

            GetTestability = (function () {
                function GetTestability() {
                    _classCallCheck(this, GetTestability);
                }

                _createClass(GetTestability, null, [{
                    key: 'addToWindow',
                    value: function addToWindow(registry) {
                        global.getAngularTestability = function (elem) {
                            var testability = registry.findTestabilityInTree(elem);
                            if (testability == null) {
                                throw new Error('Could not find testability for element.');
                            }
                            return new PublicTestability(testability);
                        };
                    }
                }]);

                return GetTestability;
            })();

            _export('GetTestability', GetTestability);
        }
    };
});


System.register('angular2/src/render/dom/shadow_dom/content_tag', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, DOM, isPresent, ListWrapper, ContentStrategy, RenderedContent, IntermediateContent, Content;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            'use strict';

            ContentStrategy = (function () {
                function ContentStrategy() {
                    _classCallCheck(this, ContentStrategy);
                }

                _createClass(ContentStrategy, [{
                    key: 'insert',
                    value: function insert(nodes) {}
                }]);

                return ContentStrategy;
            })();

            /**
             * An implementation of the content tag that is used by transcluding components.
             * It is used when the content tag is not a direct child of another component,
             * and thus does not affect redistribution.
             */

            RenderedContent = (function (_ContentStrategy) {
                function RenderedContent(contentEl) {
                    _classCallCheck(this, RenderedContent);

                    _get(Object.getPrototypeOf(RenderedContent.prototype), 'constructor', this).call(this);
                    this.beginScript = contentEl;
                    this.endScript = DOM.nextSibling(this.beginScript);
                    this.nodes = [];
                }

                _inherits(RenderedContent, _ContentStrategy);

                _createClass(RenderedContent, [{
                    key: 'insert',

                    // Inserts the nodes in between the start and end scripts.
                    // Previous content is removed.
                    value: function insert(nodes) {
                        this.nodes = nodes;
                        DOM.insertAllBefore(this.endScript, nodes);
                        this._removeNodesUntil(ListWrapper.isEmpty(nodes) ? this.endScript : nodes[0]);
                    }
                }, {
                    key: '_removeNodesUntil',
                    value: function _removeNodesUntil(node) {
                        var p = DOM.parentElement(this.beginScript);
                        for (var next = DOM.nextSibling(this.beginScript); next !== node; next = DOM.nextSibling(this.beginScript)) {
                            DOM.removeChild(p, next);
                        }
                    }
                }]);

                return RenderedContent;
            })(ContentStrategy);

            /**
             * An implementation of the content tag that is used by transcluding components.
             * It is used when the content tag is a direct child of another component,
             * and thus does not get rendered but only affect the distribution of its parent component.
             */

            IntermediateContent = (function (_ContentStrategy2) {
                function IntermediateContent(destinationLightDom) {
                    _classCallCheck(this, IntermediateContent);

                    _get(Object.getPrototypeOf(IntermediateContent.prototype), 'constructor', this).call(this);
                    this.nodes = [];
                    this.destinationLightDom = destinationLightDom;
                }

                _inherits(IntermediateContent, _ContentStrategy2);

                _createClass(IntermediateContent, [{
                    key: 'insert',
                    value: function insert(nodes) {
                        this.nodes = nodes;
                        this.destinationLightDom.redistribute();
                    }
                }]);

                return IntermediateContent;
            })(ContentStrategy);

            Content = (function () {
                function Content(contentStartEl, selector) {
                    _classCallCheck(this, Content);

                    this.select = selector;
                    this.contentStartElement = contentStartEl;
                    this._strategy = null;
                }

                _createClass(Content, [{
                    key: 'init',
                    value: function init(destinationLightDom) {
                        this._strategy = isPresent(destinationLightDom) ? new IntermediateContent(destinationLightDom) : new RenderedContent(this.contentStartElement);
                    }
                }, {
                    key: 'nodes',
                    value: function nodes() {
                        return this._strategy.nodes;
                    }
                }, {
                    key: 'insert',
                    value: function insert(nodes) {
                        this._strategy.insert(nodes);
                    }
                }]);

                return Content;
            })();

            _export('Content', Content);
        }
    };
});


System.register('angular2/src/render/dom/util', ['angular2/src/facade/lang'], function (_export) {
    'use strict';

    var StringWrapper, RegExpWrapper, NG_BINDING_CLASS_SELECTOR, NG_BINDING_CLASS, EVENT_TARGET_SEPARATOR, CAMEL_CASE_REGEXP, DASH_CASE_REGEXP;

    _export('camelCaseToDashCase', camelCaseToDashCase);

    _export('dashCaseToCamelCase', dashCaseToCamelCase);

    function camelCaseToDashCase(input) {
        return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) {
            return '-' + m[1].toLowerCase();
        });
    }

    function dashCaseToCamelCase(input) {
        return StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) {
            return m[1].toUpperCase();
        });
    }
    

    return {
        setters: [function (_angular2SrcFacadeLang) {
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
        }],
        execute: function () {
            NG_BINDING_CLASS_SELECTOR = '.ng-binding';

            _export('NG_BINDING_CLASS_SELECTOR', NG_BINDING_CLASS_SELECTOR);

            NG_BINDING_CLASS = 'ng-binding';

            _export('NG_BINDING_CLASS', NG_BINDING_CLASS);

            EVENT_TARGET_SEPARATOR = ':';

            _export('EVENT_TARGET_SEPARATOR', EVENT_TARGET_SEPARATOR);

            CAMEL_CASE_REGEXP = RegExpWrapper.create('([A-Z])');
            DASH_CASE_REGEXP = RegExpWrapper.create('-([a-z])');
        }
    };
});
System.register('angular2/src/render/dom/view/view_container', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, ListWrapper, DomViewContainer;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            'use strict';

            DomViewContainer = (function () {
                function DomViewContainer() {
                    _classCallCheck(this, DomViewContainer);

                    // The order in this list matches the DOM order.
                    this.views = [];
                }

                _createClass(DomViewContainer, [{
                    key: 'contentTagContainers',
                    value: function contentTagContainers() {
                        return this.views;
                    }
                }, {
                    key: 'nodes',
                    value: function nodes() {
                        var r = [];
                        for (var i = 0; i < this.views.length; ++i) {
                            r = ListWrapper.concat(r, this.views[i].rootNodes);
                        }
                        return r;
                    }
                }]);

                return DomViewContainer;
            })();

            _export('DomViewContainer', DomViewContainer);
        }
    };
});


System.register('angular2/src/render/dom/compiler/compile_element', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, ListWrapper, MapWrapper, DOM, isBlank, isPresent, StringJoiner, assertionsEnabled, CompileElement;

    // return an HTML representation of an element start tag - without its content
    // this is used to give contextual information in case of errors
    function getElementDescription(domElement) {
        var buf = new StringJoiner();
        var atts = DOM.attributeMap(domElement);
        buf.add('<');
        buf.add(DOM.tagName(domElement).toLowerCase());
        // show id and class first to ease element identification
        addDescriptionAttribute(buf, 'id', MapWrapper.get(atts, 'id'));
        addDescriptionAttribute(buf, 'class', MapWrapper.get(atts, 'class'));
        MapWrapper.forEach(atts, function (attValue, attName) {
            if (attName !== 'id' && attName !== 'class') {
                addDescriptionAttribute(buf, attName, attValue);
            }
        });
        buf.add('>');
        return buf.toString();
    }
    function addDescriptionAttribute(buffer, attName, attValue) {
        if (isPresent(attValue)) {
            if (attValue.length === 0) {
                buffer.add(' ' + attName);
            } else {
                buffer.add(' ' + attName + '="' + attValue + '"');
            }
        }
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            StringJoiner = _angular2SrcFacadeLang.StringJoiner;
            assertionsEnabled = _angular2SrcFacadeLang.assertionsEnabled;
        }],
        execute: function () {
            'use strict';

            /**
             * Collects all data that is needed to process an element
             * in the compile process. Fields are filled
             * by the CompileSteps starting out with the pure HTMLElement.
             */

            CompileElement = (function () {
                // error

                function CompileElement(element) {
                    var compilationUnit = arguments[1] === undefined ? '' : arguments[1];

                    _classCallCheck(this, CompileElement);

                    this.element = element;
                    this._attrs = null;
                    this._classList = null;
                    this.isViewRoot = false;
                    // inherited down to children if they don't have
                    // an own protoView
                    this.inheritedProtoView = null;
                    // inherited down to children if they don't have
                    // an own elementBinder
                    this.inheritedElementBinder = null;
                    this.distanceToInheritedBinder = 0;
                    this.compileChildren = true;
                    // description is calculated here as compilation steps may change the element
                    var tplDesc = assertionsEnabled() ? getElementDescription(element) : null;
                    if (compilationUnit !== '') {
                        this.elementDescription = compilationUnit;
                        if (isPresent(tplDesc)) this.elementDescription += ': ' + tplDesc;
                    } else {
                        this.elementDescription = tplDesc;
                    }
                }

                _createClass(CompileElement, [{
                    key: 'isBound',
                    value: function isBound() {
                        return isPresent(this.inheritedElementBinder) && this.distanceToInheritedBinder === 0;
                    }
                }, {
                    key: 'bindElement',
                    value: function bindElement() {
                        if (!this.isBound()) {
                            var parentBinder = this.inheritedElementBinder;
                            this.inheritedElementBinder = this.inheritedProtoView.bindElement(this.element, this.elementDescription);
                            if (isPresent(parentBinder)) {
                                this.inheritedElementBinder.setParent(parentBinder, this.distanceToInheritedBinder);
                            }
                            this.distanceToInheritedBinder = 0;
                        }
                        return this.inheritedElementBinder;
                    }
                }, {
                    key: 'refreshAttrs',
                    value: function refreshAttrs() {
                        this._attrs = null;
                    }
                }, {
                    key: 'attrs',
                    value: function attrs() {
                        if (isBlank(this._attrs)) {
                            this._attrs = DOM.attributeMap(this.element);
                        }
                        return this._attrs;
                    }
                }, {
                    key: 'refreshClassList',
                    value: function refreshClassList() {
                        this._classList = null;
                    }
                }, {
                    key: 'classList',
                    value: function classList() {
                        if (isBlank(this._classList)) {
                            this._classList = ListWrapper.create();
                            var elClassList = DOM.classList(this.element);
                            for (var i = 0; i < elClassList.length; i++) {
                                ListWrapper.push(this._classList, elClassList[i]);
                            }
                        }
                        return this._classList;
                    }
                }]);

                return CompileElement;
            })();

            _export('CompileElement', CompileElement);
        }
    };
});
System.register('angular2/src/render/dom/compiler/compile_control', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, isBlank, ListWrapper, CompileControl;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            'use strict';

            /**
             * Controls the processing order of elements.
             * Right now it only allows to add a parent element.
             */

            CompileControl = (function () {
                function CompileControl(steps) {
                    _classCallCheck(this, CompileControl);

                    this._steps = steps;
                    this._currentStepIndex = 0;
                    this._parent = null;
                    this._results = null;
                    this._additionalChildren = null;
                }

                _createClass(CompileControl, [{
                    key: 'internalProcess',

                    // only public so that it can be used by compile_pipeline
                    value: function internalProcess(results, startStepIndex, parent, current) {
                        this._results = results;
                        var previousStepIndex = this._currentStepIndex;
                        var previousParent = this._parent;
                        this._ignoreCurrentElement = false;
                        for (var i = startStepIndex; i < this._steps.length && !this._ignoreCurrentElement; i++) {
                            var step = this._steps[i];
                            this._parent = parent;
                            this._currentStepIndex = i;
                            step.process(parent, current, this);
                            parent = this._parent;
                        }
                        if (!this._ignoreCurrentElement) {
                            ListWrapper.push(results, current);
                        }
                        this._currentStepIndex = previousStepIndex;
                        this._parent = previousParent;
                        var localAdditionalChildren = this._additionalChildren;
                        this._additionalChildren = null;
                        return localAdditionalChildren;
                    }
                }, {
                    key: 'addParent',
                    value: function addParent(newElement) {
                        this.internalProcess(this._results, this._currentStepIndex + 1, this._parent, newElement);
                        this._parent = newElement;
                    }
                }, {
                    key: 'addChild',
                    value: function addChild(element) {
                        if (isBlank(this._additionalChildren)) {
                            this._additionalChildren = ListWrapper.create();
                        }
                        ListWrapper.push(this._additionalChildren, element);
                    }
                }, {
                    key: 'ignoreCurrentElement',

                    /**
                     * Ignores the current element.
                     *
                     * When a step calls `ignoreCurrentElement`, no further steps are executed on the current
                     * element and no `CompileElement` is added to the result list.
                     */
                    value: function ignoreCurrentElement() {
                        this._ignoreCurrentElement = true;
                    }
                }]);

                return CompileControl;
            })();

            _export('CompileControl', CompileControl);
        }
    };
});


System.register("angular2/src/render/dom/view/element_binder", ["npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
    var _classCallCheck, ElementBinder, Event, HostAction;

    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            ElementBinder = function ElementBinder() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var textNodeIndices = _ref.textNodeIndices;
                var contentTagSelector = _ref.contentTagSelector;
                var nestedProtoView = _ref.nestedProtoView;
                var componentId = _ref.componentId;
                var eventLocals = _ref.eventLocals;
                var localEvents = _ref.localEvents;
                var globalEvents = _ref.globalEvents;
                var hostActions = _ref.hostActions;
                var parentIndex = _ref.parentIndex;
                var distanceToParent = _ref.distanceToParent;
                var propertySetters = _ref.propertySetters;

                _classCallCheck(this, ElementBinder);

                this.textNodeIndices = textNodeIndices;
                this.contentTagSelector = contentTagSelector;
                this.nestedProtoView = nestedProtoView;
                this.componentId = componentId;
                this.eventLocals = eventLocals;
                this.localEvents = localEvents;
                this.globalEvents = globalEvents;
                this.hostActions = hostActions;
                this.parentIndex = parentIndex;
                this.distanceToParent = distanceToParent;
                this.propertySetters = propertySetters;
            };

            _export("ElementBinder", ElementBinder);

            Event = function Event(name, target, fullName) {
                _classCallCheck(this, Event);

                this.name = name;
                this.target = target;
                this.fullName = fullName;
            };

            _export("Event", Event);

            HostAction = function HostAction(actionName, actionExpression, expression) {
                _classCallCheck(this, HostAction);

                this.actionName = actionName;
                this.actionExpression = actionExpression;
                this.expression = expression;
            };

            _export("HostAction", HostAction);
        }
    };
});


System.register('angular2/src/render/dom/view/property_setter_factory', ['angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/dom/dom_adapter', 'angular2/src/render/dom/util', 'angular2/src/reflection/reflection'], function (_export) {
    'use strict';

    var StringWrapper, BaseException, isPresent, isBlank, isString, stringify, ListWrapper, StringMapWrapper, DOM, camelCaseToDashCase, reflector, STYLE_SEPARATOR, propertySettersCache, innerHTMLSetterCache, ATTRIBUTE_PREFIX, attributeSettersCache, CLASS_PREFIX, classSettersCache, STYLE_PREFIX, styleSettersCache;

    _export('setterFactory', setterFactory);

    function setterFactory(property) {
        var setterFn, styleParts, styleSuffix;
        if (StringWrapper.startsWith(property, ATTRIBUTE_PREFIX)) {
            setterFn = attributeSetterFactory(StringWrapper.substring(property, ATTRIBUTE_PREFIX.length));
        } else if (StringWrapper.startsWith(property, CLASS_PREFIX)) {
            setterFn = classSetterFactory(StringWrapper.substring(property, CLASS_PREFIX.length));
        } else if (StringWrapper.startsWith(property, STYLE_PREFIX)) {
            styleParts = property.split(STYLE_SEPARATOR);
            styleSuffix = styleParts.length > 2 ? ListWrapper.get(styleParts, 2) : '';
            setterFn = styleSetterFactory(ListWrapper.get(styleParts, 1), styleSuffix);
        } else if (StringWrapper.equals(property, 'innerHtml')) {
            if (isBlank(innerHTMLSetterCache)) {
                innerHTMLSetterCache = function (el, value) {
                    return DOM.setInnerHTML(el, value);
                };
            }
            setterFn = innerHTMLSetterCache;
        } else {
            property = resolvePropertyName(property);
            setterFn = StringMapWrapper.get(propertySettersCache, property);
            if (isBlank(setterFn)) {
                var propertySetterFn = reflector.setter(property);
                setterFn = function (receiver, value) {
                    if (DOM.hasProperty(receiver, property)) {
                        return propertySetterFn(receiver, value);
                    }
                };
                StringMapWrapper.set(propertySettersCache, property, setterFn);
            }
        }
        return setterFn;
    }

    function _isValidAttributeValue(attrName, value) {
        if (attrName == 'role') {
            return isString(value);
        } else {
            return isPresent(value);
        }
    }
    function attributeSetterFactory(attrName) {
        var setterFn = StringMapWrapper.get(attributeSettersCache, attrName);
        var dashCasedAttributeName;
        if (isBlank(setterFn)) {
            dashCasedAttributeName = camelCaseToDashCase(attrName);
            setterFn = function (element, value) {
                if (_isValidAttributeValue(dashCasedAttributeName, value)) {
                    DOM.setAttribute(element, dashCasedAttributeName, stringify(value));
                } else {
                    if (isPresent(value)) {
                        throw new BaseException('Invalid ' + dashCasedAttributeName + ' attribute, only string values are allowed, got \'' + stringify(value) + '\'');
                    }
                    DOM.removeAttribute(element, dashCasedAttributeName);
                }
            };
            StringMapWrapper.set(attributeSettersCache, attrName, setterFn);
        }
        return setterFn;
    }
    function classSetterFactory(className) {
        var setterFn = StringMapWrapper.get(classSettersCache, className);
        var dashCasedClassName;
        if (isBlank(setterFn)) {
            dashCasedClassName = camelCaseToDashCase(className);
            setterFn = function (element, value) {
                if (value) {
                    DOM.addClass(element, dashCasedClassName);
                } else {
                    DOM.removeClass(element, dashCasedClassName);
                }
            };
            StringMapWrapper.set(classSettersCache, className, setterFn);
        }
        return setterFn;
    }
    function styleSetterFactory(styleName, styleSuffix) {
        var cacheKey = styleName + styleSuffix;
        var setterFn = StringMapWrapper.get(styleSettersCache, cacheKey);
        var dashCasedStyleName;
        if (isBlank(setterFn)) {
            dashCasedStyleName = camelCaseToDashCase(styleName);
            setterFn = function (element, value) {
                var valAsStr;
                if (isPresent(value)) {
                    valAsStr = stringify(value);
                    DOM.setStyle(element, dashCasedStyleName, valAsStr + styleSuffix);
                } else {
                    DOM.removeStyle(element, dashCasedStyleName);
                }
            };
            StringMapWrapper.set(styleSettersCache, cacheKey, setterFn);
        }
        return setterFn;
    }
    function resolvePropertyName(attrName) {
        var mappedPropName = StringMapWrapper.get(DOM.attrToPropMap, attrName);
        return isPresent(mappedPropName) ? mappedPropName : attrName;
    }
    
    return {
        setters: [function (_angular2SrcFacadeLang) {
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            BaseException = _angular2SrcFacadeLang.BaseException;
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            isString = _angular2SrcFacadeLang.isString;
            stringify = _angular2SrcFacadeLang.stringify;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomUtil) {
            camelCaseToDashCase = _angular2SrcRenderDomUtil.camelCaseToDashCase;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
        }],
        execute: function () {
            STYLE_SEPARATOR = '.';
            propertySettersCache = StringMapWrapper.create();
            ATTRIBUTE_PREFIX = 'attr.';
            attributeSettersCache = StringMapWrapper.create();
            CLASS_PREFIX = 'class.';
            classSettersCache = StringMapWrapper.create();
            STYLE_PREFIX = 'style.';
            styleSettersCache = StringMapWrapper.create();
        }
    };
});
System.register('angular2/src/render/dom/compiler/property_binding_parser', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/render/dom/util'], function (_export) {
    var _createClass, _classCallCheck, isPresent, RegExpWrapper, MapWrapper, dashCaseToCamelCase, BIND_NAME_REGEXP, PropertyBindingParser;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcRenderDomUtil) {
            dashCaseToCamelCase = _angular2SrcRenderDomUtil.dashCaseToCamelCase;
        }],
        execute: function () {
            'use strict';

            // Group 1 = "bind-"
            // Group 2 = "var-" or "#"
            // Group 3 = "on-"
            // Group 4 = "bindon-"
            // Group 5 = the identifier after "bind-", "var-/#", or "on-"
            // Group 6 = idenitifer inside [()]
            // Group 7 = idenitifer inside []
            // Group 8 = identifier inside ()
            BIND_NAME_REGEXP = RegExpWrapper.create('^(?:(?:(?:(bind-)|(var-|#)|(on-)|(bindon-))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$');

            /**
             * Parses the property bindings on a single element.
             */

            PropertyBindingParser = (function () {
                function PropertyBindingParser(parser) {
                    _classCallCheck(this, PropertyBindingParser);

                    this._parser = parser;
                }

                _createClass(PropertyBindingParser, [{
                    key: 'process',
                    value: function process(parent, current, control) {
                        var _this = this;

                        var attrs = current.attrs();
                        var newAttrs = MapWrapper.create();
                        MapWrapper.forEach(attrs, function (attrValue, attrName) {
                            var bindParts = RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
                            if (isPresent(bindParts)) {
                                if (isPresent(bindParts[1])) {
                                    _this._bindProperty(bindParts[5], attrValue, current, newAttrs);
                                } else if (isPresent(bindParts[2])) {
                                    var identifier = bindParts[5];
                                    var value = attrValue == '' ? '$implicit' : attrValue;
                                    _this._bindVariable(identifier, value, current, newAttrs);
                                } else if (isPresent(bindParts[3])) {
                                    _this._bindEvent(bindParts[5], attrValue, current, newAttrs);
                                } else if (isPresent(bindParts[4])) {
                                    _this._bindProperty(bindParts[5], attrValue, current, newAttrs);
                                    _this._bindAssignmentEvent(bindParts[5], attrValue, current, newAttrs);
                                } else if (isPresent(bindParts[6])) {
                                    _this._bindProperty(bindParts[6], attrValue, current, newAttrs);
                                    _this._bindAssignmentEvent(bindParts[6], attrValue, current, newAttrs);
                                } else if (isPresent(bindParts[7])) {
                                    _this._bindProperty(bindParts[7], attrValue, current, newAttrs);
                                } else if (isPresent(bindParts[8])) {
                                    _this._bindEvent(bindParts[8], attrValue, current, newAttrs);
                                }
                            } else {
                                var expr = _this._parser.parseInterpolation(attrValue, current.elementDescription);
                                if (isPresent(expr)) {
                                    _this._bindPropertyAst(attrName, expr, current, newAttrs);
                                }
                            }
                        });
                        MapWrapper.forEach(newAttrs, function (attrValue, attrName) {
                            MapWrapper.set(attrs, attrName, attrValue);
                        });
                    }
                }, {
                    key: '_bindVariable',
                    value: function _bindVariable(identifier, value, current, newAttrs) {
                        current.bindElement().bindVariable(dashCaseToCamelCase(identifier), value);
                        MapWrapper.set(newAttrs, identifier, value);
                    }
                }, {
                    key: '_bindProperty',
                    value: function _bindProperty(name, expression, current, newAttrs) {
                        this._bindPropertyAst(name, this._parser.parseBinding(expression, current.elementDescription), current, newAttrs);
                    }
                }, {
                    key: '_bindPropertyAst',
                    value: function _bindPropertyAst(name, ast, current, newAttrs) {
                        var binder = current.bindElement();
                        var camelCaseName = dashCaseToCamelCase(name);
                        binder.bindProperty(camelCaseName, ast);
                        MapWrapper.set(newAttrs, name, ast.source);
                    }
                }, {
                    key: '_bindAssignmentEvent',
                    value: function _bindAssignmentEvent(name, expression, current, newAttrs) {
                        this._bindEvent(name, '' + expression + '=$event', current, newAttrs);
                    }
                }, {
                    key: '_bindEvent',
                    value: function _bindEvent(name, expression, current, newAttrs) {
                        current.bindElement().bindEvent(dashCaseToCamelCase(name), this._parser.parseAction(expression, current.elementDescription));
                        // Don't detect directives for event names for now,
                        // so don't add the event name to the CompileElement.attrs
                    }
                }]);

                return PropertyBindingParser;
            })();

            _export('PropertyBindingParser', PropertyBindingParser);
        }
    };
});


System.register('angular2/src/render/dom/compiler/text_interpolation_parser', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/dom/dom_adapter'], function (_export) {
    var _createClass, _classCallCheck, isPresent, DOM, TextInterpolationParser;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }],
        execute: function () {
            'use strict';

            /**
             * Parses interpolations in direct text child nodes of the current element.
             */

            TextInterpolationParser = (function () {
                function TextInterpolationParser(parser) {
                    _classCallCheck(this, TextInterpolationParser);

                    this._parser = parser;
                }

                _createClass(TextInterpolationParser, [{
                    key: 'process',
                    value: function process(parent, current, control) {
                        if (!current.compileChildren) {
                            return;
                        }
                        var element = current.element;
                        var childNodes = DOM.childNodes(DOM.templateAwareRoot(element));
                        for (var i = 0; i < childNodes.length; i++) {
                            var node = childNodes[i];
                            if (DOM.isTextNode(node)) {
                                var text = DOM.nodeValue(node);
                                var expr = this._parser.parseInterpolation(text, current.elementDescription);
                                if (isPresent(expr)) {
                                    DOM.setText(node, ' ');
                                    current.bindElement().bindText(i, expr);
                                }
                            }
                        }
                    }
                }]);

                return TextInterpolationParser;
            })();

            _export('TextInterpolationParser', TextInterpolationParser);
        }
    };
});


System.register('angular2/src/render/dom/compiler/selector', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, ListWrapper, MapWrapper, isPresent, isBlank, RegExpWrapper, RegExpMatcherWrapper, StringWrapper, BaseException, _EMPTY_ATTR_VALUE, _SELECTOR_REGEXP, CssSelector, SelectorMatcher, SelectorListContext, SelectorContext;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            RegExpMatcherWrapper = _angular2SrcFacadeLang.RegExpMatcherWrapper;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            'use strict';

            _EMPTY_ATTR_VALUE = '';

            // TODO: Can't use `const` here as
            // in Dart this is not transpiled into `final` yet...
            _SELECTOR_REGEXP = RegExpWrapper.create('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(\\))|' + '(\\s*,\\s*)');
            // ","
            /**
             * A css selector contains an element name,
             * css classes and attribute/value pairs with the purpose
             * of selecting subsets out of them.
             */

            CssSelector = (function () {
                function CssSelector() {
                    _classCallCheck(this, CssSelector);

                    this.element = null;
                    this.classNames = ListWrapper.create();
                    this.attrs = ListWrapper.create();
                    this.notSelectors = ListWrapper.create();
                }

                _createClass(CssSelector, [{
                    key: 'isElementSelector',
                    value: function isElementSelector() {
                        return isPresent(this.element) && ListWrapper.isEmpty(this.classNames) && ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
                    }
                }, {
                    key: 'setElement',
                    value: function setElement() {
                        var element = arguments[0] === undefined ? null : arguments[0];

                        if (isPresent(element)) {
                            element = element.toLowerCase();
                        }
                        this.element = element;
                    }
                }, {
                    key: 'addAttribute',
                    value: function addAttribute(name) {
                        var value = arguments[1] === undefined ? _EMPTY_ATTR_VALUE : arguments[1];

                        ListWrapper.push(this.attrs, name.toLowerCase());
                        if (isPresent(value)) {
                            value = value.toLowerCase();
                        } else {
                            value = _EMPTY_ATTR_VALUE;
                        }
                        ListWrapper.push(this.attrs, value);
                    }
                }, {
                    key: 'addClassName',
                    value: function addClassName(name) {
                        ListWrapper.push(this.classNames, name.toLowerCase());
                    }
                }, {
                    key: 'toString',
                    value: function toString() {
                        var res = '';
                        if (isPresent(this.element)) {
                            res += this.element;
                        }
                        if (isPresent(this.classNames)) {
                            for (var i = 0; i < this.classNames.length; i++) {
                                res += '.' + this.classNames[i];
                            }
                        }
                        if (isPresent(this.attrs)) {
                            for (var i = 0; i < this.attrs.length;) {
                                var attrName = this.attrs[i++];
                                var attrValue = this.attrs[i++];
                                res += '[' + attrName;
                                if (attrValue.length > 0) {
                                    res += '=' + attrValue;
                                }
                                res += ']';
                            }
                        }
                        ListWrapper.forEach(this.notSelectors, function (notSelector) {
                            res += ':not(' + notSelector.toString() + ')';
                        });
                        return res;
                    }
                }], [{
                    key: 'parse',
                    value: function parse(selector) {
                        var results = ListWrapper.create();
                        var _addResult = function _addResult(res, cssSel) {
                            if (cssSel.notSelectors.length > 0 && isBlank(cssSel.element) && ListWrapper.isEmpty(cssSel.classNames) && ListWrapper.isEmpty(cssSel.attrs)) {
                                cssSel.element = '*';
                            }
                            ListWrapper.push(res, cssSel);
                        };
                        var cssSelector = new CssSelector();
                        var matcher = RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
                        var match;
                        var current = cssSelector;
                        var inNot = false;
                        while (isPresent(match = RegExpMatcherWrapper.next(matcher))) {
                            if (isPresent(match[1])) {
                                if (inNot) {
                                    throw new BaseException('Nesting :not is not allowed in a selector');
                                }
                                inNot = true;
                                current = new CssSelector();
                                ListWrapper.push(cssSelector.notSelectors, current);
                            }
                            if (isPresent(match[2])) {
                                current.setElement(match[2]);
                            }
                            if (isPresent(match[3])) {
                                current.addClassName(match[3]);
                            }
                            if (isPresent(match[4])) {
                                current.addAttribute(match[4], match[5]);
                            }
                            if (isPresent(match[6])) {
                                inNot = false;
                                current = cssSelector;
                            }
                            if (isPresent(match[7])) {
                                if (inNot) {
                                    throw new BaseException('Multiple selectors in :not are not supported');
                                }
                                _addResult(results, cssSelector);
                                cssSelector = current = new CssSelector();
                            }
                        }
                        _addResult(results, cssSelector);
                        return results;
                    }
                }]);

                return CssSelector;
            })();

            _export('CssSelector', CssSelector);

            /**
             * Reads a list of CssSelectors and allows to calculate which ones
             * are contained in a given CssSelector.
             */

            SelectorMatcher = (function () {
                function SelectorMatcher() {
                    _classCallCheck(this, SelectorMatcher);

                    this._elementMap = MapWrapper.create();
                    this._elementPartialMap = MapWrapper.create();
                    this._classMap = MapWrapper.create();
                    this._classPartialMap = MapWrapper.create();
                    this._attrValueMap = MapWrapper.create();
                    this._attrValuePartialMap = MapWrapper.create();
                    this._listContexts = ListWrapper.create();
                }

                _createClass(SelectorMatcher, [{
                    key: 'addSelectables',
                    value: function addSelectables(cssSelectors, callbackCtxt) {
                        var listContext = null;
                        if (cssSelectors.length > 1) {
                            listContext = new SelectorListContext(cssSelectors);
                            ListWrapper.push(this._listContexts, listContext);
                        }
                        for (var i = 0; i < cssSelectors.length; i++) {
                            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
                        }
                    }
                }, {
                    key: '_addSelectable',

                    /**
                     * Add an object that can be found later on by calling `match`.
                     * @param cssSelector A css selector
                     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
                     */
                    value: function _addSelectable(cssSelector, callbackCtxt, listContext) {
                        var matcher = this;
                        var element = cssSelector.element;
                        var classNames = cssSelector.classNames;
                        var attrs = cssSelector.attrs;
                        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
                        if (isPresent(element)) {
                            var isTerminal = attrs.length === 0 && classNames.length === 0;
                            if (isTerminal) {
                                this._addTerminal(matcher._elementMap, element, selectable);
                            } else {
                                matcher = this._addPartial(matcher._elementPartialMap, element);
                            }
                        }
                        if (isPresent(classNames)) {
                            for (var index = 0; index < classNames.length; index++) {
                                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                                var className = classNames[index];
                                if (isTerminal) {
                                    this._addTerminal(matcher._classMap, className, selectable);
                                } else {
                                    matcher = this._addPartial(matcher._classPartialMap, className);
                                }
                            }
                        }
                        if (isPresent(attrs)) {
                            for (var index = 0; index < attrs.length;) {
                                var isTerminal = index === attrs.length - 2;
                                var attrName = attrs[index++];
                                var attrValue = attrs[index++];
                                if (isTerminal) {
                                    var terminalMap = matcher._attrValueMap;
                                    var terminalValuesMap = MapWrapper.get(terminalMap, attrName);
                                    if (isBlank(terminalValuesMap)) {
                                        terminalValuesMap = MapWrapper.create();
                                        MapWrapper.set(terminalMap, attrName, terminalValuesMap);
                                    }
                                    this._addTerminal(terminalValuesMap, attrValue, selectable);
                                } else {
                                    var parttialMap = matcher._attrValuePartialMap;
                                    var partialValuesMap = MapWrapper.get(parttialMap, attrName);
                                    if (isBlank(partialValuesMap)) {
                                        partialValuesMap = MapWrapper.create();
                                        MapWrapper.set(parttialMap, attrName, partialValuesMap);
                                    }
                                    matcher = this._addPartial(partialValuesMap, attrValue);
                                }
                            }
                        }
                    }
                }, {
                    key: '_addTerminal',
                    value: function _addTerminal(map, name, selectable) {
                        var terminalList = MapWrapper.get(map, name);
                        if (isBlank(terminalList)) {
                            terminalList = ListWrapper.create();
                            MapWrapper.set(map, name, terminalList);
                        }
                        ListWrapper.push(terminalList, selectable);
                    }
                }, {
                    key: '_addPartial',
                    value: function _addPartial(map, name) {
                        var matcher = MapWrapper.get(map, name);
                        if (isBlank(matcher)) {
                            matcher = new SelectorMatcher();
                            MapWrapper.set(map, name, matcher);
                        }
                        return matcher;
                    }
                }, {
                    key: 'match',

                    /**
                     * Find the objects that have been added via `addSelectable`
                     * whose css selector is contained in the given css selector.
                     * @param cssSelector A css selector
                     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
                     * @return boolean true if a match was found
                    */
                    value: function match(cssSelector, matchedCallback /*: (CssSelector, any) => void*/) {
                        var result = false;
                        var element = cssSelector.element;
                        var classNames = cssSelector.classNames;
                        var attrs = cssSelector.attrs;
                        for (var i = 0; i < this._listContexts.length; i++) {
                            this._listContexts[i].alreadyMatched = false;
                        }
                        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
                        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
                        if (isPresent(classNames)) {
                            for (var index = 0; index < classNames.length; index++) {
                                var className = classNames[index];
                                result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                                result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
                            }
                        }
                        if (isPresent(attrs)) {
                            for (var index = 0; index < attrs.length;) {
                                var attrName = attrs[index++];
                                var attrValue = attrs[index++];
                                var terminalValuesMap = MapWrapper.get(this._attrValueMap, attrName);
                                if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                                    result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
                                }
                                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) || result;
                                var partialValuesMap = MapWrapper.get(this._attrValuePartialMap, attrName);
                                result = this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
                            }
                        }
                        return result;
                    }
                }, {
                    key: '_matchTerminal',
                    value: function _matchTerminal(map, name, cssSelector, matchedCallback /*: (CssSelector, any) => void*/) {
                        if (isBlank(map) || isBlank(name)) {
                            return false;
                        }
                        var selectables = MapWrapper.get(map, name);
                        var starSelectables = MapWrapper.get(map, '*');
                        if (isPresent(starSelectables)) {
                            selectables = ListWrapper.concat(selectables, starSelectables);
                        }
                        if (isBlank(selectables)) {
                            return false;
                        }
                        var selectable;
                        var result = false;
                        for (var index = 0; index < selectables.length; index++) {
                            selectable = selectables[index];
                            result = selectable.finalize(cssSelector, matchedCallback) || result;
                        }
                        return result;
                    }
                }, {
                    key: '_matchPartial',
                    value: function _matchPartial(map, name, cssSelector, matchedCallback /*: (CssSelector, any) => void*/) {
                        if (isBlank(map) || isBlank(name)) {
                            return false;
                        }
                        var nestedSelector = MapWrapper.get(map, name);
                        if (isBlank(nestedSelector)) {
                            return false;
                        }
                        // TODO(perf): get rid of recursion and measure again
                        // TODO(perf): don't pass the whole selector into the recursion,
                        // but only the not processed parts
                        return nestedSelector.match(cssSelector, matchedCallback);
                    }
                }], [{
                    key: 'createNotMatcher',
                    value: function createNotMatcher(notSelectors) {
                        var notMatcher = new SelectorMatcher();
                        notMatcher.addSelectables(notSelectors, null);
                        return notMatcher;
                    }
                }]);

                return SelectorMatcher;
            })();

            _export('SelectorMatcher', SelectorMatcher);

            SelectorListContext = function SelectorListContext(selectors) {
                _classCallCheck(this, SelectorListContext);

                this.selectors = selectors;
                this.alreadyMatched = false;
            };

            // Store context to pass back selector and context when a selector is matched

            SelectorContext = (function () {
                function SelectorContext(selector, cbContext, listContext) {
                    _classCallCheck(this, SelectorContext);

                    this.selector = selector;
                    this.notSelectors = selector.notSelectors;
                    this.cbContext = cbContext;
                    this.listContext = listContext;
                }

                _createClass(SelectorContext, [{
                    key: 'finalize',
                    value: function finalize(cssSelector, callback /*: (CssSelector, any) => void*/) {
                        var result = true;
                        if (this.notSelectors.length > 0 && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
                            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
                            result = !notMatcher.match(cssSelector, null);
                        }
                        if (result && isPresent(callback) && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
                            if (isPresent(this.listContext)) {
                                this.listContext.alreadyMatched = true;
                            }
                            callback(this.selector, this.cbContext);
                        }
                        return result;
                    }
                }]);

                return SelectorContext;
            })();
        }
    };
});


System.register('angular2/src/render/dom/compiler/view_splitter', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/collection', 'angular2/src/render/dom/compiler/compile_element', 'angular2/src/render/dom/util'], function (_export) {
    var _createClass, _classCallCheck, isPresent, BaseException, StringWrapper, DOM, MapWrapper, CompileElement, dashCaseToCamelCase, ViewSplitter;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcRenderDomCompilerCompile_element) {
            CompileElement = _angular2SrcRenderDomCompilerCompile_element.CompileElement;
        }, function (_angular2SrcRenderDomUtil) {
            dashCaseToCamelCase = _angular2SrcRenderDomUtil.dashCaseToCamelCase;
        }],
        execute: function () {
            'use strict';

            /**
             * Splits views at `<template>` elements or elements with `template` attribute:
             * For `<template>` elements:
             * - moves the content into a new and disconnected `<template>` element
             *   that is marked as view root.
             *
             * For elements with a `template` attribute:
             * - replaces the element with an empty `<template>` element,
             *   parses the content of the `template` attribute and adds the information to that
             *   `<template>` element. Marks the elements as view root.
             *
             * Note: In both cases the root of the nested view is disconnected from its parent element.
             * This is needed for browsers that don't support the `<template>` element
             * as we want to do locate elements with bindings using `getElementsByClassName` later on,
             * which should not descend into the nested view.
             */

            ViewSplitter = (function () {
                function ViewSplitter(parser) {
                    _classCallCheck(this, ViewSplitter);

                    this._parser = parser;
                }

                _createClass(ViewSplitter, [{
                    key: 'process',
                    value: function process(parent, current, control) {
                        var attrs = current.attrs();
                        var templateBindings = MapWrapper.get(attrs, 'template');
                        var hasTemplateBinding = isPresent(templateBindings);
                        // look for template shortcuts such as *ng-if="condition" and treat them as template="if
                        // condition"
                        MapWrapper.forEach(attrs, function (attrValue, attrName) {
                            if (StringWrapper.startsWith(attrName, '*')) {
                                var key = StringWrapper.substring(attrName, 1); // remove the star
                                if (hasTemplateBinding) {
                                    // 2nd template binding detected
                                    throw new BaseException('Only one template directive per element is allowed: ' + ('' + templateBindings + ' and ' + key + ' cannot be used simultaneously ') + ('in ' + current.elementDescription));
                                } else {
                                    templateBindings = attrValue.length == 0 ? key : key + ' ' + attrValue;
                                    hasTemplateBinding = true;
                                }
                            }
                        });
                        if (isPresent(parent)) {
                            if (DOM.isTemplateElement(current.element)) {
                                if (!current.isViewRoot) {
                                    var viewRoot = new CompileElement(DOM.createTemplate(''));
                                    viewRoot.inheritedProtoView = current.bindElement().bindNestedProtoView(viewRoot.element);
                                    // viewRoot doesn't appear in the original template, so we associate
                                    // the current element description to get a more meaningful message in case of error
                                    viewRoot.elementDescription = current.elementDescription;
                                    viewRoot.isViewRoot = true;
                                    this._moveChildNodes(DOM.content(current.element), DOM.content(viewRoot.element));
                                    control.addChild(viewRoot);
                                }
                            }
                            if (hasTemplateBinding) {
                                var newParent = new CompileElement(DOM.createTemplate(''));
                                newParent.inheritedProtoView = current.inheritedProtoView;
                                newParent.inheritedElementBinder = current.inheritedElementBinder;
                                newParent.distanceToInheritedBinder = current.distanceToInheritedBinder;
                                // newParent doesn't appear in the original template, so we associate
                                // the current element description to get a more meaningful message in case of error
                                newParent.elementDescription = current.elementDescription;
                                current.inheritedProtoView = newParent.bindElement().bindNestedProtoView(current.element);
                                current.inheritedElementBinder = null;
                                current.distanceToInheritedBinder = 0;
                                current.isViewRoot = true;
                                this._parseTemplateBindings(templateBindings, newParent);
                                this._addParentElement(current.element, newParent.element);
                                control.addParent(newParent);
                                DOM.remove(current.element);
                            }
                        }
                    }
                }, {
                    key: '_moveChildNodes',
                    value: function _moveChildNodes(source, target) {
                        var next = DOM.firstChild(source);
                        while (isPresent(next)) {
                            DOM.appendChild(target, next);
                            next = DOM.firstChild(source);
                        }
                    }
                }, {
                    key: '_addParentElement',
                    value: function _addParentElement(currentElement, newParentElement) {
                        DOM.insertBefore(currentElement, newParentElement);
                        DOM.appendChild(newParentElement, currentElement);
                    }
                }, {
                    key: '_parseTemplateBindings',
                    value: function _parseTemplateBindings(templateBindings, compileElement) {
                        var bindings = this._parser.parseTemplateBindings(templateBindings, compileElement.elementDescription);
                        for (var i = 0; i < bindings.length; i++) {
                            var binding = bindings[i];
                            if (binding.keyIsVar) {
                                compileElement.bindElement().bindVariable(dashCaseToCamelCase(binding.key), binding.name);
                                MapWrapper.set(compileElement.attrs(), binding.key, binding.name);
                            } else if (isPresent(binding.expression)) {
                                compileElement.bindElement().bindProperty(dashCaseToCamelCase(binding.key), binding.expression);
                                MapWrapper.set(compileElement.attrs(), binding.key, binding.expression.source);
                            } else {
                                DOM.setAttribute(compileElement.element, binding.key, '');
                            }
                        }
                    }
                }]);

                return ViewSplitter;
            })();

            _export('ViewSplitter', ViewSplitter);
        }
    };
});


System.register('angular2/src/render/dom/shadow_dom/shadow_dom_compile_step', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/facade/async', 'angular2/src/dom/dom_adapter'], function (_export) {
    var _createClass, _classCallCheck, isPresent, assertionsEnabled, MapWrapper, ListWrapper, PromiseWrapper, DOM, ShadowDomCompileStep;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            assertionsEnabled = _angular2SrcFacadeLang.assertionsEnabled;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }],
        execute: function () {
            'use strict';

            ShadowDomCompileStep = (function () {
                function ShadowDomCompileStep(shadowDomStrategy, template, subTaskPromises) {
                    _classCallCheck(this, ShadowDomCompileStep);

                    this._shadowDomStrategy = shadowDomStrategy;
                    this._template = template;
                    this._subTaskPromises = subTaskPromises;
                }

                _createClass(ShadowDomCompileStep, [{
                    key: 'process',
                    value: function process(parent, current, control) {
                        var tagName = DOM.tagName(current.element).toUpperCase();
                        if (tagName == 'STYLE') {
                            this._processStyleElement(current, control);
                        } else if (tagName == 'CONTENT') {
                            this._processContentElement(current);
                        } else {
                            var componentId = current.isBound() ? current.inheritedElementBinder.componentId : null;
                            this._shadowDomStrategy.processElement(this._template.componentId, componentId, current.element);
                        }
                    }
                }, {
                    key: '_processStyleElement',
                    value: function _processStyleElement(current, control) {
                        var stylePromise = this._shadowDomStrategy.processStyleElement(this._template.componentId, this._template.absUrl, current.element);
                        if (isPresent(stylePromise) && PromiseWrapper.isPromise(stylePromise)) {
                            ListWrapper.push(this._subTaskPromises, stylePromise);
                        }
                        // Style elements should not be further processed by the compiler, as they can not contain
                        // bindings. Skipping further compiler steps allow speeding up the compilation process.
                        control.ignoreCurrentElement();
                    }
                }, {
                    key: '_processContentElement',
                    value: function _processContentElement(current) {
                        if (this._shadowDomStrategy.hasNativeContentElement()) {
                            return;
                        }
                        var attrs = current.attrs();
                        var selector = MapWrapper.get(attrs, 'select');
                        selector = isPresent(selector) ? selector : '';
                        var contentStart = DOM.createScriptTag('type', 'ng/contentStart');
                        if (assertionsEnabled()) {
                            DOM.setAttribute(contentStart, 'select', selector);
                        }
                        var contentEnd = DOM.createScriptTag('type', 'ng/contentEnd');
                        DOM.insertBefore(current.element, contentStart);
                        DOM.insertBefore(current.element, contentEnd);
                        DOM.remove(current.element);
                        current.element = contentStart;
                        current.bindElement().setContentTagSelector(selector);
                    }
                }]);

                return ShadowDomCompileStep;
            })();

            _export('ShadowDomCompileStep', ShadowDomCompileStep);
        }
    };
});


System.register('angular2/src/core/application_tokens', ['angular2/di'], function (_export) {
  'use strict';

  var OpaqueToken, appComponentRefToken, appComponentTypeToken;
  return {
    setters: [function (_angular2Di) {
      OpaqueToken = _angular2Di.OpaqueToken;
    }],
    execute: function () {
      appComponentRefToken = new OpaqueToken('ComponentRef');

      _export('appComponentRefToken', appComponentRefToken);

      appComponentTypeToken = new OpaqueToken('RootComponent');

      

      _export('appComponentTypeToken', appComponentTypeToken);
    }
  };
});
System.register('angular2/src/core/annotations/di', ['angular2/src/core/annotations_impl/di'], function (_export) {
  'use strict';

  
  return {
    setters: [function (_angular2SrcCoreAnnotations_implDi) {
      _export('QueryAnnotation', _angular2SrcCoreAnnotations_implDi.Query);

      _export('AttributeAnnotation', _angular2SrcCoreAnnotations_implDi.Attribute);
    }],
    execute: function () {}
  };
});
System.register('angular2/src/core/annotations/annotations', ['angular2/src/core/annotations_impl/annotations'], function (_export) {
  /**
   * This indirection is needed to free up Component, etc symbols in the public API
   * to be used by the decorator versions of these annotations.
   */
  'use strict';

  
  return {
    setters: [function (_angular2SrcCoreAnnotations_implAnnotations) {
      _export('ComponentAnnotation', _angular2SrcCoreAnnotations_implAnnotations.Component);

      _export('DirectiveAnnotation', _angular2SrcCoreAnnotations_implAnnotations.Directive);

      _export('onDestroy', _angular2SrcCoreAnnotations_implAnnotations.onDestroy);

      _export('onChange', _angular2SrcCoreAnnotations_implAnnotations.onChange);

      _export('onCheck', _angular2SrcCoreAnnotations_implAnnotations.onCheck);

      _export('onInit', _angular2SrcCoreAnnotations_implAnnotations.onInit);

      _export('onAllChangesDone', _angular2SrcCoreAnnotations_implAnnotations.onAllChangesDone);
    }],
    execute: function () {}
  };
});
System.register('angular2/src/core/annotations/decorators', ['angular2/src/core/annotations/annotations', 'angular2/src/core/annotations/view', 'angular2/src/core/annotations/visibility', 'angular2/src/core/annotations/di', 'angular2/src/util/decorators'], function (_export) {
  'use strict';

  var ComponentAnnotation, DirectiveAnnotation, ViewAnnotation, SelfAnnotation, ParentAnnotation, AncestorAnnotation, UnboundedAnnotation, AttributeAnnotation, QueryAnnotation, makeDecorator, makeParamDecorator, Component, Directive, View, Self, Parent, Ancestor, Unbounded, Attribute, Query;
  return {
    setters: [function (_angular2SrcCoreAnnotationsAnnotations) {
      ComponentAnnotation = _angular2SrcCoreAnnotationsAnnotations.ComponentAnnotation;
      DirectiveAnnotation = _angular2SrcCoreAnnotationsAnnotations.DirectiveAnnotation;
    }, function (_angular2SrcCoreAnnotationsView) {
      ViewAnnotation = _angular2SrcCoreAnnotationsView.ViewAnnotation;
    }, function (_angular2SrcCoreAnnotationsVisibility) {
      SelfAnnotation = _angular2SrcCoreAnnotationsVisibility.SelfAnnotation;
      ParentAnnotation = _angular2SrcCoreAnnotationsVisibility.ParentAnnotation;
      AncestorAnnotation = _angular2SrcCoreAnnotationsVisibility.AncestorAnnotation;
      UnboundedAnnotation = _angular2SrcCoreAnnotationsVisibility.UnboundedAnnotation;
    }, function (_angular2SrcCoreAnnotationsDi) {
      AttributeAnnotation = _angular2SrcCoreAnnotationsDi.AttributeAnnotation;
      QueryAnnotation = _angular2SrcCoreAnnotationsDi.QueryAnnotation;
    }, function (_angular2SrcUtilDecorators) {
      makeDecorator = _angular2SrcUtilDecorators.makeDecorator;
      makeParamDecorator = _angular2SrcUtilDecorators.makeParamDecorator;
    }],
    execute: function () {
      /* from annotations */
      Component = makeDecorator(ComponentAnnotation);

      _export('Component', Component);

      Directive = makeDecorator(DirectiveAnnotation);

      _export('Directive', Directive);

      /* from view */
      View = makeDecorator(ViewAnnotation);

      _export('View', View);

      /* from visibility */
      Self = makeParamDecorator(SelfAnnotation);

      _export('Self', Self);

      Parent = makeParamDecorator(ParentAnnotation);

      _export('Parent', Parent);

      Ancestor = makeParamDecorator(AncestorAnnotation);

      _export('Ancestor', Ancestor);

      Unbounded = makeParamDecorator(UnboundedAnnotation);

      _export('Unbounded', Unbounded);

      /* from di */
      Attribute = makeParamDecorator(AttributeAnnotation);

      _export('Attribute', Attribute);

      Query = makeParamDecorator(QueryAnnotation);

      

      _export('Query', Query);
    }
  };
});
System.register("angular2/src/directives/ng_for", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/annotations", "angular2/core", "angular2/src/facade/lang", "angular2/src/facade/collection"], function (_export) {
    var _createClass, _classCallCheck, Directive, ViewContainerRef, ProtoViewRef, isPresent, isBlank, ListWrapper, __decorate, __metadata, NgFor, RecordViewTuple;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Annotations) {
            Directive = _angular2Annotations.Directive;
        }, function (_angular2Core) {
            ViewContainerRef = _angular2Core.ViewContainerRef;
            ProtoViewRef = _angular2Core.ProtoViewRef;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The `NgFor` directive instantiates a template once per item from an iterable. The context for
             * each instantiated template inherits from the outer context with the given loop variable set
             * to the current item from the iterable.
             *
             * It is possible to alias the `index` to a local variable that will be set to the current loop
             * iteration in the template context.
             *
             * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
             *
             * * When an item is added, a new instance of the template is added to the DOM.
             * * When an item is removed, its template instance is removed from the DOM.
             * * When items are reordered, their respective templates are reordered in the DOM.
             *
             * # Example
             *
             * ```
             * <ul>
             *   <li *ng-for="#error of errors; #i = index">
             *     Error {{i}} of {{errors.length}}: {{error.message}}
             *   </li>
             * </ul>
             * ```
             *
             * # Syntax
             *
             * - `<li *ng-for="#item of items; #i = index">...</li>`
             * - `<li template="ng-for #item of items; #i = index">...</li>`
             * - `<template [ng-for] #item [ng-for-of]="items" #i="index"><li>...</li></template>`
             *
             * @exportedAs angular2/directives
             */

            NgFor = (function () {
                var _class = function NgFor(viewContainer, protoViewRef) {
                    _classCallCheck(this, _class);

                    this.viewContainer = viewContainer;
                    this.protoViewRef = protoViewRef;
                };

                _createClass(_class, [{
                    key: "iterableChanges",
                    set: function (changes) {
                        if (isBlank(changes)) {
                            this.viewContainer.clear();
                            return;
                        }
                        // TODO(rado): check if change detection can produce a change record that is
                        // easier to consume than current.
                        var recordViewTuples = [];
                        changes.forEachRemovedItem(function (removedRecord) {
                            return ListWrapper.push(recordViewTuples, new RecordViewTuple(removedRecord, null));
                        });
                        changes.forEachMovedItem(function (movedRecord) {
                            return ListWrapper.push(recordViewTuples, new RecordViewTuple(movedRecord, null));
                        });
                        var insertTuples = NgFor.bulkRemove(recordViewTuples, this.viewContainer);
                        changes.forEachAddedItem(function (addedRecord) {
                            return ListWrapper.push(insertTuples, new RecordViewTuple(addedRecord, null));
                        });
                        NgFor.bulkInsert(insertTuples, this.viewContainer, this.protoViewRef);
                        for (var i = 0; i < insertTuples.length; i++) {
                            this.perViewChange(insertTuples[i].view, insertTuples[i].record);
                        }
                    }
                }, {
                    key: "perViewChange",
                    value: function perViewChange(view, record) {
                        view.setLocal("$implicit", record.item);
                        view.setLocal("index", record.currentIndex);
                    }
                }], [{
                    key: "bulkRemove",
                    value: function bulkRemove(tuples, viewContainer) {
                        tuples.sort(function (a, b) {
                            return a.record.previousIndex - b.record.previousIndex;
                        });
                        var movedTuples = [];
                        for (var i = tuples.length - 1; i >= 0; i--) {
                            var tuple = tuples[i];
                            // separate moved views from removed views.
                            if (isPresent(tuple.record.currentIndex)) {
                                tuple.view = viewContainer.detach(tuple.record.previousIndex);
                                ListWrapper.push(movedTuples, tuple);
                            } else {
                                viewContainer.remove(tuple.record.previousIndex);
                            }
                        }
                        return movedTuples;
                    }
                }, {
                    key: "bulkInsert",
                    value: function bulkInsert(tuples, viewContainer, protoViewRef) {
                        tuples.sort(function (a, b) {
                            return a.record.currentIndex - b.record.currentIndex;
                        });
                        for (var i = 0; i < tuples.length; i++) {
                            var tuple = tuples[i];
                            if (isPresent(tuple.view)) {
                                viewContainer.insert(tuple.view, tuple.record.currentIndex);
                            } else {
                                tuple.view = viewContainer.create(protoViewRef, tuple.record.currentIndex);
                            }
                        }
                        return tuples;
                    }
                }]);

                return _class;
            })();

            _export("NgFor", NgFor);

            _export("NgFor", NgFor = __decorate([Directive({ selector: "[ng-for][ng-for-of]", properties: ["iterableChanges: ngForOf | iterableDiff"] }), __metadata("design:paramtypes", [ViewContainerRef, ProtoViewRef])], NgFor));

            RecordViewTuple = function RecordViewTuple(record, view) {
                _classCallCheck(this, RecordViewTuple);

                this.record = record;
                this.view = view;
            };
        }
    };
});


System.register("angular2/src/directives/ng_if", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/annotations", "angular2/core", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, Directive, ViewContainerRef, ProtoViewRef, isBlank, __decorate, __metadata, NgIf;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Annotations) {
            Directive = _angular2Annotations.Directive;
        }, function (_angular2Core) {
            ViewContainerRef = _angular2Core.ViewContainerRef;
            ProtoViewRef = _angular2Core.ProtoViewRef;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Removes or recreates a portion of the DOM tree based on an {expression}.
             *
             * If the expression assigned to `if` evaluates to a false value then the element is removed from
             * the
             * DOM, otherwise a clone of the element is reinserted into the DOM.
             *
             * # Example:
             *
             * ```
             * <div *ng-if="errorCount > 0" class="error">
             *   <!-- Error message displayed when the errorCount property on the current context is greater
             * than 0. -->
             *   {{errorCount}} errors detected
             * </div>
             * ```
             *
             * # Syntax
             *
             * - `<div *ng-if="condition">...</div>`
             * - `<div template="ng-if condition">...</div>`
             * - `<template [ng-if]="condition"><div>...</div></template>`
             *
             * @exportedAs angular2/directives
             */

            NgIf = (function () {
                var _class = function NgIf(viewContainer, protoViewRef) {
                    _classCallCheck(this, _class);

                    this.viewContainer = viewContainer;
                    this.prevCondition = null;
                    this.protoViewRef = protoViewRef;
                };

                _createClass(_class, [{
                    key: "ngIf",
                    set: function (newCondition /* boolean */) {
                        if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
                            this.prevCondition = true;
                            this.viewContainer.create(this.protoViewRef);
                        } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
                            this.prevCondition = false;
                            this.viewContainer.clear();
                        }
                    }
                }]);

                return _class;
            })();

            _export("NgIf", NgIf);

            _export("NgIf", NgIf = __decorate([Directive({ selector: "[ng-if]", properties: ["ngIf"] }), __metadata("design:paramtypes", [ViewContainerRef, ProtoViewRef])], NgIf));
            
        }
    };
});
System.register("angular2/src/directives/ng_non_bindable", ["npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/annotations"], function (_export) {
    var _classCallCheck, Directive, __decorate, __metadata, NgNonBindable;

    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Annotations) {
            Directive = _angular2Annotations.Directive;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current
             * DOM element. This is useful if the element contains what appears to be Angular directives and
             * bindings but which should be ignored by Angular. This could be the case if you have a site that
             * displays snippets of code, for instance.
             *
             * Example:
             *
             * ```
             * <div>Normal: {{1 + 2}}</div> // output "Normal: 3"
             * <div non-bindable>Ignored: {{1 + 2}}</div> // output "Ignored: {{1 + 2}}"
             * ```
             *
             * @exportedAs angular2/directives
             */

            NgNonBindable = (function () {
                var _class = function NgNonBindable() {
                    _classCallCheck(this, _class);
                };

                return _class;
            })();

            _export("NgNonBindable", NgNonBindable);

            _export("NgNonBindable", NgNonBindable = __decorate([Directive({ selector: "[ng-non-bindable]", compileChildren: false }), __metadata("design:paramtypes", [])], NgNonBindable));
            
        }
    };
});
System.register("angular2/src/directives/ng_switch", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/annotations", "angular2/core", "angular2/src/facade/lang", "angular2/src/facade/collection"], function (_export) {
    var _createClass, _classCallCheck, Directive, Parent, ViewContainerRef, ProtoViewRef, isPresent, isBlank, normalizeBlank, ListWrapper, MapWrapper, __decorate, __metadata, __param, SwitchView, NgSwitch, NgSwitchWhen, NgSwitchDefault, _whenDefault;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Annotations) {
            Directive = _angular2Annotations.Directive;
            Parent = _angular2Annotations.Parent;
        }, function (_angular2Core) {
            ViewContainerRef = _angular2Core.ViewContainerRef;
            ProtoViewRef = _angular2Core.ProtoViewRef;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            normalizeBlank = _angular2SrcFacadeLang.normalizeBlank;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SwitchView = (function () {
                function SwitchView(viewContainerRef, protoViewRef) {
                    _classCallCheck(this, SwitchView);

                    this._protoViewRef = protoViewRef;
                    this._viewContainerRef = viewContainerRef;
                }

                _createClass(SwitchView, [{
                    key: "create",
                    value: function create() {
                        this._viewContainerRef.create(this._protoViewRef);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this._viewContainerRef.clear();
                    }
                }]);

                return SwitchView;
            })();

            _export("SwitchView", SwitchView);

            /**
             * The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a
             * scope expression.
             * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be
             * preserved at the location as specified in the template.
             *
             * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches
             * the value obtained from the evaluated expression. In other words, you define a container element
             * (where you place the directive), place an expression on the **`[ng-switch]="..."` attribute**),
             * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per
             * element.
             * The when attribute is used to inform NgSwitch which element to display when the expression is
             * evaluated. If a matching expression is not found via a when attribute then an element with the
             * default attribute is displayed.
             *
             * # Example:
             *
             * ```
             * <ANY [ng-switch]="expression">
             *   <template [ng-switch-when]="whenExpression1">...</template>
             *   <template [ng-switch-when]="whenExpression1">...</template>
             *   <template [ng-switch-default]>...</template>
             * </ANY>
             * ```
             *
             * @exportedAs angular2/directives
             */

            NgSwitch = (function () {
                var _class = function NgSwitch() {
                    _classCallCheck(this, _class);

                    this._valueViews = MapWrapper.create();
                    this._activeViews = ListWrapper.create();
                    this._useDefault = false;
                };

                _createClass(_class, [{
                    key: "ngSwitch",
                    set: function (value) {
                        // Empty the currently active ViewContainers
                        this._emptyAllActiveViews();
                        // Add the ViewContainers matching the value (with a fallback to default)
                        this._useDefault = false;
                        var views = MapWrapper.get(this._valueViews, value);
                        if (isBlank(views)) {
                            this._useDefault = true;
                            views = normalizeBlank(MapWrapper.get(this._valueViews, _whenDefault));
                        }
                        this._activateViews(views);
                        this._switchValue = value;
                    }
                }, {
                    key: "_onWhenValueChanged",
                    value: function _onWhenValueChanged(oldWhen, newWhen, view) {
                        this._deregisterView(oldWhen, view);
                        this._registerView(newWhen, view);
                        if (oldWhen === this._switchValue) {
                            view.destroy();
                            ListWrapper.remove(this._activeViews, view);
                        } else if (newWhen === this._switchValue) {
                            if (this._useDefault) {
                                this._useDefault = false;
                                this._emptyAllActiveViews();
                            }
                            view.create();
                            ListWrapper.push(this._activeViews, view);
                        }
                        // Switch to default when there is no more active ViewContainers
                        if (this._activeViews.length === 0 && !this._useDefault) {
                            this._useDefault = true;
                            this._activateViews(MapWrapper.get(this._valueViews, _whenDefault));
                        }
                    }
                }, {
                    key: "_emptyAllActiveViews",
                    value: function _emptyAllActiveViews() {
                        var activeContainers = this._activeViews;
                        for (var i = 0; i < activeContainers.length; i++) {
                            activeContainers[i].destroy();
                        }
                        this._activeViews = ListWrapper.create();
                    }
                }, {
                    key: "_activateViews",
                    value: function _activateViews(views) {
                        // TODO(vicb): assert(this._activeViews.length === 0);
                        if (isPresent(views)) {
                            for (var i = 0; i < views.length; i++) {
                                views[i].create();
                            }
                            this._activeViews = views;
                        }
                    }
                }, {
                    key: "_registerView",
                    value: function _registerView(value, view) {
                        var views = MapWrapper.get(this._valueViews, value);
                        if (isBlank(views)) {
                            views = ListWrapper.create();
                            MapWrapper.set(this._valueViews, value, views);
                        }
                        ListWrapper.push(views, view);
                    }
                }, {
                    key: "_deregisterView",
                    value: function _deregisterView(value, view) {
                        // `_whenDefault` is used a marker for non-registered whens
                        if (value == _whenDefault) return;
                        var views = MapWrapper.get(this._valueViews, value);
                        if (views.length == 1) {
                            MapWrapper["delete"](this._valueViews, value);
                        } else {
                            ListWrapper.remove(views, view);
                        }
                    }
                }]);

                return _class;
            })();

            _export("NgSwitch", NgSwitch);

            _export("NgSwitch", NgSwitch = __decorate([Directive({ selector: "[ng-switch]", properties: ["ngSwitch"] }), __metadata("design:paramtypes", [])], NgSwitch));
            /**
             * Defines a case statement as an expression.
             *
             * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.
             *
             * Example:
             *
             * ```
             * // match against a context variable
             * <template [ng-switch-when]="contextVariable">...</template>
             *
             * // match against a constant string
             * <template [ng-switch-when]="'stringValue'">...</template>
             * ```
             *
             * @exportedAs angular2/directives
             */

            NgSwitchWhen = (function () {
                var _class2 = function NgSwitchWhen(viewContainer, protoViewRef, sswitch) {
                    _classCallCheck(this, _class2);

                    // `_whenDefault` is used as a marker for a not yet initialized value
                    this._value = _whenDefault;
                    this._switch = sswitch;
                    this._view = new SwitchView(viewContainer, protoViewRef);
                };

                _createClass(_class2, [{
                    key: "onDestroy",
                    value: function onDestroy() {
                        this._switch;
                    }
                }, {
                    key: "ngSwitchWhen",
                    set: function (value) {
                        this._switch._onWhenValueChanged(this._value, value, this._view);
                        this._value = value;
                    }
                }]);

                return _class2;
            })();

            _export("NgSwitchWhen", NgSwitchWhen);

            _export("NgSwitchWhen", NgSwitchWhen = __decorate([Directive({ selector: "[ng-switch-when]", properties: ["ngSwitchWhen"] }), __param(2, Parent()), __metadata("design:paramtypes", [ViewContainerRef, ProtoViewRef, NgSwitch])], NgSwitchWhen));
            /**
             * Defines a default case statement.
             *
             * Default case statements are displayed when no `NgSwitchWhen` match the `switch` value.
             *
             * Example:
             *
             * ```
             * <template [ng-switch-default]>...</template>
             * ```
             *
             * @exportedAs angular2/directives
             */

            NgSwitchDefault = (function () {
                var _class3 = function NgSwitchDefault(viewContainer, protoViewRef, sswitch) {
                    _classCallCheck(this, _class3);

                    sswitch._registerView(_whenDefault, new SwitchView(viewContainer, protoViewRef));
                };

                return _class3;
            })();

            _export("NgSwitchDefault", NgSwitchDefault);

            _export("NgSwitchDefault", NgSwitchDefault = __decorate([Directive({ selector: "[ng-switch-default]" }), __param(2, Parent()), __metadata("design:paramtypes", [ViewContainerRef, ProtoViewRef, NgSwitch])], NgSwitchDefault));
            _whenDefault = new Object();

            
        }
    };
});
System.register("angular2/src/directives/class", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/annotations", "angular2/core", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function (_export) {
    var _createClass, _classCallCheck, Directive, ElementRef, isPresent, DOM, __decorate, __metadata, CSSClass;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Annotations) {
            Directive = _angular2Annotations.Directive;
        }, function (_angular2Core) {
            ElementRef = _angular2Core.ElementRef;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            CSSClass = (function () {
                var _class = function CSSClass(ngEl) {
                    _classCallCheck(this, _class);

                    this._domEl = ngEl.domElement;
                };

                _createClass(_class, [{
                    key: "_toggleClass",
                    value: function _toggleClass(className, enabled) {
                        if (enabled) {
                            DOM.addClass(this._domEl, className);
                        } else {
                            DOM.removeClass(this._domEl, className);
                        }
                    }
                }, {
                    key: "iterableChanges",
                    set: function (changes) {
                        var _this = this;

                        if (isPresent(changes)) {
                            changes.forEachAddedItem(function (record) {
                                _this._toggleClass(record.key, record.currentValue);
                            });
                            changes.forEachChangedItem(function (record) {
                                _this._toggleClass(record.key, record.currentValue);
                            });
                            changes.forEachRemovedItem(function (record) {
                                if (record.previousValue) {
                                    DOM.removeClass(_this._domEl, record.key);
                                }
                            });
                        }
                    }
                }]);

                return _class;
            })();

            _export("CSSClass", CSSClass);

            _export("CSSClass", CSSClass = __decorate([Directive({ selector: "[class]", properties: ["iterableChanges: class | keyValDiff"] }), __metadata("design:paramtypes", [ElementRef])], CSSClass));
            
        }
    };
});
System.register('angular2/src/forms/validators', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, isBlank, isPresent, ListWrapper, StringMapWrapper, Validators;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }],
        execute: function () {
            'use strict';

            /**
             * Provides a set of validators used by form controls.
             *
             * # Example
             *
             * ```
             * var loginControl = new Control("", Validators.required)
             * ```
             *
             * @exportedAs angular2/forms
             */

            Validators = (function () {
                function Validators() {
                    _classCallCheck(this, Validators);
                }

                _createClass(Validators, null, [{
                    key: 'required',
                    value: function required(c) {
                        return isBlank(c.value) || c.value == '' ? { 'required': true } : null;
                    }
                }, {
                    key: 'nullValidator',
                    value: function nullValidator(c) {
                        return null;
                    }
                }, {
                    key: 'compose',
                    value: function compose(validators) {
                        return function (c) {
                            var res = ListWrapper.reduce(validators, function (res, validator) {
                                var errors = validator(c);
                                return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
                            }, {});
                            return StringMapWrapper.isEmpty(res) ? null : res;
                        };
                    }
                }, {
                    key: 'group',
                    value: function group(c) {
                        var res = {};
                        StringMapWrapper.forEach(c.controls, function (control, name) {
                            if (c.contains(name) && isPresent(control.errors)) {
                                Validators._mergeErrors(control, res);
                            }
                        });
                        return StringMapWrapper.isEmpty(res) ? null : res;
                    }
                }, {
                    key: 'array',
                    value: function array(c) {
                        var res = {};
                        ListWrapper.forEach(c.controls, function (control) {
                            if (isPresent(control.errors)) {
                                Validators._mergeErrors(control, res);
                            }
                        });
                        return StringMapWrapper.isEmpty(res) ? null : res;
                    }
                }, {
                    key: '_mergeErrors',
                    value: function _mergeErrors(control, res) {
                        StringMapWrapper.forEach(control.errors, function (value, error) {
                            if (!StringMapWrapper.contains(res, error)) {
                                res[error] = [];
                            }
                            ListWrapper.push(res[error], control);
                        });
                    }
                }]);

                return Validators;
            })();

            _export('Validators', Validators);
        }
    };
});


System.register("angular2/src/forms/directives/control_container_directive", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, ControlContainerDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            ControlContainerDirective = (function () {
                function ControlContainerDirective() {
                    _classCallCheck(this, ControlContainerDirective);
                }

                _createClass(ControlContainerDirective, [{
                    key: "formDirective",
                    get: function () {
                        return null;
                    }
                }, {
                    key: "path",
                    get: function () {
                        return null;
                    }
                }]);

                return ControlContainerDirective;
            })();

            _export("ControlContainerDirective", ControlContainerDirective);
        }
    };
});


System.register('angular2/src/forms/directives/control_directive', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/forms/validators'], function (_export) {
    var _createClass, _classCallCheck, Validators, ControlDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFormsValidators) {
            Validators = _angular2SrcFormsValidators.Validators;
        }],
        execute: function () {
            'use strict';

            ControlDirective = (function () {
                function ControlDirective() {
                    _classCallCheck(this, ControlDirective);

                    this.name = null;
                    this.valueAccessor = null;
                    this.validator = Validators.nullValidator;
                }

                _createClass(ControlDirective, [{
                    key: 'path',
                    get: function () {
                        return null;
                    }
                }]);

                return ControlDirective;
            })();

            _export('ControlDirective', ControlDirective);
        }
    };
});


System.register('angular2/src/forms/directives/shared', ['angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/forms/validators'], function (_export) {
    'use strict';

    var ListWrapper, isBlank, BaseException, Validators;

    _export('controlPath', controlPath);

    _export('setUpControl', setUpControl);

    function controlPath(name, parent) {
        var p = ListWrapper.clone(parent.path);
        ListWrapper.push(p, name);
        return p;
    }

    function setUpControl(c, dir) {
        if (isBlank(c)) _throwError(dir, 'Cannot find control');
        if (isBlank(dir.valueAccessor)) _throwError(dir, 'No value accessor for');
        c.validator = Validators.compose([c.validator, dir.validator]);
        dir.valueAccessor.writeValue(c.value);
        dir.valueAccessor.registerOnChange(function (newValue) {
            return c.updateValue(newValue);
        });
    }

    function _throwError(dir, message) {
        var path = ListWrapper.join(dir.path, ' -> ');
        throw new BaseException('' + message + ' \'' + path + '\'');
    }
    
    return {
        setters: [function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFormsValidators) {
            Validators = _angular2SrcFormsValidators.Validators;
        }],
        execute: function () {}
    };
});
System.register("angular2/src/forms/directives/form_control_directive", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/angular2", "angular2/di", "angular2/src/forms/directives/control_directive", "angular2/src/forms/directives/shared"], function (_export) {
    var _inherits, _createClass, _classCallCheck, CONST_EXPR, Directive, onChange, FORWARD_REF, Binding, ControlDirective, setUpControl, __decorate, __metadata, formControlBinding, FormControlDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            onChange = _angular2Angular2.onChange;
        }, function (_angular2Di) {
            FORWARD_REF = _angular2Di.FORWARD_REF;
            Binding = _angular2Di.Binding;
        }, function (_angular2SrcFormsDirectivesControl_directive) {
            ControlDirective = _angular2SrcFormsDirectivesControl_directive.ControlDirective;
        }, function (_angular2SrcFormsDirectivesShared) {
            setUpControl = _angular2SrcFormsDirectivesShared.setUpControl;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            formControlBinding = CONST_EXPR(new Binding(ControlDirective, { toAlias: FORWARD_REF(function () {
                    return FormControlDirective;
                }) }));

            FormControlDirective = (function (_ControlDirective) {
                var _class = function FormControlDirective() {
                    _classCallCheck(this, _class);

                    if (_ControlDirective != null) {
                        _ControlDirective.apply(this, arguments);
                    }
                };

                _inherits(_class, _ControlDirective);

                _createClass(_class, [{
                    key: "onChange",
                    value: function onChange(_) {
                        setUpControl(this.control, this);
                        this.control.updateValidity();
                    }
                }]);

                return _class;
            })(ControlDirective);

            _export("FormControlDirective", FormControlDirective);

            _export("FormControlDirective", FormControlDirective = __decorate([Directive({
                selector: "[form-control]",
                hostInjector: [formControlBinding],
                properties: ["control: form-control"],
                lifecycle: [onChange]
            }), __metadata("design:paramtypes", [])], FormControlDirective));
            
        }
    };
});
System.register("angular2/src/forms/directives/control_group_directive", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/angular2", "angular2/di", "angular2/src/facade/lang", "angular2/src/forms/directives/control_container_directive", "angular2/src/forms/directives/shared"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, Directive, Ancestor, onDestroy, onInit, FORWARD_REF, Binding, CONST_EXPR, ControlContainerDirective, controlPath, __decorate, __metadata, __param, controlGroupBinding, ControlGroupDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            onDestroy = _angular2Angular2.onDestroy;
            onInit = _angular2Angular2.onInit;
        }, function (_angular2Di) {
            FORWARD_REF = _angular2Di.FORWARD_REF;
            Binding = _angular2Di.Binding;
        }, function (_angular2SrcFacadeLang) {
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcFormsDirectivesControl_container_directive) {
            ControlContainerDirective = _angular2SrcFormsDirectivesControl_container_directive.ControlContainerDirective;
        }, function (_angular2SrcFormsDirectivesShared) {
            controlPath = _angular2SrcFormsDirectivesShared.controlPath;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            controlGroupBinding = CONST_EXPR(new Binding(ControlContainerDirective, { toAlias: FORWARD_REF(function () {
                    return ControlGroupDirective;
                }) }));

            /**
             * Binds a control group to a DOM element.
             *
             * # Example
             *
             * In this example, we bind the control group to the form element, and we bind the login and
             * password controls to the
             * login and password elements.
             *
             * Here we use {@link formDirectives}, rather than importing each form directive individually, e.g.
             * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.
             *
             *  ```
             * @Component({selector: "login-comp"})
             * @View({
             *      directives: [formDirectives],
             *      template: "<form [control-group]='loginForm'>" +
             *              "Login <input type='text' control='login'>" +
             *              "Password <input type='password' control='password'>" +
             *              "<button (click)="onLogin()">Login</button>" +
             *              "</form>"
             *      })
             * class LoginComp {
             *  loginForm:ControlGroup;
             *
             *  constructor() {
             *    this.loginForm = new ControlGroup({
             *      login: new Control(""),
             *      password: new Control("")
             *    });
             *  }
             *
             *  onLogin() {
             *    // this.loginForm.value
             *  }
             * }
             *
             *  ```
             *
             * @exportedAs angular2/forms
             */

            ControlGroupDirective = (function (_ControlContainerDirective) {
                var _class = function ControlGroupDirective(_parent) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this._parent = _parent;
                };

                _inherits(_class, _ControlContainerDirective);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        this.formDirective.addControlGroup(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.formDirective.removeControlGroup(this);
                    }
                }, {
                    key: "path",
                    get: function () {
                        return controlPath(this.name, this._parent);
                    }
                }, {
                    key: "formDirective",
                    get: function () {
                        return this._parent.formDirective;
                    }
                }]);

                return _class;
            })(ControlContainerDirective);

            _export("ControlGroupDirective", ControlGroupDirective);

            _export("ControlGroupDirective", ControlGroupDirective = __decorate([Directive({
                selector: "[control-group]",
                hostInjector: [controlGroupBinding],
                properties: ["name: control-group"],
                lifecycle: [onInit, onDestroy]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [ControlContainerDirective])], ControlGroupDirective));
            
        }
    };
});
System.register("angular2/src/forms/directives/form_model_directive", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/angular2", "angular2/di", "angular2/src/forms/directives/control_container_directive", "angular2/src/forms/directives/shared"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, CONST_EXPR, ListWrapper, Directive, onChange, FORWARD_REF, Binding, ControlContainerDirective, setUpControl, __decorate, __metadata, formDirectiveBinding, FormModelDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            onChange = _angular2Angular2.onChange;
        }, function (_angular2Di) {
            FORWARD_REF = _angular2Di.FORWARD_REF;
            Binding = _angular2Di.Binding;
        }, function (_angular2SrcFormsDirectivesControl_container_directive) {
            ControlContainerDirective = _angular2SrcFormsDirectivesControl_container_directive.ControlContainerDirective;
        }, function (_angular2SrcFormsDirectivesShared) {
            setUpControl = _angular2SrcFormsDirectivesShared.setUpControl;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            formDirectiveBinding = CONST_EXPR(new Binding(ControlContainerDirective, { toAlias: FORWARD_REF(function () {
                    return FormModelDirective;
                }) }));

            FormModelDirective = (function (_ControlContainerDirective) {
                var _class = function FormModelDirective() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this.form = null;
                    this.directives = [];
                };

                _inherits(_class, _ControlContainerDirective);

                _createClass(_class, [{
                    key: "onChange",
                    value: function onChange(_) {
                        this._updateDomValue();
                    }
                }, {
                    key: "formDirective",
                    get: function () {
                        return this;
                    }
                }, {
                    key: "path",
                    get: function () {
                        return [];
                    }
                }, {
                    key: "addControl",
                    value: function addControl(dir) {
                        var c = this.form.find(dir.path);
                        setUpControl(c, dir);
                        c.updateValidity();
                        ListWrapper.push(this.directives, dir);
                    }
                }, {
                    key: "removeControl",
                    value: function removeControl(dir) {
                        ListWrapper.remove(this.directives, dir);
                    }
                }, {
                    key: "addControlGroup",
                    value: function addControlGroup(dir) {}
                }, {
                    key: "removeControlGroup",
                    value: function removeControlGroup(dir) {}
                }, {
                    key: "_updateDomValue",
                    value: function _updateDomValue() {
                        var _this = this;

                        ListWrapper.forEach(this.directives, function (dir) {
                            var c = _this.form.find(dir.path);
                            dir.valueAccessor.writeValue(c.value);
                        });
                    }
                }]);

                return _class;
            })(ControlContainerDirective);

            _export("FormModelDirective", FormModelDirective);

            _export("FormModelDirective", FormModelDirective = __decorate([Directive({
                selector: "[form-model]",
                hostInjector: [formDirectiveBinding],
                properties: ["form: form-model"],
                lifecycle: [onChange]
            }), __metadata("design:paramtypes", [])], FormModelDirective));
            
        }
    };
});
System.register("angular2/src/forms/directives/template_driven_form_directive", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/annotations/decorators", "angular2/di", "angular2/src/forms/directives/control_container_directive", "angular2/src/forms/model", "angular2/src/forms/directives/shared"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, PromiseWrapper, ListWrapper, isPresent, CONST_EXPR, Directive, FORWARD_REF, Binding, ControlContainerDirective, ControlGroup, Control, setUpControl, __decorate, __metadata, formDirectiveBinding, TemplateDrivenFormDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcCoreAnnotationsDecorators) {
            Directive = _angular2SrcCoreAnnotationsDecorators.Directive;
        }, function (_angular2Di) {
            FORWARD_REF = _angular2Di.FORWARD_REF;
            Binding = _angular2Di.Binding;
        }, function (_angular2SrcFormsDirectivesControl_container_directive) {
            ControlContainerDirective = _angular2SrcFormsDirectivesControl_container_directive.ControlContainerDirective;
        }, function (_angular2SrcFormsModel) {
            ControlGroup = _angular2SrcFormsModel.ControlGroup;
            Control = _angular2SrcFormsModel.Control;
        }, function (_angular2SrcFormsDirectivesShared) {
            setUpControl = _angular2SrcFormsDirectivesShared.setUpControl;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            formDirectiveBinding = CONST_EXPR(new Binding(ControlContainerDirective, { toAlias: FORWARD_REF(function () {
                    return TemplateDrivenFormDirective;
                }) }));

            TemplateDrivenFormDirective = (function (_ControlContainerDirective) {
                var _class = function TemplateDrivenFormDirective() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this.form = new ControlGroup({});
                };

                _inherits(_class, _ControlContainerDirective);

                _createClass(_class, [{
                    key: "formDirective",
                    get: function () {
                        return this;
                    }
                }, {
                    key: "path",
                    get: function () {
                        return [];
                    }
                }, {
                    key: "controls",
                    get: function () {
                        return this.form.controls;
                    }
                }, {
                    key: "value",
                    get: function () {
                        return this.form.value;
                    }
                }, {
                    key: "addControl",
                    value: function addControl(dir) {
                        var _this = this;

                        this._later(function (_) {
                            var group = _this._findContainer(dir.path);
                            var c = new Control("");
                            setUpControl(c, dir);
                            group.addControl(dir.name, c);
                        });
                    }
                }, {
                    key: "removeControl",
                    value: function removeControl(dir) {
                        var _this2 = this;

                        this._later(function (_) {
                            var c = _this2._findContainer(dir.path);
                            if (isPresent(c)) c.removeControl(dir.name);
                        });
                    }
                }, {
                    key: "addControlGroup",
                    value: function addControlGroup(dir) {
                        var _this3 = this;

                        this._later(function (_) {
                            var group = _this3._findContainer(dir.path);
                            var c = new ControlGroup({});
                            group.addControl(dir.name, c);
                        });
                    }
                }, {
                    key: "removeControlGroup",
                    value: function removeControlGroup(dir) {
                        var _this4 = this;

                        this._later(function (_) {
                            var c = _this4._findContainer(dir.path);
                            if (isPresent(c)) c.removeControl(dir.name);
                        });
                    }
                }, {
                    key: "_findContainer",
                    value: function _findContainer(path) {
                        ListWrapper.removeLast(path);
                        return this.form.find(path);
                    }
                }, {
                    key: "_later",
                    value: function _later(fn) {
                        var c = PromiseWrapper.completer();
                        PromiseWrapper.then(c.promise, fn, function (_) {});
                        c.resolve(null);
                    }
                }]);

                return _class;
            })(ControlContainerDirective);

            _export("TemplateDrivenFormDirective", TemplateDrivenFormDirective);

            _export("TemplateDrivenFormDirective", TemplateDrivenFormDirective = __decorate([Directive({ selector: "[form]", hostInjector: [formDirectiveBinding] }), __metadata("design:paramtypes", [])], TemplateDrivenFormDirective));
            
        }
    };
});
System.register("angular2/src/forms/directives/default_value_accessor", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/angular2", "angular2/src/render/api", "angular2/src/forms/directives/control_directive"], function (_export) {
    var _createClass, _classCallCheck, ElementRef, Directive, Renderer, ControlDirective, __decorate, __metadata, DefaultValueAccessor;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_angular2SrcRenderApi) {
            Renderer = _angular2SrcRenderApi.Renderer;
        }, function (_angular2SrcFormsDirectivesControl_directive) {
            ControlDirective = _angular2SrcFormsDirectivesControl_directive.ControlDirective;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The default accessor for writing a value and listening to changes that is used by a {@link
              * Control} directive.
             *
             * This is the default strategy that Angular uses when no other accessor is applied.
             *
             *  # Example
             *  ```
             *  <input type="text" [control]="loginControl">
             *  ```
             *
             * @exportedAs angular2/forms
             */

            DefaultValueAccessor = (function () {
                var _class = function DefaultValueAccessor(cd, _elementRef, _renderer) {
                    _classCallCheck(this, _class);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.value = null;
                    this.onChange = function (_) {};
                    cd.valueAccessor = this;
                };

                _createClass(_class, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, "value", value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }]);

                return _class;
            })();

            _export("DefaultValueAccessor", DefaultValueAccessor);

            _export("DefaultValueAccessor", DefaultValueAccessor = __decorate([Directive({
                selector: "input:not([type=checkbox])[control],textarea[control],input:not([type=checkbox])[form-control],textarea[form-control]",
                hostListeners: { "change": "onChange($event.target.value)", "input": "onChange($event.target.value)" },
                hostProperties: { "value": "value" }
            }), __metadata("design:paramtypes", [ControlDirective, ElementRef, Renderer])], DefaultValueAccessor));
            
        }
    };
});
System.register("angular2/src/forms/directives/checkbox_value_accessor", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/angular2", "angular2/src/render/api", "angular2/src/forms/directives/control_directive"], function (_export) {
    var _createClass, _classCallCheck, ElementRef, Directive, Renderer, ControlDirective, __decorate, __metadata, CheckboxControlValueAccessor;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_angular2SrcRenderApi) {
            Renderer = _angular2SrcRenderApi.Renderer;
        }, function (_angular2SrcFormsDirectivesControl_directive) {
            ControlDirective = _angular2SrcFormsDirectivesControl_directive.ControlDirective;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The accessor for writing a value and listening to changes on a checkbox input element.
             *
             *
             *  # Example
             *  ```
             *  <input type="checkbox" [control]="rememberLogin">
             *  ```
             *
             * @exportedAs angular2/forms
             */

            CheckboxControlValueAccessor = (function () {
                var _class = function CheckboxControlValueAccessor(cd, _elementRef, _renderer) {
                    _classCallCheck(this, _class);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.onChange = function (_) {};
                    cd.valueAccessor = this;
                };

                _createClass(_class, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, "checked", value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }]);

                return _class;
            })();

            _export("CheckboxControlValueAccessor", CheckboxControlValueAccessor);

            _export("CheckboxControlValueAccessor", CheckboxControlValueAccessor = __decorate([Directive({
                selector: "input[type=checkbox][control],input[type=checkbox][form-control]",
                hostListeners: { "change": "onChange($event.target.checked)" },
                hostProperties: { "checked": "checked" }
            }), __metadata("design:paramtypes", [ControlDirective, ElementRef, Renderer])], CheckboxControlValueAccessor));
            
        }
    };
});
System.register("angular2/src/forms/directives/select_control_value_accessor", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/angular2", "angular2/src/render/api", "angular2/src/forms/directives/control_directive"], function (_export) {
    var _createClass, _classCallCheck, ElementRef, Directive, Renderer, ControlDirective, __decorate, __metadata, SelectControlValueAccessor;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_angular2SrcRenderApi) {
            Renderer = _angular2SrcRenderApi.Renderer;
        }, function (_angular2SrcFormsDirectivesControl_directive) {
            ControlDirective = _angular2SrcFormsDirectivesControl_directive.ControlDirective;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The accessor for writing a value and listening to changes that is used by a {@link
              * Control} directive.
             *
             * This is the default strategy that Angular uses when no other accessor is applied.
             *
             *  # Example
             *  ```
             *  <input type="text" [control]="loginControl">
             *  ```
             *
             * @exportedAs angular2/forms
             */

            SelectControlValueAccessor = (function () {
                var _class = function SelectControlValueAccessor(cd, _elementRef, _renderer) {
                    _classCallCheck(this, _class);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    this.value = null;
                    this.onChange = function (_) {};
                    this.value = "";
                    cd.valueAccessor = this;
                };

                _createClass(_class, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, "value", value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }]);

                return _class;
            })();

            _export("SelectControlValueAccessor", SelectControlValueAccessor);

            _export("SelectControlValueAccessor", SelectControlValueAccessor = __decorate([Directive({
                selector: "select[control],select[form-control]",
                hostListeners: { "change": "onChange($event.target.value)", "input": "onChange($event.target.value)" },
                hostProperties: { "value": "value" }
            }), __metadata("design:paramtypes", [ControlDirective, ElementRef, Renderer])], SelectControlValueAccessor));
            
        }
    };
});
System.register("angular2/src/forms/validator_directives", ["npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/angular2", "angular2/src/forms/validators", "angular2/src/forms/directives"], function (_export) {
    var _classCallCheck, Directive, Validators, ControlDirective, __decorate, __metadata, RequiredValidatorDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_angular2SrcFormsValidators) {
            Validators = _angular2SrcFormsValidators.Validators;
        }, function (_angular2SrcFormsDirectives) {
            ControlDirective = _angular2SrcFormsDirectives.ControlDirective;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            RequiredValidatorDirective = (function () {
                var _class = function RequiredValidatorDirective(c) {
                    _classCallCheck(this, _class);

                    c.validator = Validators.compose([c.validator, Validators.required]);
                };

                return _class;
            })();

            _export("RequiredValidatorDirective", RequiredValidatorDirective);

            _export("RequiredValidatorDirective", RequiredValidatorDirective = __decorate([Directive({ selector: "[required]" }), __metadata("design:paramtypes", [ControlDirective])], RequiredValidatorDirective));
            
        }
    };
});
System.register('angular2/src/forms/form_builder', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/forms/model'], function (_export) {
    var _createClass, _classCallCheck, StringMapWrapper, ListWrapper, isPresent, modelModule, FormBuilder;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFormsModel) {
            modelModule = _angular2SrcFormsModel;
        }],
        execute: function () {
            'use strict';

            /**
             * Creates a form object from a user-specified configuration.
             *
             * # Example
             *
             * ```
             * import {Component, View, bootstrap} from 'angular2/angular2';
             * import {FormBuilder, Validators, formDirectives, ControlGroup} from 'angular2/forms';
             *
             * @Component({
             *   selector: 'login-comp',
             *   appInjector: [
             *     FormBuilder
             *   ]
             * })
             * @View({
             *   template: `
             *     <form [control-group]="loginForm">
             *       Login <input control="login">
             *
             *       <div control-group="passwordRetry">
             *         Password <input type="password" control="password">
             *         Confirm password <input type="password" control="passwordConfirmation">
             *       </div>
             *     </form>
             *   `,
             *   directives: [
             *     formDirectives
             *   ]
             * })
             * class LoginComp {
             *   loginForm: ControlGroup;
             *
             *   constructor(builder: FormBuilder) {
             *     this.loginForm = builder.group({
             *       login: ["", Validators.required],
             *
             *       passwordRetry: builder.group({
             *         password: ["", Validators.required],
             *         passwordConfirmation: ["", Validators.required]
             *       })
             *     });
             *   }
             * }
             *
             * bootstrap(LoginComp)
             * ```
             *
             * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a
             * nested
             * {@link ControlGroup} that defines a `password` and a `passwordConfirmation` {@link Control}:
             *
             * ```
             *  var loginForm = builder.group({
             *    login: ["", Validators.required],
             *
             *    passwordRetry: builder.group({
             *      password: ["", Validators.required],
             *      passwordConfirmation: ["", Validators.required]
             *    })
             *  });
             *
             *  ```
             * @exportedAs angular2/forms
             */

            FormBuilder = (function () {
                function FormBuilder() {
                    _classCallCheck(this, FormBuilder);
                }

                _createClass(FormBuilder, [{
                    key: 'group',
                    value: function group(controlsConfig) {
                        var extra = arguments[1] === undefined ? null : arguments[1];

                        var controls = this._reduceControls(controlsConfig);
                        var optionals = isPresent(extra) ? StringMapWrapper.get(extra, 'optionals') : null;
                        var validator = isPresent(extra) ? StringMapWrapper.get(extra, 'validator') : null;
                        if (isPresent(validator)) {
                            return new modelModule.ControlGroup(controls, optionals, validator);
                        } else {
                            return new modelModule.ControlGroup(controls, optionals);
                        }
                    }
                }, {
                    key: 'control',
                    value: function control(value) {
                        var validator = arguments[1] === undefined ? null : arguments[1];

                        if (isPresent(validator)) {
                            return new modelModule.Control(value, validator);
                        } else {
                            return new modelModule.Control(value);
                        }
                    }
                }, {
                    key: 'array',
                    value: function array(controlsConfig) {
                        var _this = this;

                        var validator = arguments[1] === undefined ? null : arguments[1];

                        var controls = ListWrapper.map(controlsConfig, function (c) {
                            return _this._createControl(c);
                        });
                        if (isPresent(validator)) {
                            return new modelModule.ControlArray(controls, validator);
                        } else {
                            return new modelModule.ControlArray(controls);
                        }
                    }
                }, {
                    key: '_reduceControls',
                    value: function _reduceControls(controlsConfig) {
                        var _this2 = this;

                        var controls = {};
                        StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {
                            controls[controlName] = _this2._createControl(controlConfig);
                        });
                        return controls;
                    }
                }, {
                    key: '_createControl',
                    value: function _createControl(controlConfig) {
                        if (controlConfig instanceof modelModule.Control || controlConfig instanceof modelModule.ControlGroup || controlConfig instanceof modelModule.ControlArray) {
                            return controlConfig;
                        } else if (ListWrapper.isList(controlConfig)) {
                            var value = ListWrapper.get(controlConfig, 0);
                            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
                            return this.control(value, validator);
                        } else {
                            return this.control(controlConfig);
                        }
                    }
                }]);

                return FormBuilder;
            })();

            _export('FormBuilder', FormBuilder);
        }
    };
});


System.register('angular2/src/di/decorators', ['angular2/src/di/annotations', 'angular2/src/util/decorators'], function (_export) {
  'use strict';

  var InjectAnnotation, InjectPromiseAnnotation, InjectLazyAnnotation, OptionalAnnotation, InjectableAnnotation, makeDecorator, makeParamDecorator, Inject, InjectPromise, InjectLazy, Optional, Injectable;
  return {
    setters: [function (_angular2SrcDiAnnotations) {
      InjectAnnotation = _angular2SrcDiAnnotations.InjectAnnotation;
      InjectPromiseAnnotation = _angular2SrcDiAnnotations.InjectPromiseAnnotation;
      InjectLazyAnnotation = _angular2SrcDiAnnotations.InjectLazyAnnotation;
      OptionalAnnotation = _angular2SrcDiAnnotations.OptionalAnnotation;
      InjectableAnnotation = _angular2SrcDiAnnotations.InjectableAnnotation;
    }, function (_angular2SrcUtilDecorators) {
      makeDecorator = _angular2SrcUtilDecorators.makeDecorator;
      makeParamDecorator = _angular2SrcUtilDecorators.makeParamDecorator;
    }],
    execute: function () {
      Inject = makeParamDecorator(InjectAnnotation);

      _export('Inject', Inject);

      InjectPromise = makeParamDecorator(InjectPromiseAnnotation);

      _export('InjectPromise', InjectPromise);

      InjectLazy = makeParamDecorator(InjectLazyAnnotation);

      _export('InjectLazy', InjectLazy);

      Optional = makeParamDecorator(OptionalAnnotation);

      _export('Optional', Optional);

      Injectable = makeDecorator(InjectableAnnotation);

      

      _export('Injectable', Injectable);
    }
  };
});
System.register('angular2/src/reflection/reflection', ['angular2/src/reflection/reflector', 'angular2/src/reflection/reflection_capabilities'], function (_export) {
  'use strict';

  var Reflector, ReflectionCapabilities, reflector;
  return {
    setters: [function (_angular2SrcReflectionReflector) {
      Reflector = _angular2SrcReflectionReflector.Reflector;

      _export('Reflector', _angular2SrcReflectionReflector.Reflector);
    }, function (_angular2SrcReflectionReflection_capabilities) {
      ReflectionCapabilities = _angular2SrcReflectionReflection_capabilities.ReflectionCapabilities;
    }],
    execute: function () {
      reflector = new Reflector(new ReflectionCapabilities());

      

      _export('reflector', reflector);
    }
  };
});
System.register('angular2/src/change_detection/change_detection_util', ['npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/create-class', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/change_detection/exceptions', 'angular2/src/change_detection/pipes/pipe', 'angular2/src/change_detection/constants'], function (_export) {
    var _classCallCheck, _createClass, isBlank, BaseException, StringMapWrapper, ExpressionChangedAfterItHasBeenChecked, WrappedValue, CHECK_ALWAYS, CHECK_ONCE, ON_PUSH, _uninitialized, SimpleChange, _simpleChangesIndex, _simpleChanges, ChangeDetectionUtil;

    function _simpleChange(previousValue, currentValue) {
        var index = _simpleChangesIndex++ % 20;
        var s = _simpleChanges[index];
        s.previousValue = previousValue;
        s.currentValue = currentValue;
        return s;
    }
    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2SrcChange_detectionExceptions) {
            ExpressionChangedAfterItHasBeenChecked = _angular2SrcChange_detectionExceptions.ExpressionChangedAfterItHasBeenChecked;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            WrappedValue = _angular2SrcChange_detectionPipesPipe.WrappedValue;
        }, function (_angular2SrcChange_detectionConstants) {
            CHECK_ALWAYS = _angular2SrcChange_detectionConstants.CHECK_ALWAYS;
            CHECK_ONCE = _angular2SrcChange_detectionConstants.CHECK_ONCE;
            ON_PUSH = _angular2SrcChange_detectionConstants.ON_PUSH;
        }],
        execute: function () {
            'use strict';

            _uninitialized = new Object();

            _export('uninitialized', _uninitialized);

            SimpleChange = function SimpleChange(previousValue, currentValue) {
                _classCallCheck(this, SimpleChange);

                this.previousValue = previousValue;
                this.currentValue = currentValue;
            };

            _export('SimpleChange', SimpleChange);

            _simpleChangesIndex = 0;
            _simpleChanges = [new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null)];

            ChangeDetectionUtil = (function () {
                function ChangeDetectionUtil() {
                    _classCallCheck(this, ChangeDetectionUtil);
                }

                _createClass(ChangeDetectionUtil, null, [{
                    key: 'uninitialized',
                    value: function uninitialized() {
                        return _uninitialized;
                    }
                }, {
                    key: 'arrayFn0',
                    value: function arrayFn0() {
                        return [];
                    }
                }, {
                    key: 'arrayFn1',
                    value: function arrayFn1(a1) {
                        return [a1];
                    }
                }, {
                    key: 'arrayFn2',
                    value: function arrayFn2(a1, a2) {
                        return [a1, a2];
                    }
                }, {
                    key: 'arrayFn3',
                    value: function arrayFn3(a1, a2, a3) {
                        return [a1, a2, a3];
                    }
                }, {
                    key: 'arrayFn4',
                    value: function arrayFn4(a1, a2, a3, a4) {
                        return [a1, a2, a3, a4];
                    }
                }, {
                    key: 'arrayFn5',
                    value: function arrayFn5(a1, a2, a3, a4, a5) {
                        return [a1, a2, a3, a4, a5];
                    }
                }, {
                    key: 'arrayFn6',
                    value: function arrayFn6(a1, a2, a3, a4, a5, a6) {
                        return [a1, a2, a3, a4, a5, a6];
                    }
                }, {
                    key: 'arrayFn7',
                    value: function arrayFn7(a1, a2, a3, a4, a5, a6, a7) {
                        return [a1, a2, a3, a4, a5, a6, a7];
                    }
                }, {
                    key: 'arrayFn8',
                    value: function arrayFn8(a1, a2, a3, a4, a5, a6, a7, a8) {
                        return [a1, a2, a3, a4, a5, a6, a7, a8];
                    }
                }, {
                    key: 'arrayFn9',
                    value: function arrayFn9(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                        return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
                    }
                }, {
                    key: 'operation_negate',
                    value: function operation_negate(value) {
                        return !value;
                    }
                }, {
                    key: 'operation_add',
                    value: function operation_add(left, right) {
                        return left + right;
                    }
                }, {
                    key: 'operation_subtract',
                    value: function operation_subtract(left, right) {
                        return left - right;
                    }
                }, {
                    key: 'operation_multiply',
                    value: function operation_multiply(left, right) {
                        return left * right;
                    }
                }, {
                    key: 'operation_divide',
                    value: function operation_divide(left, right) {
                        return left / right;
                    }
                }, {
                    key: 'operation_remainder',
                    value: function operation_remainder(left, right) {
                        return left % right;
                    }
                }, {
                    key: 'operation_equals',
                    value: function operation_equals(left, right) {
                        return left == right;
                    }
                }, {
                    key: 'operation_not_equals',
                    value: function operation_not_equals(left, right) {
                        return left != right;
                    }
                }, {
                    key: 'operation_identical',
                    value: function operation_identical(left, right) {
                        return left === right;
                    }
                }, {
                    key: 'operation_not_identical',
                    value: function operation_not_identical(left, right) {
                        return left !== right;
                    }
                }, {
                    key: 'operation_less_then',
                    value: function operation_less_then(left, right) {
                        return left < right;
                    }
                }, {
                    key: 'operation_greater_then',
                    value: function operation_greater_then(left, right) {
                        return left > right;
                    }
                }, {
                    key: 'operation_less_or_equals_then',
                    value: function operation_less_or_equals_then(left, right) {
                        return left <= right;
                    }
                }, {
                    key: 'operation_greater_or_equals_then',
                    value: function operation_greater_or_equals_then(left, right) {
                        return left >= right;
                    }
                }, {
                    key: 'operation_logical_and',
                    value: function operation_logical_and(left, right) {
                        return left && right;
                    }
                }, {
                    key: 'operation_logical_or',
                    value: function operation_logical_or(left, right) {
                        return left || right;
                    }
                }, {
                    key: 'cond',
                    value: function cond(_cond, trueVal, falseVal) {
                        return _cond ? trueVal : falseVal;
                    }
                }, {
                    key: 'mapFn',
                    value: function mapFn(keys) {
                        function buildMap(values) {
                            var res = StringMapWrapper.create();
                            for (var i = 0; i < keys.length; ++i) {
                                StringMapWrapper.set(res, keys[i], values[i]);
                            }
                            return res;
                        }
                        switch (keys.length) {
                            case 0:
                                return function () {
                                    return [];
                                };
                            case 1:
                                return function (a1) {
                                    return buildMap([a1]);
                                };
                            case 2:
                                return function (a1, a2) {
                                    return buildMap([a1, a2]);
                                };
                            case 3:
                                return function (a1, a2, a3) {
                                    return buildMap([a1, a2, a3]);
                                };
                            case 4:
                                return function (a1, a2, a3, a4) {
                                    return buildMap([a1, a2, a3, a4]);
                                };
                            case 5:
                                return function (a1, a2, a3, a4, a5) {
                                    return buildMap([a1, a2, a3, a4, a5]);
                                };
                            case 6:
                                return function (a1, a2, a3, a4, a5, a6) {
                                    return buildMap([a1, a2, a3, a4, a5, a6]);
                                };
                            case 7:
                                return function (a1, a2, a3, a4, a5, a6, a7) {
                                    return buildMap([a1, a2, a3, a4, a5, a6, a7]);
                                };
                            case 8:
                                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
                                    return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]);
                                };
                            case 9:
                                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                                    return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                                };
                            default:
                                throw new BaseException('Does not support literal maps with more than 9 elements');
                        }
                    }
                }, {
                    key: 'keyedAccess',
                    value: function keyedAccess(obj, args) {
                        return obj[args[0]];
                    }
                }, {
                    key: 'unwrapValue',
                    value: function unwrapValue(value) {
                        if (value instanceof WrappedValue) {
                            return value.wrapped;
                        } else {
                            return value;
                        }
                    }
                }, {
                    key: 'throwOnChange',
                    value: function throwOnChange(proto, change) {
                        throw new ExpressionChangedAfterItHasBeenChecked(proto, change);
                    }
                }, {
                    key: 'changeDetectionMode',
                    value: function changeDetectionMode(strategy) {
                        return strategy == ON_PUSH ? CHECK_ONCE : CHECK_ALWAYS;
                    }
                }, {
                    key: 'simpleChange',
                    value: function simpleChange(previousValue, currentValue) {
                        return _simpleChange(previousValue, currentValue);
                    }
                }, {
                    key: 'addChange',
                    value: function addChange(changes, propertyName, change) {
                        if (isBlank(changes)) {
                            changes = {};
                        }
                        changes[propertyName] = change;
                        return changes;
                    }
                }, {
                    key: 'isValueBlank',
                    value: function isValueBlank(value) {
                        return isBlank(value);
                    }
                }]);

                return ChangeDetectionUtil;
            })();

            _export('ChangeDetectionUtil', ChangeDetectionUtil);
        }
    };
});


System.register('angular2/src/change_detection/abstract_change_detector', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/change_detection/change_detector_ref', 'angular2/src/change_detection/interfaces', 'angular2/src/change_detection/constants'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, isPresent, ListWrapper, ChangeDetectorRef, ChangeDetector, CHECK_ONCE, CHECKED, DETACHED, AbstractChangeDetector;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcChange_detectionChange_detector_ref) {
            ChangeDetectorRef = _angular2SrcChange_detectionChange_detector_ref.ChangeDetectorRef;
        }, function (_angular2SrcChange_detectionInterfaces) {
            ChangeDetector = _angular2SrcChange_detectionInterfaces.ChangeDetector;
        }, function (_angular2SrcChange_detectionConstants) {
            CHECK_ONCE = _angular2SrcChange_detectionConstants.CHECK_ONCE;
            CHECKED = _angular2SrcChange_detectionConstants.CHECKED;
            DETACHED = _angular2SrcChange_detectionConstants.DETACHED;
        }],
        execute: function () {
            'use strict';

            AbstractChangeDetector = (function (_ChangeDetector) {
                function AbstractChangeDetector() {
                    _classCallCheck(this, AbstractChangeDetector);

                    _get(Object.getPrototypeOf(AbstractChangeDetector.prototype), 'constructor', this).call(this);
                    this.lightDomChildren = [];
                    this.shadowDomChildren = [];
                    this.ref = new ChangeDetectorRef(this);
                    this.mode = null;
                }

                _inherits(AbstractChangeDetector, _ChangeDetector);

                _createClass(AbstractChangeDetector, [{
                    key: 'addChild',
                    value: function addChild(cd) {
                        ListWrapper.push(this.lightDomChildren, cd);
                        cd.parent = this;
                    }
                }, {
                    key: 'removeChild',
                    value: function removeChild(cd) {
                        ListWrapper.remove(this.lightDomChildren, cd);
                    }
                }, {
                    key: 'addShadowDomChild',
                    value: function addShadowDomChild(cd) {
                        ListWrapper.push(this.shadowDomChildren, cd);
                        cd.parent = this;
                    }
                }, {
                    key: 'removeShadowDomChild',
                    value: function removeShadowDomChild(cd) {
                        ListWrapper.remove(this.shadowDomChildren, cd);
                    }
                }, {
                    key: 'remove',
                    value: function remove() {
                        this.parent.removeChild(this);
                    }
                }, {
                    key: 'detectChanges',
                    value: function detectChanges() {
                        this._detectChanges(false);
                    }
                }, {
                    key: 'checkNoChanges',
                    value: function checkNoChanges() {
                        this._detectChanges(true);
                    }
                }, {
                    key: '_detectChanges',
                    value: function _detectChanges(throwOnChange) {
                        if (this.mode === DETACHED || this.mode === CHECKED) return;
                        this.detectChangesInRecords(throwOnChange);
                        this._detectChangesInLightDomChildren(throwOnChange);
                        if (throwOnChange === false) this.callOnAllChangesDone();
                        this._detectChangesInShadowDomChildren(throwOnChange);
                        if (this.mode === CHECK_ONCE) this.mode = CHECKED;
                    }
                }, {
                    key: 'detectChangesInRecords',
                    value: function detectChangesInRecords(throwOnChange) {}
                }, {
                    key: 'callOnAllChangesDone',
                    value: function callOnAllChangesDone() {}
                }, {
                    key: '_detectChangesInLightDomChildren',
                    value: function _detectChangesInLightDomChildren(throwOnChange) {
                        var c = this.lightDomChildren;
                        for (var i = 0; i < c.length; ++i) {
                            c[i]._detectChanges(throwOnChange);
                        }
                    }
                }, {
                    key: '_detectChangesInShadowDomChildren',
                    value: function _detectChangesInShadowDomChildren(throwOnChange) {
                        var c = this.shadowDomChildren;
                        for (var i = 0; i < c.length; ++i) {
                            c[i]._detectChanges(throwOnChange);
                        }
                    }
                }, {
                    key: 'markAsCheckOnce',
                    value: function markAsCheckOnce() {
                        this.mode = CHECK_ONCE;
                    }
                }, {
                    key: 'markPathToRootAsCheckOnce',
                    value: function markPathToRootAsCheckOnce() {
                        var c = this;
                        while (isPresent(c) && c.mode != DETACHED) {
                            if (c.mode === CHECKED) c.mode = CHECK_ONCE;
                            c = c.parent;
                        }
                    }
                }]);

                return AbstractChangeDetector;
            })(ChangeDetector);

            _export('AbstractChangeDetector', AbstractChangeDetector);
        }
    };
});


System.register('angular2/src/core/annotations/visibility', ['angular2/src/core/annotations_impl/visibility'], function (_export) {
  'use strict';

  
  return {
    setters: [function (_angular2SrcCoreAnnotations_implVisibility) {
      _export('SelfAnnotation', _angular2SrcCoreAnnotations_implVisibility.Self);

      _export('AncestorAnnotation', _angular2SrcCoreAnnotations_implVisibility.Ancestor);

      _export('ParentAnnotation', _angular2SrcCoreAnnotations_implVisibility.Parent);

      _export('UnboundedAnnotation', _angular2SrcCoreAnnotations_implVisibility.Unbounded);
    }],
    execute: function () {}
  };
});
System.register('angular2/src/core/annotations/view', ['angular2/src/core/annotations_impl/view'], function (_export) {
  
  'use strict';

  return {
    setters: [function (_angular2SrcCoreAnnotations_implView) {
      _export('ViewAnnotation', _angular2SrcCoreAnnotations_implView.View);
    }],
    execute: function () {}
  };
});
System.register('angular2/src/di/key', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/di/type_literal', 'angular2/src/di/forward_ref'], function (_export) {
    var _createClass, _classCallCheck, MapWrapper, stringify, isBlank, BaseException, TypeLiteral, resolveForwardRef, Key, KeyRegistry, _globalKeyRegistry;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcFacadeLang) {
            stringify = _angular2SrcFacadeLang.stringify;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcDiType_literal) {
            TypeLiteral = _angular2SrcDiType_literal.TypeLiteral;

            _export('TypeLiteral', _angular2SrcDiType_literal.TypeLiteral);
        }, function (_angular2SrcDiForward_ref) {
            resolveForwardRef = _angular2SrcDiForward_ref.resolveForwardRef;
        }],
        execute: function () {
            'use strict';

            // TODO: uncoment `int` once https://github.com/angular/angular/issues/1414 is fixed
            /**
             * A unique object used for retrieving items from the {@link Injector}.
             *
             * Keys have:
             * - a system-wide unique `id`.
             * - a `token`, usually the `Type` of the instance.
             *
             * Keys are used internally by the {@link Injector} because their system-wide unique `id`s allow the
             * injector to index in arrays rather than looking up items in maps.
             *
             * @exportedAs angular2/di
             */

            Key = (function () {
                /**
                 * @private
                 */

                function Key(token, id) {
                    _classCallCheck(this, Key);

                    if (isBlank(token)) {
                        throw new BaseException('Token must be defined!');
                    }
                    this.token = token;
                    this.id = id;
                }

                _createClass(Key, [{
                    key: 'displayName',
                    get: function () {
                        return stringify(this.token);
                    }
                }], [{
                    key: 'get',

                    /**
                     * Retrieves a `Key` for a token.
                     */
                    value: function get(token) {
                        return _globalKeyRegistry.get(resolveForwardRef(token));
                    }
                }, {
                    key: 'numberOfKeys',

                    /**
                     * @returns the number of keys registered in the system.
                     */
                    get: function () {
                        return _globalKeyRegistry.numberOfKeys;
                    }
                }]);

                return Key;
            })();

            _export('Key', Key);

            /**
             * @private
             */

            KeyRegistry = (function () {
                function KeyRegistry() {
                    _classCallCheck(this, KeyRegistry);

                    this._allKeys = MapWrapper.create();
                }

                _createClass(KeyRegistry, [{
                    key: 'get',
                    value: function get(token) {
                        if (token instanceof Key) return token;
                        // TODO: workaround for https://github.com/Microsoft/TypeScript/issues/3123
                        var theToken = token;
                        if (token instanceof TypeLiteral) {
                            theToken = token.type;
                        }
                        token = theToken;
                        if (MapWrapper.contains(this._allKeys, token)) {
                            return MapWrapper.get(this._allKeys, token);
                        }
                        var newKey = new Key(token, Key.numberOfKeys);
                        MapWrapper.set(this._allKeys, token, newKey);
                        return newKey;
                    }
                }, {
                    key: 'numberOfKeys',
                    get: function () {
                        return MapWrapper.size(this._allKeys);
                    }
                }]);

                return KeyRegistry;
            })();

            _export('KeyRegistry', KeyRegistry);

            _globalKeyRegistry = new KeyRegistry();

            
        }
    };
});
System.register('angular2/src/dom/browser_adapter', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/dom/dom_adapter', 'angular2/src/dom/generic_browser_adapter'], function (_export) {
    var _inherits, _createClass, _classCallCheck, MapWrapper, ListWrapper, isBlank, isPresent, global, setRootDomAdapter, GenericBrowserDomAdapter, _attrToPropMap, DOM_KEY_LOCATION_NUMPAD, _keyMap, _chromeNumKeyPadMap, BrowserDomAdapter, urlParsingNode;

    function relativePath(url) {
        if (isBlank(urlParsingNode)) {
            urlParsingNode = document.createElement('a');
        }
        urlParsingNode.setAttribute('href', url);
        return urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            global = _angular2SrcFacadeLang.global;
        }, function (_angular2SrcDomDom_adapter) {
            setRootDomAdapter = _angular2SrcDomDom_adapter.setRootDomAdapter;
        }, function (_angular2SrcDomGeneric_browser_adapter) {
            GenericBrowserDomAdapter = _angular2SrcDomGeneric_browser_adapter.GenericBrowserDomAdapter;
        }],
        execute: function () {
            'use strict';

            _attrToPropMap = { 'innerHtml': 'innerHTML', 'readonly': 'readOnly', 'tabindex': 'tabIndex' };
            DOM_KEY_LOCATION_NUMPAD = 3;

            // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
            _keyMap = {
                // The following values are here for cross-browser compatibility and to match the W3C standard
                // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
                '\b': 'Backspace',
                '\t': 'Tab',
                '': 'Delete',
                '\u001b': 'Escape',
                'Del': 'Delete',
                'Esc': 'Escape',
                'Left': 'ArrowLeft',
                'Right': 'ArrowRight',
                'Up': 'ArrowUp',
                'Down': 'ArrowDown',
                'Menu': 'ContextMenu',
                'Scroll': 'ScrollLock',
                'Win': 'OS'
            };

            // There is a bug in Chrome for numeric keypad keys:
            // https://code.google.com/p/chromium/issues/detail?id=155654
            // 1, 2, 3 ... are reported as A, B, C ...
            _chromeNumKeyPadMap = {
                'A': '1',
                'B': '2',
                'C': '3',
                'D': '4',
                'E': '5',
                'F': '6',
                'G': '7',
                'H': '8',
                'I': '9',
                'J': '*',
                'K': '+',
                'M': '-',
                'N': '.',
                'O': '/',
                '`': '0',
                '': 'NumLock'
            };

            BrowserDomAdapter = (function (_GenericBrowserDomAdapter) {
                function BrowserDomAdapter() {
                    _classCallCheck(this, BrowserDomAdapter);

                    if (_GenericBrowserDomAdapter != null) {
                        _GenericBrowserDomAdapter.apply(this, arguments);
                    }
                }

                _inherits(BrowserDomAdapter, _GenericBrowserDomAdapter);

                _createClass(BrowserDomAdapter, [{
                    key: 'logError',

                    // TODO(tbosch): move this into a separate environment class once we have it
                    value: function logError(error) {
                        window.console.error(error);
                    }
                }, {
                    key: 'attrToPropMap',
                    get: function () {
                        return _attrToPropMap;
                    }
                }, {
                    key: 'query',
                    value: function query(selector) {
                        return document.querySelector(selector);
                    }
                }, {
                    key: 'querySelector',
                    value: function querySelector(el, selector) {
                        return el.querySelector(selector);
                    }
                }, {
                    key: 'querySelectorAll',
                    value: function querySelectorAll(el, selector) {
                        return el.querySelectorAll(selector);
                    }
                }, {
                    key: 'on',
                    value: function on(el, evt, listener) {
                        el.addEventListener(evt, listener, false);
                    }
                }, {
                    key: 'onAndCancel',
                    value: function onAndCancel(el, evt, listener) {
                        el.addEventListener(evt, listener, false);
                        // Needed to follow Dart's subscription semantic, until fix of
                        // https://code.google.com/p/dart/issues/detail?id=17406
                        return function () {
                            el.removeEventListener(evt, listener, false);
                        };
                    }
                }, {
                    key: 'dispatchEvent',
                    value: function dispatchEvent(el, evt) {
                        el.dispatchEvent(evt);
                    }
                }, {
                    key: 'createMouseEvent',
                    value: function createMouseEvent(eventType) {
                        var evt = document.createEvent('MouseEvent');
                        evt.initEvent(eventType, true, true);
                        return evt;
                    }
                }, {
                    key: 'createEvent',
                    value: function createEvent(eventType) {
                        var evt = document.createEvent('Event');
                        evt.initEvent(eventType, true, true);
                        return evt;
                    }
                }, {
                    key: 'preventDefault',
                    value: function preventDefault(evt) {
                        evt.preventDefault();
                        evt.returnValue = false;
                    }
                }, {
                    key: 'getInnerHTML',
                    value: function getInnerHTML(el) {
                        return el.innerHTML;
                    }
                }, {
                    key: 'getOuterHTML',
                    value: function getOuterHTML(el) {
                        return el.outerHTML;
                    }
                }, {
                    key: 'nodeName',
                    value: function nodeName(node) {
                        return node.nodeName;
                    }
                }, {
                    key: 'nodeValue',
                    value: function nodeValue(node) {
                        return node.nodeValue;
                    }
                }, {
                    key: 'type',
                    value: function type(node) {
                        return node.type;
                    }
                }, {
                    key: 'content',
                    value: function content(node) {
                        if (this.hasProperty(node, 'content')) {
                            return node.content;
                        } else {
                            return node;
                        }
                    }
                }, {
                    key: 'firstChild',
                    value: function firstChild(el) {
                        return el.firstChild;
                    }
                }, {
                    key: 'nextSibling',
                    value: function nextSibling(el) {
                        return el.nextSibling;
                    }
                }, {
                    key: 'parentElement',
                    value: function parentElement(el) {
                        return el.parentElement;
                    }
                }, {
                    key: 'childNodes',
                    value: function childNodes(el) {
                        return el.childNodes;
                    }
                }, {
                    key: 'childNodesAsList',
                    value: function childNodesAsList(el) {
                        var childNodes = el.childNodes;
                        var res = ListWrapper.createFixedSize(childNodes.length);
                        for (var i = 0; i < childNodes.length; i++) {
                            res[i] = childNodes[i];
                        }
                        return res;
                    }
                }, {
                    key: 'clearNodes',
                    value: function clearNodes(el) {
                        for (var i = 0; i < el.childNodes.length; i++) {
                            this.remove(el.childNodes[i]);
                        }
                    }
                }, {
                    key: 'appendChild',
                    value: function appendChild(el, node) {
                        el.appendChild(node);
                    }
                }, {
                    key: 'removeChild',
                    value: function removeChild(el, node) {
                        el.removeChild(node);
                    }
                }, {
                    key: 'replaceChild',
                    value: function replaceChild(el, newChild, oldChild) {
                        el.replaceChild(newChild, oldChild);
                    }
                }, {
                    key: 'remove',
                    value: function remove(el) {
                        var parent = el.parentNode;
                        parent.removeChild(el);
                        return el;
                    }
                }, {
                    key: 'insertBefore',
                    value: function insertBefore(el, node) {
                        el.parentNode.insertBefore(node, el);
                    }
                }, {
                    key: 'insertAllBefore',
                    value: function insertAllBefore(el, nodes) {
                        ListWrapper.forEach(nodes, function (n) {
                            el.parentNode.insertBefore(n, el);
                        });
                    }
                }, {
                    key: 'insertAfter',
                    value: function insertAfter(el, node) {
                        el.parentNode.insertBefore(node, el.nextSibling);
                    }
                }, {
                    key: 'setInnerHTML',
                    value: function setInnerHTML(el, value) {
                        el.innerHTML = value;
                    }
                }, {
                    key: 'getText',
                    value: function getText(el) {
                        return el.textContent;
                    }
                }, {
                    key: 'setText',

                    // TODO(vicb): removed Element type because it does not support StyleElement
                    value: function setText(el, value) {
                        el.textContent = value;
                    }
                }, {
                    key: 'getValue',
                    value: function getValue(el) {
                        return el.value;
                    }
                }, {
                    key: 'setValue',
                    value: function setValue(el, value) {
                        el.value = value;
                    }
                }, {
                    key: 'getChecked',
                    value: function getChecked(el) {
                        return el.checked;
                    }
                }, {
                    key: 'setChecked',
                    value: function setChecked(el, value) {
                        el.checked = value;
                    }
                }, {
                    key: 'createTemplate',
                    value: function createTemplate(html) {
                        var t = document.createElement('template');
                        t.innerHTML = html;
                        return t;
                    }
                }, {
                    key: 'createElement',
                    value: function createElement(tagName) {
                        var doc = arguments[1] === undefined ? document : arguments[1];
                        return doc.createElement(tagName);
                    }
                }, {
                    key: 'createTextNode',
                    value: function createTextNode(text) {
                        var doc = arguments[1] === undefined ? document : arguments[1];
                        return doc.createTextNode(text);
                    }
                }, {
                    key: 'createScriptTag',
                    value: function createScriptTag(attrName, attrValue) {
                        var doc = arguments[2] === undefined ? document : arguments[2];

                        var el = doc.createElement('SCRIPT');
                        el.setAttribute(attrName, attrValue);
                        return el;
                    }
                }, {
                    key: 'createStyleElement',
                    value: function createStyleElement(css) {
                        var doc = arguments[1] === undefined ? document : arguments[1];

                        var style = doc.createElement('style');
                        this.appendChild(style, this.createTextNode(css));
                        return style;
                    }
                }, {
                    key: 'createShadowRoot',
                    value: function createShadowRoot(el) {
                        return el.createShadowRoot();
                    }
                }, {
                    key: 'getShadowRoot',
                    value: function getShadowRoot(el) {
                        return el.shadowRoot;
                    }
                }, {
                    key: 'getHost',
                    value: function getHost(el) {
                        return el.host;
                    }
                }, {
                    key: 'clone',
                    value: function clone(node) {
                        return node.cloneNode(true);
                    }
                }, {
                    key: 'hasProperty',
                    value: function hasProperty(element, name) {
                        return name in element;
                    }
                }, {
                    key: 'getElementsByClassName',
                    value: function getElementsByClassName(element, name) {
                        return element.getElementsByClassName(name);
                    }
                }, {
                    key: 'getElementsByTagName',
                    value: function getElementsByTagName(element, name) {
                        return element.getElementsByTagName(name);
                    }
                }, {
                    key: 'classList',
                    value: function classList(element) {
                        return Array.prototype.slice.call(element.classList, 0);
                    }
                }, {
                    key: 'addClass',
                    value: function addClass(element, classname) {
                        element.classList.add(classname);
                    }
                }, {
                    key: 'removeClass',
                    value: function removeClass(element, classname) {
                        element.classList.remove(classname);
                    }
                }, {
                    key: 'hasClass',
                    value: function hasClass(element, classname) {
                        return element.classList.contains(classname);
                    }
                }, {
                    key: 'setStyle',
                    value: function setStyle(element, stylename, stylevalue) {
                        element.style[stylename] = stylevalue;
                    }
                }, {
                    key: 'removeStyle',
                    value: function removeStyle(element, stylename) {
                        element.style[stylename] = null;
                    }
                }, {
                    key: 'getStyle',
                    value: function getStyle(element, stylename) {
                        return element.style[stylename];
                    }
                }, {
                    key: 'tagName',
                    value: function tagName(element) {
                        return element.tagName;
                    }
                }, {
                    key: 'attributeMap',
                    value: function attributeMap(element) {
                        var res = MapWrapper.create();
                        var elAttrs = element.attributes;
                        for (var i = 0; i < elAttrs.length; i++) {
                            var attrib = elAttrs[i];
                            MapWrapper.set(res, attrib.name, attrib.value);
                        }
                        return res;
                    }
                }, {
                    key: 'hasAttribute',
                    value: function hasAttribute(element, attribute) {
                        return element.hasAttribute(attribute);
                    }
                }, {
                    key: 'getAttribute',
                    value: function getAttribute(element, attribute) {
                        return element.getAttribute(attribute);
                    }
                }, {
                    key: 'setAttribute',
                    value: function setAttribute(element, name, value) {
                        element.setAttribute(name, value);
                    }
                }, {
                    key: 'removeAttribute',
                    value: function removeAttribute(element, attribute) {
                        return element.removeAttribute(attribute);
                    }
                }, {
                    key: 'templateAwareRoot',
                    value: function templateAwareRoot(el) {
                        return this.isTemplateElement(el) ? this.content(el) : el;
                    }
                }, {
                    key: 'createHtmlDocument',
                    value: function createHtmlDocument() {
                        return document.implementation.createHTMLDocument('fakeTitle');
                    }
                }, {
                    key: 'defaultDoc',
                    value: function defaultDoc() {
                        return document;
                    }
                }, {
                    key: 'getBoundingClientRect',
                    value: function getBoundingClientRect(el) {
                        try {
                            return el.getBoundingClientRect();
                        } catch (e) {
                            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
                        }
                    }
                }, {
                    key: 'getTitle',
                    value: function getTitle() {
                        return document.title;
                    }
                }, {
                    key: 'setTitle',
                    value: function setTitle(newTitle) {
                        document.title = newTitle || '';
                    }
                }, {
                    key: 'elementMatches',
                    value: function elementMatches(n, selector) {
                        return n instanceof HTMLElement && n.matches ? n.matches(selector) : n.msMatchesSelector(selector);
                    }
                }, {
                    key: 'isTemplateElement',
                    value: function isTemplateElement(el) {
                        return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
                    }
                }, {
                    key: 'isTextNode',
                    value: function isTextNode(node) {
                        return node.nodeType === Node.TEXT_NODE;
                    }
                }, {
                    key: 'isCommentNode',
                    value: function isCommentNode(node) {
                        return node.nodeType === Node.COMMENT_NODE;
                    }
                }, {
                    key: 'isElementNode',
                    value: function isElementNode(node) {
                        return node.nodeType === Node.ELEMENT_NODE;
                    }
                }, {
                    key: 'hasShadowRoot',
                    value: function hasShadowRoot(node) {
                        return node instanceof HTMLElement && isPresent(node.shadowRoot);
                    }
                }, {
                    key: 'isShadowRoot',
                    value: function isShadowRoot(node) {
                        return node instanceof DocumentFragment;
                    }
                }, {
                    key: 'importIntoDoc',
                    value: function importIntoDoc(node) {
                        var toImport = node;
                        if (this.isTemplateElement(node)) {
                            toImport = this.content(node);
                        }
                        return document.importNode(toImport, true);
                    }
                }, {
                    key: 'isPageRule',
                    value: function isPageRule(rule) {
                        return rule.type === CSSRule.PAGE_RULE;
                    }
                }, {
                    key: 'isStyleRule',
                    value: function isStyleRule(rule) {
                        return rule.type === CSSRule.STYLE_RULE;
                    }
                }, {
                    key: 'isMediaRule',
                    value: function isMediaRule(rule) {
                        return rule.type === CSSRule.MEDIA_RULE;
                    }
                }, {
                    key: 'isKeyframesRule',
                    value: function isKeyframesRule(rule) {
                        return rule.type === CSSRule.KEYFRAMES_RULE;
                    }
                }, {
                    key: 'getHref',
                    value: function getHref(el) {
                        return el.href;
                    }
                }, {
                    key: 'getEventKey',
                    value: function getEventKey(event) {
                        var key = event.key;
                        if (isBlank(key)) {
                            key = event.keyIdentifier;
                            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
                            // Safari
                            // cf
                            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
                            if (isBlank(key)) {
                                return 'Unidentified';
                            }
                            if (key.startsWith('U+')) {
                                key = String.fromCharCode(parseInt(key.substring(2), 16));
                                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                                    // There is a bug in Chrome for numeric keypad keys:
                                    // https://code.google.com/p/chromium/issues/detail?id=155654
                                    // 1, 2, 3 ... are reported as A, B, C ...
                                    key = _chromeNumKeyPadMap[key];
                                }
                            }
                        }
                        if (_keyMap.hasOwnProperty(key)) {
                            key = _keyMap[key];
                        }
                        return key;
                    }
                }, {
                    key: 'getGlobalEventTarget',
                    value: function getGlobalEventTarget(target) {
                        if (target == 'window') {
                            return window;
                        } else if (target == 'document') {
                            return document;
                        } else if (target == 'body') {
                            return document.body;
                        }
                    }
                }, {
                    key: 'getHistory',
                    value: function getHistory() {
                        return window.history;
                    }
                }, {
                    key: 'getLocation',
                    value: function getLocation() {
                        return window.location;
                    }
                }, {
                    key: 'getBaseHref',
                    value: function getBaseHref() {
                        return relativePath(document.baseURI);
                    }
                }, {
                    key: 'getUserAgent',
                    value: function getUserAgent() {
                        return window.navigator.userAgent;
                    }
                }, {
                    key: 'setData',
                    value: function setData(element, name, value) {
                        element.dataset[name] = value;
                    }
                }, {
                    key: 'getData',
                    value: function getData(element, name) {
                        return element.dataset[name];
                    }
                }, {
                    key: 'setGlobalVar',

                    // TODO(tbosch): move this into a separate environment class once we have it
                    value: function setGlobalVar(name, value) {
                        global[name] = value;
                    }
                }], [{
                    key: 'makeCurrent',
                    value: function makeCurrent() {
                        setRootDomAdapter(new BrowserDomAdapter());
                    }
                }]);

                return BrowserDomAdapter;
            })(GenericBrowserDomAdapter);

            _export('BrowserDomAdapter', BrowserDomAdapter);

            // based on urlUtils.js in AngularJS 1
            urlParsingNode = null;
        }
    };
});
System.register('angular2/src/core/compiler/view', ['npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/create-class', 'angular2/src/facade/collection', 'angular2/change_detection', 'angular2/src/core/compiler/element_binder', 'angular2/src/facade/lang'], function (_export) {
    var _classCallCheck, _createClass, ListWrapper, MapWrapper, StringMapWrapper, Locals, ElementBinder, isPresent, isBlank, BaseException, AppViewContainer, AppView, AppProtoView;

    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2Change_detection) {
            Locals = _angular2Change_detection.Locals;
        }, function (_angular2SrcCoreCompilerElement_binder) {
            ElementBinder = _angular2SrcCoreCompilerElement_binder.ElementBinder;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            'use strict';

            AppViewContainer = function AppViewContainer() {
                _classCallCheck(this, AppViewContainer);

                // The order in this list matches the DOM order.
                this.views = [];
            };

            _export('AppViewContainer', AppViewContainer);

            /**
             * Const of making objects: http://jsperf.com/instantiate-size-of-object
             *
             */

            AppView = (function () {
                function AppView(renderer, proto, protoLocals) {
                    _classCallCheck(this, AppView);

                    this.renderer = renderer;
                    this.proto = proto;
                    this.render = null;
                    this.changeDetector = null;
                    this.elementInjectors = null;
                    this.rootElementInjectors = null;
                    this.componentChildViews = null;
                    this.viewContainers = ListWrapper.createFixedSize(this.proto.elementBinders.length);
                    this.preBuiltObjects = null;
                    this.context = null;
                    this.locals = new Locals(null, MapWrapper.clone(protoLocals)); // TODO optimize this
                    this.freeHostViews = [];
                }

                _createClass(AppView, [{
                    key: 'init',
                    value: function init(changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, componentChildViews) {
                        this.changeDetector = changeDetector;
                        this.elementInjectors = elementInjectors;
                        this.rootElementInjectors = rootElementInjectors;
                        this.preBuiltObjects = preBuiltObjects;
                        this.componentChildViews = componentChildViews;
                    }
                }, {
                    key: 'setLocal',
                    value: function setLocal(contextName, value) {
                        if (!this.hydrated()) throw new BaseException('Cannot set locals on dehydrated view.');
                        if (!MapWrapper.contains(this.proto.variableBindings, contextName)) {
                            return;
                        }
                        var templateName = MapWrapper.get(this.proto.variableBindings, contextName);
                        this.locals.set(templateName, value);
                    }
                }, {
                    key: 'hydrated',
                    value: function hydrated() {
                        return isPresent(this.context);
                    }
                }, {
                    key: 'triggerEventHandlers',

                    /**
                     * Triggers the event handlers for the element and the directives.
                     *
                     * This method is intended to be called from directive EventEmitters.
                     *
                     * @param {string} eventName
                     * @param {*} eventObj
                     * @param {int} binderIndex
                     */
                    value: function triggerEventHandlers(eventName, eventObj, binderIndex) {
                        var locals = MapWrapper.create();
                        MapWrapper.set(locals, '$event', eventObj);
                        this.dispatchEvent(binderIndex, eventName, locals);
                    }
                }, {
                    key: 'notifyOnBinding',

                    // dispatch to element injector or text nodes based on context
                    value: function notifyOnBinding(b, currentValue) {
                        if (b.isElement()) {
                            this.renderer.setElementProperty(this.render, b.elementIndex, b.propertyName, currentValue);
                        } else {
                            // we know it refers to _textNodes.
                            this.renderer.setText(this.render, b.elementIndex, currentValue);
                        }
                    }
                }, {
                    key: 'getDirectiveFor',
                    value: function getDirectiveFor(directive) {
                        var elementInjector = this.elementInjectors[directive.elementIndex];
                        return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
                    }
                }, {
                    key: 'getDetectorFor',
                    value: function getDetectorFor(directive) {
                        var childView = this.componentChildViews[directive.elementIndex];
                        return isPresent(childView) ? childView.changeDetector : null;
                    }
                }, {
                    key: 'callAction',
                    value: function callAction(elementIndex, actionExpression, action) {
                        this.renderer.callAction(this.render, elementIndex, actionExpression, action);
                    }
                }, {
                    key: 'dispatchEvent',

                    // implementation of EventDispatcher#dispatchEvent
                    // returns false if preventDefault must be applied to the DOM event
                    value: function dispatchEvent(elementIndex, eventName, locals) {
                        var _this = this;

                        // Most of the time the event will be fired only when the view is in the live document.
                        // However, in a rare circumstance the view might get dehydrated, in between the event
                        // queuing up and firing.
                        var allowDefaultBehavior = true;
                        if (this.hydrated()) {
                            var elBinder = this.proto.elementBinders[elementIndex];
                            if (isBlank(elBinder.hostListeners)) return allowDefaultBehavior;
                            var eventMap = elBinder.hostListeners[eventName];
                            if (isBlank(eventMap)) return allowDefaultBehavior;
                            MapWrapper.forEach(eventMap, function (expr, directiveIndex) {
                                var context;
                                if (directiveIndex === -1) {
                                    context = _this.context;
                                } else {
                                    context = _this.elementInjectors[elementIndex].getDirectiveAtIndex(directiveIndex);
                                }
                                var result = expr.eval(context, new Locals(_this.locals, locals));
                                if (isPresent(result)) {
                                    allowDefaultBehavior = allowDefaultBehavior && result == true;
                                }
                            });
                        }
                        return allowDefaultBehavior;
                    }
                }]);

                return AppView;
            })();

            _export('AppView', AppView);

            /**
             *
             */

            AppProtoView = (function () {
                function AppProtoView(render, protoChangeDetector, variableBindings) {
                    var _this2 = this;

                    _classCallCheck(this, AppProtoView);

                    this.render = render;
                    this.protoChangeDetector = protoChangeDetector;
                    this.variableBindings = variableBindings;
                    this.elementBinders = [];
                    this.protoLocals = MapWrapper.create();
                    if (isPresent(variableBindings)) {
                        MapWrapper.forEach(variableBindings, function (templateName, _) {
                            MapWrapper.set(_this2.protoLocals, templateName, null);
                        });
                    }
                }

                _createClass(AppProtoView, [{
                    key: 'bindElement',
                    value: function bindElement(parent, distanceToParent, protoElementInjector) {
                        var componentDirective = arguments[3] === undefined ? null : arguments[3];

                        var elBinder = new ElementBinder(this.elementBinders.length, parent, distanceToParent, protoElementInjector, componentDirective);
                        ListWrapper.push(this.elementBinders, elBinder);
                        return elBinder;
                    }
                }, {
                    key: 'bindEvent',

                    /**
                     * Adds an event binding for the last created ElementBinder via bindElement.
                     *
                     * If the directive index is a positive integer, the event is evaluated in the context of
                     * the given directive.
                     *
                     * If the directive index is -1, the event is evaluated in the context of the enclosing view.
                     *
                     * @param {string} eventName
                     * @param {AST} expression
                     * @param {int} directiveIndex The directive index in the binder or -1 when the event is not bound
                     *                             to a directive
                     */
                    value: function bindEvent(eventBindings, boundElementIndex) {
                        var directiveIndex = arguments[2] === undefined ? -1 : arguments[2];

                        var elBinder = this.elementBinders[boundElementIndex];
                        var events = elBinder.hostListeners;
                        if (isBlank(events)) {
                            events = StringMapWrapper.create();
                            elBinder.hostListeners = events;
                        }
                        for (var i = 0; i < eventBindings.length; i++) {
                            var eventBinding = eventBindings[i];
                            var eventName = eventBinding.fullName;
                            var event = StringMapWrapper.get(events, eventName);
                            if (isBlank(event)) {
                                event = MapWrapper.create();
                                StringMapWrapper.set(events, eventName, event);
                            }
                            MapWrapper.set(event, directiveIndex, eventBinding.source);
                        }
                    }
                }]);

                return AppProtoView;
            })();

            _export('AppProtoView', AppProtoView);
        }
    };
});


System.register('angular2/src/core/compiler/element_ref', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/dom/dom_adapter', 'angular2/src/facade/lang', 'angular2/src/render/dom/view/view'], function (_export) {
    var _createClass, _classCallCheck, DOM, normalizeBlank, resolveInternalDomView, ElementRef;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeLang) {
            normalizeBlank = _angular2SrcFacadeLang.normalizeBlank;
        }, function (_angular2SrcRenderDomViewView) {
            resolveInternalDomView = _angular2SrcRenderDomViewView.resolveInternalDomView;
        }],
        execute: function () {
            'use strict';

            /**
             * @exportedAs angular2/view
             */

            ElementRef = (function () {
                function ElementRef(parentView, boundElementIndex) {
                    _classCallCheck(this, ElementRef);

                    this.parentView = parentView;
                    this.boundElementIndex = boundElementIndex;
                }

                _createClass(ElementRef, [{
                    key: 'domElement',

                    /**
                     * Exposes the underlying DOM element.
                     * (DEPRECATED way of accessing the DOM, replacement coming)
                     */
                    // TODO(tbosch): Here we expose the real DOM element.
                    // We need a more general way to read/write to the DOM element
                    // via a proper abstraction in the render layer
                    get: function () {
                        return resolveInternalDomView(this.parentView.render).boundElements[this.boundElementIndex];
                    }
                }, {
                    key: 'getAttribute',

                    /**
                     * Gets an attribute from the underlying DOM element.
                     * (DEPRECATED way of accessing the DOM, replacement coming)
                     */
                    // TODO(tbosch): Here we expose the real DOM element.
                    // We need a more general way to read/write to the DOM element
                    // via a proper abstraction in the render layer
                    value: function getAttribute(name) {
                        return normalizeBlank(DOM.getAttribute(this.domElement, name));
                    }
                }]);

                return ElementRef;
            })();

            _export('ElementRef', ElementRef);
        }
    };
});


System.register("angular2/src/render/dom/compiler/template_loader", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/services/xhr", "angular2/src/services/url_resolver"], function (_export) {
    var _createClass, _classCallCheck, Injectable, isBlank, isPresent, BaseException, StringMapWrapper, PromiseWrapper, DOM, XHR, UrlResolver, __decorate, __metadata, TemplateLoader;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcServicesXhr) {
            XHR = _angular2SrcServicesXhr.XHR;
        }, function (_angular2SrcServicesUrl_resolver) {
            UrlResolver = _angular2SrcServicesUrl_resolver.UrlResolver;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Strategy to load component templates.
             * TODO: Make public API once we are more confident in this approach.
             */

            TemplateLoader = (function () {
                var _class = function TemplateLoader(xhr, urlResolver) {
                    _classCallCheck(this, _class);

                    this._xhr = xhr;
                    this._htmlCache = StringMapWrapper.create();
                };

                _createClass(_class, [{
                    key: "load",
                    value: function load(template) {
                        if (isPresent(template.template)) {
                            return PromiseWrapper.resolve(DOM.createTemplate(template.template));
                        }
                        var url = template.absUrl;
                        if (isPresent(url)) {
                            var promise = StringMapWrapper.get(this._htmlCache, url);
                            if (isBlank(promise)) {
                                // TODO(vicb): change error when TS gets fixed
                                // https://github.com/angular/angular/issues/2280
                                // throw new BaseException(`Failed to fetch url "${url}"`);
                                promise = PromiseWrapper.then(this._xhr.get(url), function (html) {
                                    var template = DOM.createTemplate(html);
                                    return template;
                                }, function (_) {
                                    return PromiseWrapper.reject(new BaseException("Failed to fetch url \"" + url + "\""), null);
                                });
                                StringMapWrapper.set(this._htmlCache, url, promise);
                            }
                            // We need to clone the result as others might change it
                            // (e.g. the compiler).
                            return promise.then(function (tplElement) {
                                return DOM.clone(tplElement);
                            });
                        }
                        throw new BaseException("View should have either the url or template property set");
                    }
                }]);

                return _class;
            })();

            _export("TemplateLoader", TemplateLoader);

            _export("TemplateLoader", TemplateLoader = __decorate([Injectable(), __metadata("design:paramtypes", [XHR, UrlResolver])], TemplateLoader));
            
        }
    };
});
System.register('angular2/src/render/dom/shadow_dom/util', ['angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/dom/dom_adapter', 'angular2/src/render/dom/shadow_dom/shadow_css'], function (_export) {
    'use strict';

    var isBlank, isPresent, MapWrapper, DOM, ShadowCss, _componentUIDs, _nextComponentUID, _sharedStyleTexts, _lastInsertedStyleEl;

    _export('getComponentId', getComponentId);

    _export('insertSharedStyleText', insertSharedStyleText);

    _export('insertStyleElement', insertStyleElement);

    _export('getHostAttribute', getHostAttribute);

    _export('getContentAttribute', getContentAttribute);

    _export('shimCssForComponent', shimCssForComponent);

    _export('resetShadowDomCache', resetShadowDomCache);

    function getComponentId(componentStringId) {
        var id = MapWrapper.get(_componentUIDs, componentStringId);
        if (isBlank(id)) {
            id = _nextComponentUID++;
            MapWrapper.set(_componentUIDs, componentStringId, id);
        }
        return id;
    }

    function insertSharedStyleText(cssText, styleHost, styleEl) {
        if (!MapWrapper.contains(_sharedStyleTexts, cssText)) {
            // Styles are unscoped and shared across components, only append them to the head
            // when there are not present yet
            MapWrapper.set(_sharedStyleTexts, cssText, true);
            insertStyleElement(styleHost, styleEl);
        }
    }

    function insertStyleElement(host, styleEl) {
        if (isBlank(_lastInsertedStyleEl)) {
            var firstChild = DOM.firstChild(host);
            if (isPresent(firstChild)) {
                DOM.insertBefore(firstChild, styleEl);
            } else {
                DOM.appendChild(host, styleEl);
            }
        } else {
            DOM.insertAfter(_lastInsertedStyleEl, styleEl);
        }
        _lastInsertedStyleEl = styleEl;
    }

    // Return the attribute to be added to the component

    function getHostAttribute(id) {
        return '_nghost-' + id;
    }

    // Returns the attribute to be added on every single element nodes in the component

    function getContentAttribute(id) {
        return '_ngcontent-' + id;
    }

    function shimCssForComponent(cssText, componentId) {
        var id = getComponentId(componentId);
        var shadowCss = new ShadowCss();
        return shadowCss.shimCssText(cssText, getContentAttribute(id), getHostAttribute(id));
    }

    // Reset the caches - used for tests only

    function resetShadowDomCache() {
        MapWrapper.clear(_componentUIDs);
        _nextComponentUID = 0;
        MapWrapper.clear(_sharedStyleTexts);
        _lastInsertedStyleEl = null;
    }
    

    return {
        setters: [function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomShadow_domShadow_css) {
            ShadowCss = _angular2SrcRenderDomShadow_domShadow_css.ShadowCss;
        }],
        execute: function () {
            _componentUIDs = MapWrapper.create();
            _nextComponentUID = 0;
            _sharedStyleTexts = MapWrapper.create();
        }
    };
});
System.register('angular2/src/render/dom/events/hammer_gestures', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/render/dom/events/hammer_common', 'angular2/src/facade/lang'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, HammerGesturesPluginCommon, isPresent, BaseException, HammerGesturesPlugin;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcRenderDomEventsHammer_common) {
            HammerGesturesPluginCommon = _angular2SrcRenderDomEventsHammer_common.HammerGesturesPluginCommon;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            /// <reference path="../../../../typings/hammerjs/hammerjs"/>
            'use strict';

            HammerGesturesPlugin = (function (_HammerGesturesPluginCommon) {
                function HammerGesturesPlugin() {
                    _classCallCheck(this, HammerGesturesPlugin);

                    _get(Object.getPrototypeOf(HammerGesturesPlugin.prototype), 'constructor', this).call(this);
                }

                _inherits(HammerGesturesPlugin, _HammerGesturesPluginCommon);

                _createClass(HammerGesturesPlugin, [{
                    key: 'supports',
                    value: function supports(eventName) {
                        if (!_get(Object.getPrototypeOf(HammerGesturesPlugin.prototype), 'supports', this).call(this, eventName)) return false;
                        if (!isPresent(window['Hammer'])) {
                            throw new BaseException('Hammer.js is not loaded, can not bind ' + eventName + ' event');
                        }
                        return true;
                    }
                }, {
                    key: 'addEventListener',
                    value: function addEventListener(element, eventName, handler, shouldSupportBubble) {
                        if (shouldSupportBubble) throw new BaseException('Hammer.js plugin does not support bubbling gestures.');
                        var zone = this.manager.getZone();
                        eventName = eventName.toLowerCase();
                        zone.runOutsideAngular(function () {
                            // Creating the manager bind events, must be done outside of angular
                            var mc = new Hammer(element);
                            mc.get('pinch').set({ enable: true });
                            mc.get('rotate').set({ enable: true });
                            mc.on(eventName, function (eventObj) {
                                zone.run(function () {
                                    handler(eventObj);
                                });
                            });
                        });
                    }
                }]);

                return HammerGesturesPlugin;
            })(HammerGesturesPluginCommon);

            _export('HammerGesturesPlugin', HammerGesturesPlugin);
        }
    };
});


System.register("angular2/src/core/testability/testability", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/testability/get_testability"], function (_export) {
    var _createClass, _classCallCheck, Injectable, DOM, MapWrapper, ListWrapper, BaseException, getTestabilityModule, __decorate, __metadata, Testability, TestabilityRegistry;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcCoreTestabilityGet_testability) {
            getTestabilityModule = _angular2SrcCoreTestabilityGet_testability;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The Testability service provides testing hooks that can be accessed from
             * the browser and by services such as Protractor. Each bootstrapped Angular
             * application on the page will have an instance of Testability.
             */

            Testability = (function () {
                var _class = function Testability() {
                    _classCallCheck(this, _class);

                    this._pendingCount = 0;
                    this._callbacks = ListWrapper.create();
                };

                _createClass(_class, [{
                    key: "increaseCount",
                    value: function increaseCount() {
                        var delta = arguments[0] === undefined ? 1 : arguments[0];

                        this._pendingCount += delta;
                        if (this._pendingCount < 0) {
                            throw new BaseException("pending async requests below zero");
                        } else if (this._pendingCount == 0) {
                            this._runCallbacks();
                        }
                        return this._pendingCount;
                    }
                }, {
                    key: "_runCallbacks",
                    value: function _runCallbacks() {
                        while (this._callbacks.length !== 0) {
                            ListWrapper.removeLast(this._callbacks)();
                        }
                    }
                }, {
                    key: "whenStable",
                    value: function whenStable(callback) {
                        ListWrapper.push(this._callbacks, callback);
                        if (this._pendingCount === 0) {
                            this._runCallbacks();
                        }
                        // TODO(juliemr) - hook into the zone api.
                    }
                }, {
                    key: "getPendingCount",
                    value: function getPendingCount() {
                        return this._pendingCount;
                    }
                }, {
                    key: "findBindings",
                    value: function findBindings(using, binding, exactMatch) {
                        // TODO(juliemr): implement.
                        return [];
                    }
                }]);

                return _class;
            })();

            _export("Testability", Testability);

            _export("Testability", Testability = __decorate([Injectable(), __metadata("design:paramtypes", [])], Testability));

            TestabilityRegistry = (function () {
                var _class2 = function TestabilityRegistry() {
                    _classCallCheck(this, _class2);

                    this._applications = MapWrapper.create();
                    getTestabilityModule.GetTestability.addToWindow(this);
                };

                _createClass(_class2, [{
                    key: "registerApplication",
                    value: function registerApplication(token, testability) {
                        MapWrapper.set(this._applications, token, testability);
                    }
                }, {
                    key: "findTestabilityInTree",
                    value: function findTestabilityInTree(elem) {
                        if (elem == null) {
                            return null;
                        }
                        if (MapWrapper.contains(this._applications, elem)) {
                            return MapWrapper.get(this._applications, elem);
                        }
                        if (DOM.isShadowRoot(elem)) {
                            return this.findTestabilityInTree(DOM.getHost(elem));
                        }
                        return this.findTestabilityInTree(DOM.parentElement(elem));
                    }
                }]);

                return _class2;
            })();

            _export("TestabilityRegistry", TestabilityRegistry);

            _export("TestabilityRegistry", TestabilityRegistry = __decorate([Injectable(), __metadata("design:paramtypes", [])], TestabilityRegistry));
            
        }
    };
});
System.register('angular2/src/render/dom/view/proto_view', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/dom/dom_adapter', 'angular2/src/render/dom/util', 'angular2/src/render/api'], function (_export) {
    var _inherits, _get, _classCallCheck, isPresent, DOM, NG_BINDING_CLASS, RenderProtoViewRef, DomProtoViewRef, DomProtoView;

    function resolveInternalDomProtoView(protoViewRef) {
        return protoViewRef._protoView;
    }

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomUtil) {
            NG_BINDING_CLASS = _angular2SrcRenderDomUtil.NG_BINDING_CLASS;
        }, function (_angular2SrcRenderApi) {
            RenderProtoViewRef = _angular2SrcRenderApi.RenderProtoViewRef;
        }],
        execute: function () {
            'use strict';

            _export('resolveInternalDomProtoView', resolveInternalDomProtoView);

            DomProtoViewRef = (function (_RenderProtoViewRef) {
                function DomProtoViewRef(protoView) {
                    _classCallCheck(this, DomProtoViewRef);

                    _get(Object.getPrototypeOf(DomProtoViewRef.prototype), 'constructor', this).call(this);
                    this._protoView = protoView;
                }

                _inherits(DomProtoViewRef, _RenderProtoViewRef);

                return DomProtoViewRef;
            })(RenderProtoViewRef);

            _export('DomProtoViewRef', DomProtoViewRef);

            DomProtoView = function DomProtoView(_ref) {
                var elementBinders = _ref.elementBinders;
                var element = _ref.element;

                _classCallCheck(this, DomProtoView);

                this.element = element;
                this.elementBinders = elementBinders;
                this.isTemplateElement = DOM.isTemplateElement(this.element);
                this.rootBindingOffset = isPresent(this.element) && DOM.hasClass(this.element, NG_BINDING_CLASS) ? 1 : 0;
            };

            _export('DomProtoView', DomProtoView);
        }
    };
});


System.register('angular2/src/render/dom/view/proto_view_builder', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/dom/dom_adapter', 'angular2/change_detection', 'angular2/src/render/dom/view/proto_view', 'angular2/src/render/dom/view/element_binder', 'angular2/src/render/dom/view/property_setter_factory', 'angular2/src/render/api', 'angular2/src/render/dom/util'], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, isPresent, isBlank, BaseException, ListWrapper, MapWrapper, DOM, ASTWithSource, AstTransformer, AccessMember, LiteralArray, ImplicitReceiver, DomProtoView, DomProtoViewRef, resolveInternalDomProtoView, ElementBinder, Event, HostAction, setterFactory, api, NG_BINDING_CLASS, EVENT_TARGET_SEPARATOR, ProtoViewBuilder, ElementBinderBuilder, DirectiveBuilder, EventBuilder;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2Change_detection) {
            ASTWithSource = _angular2Change_detection.ASTWithSource;
            AstTransformer = _angular2Change_detection.AstTransformer;
            AccessMember = _angular2Change_detection.AccessMember;
            LiteralArray = _angular2Change_detection.LiteralArray;
            ImplicitReceiver = _angular2Change_detection.ImplicitReceiver;
        }, function (_angular2SrcRenderDomViewProto_view) {
            DomProtoView = _angular2SrcRenderDomViewProto_view.DomProtoView;
            DomProtoViewRef = _angular2SrcRenderDomViewProto_view.DomProtoViewRef;
            resolveInternalDomProtoView = _angular2SrcRenderDomViewProto_view.resolveInternalDomProtoView;
        }, function (_angular2SrcRenderDomViewElement_binder) {
            ElementBinder = _angular2SrcRenderDomViewElement_binder.ElementBinder;
            Event = _angular2SrcRenderDomViewElement_binder.Event;
            HostAction = _angular2SrcRenderDomViewElement_binder.HostAction;
        }, function (_angular2SrcRenderDomViewProperty_setter_factory) {
            setterFactory = _angular2SrcRenderDomViewProperty_setter_factory.setterFactory;
        }, function (_angular2SrcRenderApi) {
            api = _angular2SrcRenderApi;
        }, function (_angular2SrcRenderDomUtil) {
            NG_BINDING_CLASS = _angular2SrcRenderDomUtil.NG_BINDING_CLASS;
            EVENT_TARGET_SEPARATOR = _angular2SrcRenderDomUtil.EVENT_TARGET_SEPARATOR;
        }],
        execute: function () {
            'use strict';

            ProtoViewBuilder = (function () {
                function ProtoViewBuilder(rootElement, type) {
                    _classCallCheck(this, ProtoViewBuilder);

                    this.rootElement = rootElement;
                    this.elements = [];
                    this.variableBindings = MapWrapper.create();
                    this.type = type;
                }

                _createClass(ProtoViewBuilder, [{
                    key: 'bindElement',
                    value: function bindElement(element) {
                        var description = arguments[1] === undefined ? null : arguments[1];

                        var builder = new ElementBinderBuilder(this.elements.length, element, description);
                        ListWrapper.push(this.elements, builder);
                        DOM.addClass(element, NG_BINDING_CLASS);
                        return builder;
                    }
                }, {
                    key: 'bindVariable',
                    value: function bindVariable(name, value) {
                        // Store the variable map from value to variable, reflecting how it will be used later by
                        // DomView. When a local is set to the view, a lookup for the variable name will take place
                        // keyed
                        // by the "value", or exported identifier. For example, ng-for sets a view local of "index".
                        // When this occurs, a lookup keyed by "index" must occur to find if there is a var referencing
                        // it.
                        MapWrapper.set(this.variableBindings, value, name);
                    }
                }, {
                    key: 'build',
                    value: function build() {
                        var renderElementBinders = [];
                        var apiElementBinders = [];
                        ListWrapper.forEach(this.elements, function (ebb) {
                            var propertySetters = MapWrapper.create();
                            var hostActions = MapWrapper.create();
                            var apiDirectiveBinders = ListWrapper.map(ebb.directives, function (dbb) {
                                ebb.eventBuilder.merge(dbb.eventBuilder);
                                MapWrapper.forEach(dbb.hostPropertyBindings, function (_, hostPropertyName) {
                                    MapWrapper.set(propertySetters, hostPropertyName, setterFactory(hostPropertyName));
                                });
                                ListWrapper.forEach(dbb.hostActions, function (hostAction) {
                                    MapWrapper.set(hostActions, hostAction.actionExpression, hostAction.expression);
                                });
                                return new api.DirectiveBinder({
                                    directiveIndex: dbb.directiveIndex,
                                    propertyBindings: dbb.propertyBindings,
                                    eventBindings: dbb.eventBindings,
                                    hostPropertyBindings: dbb.hostPropertyBindings
                                });
                            });
                            MapWrapper.forEach(ebb.propertyBindings, function (_, propertyName) {
                                MapWrapper.set(propertySetters, propertyName, setterFactory(propertyName));
                            });
                            var nestedProtoView = isPresent(ebb.nestedProtoView) ? ebb.nestedProtoView.build() : null;
                            var parentIndex = isPresent(ebb.parent) ? ebb.parent.index : -1;
                            ListWrapper.push(apiElementBinders, new api.ElementBinder({
                                index: ebb.index,
                                parentIndex: parentIndex,
                                distanceToParent: ebb.distanceToParent,
                                directives: apiDirectiveBinders,
                                nestedProtoView: nestedProtoView,
                                propertyBindings: ebb.propertyBindings,
                                variableBindings: ebb.variableBindings,
                                eventBindings: ebb.eventBindings,
                                textBindings: ebb.textBindings,
                                readAttributes: ebb.readAttributes
                            }));
                            ListWrapper.push(renderElementBinders, new ElementBinder({
                                textNodeIndices: ebb.textBindingIndices,
                                contentTagSelector: ebb.contentTagSelector,
                                parentIndex: parentIndex,
                                distanceToParent: ebb.distanceToParent,
                                nestedProtoView: isPresent(nestedProtoView) ? resolveInternalDomProtoView(nestedProtoView.render) : null,
                                componentId: ebb.componentId,
                                eventLocals: new LiteralArray(ebb.eventBuilder.buildEventLocals()),
                                localEvents: ebb.eventBuilder.buildLocalEvents(),
                                globalEvents: ebb.eventBuilder.buildGlobalEvents(),
                                hostActions: hostActions,
                                propertySetters: propertySetters
                            }));
                        });
                        return new api.ProtoViewDto({
                            render: new DomProtoViewRef(new DomProtoView({ element: this.rootElement, elementBinders: renderElementBinders })),
                            type: this.type,
                            elementBinders: apiElementBinders,
                            variableBindings: this.variableBindings
                        });
                    }
                }]);

                return ProtoViewBuilder;
            })();

            _export('ProtoViewBuilder', ProtoViewBuilder);

            ElementBinderBuilder = (function () {
                function ElementBinderBuilder(index, element, description) {
                    _classCallCheck(this, ElementBinderBuilder);

                    this.element = element;
                    this.index = index;
                    this.parent = null;
                    this.distanceToParent = 0;
                    this.directives = [];
                    this.nestedProtoView = null;
                    this.propertyBindings = MapWrapper.create();
                    this.variableBindings = MapWrapper.create();
                    this.eventBindings = ListWrapper.create();
                    this.eventBuilder = new EventBuilder();
                    this.textBindings = [];
                    this.textBindingIndices = [];
                    this.contentTagSelector = null;
                    this.componentId = null;
                    this.readAttributes = MapWrapper.create();
                }

                _createClass(ElementBinderBuilder, [{
                    key: 'setParent',
                    value: function setParent(parent, distanceToParent) {
                        this.parent = parent;
                        if (isPresent(parent)) {
                            this.distanceToParent = distanceToParent;
                        }
                        return this;
                    }
                }, {
                    key: 'readAttribute',
                    value: function readAttribute(attrName) {
                        if (isBlank(MapWrapper.get(this.readAttributes, attrName))) {
                            MapWrapper.set(this.readAttributes, attrName, DOM.getAttribute(this.element, attrName));
                        }
                    }
                }, {
                    key: 'bindDirective',
                    value: function bindDirective(directiveIndex) {
                        var directive = new DirectiveBuilder(directiveIndex);
                        ListWrapper.push(this.directives, directive);
                        return directive;
                    }
                }, {
                    key: 'bindNestedProtoView',
                    value: function bindNestedProtoView(rootElement) {
                        if (isPresent(this.nestedProtoView)) {
                            throw new BaseException('Only one nested view per element is allowed');
                        }
                        this.nestedProtoView = new ProtoViewBuilder(rootElement, api.ProtoViewDto.EMBEDDED_VIEW_TYPE);
                        return this.nestedProtoView;
                    }
                }, {
                    key: 'bindProperty',
                    value: function bindProperty(name, expression) {
                        MapWrapper.set(this.propertyBindings, name, expression);
                    }
                }, {
                    key: 'bindVariable',
                    value: function bindVariable(name, value) {
                        // When current is a view root, the variable bindings are set to the *nested* proto view.
                        // The root view conceptually signifies a new "block scope" (the nested view), to which
                        // the variables are bound.
                        if (isPresent(this.nestedProtoView)) {
                            this.nestedProtoView.bindVariable(name, value);
                        } else {
                            // Store the variable map from value to variable, reflecting how it will be used later by
                            // DomView. When a local is set to the view, a lookup for the variable name will take place
                            // keyed
                            // by the "value", or exported identifier. For example, ng-for sets a view local of "index".
                            // When this occurs, a lookup keyed by "index" must occur to find if there is a var
                            // referencing
                            // it.
                            MapWrapper.set(this.variableBindings, value, name);
                        }
                    }
                }, {
                    key: 'bindEvent',
                    value: function bindEvent(name, expression) {
                        var target = arguments[2] === undefined ? null : arguments[2];

                        ListWrapper.push(this.eventBindings, this.eventBuilder.add(name, expression, target));
                    }
                }, {
                    key: 'bindText',
                    value: function bindText(index, expression) {
                        ListWrapper.push(this.textBindingIndices, index);
                        ListWrapper.push(this.textBindings, expression);
                    }
                }, {
                    key: 'setContentTagSelector',
                    value: function setContentTagSelector(value) {
                        this.contentTagSelector = value;
                    }
                }, {
                    key: 'setComponentId',
                    value: function setComponentId(componentId) {
                        this.componentId = componentId;
                    }
                }]);

                return ElementBinderBuilder;
            })();

            _export('ElementBinderBuilder', ElementBinderBuilder);

            DirectiveBuilder = (function () {
                function DirectiveBuilder(directiveIndex) {
                    _classCallCheck(this, DirectiveBuilder);

                    this.directiveIndex = directiveIndex;
                    this.propertyBindings = MapWrapper.create();
                    this.hostPropertyBindings = MapWrapper.create();
                    this.hostActions = ListWrapper.create();
                    this.eventBindings = ListWrapper.create();
                    this.eventBuilder = new EventBuilder();
                }

                _createClass(DirectiveBuilder, [{
                    key: 'bindProperty',
                    value: function bindProperty(name, expression) {
                        MapWrapper.set(this.propertyBindings, name, expression);
                    }
                }, {
                    key: 'bindHostProperty',
                    value: function bindHostProperty(name, expression) {
                        MapWrapper.set(this.hostPropertyBindings, name, expression);
                    }
                }, {
                    key: 'bindHostAction',
                    value: function bindHostAction(actionName, actionExpression, expression) {
                        ListWrapper.push(this.hostActions, new HostAction(actionName, actionExpression, expression));
                    }
                }, {
                    key: 'bindEvent',
                    value: function bindEvent(name, expression) {
                        var target = arguments[2] === undefined ? null : arguments[2];

                        ListWrapper.push(this.eventBindings, this.eventBuilder.add(name, expression, target));
                    }
                }]);

                return DirectiveBuilder;
            })();

            _export('DirectiveBuilder', DirectiveBuilder);

            EventBuilder = (function (_AstTransformer) {
                function EventBuilder() {
                    _classCallCheck(this, EventBuilder);

                    _get(Object.getPrototypeOf(EventBuilder.prototype), 'constructor', this).call(this);
                    this.locals = [];
                    this.localEvents = [];
                    this.globalEvents = [];
                    this._implicitReceiver = new ImplicitReceiver();
                }

                _inherits(EventBuilder, _AstTransformer);

                _createClass(EventBuilder, [{
                    key: 'add',
                    value: function add(name, source, target) {
                        // TODO(tbosch): reenable this when we are parsing element properties
                        // out of action expressions
                        // var adjustedAst = astWithSource.ast.visit(this);
                        var adjustedAst = source.ast;
                        var fullName = isPresent(target) ? target + EVENT_TARGET_SEPARATOR + name : name;
                        var result = new api.EventBinding(fullName, new ASTWithSource(adjustedAst, source.source, source.location));
                        var event = new Event(name, target, fullName);
                        if (isBlank(target)) {
                            ListWrapper.push(this.localEvents, event);
                        } else {
                            ListWrapper.push(this.globalEvents, event);
                        }
                        return result;
                    }
                }, {
                    key: 'visitAccessMember',
                    value: function visitAccessMember(ast) {
                        var isEventAccess = false;
                        var current = ast;
                        while (!isEventAccess && current instanceof AccessMember) {
                            var am = current;
                            if (am.name == '$event') {
                                isEventAccess = true;
                            }
                            current = am.receiver;
                        }
                        if (isEventAccess) {
                            ListWrapper.push(this.locals, ast);
                            var index = this.locals.length - 1;
                            return new AccessMember(this._implicitReceiver, '' + index, function (arr) {
                                return arr[index];
                            }, null);
                        } else {
                            return ast;
                        }
                    }
                }, {
                    key: 'buildEventLocals',
                    value: function buildEventLocals() {
                        return this.locals;
                    }
                }, {
                    key: 'buildLocalEvents',
                    value: function buildLocalEvents() {
                        return this.localEvents;
                    }
                }, {
                    key: 'buildGlobalEvents',
                    value: function buildGlobalEvents() {
                        return this.globalEvents;
                    }
                }, {
                    key: 'merge',
                    value: function merge(eventBuilder) {
                        this._merge(this.localEvents, eventBuilder.localEvents);
                        this._merge(this.globalEvents, eventBuilder.globalEvents);
                        ListWrapper.concat(this.locals, eventBuilder.locals);
                    }
                }, {
                    key: '_merge',
                    value: function _merge(host, tobeAdded) {
                        var names = ListWrapper.create();
                        for (var i = 0; i < host.length; i++) {
                            ListWrapper.push(names, host[i].fullName);
                        }
                        for (var j = 0; j < tobeAdded.length; j++) {
                            if (!ListWrapper.contains(names, tobeAdded[j].fullName)) {
                                ListWrapper.push(host, tobeAdded[j]);
                            }
                        }
                    }
                }]);

                return EventBuilder;
            })(AstTransformer);

            _export('EventBuilder', EventBuilder);
        }
    };
});


System.register('angular2/src/render/dom/compiler/directive_parser', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/dom/dom_adapter', 'angular2/src/render/dom/compiler/selector', 'angular2/src/render/api', 'angular2/src/render/dom/util'], function (_export) {
    var _createClass, _classCallCheck, isPresent, isBlank, BaseException, StringWrapper, MapWrapper, ListWrapper, DOM, SelectorMatcher, CssSelector, DirectiveMetadata, dashCaseToCamelCase, camelCaseToDashCase, EVENT_TARGET_SEPARATOR, DirectiveParser;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
        }, function (_angular2SrcFacadeCollection) {
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomCompilerSelector) {
            SelectorMatcher = _angular2SrcRenderDomCompilerSelector.SelectorMatcher;
            CssSelector = _angular2SrcRenderDomCompilerSelector.CssSelector;
        }, function (_angular2SrcRenderApi) {
            DirectiveMetadata = _angular2SrcRenderApi.DirectiveMetadata;
        }, function (_angular2SrcRenderDomUtil) {
            dashCaseToCamelCase = _angular2SrcRenderDomUtil.dashCaseToCamelCase;
            camelCaseToDashCase = _angular2SrcRenderDomUtil.camelCaseToDashCase;
            EVENT_TARGET_SEPARATOR = _angular2SrcRenderDomUtil.EVENT_TARGET_SEPARATOR;
        }],
        execute: function () {
            'use strict';

            /**
             * Parses the directives on a single element. Assumes ViewSplitter has already created
             * <template> elements for template directives.
             */

            DirectiveParser = (function () {
                function DirectiveParser(parser, directives) {
                    _classCallCheck(this, DirectiveParser);

                    this._parser = parser;
                    this._selectorMatcher = new SelectorMatcher();
                    this._directives = directives;
                    for (var i = 0; i < directives.length; i++) {
                        var directive = directives[i];
                        var selector = CssSelector.parse(directive.selector);
                        this._ensureComponentOnlyHasElementSelector(selector, directive);
                        this._selectorMatcher.addSelectables(selector, i);
                    }
                }

                _createClass(DirectiveParser, [{
                    key: '_ensureComponentOnlyHasElementSelector',
                    value: function _ensureComponentOnlyHasElementSelector(selector, directive) {
                        var isElementSelector = selector.length === 1 && selector[0].isElementSelector();
                        if (!isElementSelector && directive.type === DirectiveMetadata.COMPONENT_TYPE) {
                            throw new BaseException('Component \'' + directive.id + '\' can only have an element selector, but had \'' + directive.selector + '\'');
                        }
                    }
                }, {
                    key: 'process',
                    value: function process(parent, current, control) {
                        var _this = this;

                        var attrs = current.attrs();
                        var classList = current.classList();
                        var cssSelector = new CssSelector();
                        var nodeName = DOM.nodeName(current.element);
                        cssSelector.setElement(nodeName);
                        for (var i = 0; i < classList.length; i++) {
                            cssSelector.addClassName(classList[i]);
                        }
                        MapWrapper.forEach(attrs, function (attrValue, attrName) {
                            cssSelector.addAttribute(attrName, attrValue);
                        });
                        var componentDirective;
                        var foundDirectiveIndices = [];
                        var elementBinder = null;
                        this._selectorMatcher.match(cssSelector, function (selector, directiveIndex) {
                            elementBinder = current.bindElement();
                            var directive = _this._directives[directiveIndex];
                            if (directive.type === DirectiveMetadata.COMPONENT_TYPE) {
                                // components need to go first, so it is easier to locate them in the result.
                                ListWrapper.insert(foundDirectiveIndices, 0, directiveIndex);
                                if (isPresent(componentDirective)) {
                                    throw new BaseException('Only one component directive is allowed per element - check ' + current.elementDescription);
                                }
                                componentDirective = directive;
                                elementBinder.setComponentId(directive.id);
                            } else {
                                ListWrapper.push(foundDirectiveIndices, directiveIndex);
                            }
                        });
                        ListWrapper.forEach(foundDirectiveIndices, function (directiveIndex) {
                            var directive = _this._directives[directiveIndex];
                            var directiveBinderBuilder = elementBinder.bindDirective(directiveIndex);
                            current.compileChildren = current.compileChildren && directive.compileChildren;
                            if (isPresent(directive.properties)) {
                                ListWrapper.forEach(directive.properties, function (bindConfig) {
                                    _this._bindDirectiveProperty(bindConfig, current, directiveBinderBuilder);
                                });
                            }
                            if (isPresent(directive.hostListeners)) {
                                MapWrapper.forEach(directive.hostListeners, function (action, eventName) {
                                    _this._bindDirectiveEvent(eventName, action, current, directiveBinderBuilder);
                                });
                            }
                            if (isPresent(directive.hostActions)) {
                                MapWrapper.forEach(directive.hostActions, function (action, actionName) {
                                    _this._bindHostAction(actionName, action, current, directiveBinderBuilder);
                                });
                            }
                            if (isPresent(directive.hostProperties)) {
                                MapWrapper.forEach(directive.hostProperties, function (hostPropertyName, directivePropertyName) {
                                    _this._bindHostProperty(hostPropertyName, directivePropertyName, current, directiveBinderBuilder);
                                });
                            }
                            if (isPresent(directive.hostAttributes)) {
                                MapWrapper.forEach(directive.hostAttributes, function (hostAttrValue, hostAttrName) {
                                    _this._addHostAttribute(hostAttrName, hostAttrValue, current);
                                });
                            }
                            if (isPresent(directive.readAttributes)) {
                                ListWrapper.forEach(directive.readAttributes, function (attrName) {
                                    elementBinder.readAttribute(attrName);
                                });
                            }
                        });
                    }
                }, {
                    key: '_bindDirectiveProperty',
                    value: function _bindDirectiveProperty(bindConfig, compileElement, directiveBinderBuilder) {
                        // Name of the property on the directive
                        var dirProperty = undefined;
                        // Name of the property on the element
                        var elProp = undefined;
                        var pipes = undefined;
                        var assignIndex = bindConfig.indexOf(':');
                        if (assignIndex > -1) {
                            // canonical syntax: `dirProp: elProp | pipe0 | ... | pipeN`
                            dirProperty = StringWrapper.substring(bindConfig, 0, assignIndex).trim();
                            pipes = this._splitBindConfig(StringWrapper.substring(bindConfig, assignIndex + 1));
                            elProp = ListWrapper.removeAt(pipes, 0);
                        } else {
                            // shorthand syntax when the name of the property on the directive and on the element is the
                            // same, ie `property`
                            dirProperty = bindConfig;
                            elProp = bindConfig;
                            pipes = [];
                        }
                        var bindingAst = MapWrapper.get(compileElement.bindElement().propertyBindings, dashCaseToCamelCase(elProp));
                        if (isBlank(bindingAst)) {
                            var attributeValue = MapWrapper.get(compileElement.attrs(), camelCaseToDashCase(elProp));
                            if (isPresent(attributeValue)) {
                                bindingAst = this._parser.wrapLiteralPrimitive(attributeValue, compileElement.elementDescription);
                            }
                        }
                        // Bindings are optional, so this binding only needs to be set up if an expression is given.
                        if (isPresent(bindingAst)) {
                            var fullExpAstWithBindPipes = this._parser.addPipes(bindingAst, pipes);
                            directiveBinderBuilder.bindProperty(dirProperty, fullExpAstWithBindPipes);
                        }
                    }
                }, {
                    key: '_bindDirectiveEvent',
                    value: function _bindDirectiveEvent(eventName, action, compileElement, directiveBinderBuilder) {
                        var ast = this._parser.parseAction(action, compileElement.elementDescription);
                        if (StringWrapper.contains(eventName, EVENT_TARGET_SEPARATOR)) {
                            var parts = eventName.split(EVENT_TARGET_SEPARATOR);
                            directiveBinderBuilder.bindEvent(parts[1], ast, parts[0]);
                        } else {
                            directiveBinderBuilder.bindEvent(eventName, ast);
                        }
                    }
                }, {
                    key: '_bindHostAction',
                    value: function _bindHostAction(actionName, actionExpression, compileElement, directiveBinderBuilder) {
                        var ast = this._parser.parseAction(actionExpression, compileElement.elementDescription);
                        directiveBinderBuilder.bindHostAction(actionName, actionExpression, ast);
                    }
                }, {
                    key: '_bindHostProperty',
                    value: function _bindHostProperty(hostPropertyName, directivePropertyName, compileElement, directiveBinderBuilder) {
                        var ast = this._parser.parseBinding(directivePropertyName, 'hostProperties of ' + compileElement.elementDescription);
                        directiveBinderBuilder.bindHostProperty(hostPropertyName, ast);
                    }
                }, {
                    key: '_addHostAttribute',
                    value: function _addHostAttribute(attrName, attrValue, compileElement) {
                        if (StringWrapper.equals(attrName, 'class')) {
                            ListWrapper.forEach(attrValue.split(' '), function (className) {
                                DOM.addClass(compileElement.element, className);
                            });
                        } else if (!DOM.hasAttribute(compileElement.element, attrName)) {
                            DOM.setAttribute(compileElement.element, attrName, attrValue);
                        }
                    }
                }, {
                    key: '_splitBindConfig',
                    value: function _splitBindConfig(bindConfig) {
                        return ListWrapper.map(bindConfig.split('|'), function (s) {
                            return s.trim();
                        });
                    }
                }]);

                return DirectiveParser;
            })();

            _export('DirectiveParser', DirectiveParser);
        }
    };
});


System.register('angular2/annotations', ['angular2/src/core/annotations/annotations', 'angular2/src/core/annotations/decorators'], function (_export) {
  /**
   * @module
   * @public
   * @description
   *
   * Annotations provide the additional information that Angular requires in order to run your
   * application. This module
   * contains {@link Component}, {@link Directive}, and {@link View} annotations, as well as {@link
   * Parent} and {@link Ancestor} annotations that are
   * used by Angular to resolve dependencies.
   *
   */

  
  'use strict';

  return {
    setters: [function (_angular2SrcCoreAnnotationsAnnotations) {
      for (var _key in _angular2SrcCoreAnnotationsAnnotations) {
        _export(_key, _angular2SrcCoreAnnotationsAnnotations[_key]);
      }
    }, function (_angular2SrcCoreAnnotationsDecorators) {
      for (var _key2 in _angular2SrcCoreAnnotationsDecorators) {
        _export(_key2, _angular2SrcCoreAnnotationsDecorators[_key2]);
      }
    }],
    execute: function () {}
  };
});
System.register('angular2/directives', ['angular2/src/facade/lang', 'angular2/src/directives/ng_for', 'angular2/src/directives/ng_if', 'angular2/src/directives/ng_non_bindable', 'angular2/src/directives/ng_switch', 'angular2/src/directives/class'], function (_export) {
  /**
   * @module
   * @public
   * @description
   * Common directives shipped with Angular.
   */
  'use strict';

  var CONST_EXPR, NgFor, NgIf, NgNonBindable, NgSwitch, NgSwitchWhen, NgSwitchDefault, coreDirectives;
  return {
    setters: [function (_angular2SrcFacadeLang) {
      CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
    }, function (_angular2SrcDirectivesNg_for) {
      NgFor = _angular2SrcDirectivesNg_for.NgFor;

      for (var _key2 in _angular2SrcDirectivesNg_for) {
        _export(_key2, _angular2SrcDirectivesNg_for[_key2]);
      }
    }, function (_angular2SrcDirectivesNg_if) {
      NgIf = _angular2SrcDirectivesNg_if.NgIf;

      for (var _key3 in _angular2SrcDirectivesNg_if) {
        _export(_key3, _angular2SrcDirectivesNg_if[_key3]);
      }
    }, function (_angular2SrcDirectivesNg_non_bindable) {
      NgNonBindable = _angular2SrcDirectivesNg_non_bindable.NgNonBindable;

      for (var _key4 in _angular2SrcDirectivesNg_non_bindable) {
        _export(_key4, _angular2SrcDirectivesNg_non_bindable[_key4]);
      }
    }, function (_angular2SrcDirectivesNg_switch) {
      NgSwitch = _angular2SrcDirectivesNg_switch.NgSwitch;
      NgSwitchWhen = _angular2SrcDirectivesNg_switch.NgSwitchWhen;
      NgSwitchDefault = _angular2SrcDirectivesNg_switch.NgSwitchDefault;

      for (var _key5 in _angular2SrcDirectivesNg_switch) {
        _export(_key5, _angular2SrcDirectivesNg_switch[_key5]);
      }
    }, function (_angular2SrcDirectivesClass) {
      for (var _key in _angular2SrcDirectivesClass) {
        _export(_key, _angular2SrcDirectivesClass[_key]);
      }
    }],
    execute: function () {
      /**
       * A collection of the Angular core directives that are likely to be used in each and every Angular
       * application.
       *
       * This collection can be used to quickly enumerate all the built-in directives in the `@View`
       * annotation. For example,
       * instead of writing:
       *
       * ```
       * import {If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';
       * import {OtherDirective} from 'myDirectives';
       *
       * @Component({
       *  selector: 'my-component'
       * })
       * @View({
       *   templateUrl: 'myComponent.html',
       *   directives: [If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
       * })
       * export class MyComponent {
       *   ...
       * }
       * ```
       * one could enumerate all the core directives at once:
       *
       * ```
       * import {coreDirectives} from 'angular2/angular2';
       * import {OtherDirective} from 'myDirectives';
       *
       * @Component({
       *  selector: 'my-component'
       * })
       * @View({
       *   templateUrl: 'myComponent.html',
       *   directives: [coreDirectives, OtherDirective]
       * })
       * export class MyComponent {
       *   ...
       * }
       * ```
       *
       */
      coreDirectives = CONST_EXPR([NgFor, NgIf, NgNonBindable, NgSwitch, NgSwitchWhen, NgSwitchDefault]);

      

      _export('coreDirectives', coreDirectives);
    }
  };
});
System.register('angular2/src/forms/model', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'angular2/src/facade/lang', 'angular2/src/facade/async', 'angular2/src/facade/collection', 'angular2/src/forms/validators'], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, StringWrapper, isPresent, EventEmitter, ObservableWrapper, StringMapWrapper, ListWrapper, List, Validators, VALID, INVALID, AbstractControl, Control, ControlGroup, ControlArray;

    function isControl(c) {
        return c instanceof AbstractControl;
    }

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_angular2SrcFacadeLang) {
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            isPresent = _angular2SrcFacadeLang.isPresent;
        }, function (_angular2SrcFacadeAsync) {
            EventEmitter = _angular2SrcFacadeAsync.EventEmitter;
            ObservableWrapper = _angular2SrcFacadeAsync.ObservableWrapper;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            List = _angular2SrcFacadeCollection.List;
        }, function (_angular2SrcFormsValidators) {
            Validators = _angular2SrcFormsValidators.Validators;
        }],
        execute: function () {
            'use strict';

            _export('isControl', isControl);

            /**
             * Indicates that a Control is valid, i.e. that no errors exist in the input value.
             *
             * @exportedAs angular2/forms
             */
            VALID = 'VALID';

            _export('VALID', VALID);

            /**
             * Indicates that a Control is invalid, i.e. that an error exists in the input value.
             *
             * @exportedAs angular2/forms
             */
            INVALID = 'INVALID';

            _export('INVALID', INVALID);

            /**
             * Omitting from external API doc as this is really an abstract internal concept.
             */

            AbstractControl = (function () {
                function AbstractControl(validator) {
                    _classCallCheck(this, AbstractControl);

                    this.validator = validator;
                    this._pristine = true;
                }

                _createClass(AbstractControl, [{
                    key: 'value',
                    get: function () {
                        return this._value;
                    },
                    set: function (v) {
                        this._value = v;
                    }
                }, {
                    key: 'status',
                    get: function () {
                        return this._status;
                    }
                }, {
                    key: 'valid',
                    get: function () {
                        return this._status === VALID;
                    }
                }, {
                    key: 'errors',
                    get: function () {
                        return this._errors;
                    }
                }, {
                    key: 'pristine',
                    get: function () {
                        return this._pristine;
                    }
                }, {
                    key: 'dirty',
                    get: function () {
                        return !this.pristine;
                    }
                }, {
                    key: 'valueChanges',
                    get: function () {
                        return this._valueChanges;
                    }
                }, {
                    key: 'setParent',
                    value: function setParent(parent) {
                        this._parent = parent;
                    }
                }, {
                    key: '_updateParent',
                    value: function _updateParent() {
                        if (isPresent(this._parent)) {
                            this._parent._updateValue();
                        }
                    }
                }, {
                    key: 'updateValidity',
                    value: function updateValidity() {
                        this._errors = this.validator(this);
                        this._status = isPresent(this._errors) ? INVALID : VALID;
                        if (isPresent(this._parent)) {
                            this._parent.updateValidity();
                        }
                    }
                }]);

                return AbstractControl;
            })();

            _export('AbstractControl', AbstractControl);

            /**
             * Defines a part of a form that cannot be divided into other controls.
             *
             * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
             * with
             * {@link ControlGroup} and {@link ControlArray}.
             *
             * @exportedAs angular2/forms
             */

            Control = (function (_AbstractControl) {
                function Control(value) {
                    var validator = arguments[1] === undefined ? Validators.nullValidator : arguments[1];

                    _classCallCheck(this, Control);

                    _get(Object.getPrototypeOf(Control.prototype), 'constructor', this).call(this, validator);
                    this._setValueErrorsStatus(value);
                    this._valueChanges = new EventEmitter();
                }

                _inherits(Control, _AbstractControl);

                _createClass(Control, [{
                    key: 'updateValue',
                    value: function updateValue(value) {
                        this._setValueErrorsStatus(value);
                        this._pristine = false;
                        ObservableWrapper.callNext(this._valueChanges, this._value);
                        this._updateParent();
                    }
                }, {
                    key: '_setValueErrorsStatus',
                    value: function _setValueErrorsStatus(value) {
                        this._value = value;
                        this._errors = this.validator(this);
                        this._status = isPresent(this._errors) ? INVALID : VALID;
                    }
                }]);

                return Control;
            })(AbstractControl);

            _export('Control', Control);

            /**
             * Defines a part of a form, of fixed length, that can contain other controls.
             *
             * A ControlGroup aggregates the values and errors of each {@link Control} in the group. Thus, if
             * one of the controls
             * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,
             * the entire group
             * changes as well.
             *
             * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
             * along with
             * {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other controls,
             * but is of variable
             * length.
             *
             * @exportedAs angular2/forms
             */

            ControlGroup = (function (_AbstractControl2) {
                function ControlGroup(controls) {
                    var optionals = arguments[1] === undefined ? null : arguments[1];
                    var validator = arguments[2] === undefined ? Validators.group : arguments[2];

                    _classCallCheck(this, ControlGroup);

                    _get(Object.getPrototypeOf(ControlGroup.prototype), 'constructor', this).call(this, validator);
                    this.controls = controls;
                    this._optionals = isPresent(optionals) ? optionals : {};
                    this._valueChanges = new EventEmitter();
                    this._setParentForControls();
                    this._setValueErrorsStatus();
                }

                _inherits(ControlGroup, _AbstractControl2);

                _createClass(ControlGroup, [{
                    key: 'addControl',
                    value: function addControl(name, c) {
                        this.controls[name] = c;
                    }
                }, {
                    key: 'removeControl',
                    value: function removeControl(name) {
                        StringMapWrapper['delete'](this.controls, name);
                    }
                }, {
                    key: 'include',
                    value: function include(controlName) {
                        StringMapWrapper.set(this._optionals, controlName, true);
                        this._updateValue();
                    }
                }, {
                    key: 'exclude',
                    value: function exclude(controlName) {
                        StringMapWrapper.set(this._optionals, controlName, false);
                        this._updateValue();
                    }
                }, {
                    key: 'contains',
                    value: function contains(controlName) {
                        var c = StringMapWrapper.contains(this.controls, controlName);
                        return c && this._included(controlName);
                    }
                }, {
                    key: 'find',
                    value: function find(path) {
                        if (!(path instanceof List)) {
                            path = StringWrapper.split(path, new RegExp('/'));
                        }
                        return ListWrapper.reduce(path, function (v, name) {
                            return v instanceof ControlGroup && isPresent(v.controls[name]) ? v.controls[name] : null;
                        }, this);
                    }
                }, {
                    key: '_setParentForControls',
                    value: function _setParentForControls() {
                        var _this = this;

                        StringMapWrapper.forEach(this.controls, function (control, name) {
                            control.setParent(_this);
                        });
                    }
                }, {
                    key: '_updateValue',
                    value: function _updateValue() {
                        this._setValueErrorsStatus();
                        this._pristine = false;
                        ObservableWrapper.callNext(this._valueChanges, this._value);
                        this._updateParent();
                    }
                }, {
                    key: '_setValueErrorsStatus',
                    value: function _setValueErrorsStatus() {
                        this._value = this._reduceValue();
                        this._errors = this.validator(this);
                        this._status = isPresent(this._errors) ? INVALID : VALID;
                    }
                }, {
                    key: '_reduceValue',
                    value: function _reduceValue() {
                        return this._reduceChildren({}, function (acc, control, name) {
                            acc[name] = control.value;
                            return acc;
                        });
                    }
                }, {
                    key: '_reduceChildren',
                    value: function _reduceChildren(initValue, fn) {
                        var _this2 = this;

                        var res = initValue;
                        StringMapWrapper.forEach(this.controls, function (control, name) {
                            if (_this2._included(name)) {
                                res = fn(res, control, name);
                            }
                        });
                        return res;
                    }
                }, {
                    key: '_included',
                    value: function _included(controlName) {
                        var isOptional = StringMapWrapper.contains(this._optionals, controlName);
                        return !isOptional || StringMapWrapper.get(this._optionals, controlName);
                    }
                }]);

                return ControlGroup;
            })(AbstractControl);

            _export('ControlGroup', ControlGroup);

            /**
             * Defines a part of a form, of variable length, that can contain other controls.
             *
             * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
             * one of the controls
             * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,
             * the entire group
             * changes as well.
             *
             * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
             * along with
             * {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain other controls,
             * but is of fixed
             * length.
             *
             * @exportedAs angular2/forms
             */

            ControlArray = (function (_AbstractControl3) {
                function ControlArray(controls) {
                    var validator = arguments[1] === undefined ? Validators.array : arguments[1];

                    _classCallCheck(this, ControlArray);

                    _get(Object.getPrototypeOf(ControlArray.prototype), 'constructor', this).call(this, validator);
                    this.controls = controls;
                    this._valueChanges = new EventEmitter();
                    this._setParentForControls();
                    this._setValueErrorsStatus();
                }

                _inherits(ControlArray, _AbstractControl3);

                _createClass(ControlArray, [{
                    key: 'at',
                    value: function at(index) {
                        return this.controls[index];
                    }
                }, {
                    key: 'push',
                    value: function push(control) {
                        ListWrapper.push(this.controls, control);
                        control.setParent(this);
                        this._updateValue();
                    }
                }, {
                    key: 'insert',
                    value: function insert(index, control) {
                        ListWrapper.insert(this.controls, index, control);
                        control.setParent(this);
                        this._updateValue();
                    }
                }, {
                    key: 'removeAt',
                    value: function removeAt(index) {
                        ListWrapper.removeAt(this.controls, index);
                        this._updateValue();
                    }
                }, {
                    key: 'length',
                    get: function () {
                        return this.controls.length;
                    }
                }, {
                    key: '_updateValue',
                    value: function _updateValue() {
                        this._setValueErrorsStatus();
                        this._pristine = false;
                        ObservableWrapper.callNext(this._valueChanges, this._value);
                        this._updateParent();
                    }
                }, {
                    key: '_setParentForControls',
                    value: function _setParentForControls() {
                        var _this3 = this;

                        ListWrapper.forEach(this.controls, function (control) {
                            control.setParent(_this3);
                        });
                    }
                }, {
                    key: '_setValueErrorsStatus',
                    value: function _setValueErrorsStatus() {
                        this._value = ListWrapper.map(this.controls, function (c) {
                            return c.value;
                        });
                        this._errors = this.validator(this);
                        this._status = isPresent(this._errors) ? INVALID : VALID;
                    }
                }]);

                return ControlArray;
            })(AbstractControl);

            _export('ControlArray', ControlArray);
        }
    };
});


System.register("angular2/src/forms/directives/control_name_directive", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/angular2", "angular2/di", "angular2/src/forms/directives/control_container_directive", "angular2/src/forms/directives/control_directive", "angular2/src/forms/directives/shared"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, CONST_EXPR, Directive, Ancestor, onDestroy, onInit, FORWARD_REF, Binding, ControlContainerDirective, ControlDirective, controlPath, __decorate, __metadata, __param, controlNameBinding, ControlNameDirective;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            onDestroy = _angular2Angular2.onDestroy;
            onInit = _angular2Angular2.onInit;
        }, function (_angular2Di) {
            FORWARD_REF = _angular2Di.FORWARD_REF;
            Binding = _angular2Di.Binding;
        }, function (_angular2SrcFormsDirectivesControl_container_directive) {
            ControlContainerDirective = _angular2SrcFormsDirectivesControl_container_directive.ControlContainerDirective;
        }, function (_angular2SrcFormsDirectivesControl_directive) {
            ControlDirective = _angular2SrcFormsDirectivesControl_directive.ControlDirective;
        }, function (_angular2SrcFormsDirectivesShared) {
            controlPath = _angular2SrcFormsDirectivesShared.controlPath;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            controlNameBinding = CONST_EXPR(new Binding(ControlDirective, { toAlias: FORWARD_REF(function () {
                    return ControlNameDirective;
                }) }));

            /**
             * Binds a control to a DOM element.
             *
             * # Example
             *
             * In this example, we bind the control to an input element. When the value of the input element
             * changes, the value of
             * the control will reflect that change. Likewise, if the value of the control changes, the input
             * element reflects that
             * change.
             *
             * Here we use {@link formDirectives}, rather than importing each form directive individually, e.g.
             * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.
             *
             *  ```
             * @Component({selector: "login-comp"})
             * @View({
             *      directives: [formDirectives],
             *      template: "<input type='text' [control]='loginControl'>"
             *      })
             * class LoginComp {
             *  loginControl:Control;
             *
             *  constructor() {
             *    this.loginControl = new Control('');
             *  }
             * }
             *
             *  ```
             *
             * @exportedAs angular2/forms
             */

            ControlNameDirective = (function (_ControlDirective) {
                var _class = function ControlNameDirective(_parent) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this._parent = _parent;
                };

                _inherits(_class, _ControlDirective);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        this.formDirective.addControl(this);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.formDirective.removeControl(this);
                    }
                }, {
                    key: "path",
                    get: function () {
                        return controlPath(this.name, this._parent);
                    }
                }, {
                    key: "formDirective",
                    get: function () {
                        return this._parent.formDirective;
                    }
                }]);

                return _class;
            })(ControlDirective);

            _export("ControlNameDirective", ControlNameDirective);

            _export("ControlNameDirective", ControlNameDirective = __decorate([Directive({
                selector: "[control]",
                hostInjector: [controlNameBinding],
                properties: ["name: control"],
                lifecycle: [onDestroy, onInit]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [ControlContainerDirective])], ControlNameDirective));
            
        }
    };
});
System.register('angular2/src/facade/collection', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/core-js/object/keys', 'npm:babel-runtime@5.4.7/core-js/is-iterable', 'npm:babel-runtime@5.4.7/core-js/get-iterator', 'angular2/src/facade/lang'], function (_export) {
    var _createClass, _classCallCheck, _Object$keys, _isIterable, _getIterator, isJsObject, global, isPresent, List, Map, Set, StringMap, createMapFromPairs, createMapFromMap, _clearValues, MapWrapper, StringMapWrapper, ListWrapper, createSetFromList, SetWrapper;

    function isListLikeIterable(obj) {
        if (!isJsObject(obj)) return false;
        return ListWrapper.isList(obj) || !(obj instanceof Map) && _isIterable(obj); // JS Iterable have a Symbol.iterator prop
    }

    function iterateListLike(obj, fn) {
        if (ListWrapper.isList(obj)) {
            for (var i = 0; i < obj.length; i++) {
                fn(obj[i]);
            }
        } else {
            var iterator = _getIterator(obj);
            var item;
            while (!(item = iterator.next()).done) {
                fn(item.value);
            }
        }
    }

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime547CoreJsObjectKeys['default'];
        }, function (_npmBabelRuntime547CoreJsIsIterable) {
            _isIterable = _npmBabelRuntime547CoreJsIsIterable['default'];
        }, function (_npmBabelRuntime547CoreJsGetIterator) {
            _getIterator = _npmBabelRuntime547CoreJsGetIterator['default'];
        }, function (_angular2SrcFacadeLang) {
            isJsObject = _angular2SrcFacadeLang.isJsObject;
            global = _angular2SrcFacadeLang.global;
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {
            'use strict';

            _export('isListLikeIterable', isListLikeIterable);

            _export('iterateListLike', iterateListLike);

            List = global.Array;

            _export('List', List);

            Map = global.Map;

            _export('Map', Map);

            Set = global.Set;

            _export('Set', Set);

            StringMap = global.Object;

            _export('StringMap', StringMap);

            // Safari and Internet Explorer do not support the iterable parameter to the
            // Map constructor.  We work around that by manually adding the items.

            createMapFromPairs = (function () {
                try {
                    if (new Map([1, 2]).size === 2) {
                        return function createMapFromPairs(pairs) {
                            return new Map(pairs);
                        };
                    }
                } catch (e) {}
                return function createMapAndPopulateFromPairs(pairs) {
                    var map = new Map();
                    for (var i = 0; i < pairs.length; i++) {
                        var pair = pairs[i];
                        map.set(pair[0], pair[1]);
                    }
                    return map;
                };
            })();

            createMapFromMap = (function () {
                try {
                    if (new Map(new Map())) {
                        return function createMapFromMap(m) {
                            return new Map(m);
                        };
                    }
                } catch (e) {}
                return function createMapAndPopulateFromMap(m) {
                    var map = new Map();
                    m.forEach(function (v, k) {
                        map.set(k, v);
                    });
                    return map;
                };
            })();

            _clearValues = (function () {
                if (new Map().keys().next) {
                    return function _clearValues(m) {
                        var keyIterator = m.keys();
                        var k;
                        while (!(k = keyIterator.next()).done) {
                            m.set(k.value, null);
                        }
                    };
                } else {
                    return function _clearValuesWithForeEach(m) {
                        m.forEach(function (v, k) {
                            m.set(k, null);
                        });
                    };
                }
            })();

            MapWrapper = (function () {
                function MapWrapper() {
                    _classCallCheck(this, MapWrapper);
                }

                _createClass(MapWrapper, null, [{
                    key: 'create',
                    value: function create() {
                        return new Map();
                    }
                }, {
                    key: 'clone',
                    value: function clone(m) {
                        return createMapFromMap(m);
                    }
                }, {
                    key: 'createFromStringMap',
                    value: function createFromStringMap(stringMap) {
                        var result = MapWrapper.create();
                        for (var prop in stringMap) {
                            MapWrapper.set(result, prop, stringMap[prop]);
                        }
                        return result;
                    }
                }, {
                    key: 'createFromPairs',
                    value: function createFromPairs(pairs) {
                        return createMapFromPairs(pairs);
                    }
                }, {
                    key: 'get',
                    value: function get(m, k) {
                        return m.get(k);
                    }
                }, {
                    key: 'set',
                    value: function set(m, k, v) {
                        m.set(k, v);
                    }
                }, {
                    key: 'contains',
                    value: function contains(m, k) {
                        return m.has(k);
                    }
                }, {
                    key: 'forEach',
                    value: function forEach(m, fn) {
                        m.forEach(fn);
                    }
                }, {
                    key: 'size',
                    value: function size(m) {
                        return m.size;
                    }
                }, {
                    key: 'delete',
                    value: function _delete(m, k) {
                        m['delete'](k);
                    }
                }, {
                    key: 'clear',
                    value: function clear(m) {
                        m.clear();
                    }
                }, {
                    key: 'clearValues',
                    value: function clearValues(m) {
                        _clearValues(m);
                    }
                }, {
                    key: 'iterable',
                    value: function iterable(m) {
                        return m;
                    }
                }, {
                    key: 'keys',
                    value: function keys(m) {
                        return m.keys();
                    }
                }, {
                    key: 'values',
                    value: function values(m) {
                        return m.values();
                    }
                }]);

                return MapWrapper;
            })();

            _export('MapWrapper', MapWrapper);

            /**
             * Wraps Javascript Objects
             */

            StringMapWrapper = (function () {
                function StringMapWrapper() {
                    _classCallCheck(this, StringMapWrapper);
                }

                _createClass(StringMapWrapper, null, [{
                    key: 'create',
                    value: function create() {
                        // Note: We are not using Object.create(null) here due to
                        // performance!
                        // http://jsperf.com/ng2-object-create-null
                        return {};
                    }
                }, {
                    key: 'contains',
                    value: function contains(map, key) {
                        return map.hasOwnProperty(key);
                    }
                }, {
                    key: 'get',
                    value: function get(map, key) {
                        return map.hasOwnProperty(key) ? map[key] : undefined;
                    }
                }, {
                    key: 'set',
                    value: function set(map, key, value) {
                        map[key] = value;
                    }
                }, {
                    key: 'keys',
                    value: function keys(map) {
                        return _Object$keys(map);
                    }
                }, {
                    key: 'isEmpty',
                    value: function isEmpty(map) {
                        for (var prop in map) {
                            return false;
                        }
                        return true;
                    }
                }, {
                    key: 'delete',
                    value: function _delete(map, key) {
                        delete map[key];
                    }
                }, {
                    key: 'forEach',
                    value: function forEach(map, callback) {
                        for (var prop in map) {
                            if (map.hasOwnProperty(prop)) {
                                callback(map[prop], prop);
                            }
                        }
                    }
                }, {
                    key: 'merge',
                    value: function merge(m1, m2) {
                        var m = {};
                        for (var attr in m1) {
                            if (m1.hasOwnProperty(attr)) {
                                m[attr] = m1[attr];
                            }
                        }
                        for (var attr in m2) {
                            if (m2.hasOwnProperty(attr)) {
                                m[attr] = m2[attr];
                            }
                        }
                        return m;
                    }
                }, {
                    key: 'equals',
                    value: function equals(m1, m2) {
                        var k1 = _Object$keys(m1);
                        var k2 = _Object$keys(m2);
                        if (k1.length != k2.length) {
                            return false;
                        }
                        var key;
                        for (var i = 0; i < k1.length; i++) {
                            key = k1[i];
                            if (m1[key] !== m2[key]) {
                                return false;
                            }
                        }
                        return true;
                    }
                }]);

                return StringMapWrapper;
            })();

            _export('StringMapWrapper', StringMapWrapper);

            ListWrapper = (function () {
                function ListWrapper() {
                    _classCallCheck(this, ListWrapper);
                }

                _createClass(ListWrapper, null, [{
                    key: 'create',
                    value: function create() {
                        return new List();
                    }
                }, {
                    key: 'createFixedSize',
                    value: function createFixedSize(size) {
                        return new List(size);
                    }
                }, {
                    key: 'get',
                    value: function get(m, k) {
                        return m[k];
                    }
                }, {
                    key: 'set',
                    value: function set(m, k, v) {
                        m[k] = v;
                    }
                }, {
                    key: 'clone',
                    value: function clone(array) {
                        return array.slice(0);
                    }
                }, {
                    key: 'map',
                    value: function map(array, fn) {
                        return array.map(fn);
                    }
                }, {
                    key: 'forEach',
                    value: function forEach(array, fn) {
                        for (var i = 0; i < array.length; i++) {
                            fn(array[i]);
                        }
                    }
                }, {
                    key: 'push',
                    value: function push(array, el) {
                        array.push(el);
                    }
                }, {
                    key: 'first',
                    value: function first(array) {
                        if (!array) return null;
                        return array[0];
                    }
                }, {
                    key: 'last',
                    value: function last(array) {
                        if (!array || array.length == 0) return null;
                        return array[array.length - 1];
                    }
                }, {
                    key: 'find',
                    value: function find(list, pred) {
                        for (var i = 0; i < list.length; ++i) {
                            if (pred(list[i])) return list[i];
                        }
                        return null;
                    }
                }, {
                    key: 'indexOf',
                    value: function indexOf(array, value) {
                        var startIndex = arguments[2] === undefined ? 0 : arguments[2];

                        return array.indexOf(value, startIndex);
                    }
                }, {
                    key: 'reduce',
                    value: function reduce(list, fn, init) {
                        return list.reduce(fn, init);
                    }
                }, {
                    key: 'filter',
                    value: function filter(array, pred) {
                        return array.filter(pred);
                    }
                }, {
                    key: 'any',
                    value: function any(list, pred) {
                        for (var i = 0; i < list.length; ++i) {
                            if (pred(list[i])) return true;
                        }
                        return false;
                    }
                }, {
                    key: 'contains',
                    value: function contains(list, el) {
                        return list.indexOf(el) !== -1;
                    }
                }, {
                    key: 'reversed',
                    value: function reversed(array) {
                        var a = ListWrapper.clone(array);
                        return a.reverse();
                    }
                }, {
                    key: 'concat',
                    value: function concat(a, b) {
                        return a.concat(b);
                    }
                }, {
                    key: 'isList',
                    value: function isList(list) {
                        return Array.isArray(list);
                    }
                }, {
                    key: 'insert',
                    value: function insert(list, index, value) {
                        list.splice(index, 0, value);
                    }
                }, {
                    key: 'removeAt',
                    value: function removeAt(list, index) {
                        var res = list[index];
                        list.splice(index, 1);
                        return res;
                    }
                }, {
                    key: 'removeAll',
                    value: function removeAll(list, items) {
                        for (var i = 0; i < items.length; ++i) {
                            var index = list.indexOf(items[i]);
                            list.splice(index, 1);
                        }
                    }
                }, {
                    key: 'removeLast',
                    value: function removeLast(list) {
                        return list.pop();
                    }
                }, {
                    key: 'remove',
                    value: function remove(list, el) {
                        var index = list.indexOf(el);
                        if (index > -1) {
                            list.splice(index, 1);
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: 'clear',
                    value: function clear(list) {
                        list.splice(0, list.length);
                    }
                }, {
                    key: 'join',
                    value: function join(list, s) {
                        return list.join(s);
                    }
                }, {
                    key: 'isEmpty',
                    value: function isEmpty(list) {
                        return list.length == 0;
                    }
                }, {
                    key: 'fill',
                    value: function fill(list, value) {
                        var start = arguments[2] === undefined ? 0 : arguments[2];
                        var end = arguments[3] === undefined ? null : arguments[3];

                        list.fill(value, start, end === null ? undefined : end);
                    }
                }, {
                    key: 'equals',
                    value: function equals(a, b) {
                        if (a.length != b.length) return false;
                        for (var i = 0; i < a.length; ++i) {
                            if (a[i] !== b[i]) return false;
                        }
                        return true;
                    }
                }, {
                    key: 'slice',
                    value: function slice(l) {
                        var from = arguments[1] === undefined ? 0 : arguments[1];
                        var to = arguments[2] === undefined ? null : arguments[2];

                        return l.slice(from, to === null ? undefined : to);
                    }
                }, {
                    key: 'splice',
                    value: function splice(l, from, length) {
                        return l.splice(from, length);
                    }
                }, {
                    key: 'sort',
                    value: function sort(l, compareFn) {
                        if (isPresent(compareFn)) {
                            l.sort(compareFn);
                        } else {
                            l.sort();
                        }
                    }
                }]);

                return ListWrapper;
            })();

            _export('ListWrapper', ListWrapper);

            // Safari and Internet Explorer do not support the iterable parameter to the
            // Set constructor.  We work around that by manually adding the items.

            createSetFromList = (function () {
                var test = new Set([1, 2, 3]);
                if (test.size === 3) {
                    return function createSetFromList(lst) {
                        return new Set(lst);
                    };
                } else {
                    return function createSetAndPopulateFromList(lst) {
                        var res = new Set(lst);
                        if (res.size !== lst.length) {
                            for (var i = 0; i < lst.length; i++) {
                                res.add(lst[i]);
                            }
                        }
                        return res;
                    };
                }
            })();

            SetWrapper = (function () {
                function SetWrapper() {
                    _classCallCheck(this, SetWrapper);
                }

                _createClass(SetWrapper, null, [{
                    key: 'createFromList',
                    value: function createFromList(lst) {
                        return createSetFromList(lst);
                    }
                }, {
                    key: 'has',
                    value: function has(s, key) {
                        return s.has(key);
                    }
                }]);

                return SetWrapper;
            })();

            _export('SetWrapper', SetWrapper);
        }
    };
});


System.register("angular2/src/change_detection/parser/lexer", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "angular2/src/di/decorators", "angular2/src/facade/collection", "angular2/src/facade/lang"], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, Injectable, ListWrapper, SetWrapper, NumberWrapper, StringJoiner, StringWrapper, BaseException, __decorate, __metadata, TOKEN_TYPE_CHARACTER, TOKEN_TYPE_IDENTIFIER, TOKEN_TYPE_KEYWORD, TOKEN_TYPE_STRING, TOKEN_TYPE_OPERATOR, TOKEN_TYPE_NUMBER, Lexer, Token, EOF, $EOF, $TAB, $LF, $VTAB, $FF, $CR, $SPACE, $BANG, $DQ, $HASH, $$, $PERCENT, $AMPERSAND, $SQ, $LPAREN, $RPAREN, $STAR, $PLUS, $COMMA, $MINUS, $PERIOD, $SLASH, $COLON, $SEMICOLON, $LT, $EQ, $GT, $QUESTION, $0, $9, $A, $E, $Z, $LBRACKET, $BACKSLASH, $RBRACKET, $CARET, $_, $a, $e, $f, $n, $r, $t, $u, $v, $z, $LBRACE, $BAR, $RBRACE, $NBSP, ScannerError, _Scanner, OPERATORS, KEYWORDS;

    function newCharacterToken(index, code) {
        return new Token(index, TOKEN_TYPE_CHARACTER, code, StringWrapper.fromCharCode(code));
    }
    function newIdentifierToken(index, text) {
        return new Token(index, TOKEN_TYPE_IDENTIFIER, 0, text);
    }
    function newKeywordToken(index, text) {
        return new Token(index, TOKEN_TYPE_KEYWORD, 0, text);
    }
    function newOperatorToken(index, text) {
        return new Token(index, TOKEN_TYPE_OPERATOR, 0, text);
    }
    function newStringToken(index, text) {
        return new Token(index, TOKEN_TYPE_STRING, 0, text);
    }
    function newNumberToken(index, n) {
        return new Token(index, TOKEN_TYPE_NUMBER, n, "");
    }

    function isWhitespace(code) {
        return code >= $TAB && code <= $SPACE || code == $NBSP;
    }
    function isIdentifierStart(code) {
        return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
    }
    function isIdentifierPart(code) {
        return $a <= code && code <= $z || $A <= code && code <= $Z || $0 <= code && code <= $9 || code == $_ || code == $$;
    }
    function isDigit(code) {
        return $0 <= code && code <= $9;
    }
    function isExponentStart(code) {
        return code == $e || code == $E;
    }
    function isExponentSign(code) {
        return code == $MINUS || code == $PLUS;
    }
    function unescape(code) {
        switch (code) {
            case $n:
                return $LF;
            case $f:
                return $FF;
            case $r:
                return $CR;
            case $t:
                return $TAB;
            case $v:
                return $VTAB;
            default:
                return code;
        }
    }
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_angular2SrcDiDecorators) {
            Injectable = _angular2SrcDiDecorators.Injectable;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            SetWrapper = _angular2SrcFacadeCollection.SetWrapper;
        }, function (_angular2SrcFacadeLang) {
            NumberWrapper = _angular2SrcFacadeLang.NumberWrapper;
            StringJoiner = _angular2SrcFacadeLang.StringJoiner;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            TOKEN_TYPE_CHARACTER = 1;

            _export("TOKEN_TYPE_CHARACTER", TOKEN_TYPE_CHARACTER);

            TOKEN_TYPE_IDENTIFIER = 2;

            _export("TOKEN_TYPE_IDENTIFIER", TOKEN_TYPE_IDENTIFIER);

            TOKEN_TYPE_KEYWORD = 3;

            _export("TOKEN_TYPE_KEYWORD", TOKEN_TYPE_KEYWORD);

            TOKEN_TYPE_STRING = 4;

            _export("TOKEN_TYPE_STRING", TOKEN_TYPE_STRING);

            TOKEN_TYPE_OPERATOR = 5;

            _export("TOKEN_TYPE_OPERATOR", TOKEN_TYPE_OPERATOR);

            TOKEN_TYPE_NUMBER = 6;

            _export("TOKEN_TYPE_NUMBER", TOKEN_TYPE_NUMBER);

            Lexer = (function () {
                var _class = function Lexer() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "tokenize",
                    value: function tokenize(text) {
                        var scanner = new _Scanner(text);
                        var tokens = [];
                        var token = scanner.scanToken();
                        while (token != null) {
                            ListWrapper.push(tokens, token);
                            token = scanner.scanToken();
                        }
                        return tokens;
                    }
                }]);

                return _class;
            })();

            _export("Lexer", Lexer);

            _export("Lexer", Lexer = __decorate([Injectable(), __metadata("design:paramtypes", [])], Lexer));

            Token = (function () {
                function Token(index, type, numValue, strValue) {
                    _classCallCheck(this, Token);

                    this.index = index;
                    this.type = type;
                    this.numValue = numValue;
                    this.strValue = strValue;
                }

                _createClass(Token, [{
                    key: "isCharacter",
                    value: function isCharacter(code) {
                        return this.type == TOKEN_TYPE_CHARACTER && this.numValue == code;
                    }
                }, {
                    key: "isNumber",
                    value: function isNumber() {
                        return this.type == TOKEN_TYPE_NUMBER;
                    }
                }, {
                    key: "isString",
                    value: function isString() {
                        return this.type == TOKEN_TYPE_STRING;
                    }
                }, {
                    key: "isOperator",
                    value: function isOperator(operater) {
                        return this.type == TOKEN_TYPE_OPERATOR && this.strValue == operater;
                    }
                }, {
                    key: "isIdentifier",
                    value: function isIdentifier() {
                        return this.type == TOKEN_TYPE_IDENTIFIER;
                    }
                }, {
                    key: "isKeyword",
                    value: function isKeyword() {
                        return this.type == TOKEN_TYPE_KEYWORD;
                    }
                }, {
                    key: "isKeywordVar",
                    value: function isKeywordVar() {
                        return this.type == TOKEN_TYPE_KEYWORD && this.strValue == "var";
                    }
                }, {
                    key: "isKeywordNull",
                    value: function isKeywordNull() {
                        return this.type == TOKEN_TYPE_KEYWORD && this.strValue == "null";
                    }
                }, {
                    key: "isKeywordUndefined",
                    value: function isKeywordUndefined() {
                        return this.type == TOKEN_TYPE_KEYWORD && this.strValue == "undefined";
                    }
                }, {
                    key: "isKeywordTrue",
                    value: function isKeywordTrue() {
                        return this.type == TOKEN_TYPE_KEYWORD && this.strValue == "true";
                    }
                }, {
                    key: "isKeywordFalse",
                    value: function isKeywordFalse() {
                        return this.type == TOKEN_TYPE_KEYWORD && this.strValue == "false";
                    }
                }, {
                    key: "toNumber",
                    value: function toNumber() {
                        // -1 instead of NULL ok?
                        return this.type == TOKEN_TYPE_NUMBER ? this.numValue : -1;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var t = this.type;
                        if (t >= TOKEN_TYPE_CHARACTER && t <= TOKEN_TYPE_STRING) {
                            return this.strValue;
                        } else if (t == TOKEN_TYPE_NUMBER) {
                            return this.numValue.toString();
                        } else {
                            return null;
                        }
                    }
                }]);

                return Token;
            })();

            _export("Token", Token);

            EOF = new Token(-1, 0, 0, "");

            _export("EOF", EOF);

            $EOF = 0;

            _export("$EOF", $EOF);

            $TAB = 9;

            _export("$TAB", $TAB);

            $LF = 10;

            _export("$LF", $LF);

            $VTAB = 11;

            _export("$VTAB", $VTAB);

            $FF = 12;

            _export("$FF", $FF);

            $CR = 13;

            _export("$CR", $CR);

            $SPACE = 32;

            _export("$SPACE", $SPACE);

            $BANG = 33;

            _export("$BANG", $BANG);

            $DQ = 34;

            _export("$DQ", $DQ);

            $HASH = 35;

            _export("$HASH", $HASH);

            $$ = 36;

            _export("$$", $$);

            $PERCENT = 37;

            _export("$PERCENT", $PERCENT);

            $AMPERSAND = 38;

            _export("$AMPERSAND", $AMPERSAND);

            $SQ = 39;

            _export("$SQ", $SQ);

            $LPAREN = 40;

            _export("$LPAREN", $LPAREN);

            $RPAREN = 41;

            _export("$RPAREN", $RPAREN);

            $STAR = 42;

            _export("$STAR", $STAR);

            $PLUS = 43;

            _export("$PLUS", $PLUS);

            $COMMA = 44;

            _export("$COMMA", $COMMA);

            $MINUS = 45;

            _export("$MINUS", $MINUS);

            $PERIOD = 46;

            _export("$PERIOD", $PERIOD);

            $SLASH = 47;

            _export("$SLASH", $SLASH);

            $COLON = 58;

            _export("$COLON", $COLON);

            $SEMICOLON = 59;

            _export("$SEMICOLON", $SEMICOLON);

            $LT = 60;

            _export("$LT", $LT);

            $EQ = 61;

            _export("$EQ", $EQ);

            $GT = 62;

            _export("$GT", $GT);

            $QUESTION = 63;

            _export("$QUESTION", $QUESTION);

            $0 = 48;
            $9 = 57;
            $A = 65;
            $E = 69;
            $Z = 90;
            $LBRACKET = 91;

            _export("$LBRACKET", $LBRACKET);

            $BACKSLASH = 92;

            _export("$BACKSLASH", $BACKSLASH);

            $RBRACKET = 93;

            _export("$RBRACKET", $RBRACKET);

            $CARET = 94;
            $_ = 95;
            $a = 97;
            $e = 101;
            $f = 102;
            $n = 110;
            $r = 114;
            $t = 116;
            $u = 117;
            $v = 118;
            $z = 122;
            $LBRACE = 123;

            _export("$LBRACE", $LBRACE);

            $BAR = 124;

            _export("$BAR", $BAR);

            $RBRACE = 125;

            _export("$RBRACE", $RBRACE);

            $NBSP = 160;

            ScannerError = (function (_BaseException) {
                function ScannerError(message) {
                    _classCallCheck(this, ScannerError);

                    _get(Object.getPrototypeOf(ScannerError.prototype), "constructor", this).call(this);
                    this.message = message;
                }

                _inherits(ScannerError, _BaseException);

                _createClass(ScannerError, [{
                    key: "toString",
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return ScannerError;
            })(BaseException);

            _export("ScannerError", ScannerError);

            _Scanner = (function () {
                function _Scanner(input) {
                    _classCallCheck(this, _Scanner);

                    this.input = input;
                    this.length = input.length;
                    this.peek = 0;
                    this.index = -1;
                    this.advance();
                }

                _createClass(_Scanner, [{
                    key: "advance",
                    value: function advance() {
                        this.peek = ++this.index >= this.length ? $EOF : StringWrapper.charCodeAt(this.input, this.index);
                    }
                }, {
                    key: "scanToken",
                    value: function scanToken() {
                        var input = this.input,
                            length = this.length,
                            peek = this.peek,
                            index = this.index;
                        // Skip whitespace.
                        while (peek <= $SPACE) {
                            if (++index >= length) {
                                peek = $EOF;
                                break;
                            } else {
                                peek = StringWrapper.charCodeAt(input, index);
                            }
                        }
                        this.peek = peek;
                        this.index = index;
                        if (index >= length) {
                            return null;
                        }
                        // Handle identifiers and numbers.
                        if (isIdentifierStart(peek)) return this.scanIdentifier();
                        if (isDigit(peek)) return this.scanNumber(index);
                        var start = index;
                        switch (peek) {
                            case $PERIOD:
                                this.advance();
                                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
                            case $LPAREN:
                            case $RPAREN:
                            case $LBRACE:
                            case $RBRACE:
                            case $LBRACKET:
                            case $RBRACKET:
                            case $COMMA:
                            case $COLON:
                            case $SEMICOLON:
                                return this.scanCharacter(start, peek);
                            case $SQ:
                            case $DQ:
                                return this.scanString();
                            case $HASH:
                            case $PLUS:
                            case $MINUS:
                            case $STAR:
                            case $SLASH:
                            case $PERCENT:
                            case $CARET:
                                return this.scanOperator(start, StringWrapper.fromCharCode(peek));
                            case $QUESTION:
                                return this.scanComplexOperator(start, $PERIOD, "?", ".");
                            case $LT:
                            case $GT:
                            case $BANG:
                            case $EQ:
                                return this.scanComplexOperator(start, $EQ, StringWrapper.fromCharCode(peek), "=");
                            case $AMPERSAND:
                                return this.scanComplexOperator(start, $AMPERSAND, "&", "&");
                            case $BAR:
                                return this.scanComplexOperator(start, $BAR, "|", "|");
                            case $NBSP:
                                while (isWhitespace(this.peek)) this.advance();
                                return this.scanToken();
                        }
                        this.error("Unexpected character [" + StringWrapper.fromCharCode(peek) + "]", 0);
                        return null;
                    }
                }, {
                    key: "scanCharacter",
                    value: function scanCharacter(start, code) {
                        assert(this.peek == code);
                        this.advance();
                        return newCharacterToken(start, code);
                    }
                }, {
                    key: "scanOperator",
                    value: function scanOperator(start, str) {
                        assert(this.peek == StringWrapper.charCodeAt(str, 0));
                        assert(SetWrapper.has(OPERATORS, str));
                        this.advance();
                        return newOperatorToken(start, str);
                    }
                }, {
                    key: "scanComplexOperator",
                    value: function scanComplexOperator(start, code, one, two) {
                        assert(this.peek == StringWrapper.charCodeAt(one, 0));
                        this.advance();
                        var str = one;
                        while (this.peek == code) {
                            this.advance();
                            str += two;
                        }
                        assert(SetWrapper.has(OPERATORS, str));
                        return newOperatorToken(start, str);
                    }
                }, {
                    key: "scanIdentifier",
                    value: function scanIdentifier() {
                        assert(isIdentifierStart(this.peek));
                        var start = this.index;
                        this.advance();
                        while (isIdentifierPart(this.peek)) this.advance();
                        var str = this.input.substring(start, this.index);
                        if (SetWrapper.has(KEYWORDS, str)) {
                            return newKeywordToken(start, str);
                        } else {
                            return newIdentifierToken(start, str);
                        }
                    }
                }, {
                    key: "scanNumber",
                    value: function scanNumber(start) {
                        assert(isDigit(this.peek));
                        var simple = this.index === start;
                        this.advance(); // Skip initial digit.
                        while (true) {
                            if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
                                simple = false;
                            } else if (isExponentStart(this.peek)) {
                                this.advance();
                                if (isExponentSign(this.peek)) this.advance();
                                if (!isDigit(this.peek)) this.error("Invalid exponent", -1);
                                simple = false;
                            } else {
                                break;
                            }
                            this.advance();
                        }
                        var str = this.input.substring(start, this.index);
                        // TODO
                        var value = simple ? NumberWrapper.parseIntAutoRadix(str) : NumberWrapper.parseFloat(str);
                        return newNumberToken(start, value);
                    }
                }, {
                    key: "scanString",
                    value: function scanString() {
                        assert(this.peek == $SQ || this.peek == $DQ);
                        var start = this.index;
                        var quote = this.peek;
                        this.advance(); // Skip initial quote.
                        var buffer;
                        var marker = this.index;
                        var input = this.input;
                        while (this.peek != quote) {
                            if (this.peek == $BACKSLASH) {
                                if (buffer == null) buffer = new StringJoiner();
                                buffer.add(input.substring(marker, this.index));
                                this.advance();
                                var unescapedCode;
                                if (this.peek == $u) {
                                    // 4 character hex code for unicode character.
                                    var hex = input.substring(this.index + 1, this.index + 5);
                                    try {
                                        unescapedCode = NumberWrapper.parseInt(hex, 16);
                                    } catch (e) {
                                        this.error("Invalid unicode escape [\\u" + hex + "]", 0);
                                    }
                                    for (var i = 0; i < 5; i++) {
                                        this.advance();
                                    }
                                } else {
                                    unescapedCode = unescape(this.peek);
                                    this.advance();
                                }
                                buffer.add(StringWrapper.fromCharCode(unescapedCode));
                                marker = this.index;
                            } else if (this.peek == $EOF) {
                                this.error("Unterminated quote", 0);
                            } else {
                                this.advance();
                            }
                        }
                        var last = input.substring(marker, this.index);
                        this.advance(); // Skip terminating quote.
                        // Compute the unescaped string value.
                        var unescaped = last;
                        if (buffer != null) {
                            buffer.add(last);
                            unescaped = buffer.toString();
                        }
                        return newStringToken(start, unescaped);
                    }
                }, {
                    key: "error",
                    value: function error(message, offset) {
                        var position = this.index + offset;
                        throw new ScannerError("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
                    }
                }]);

                return _Scanner;
            })();

            OPERATORS = SetWrapper.createFromList(["+", "-", "*", "/", "%", "^", "=", "==", "!=", "===", "!==", "<", ">", "<=", ">=", "&&", "||", "&", "|", "!", "?", "#", "?."]);
            KEYWORDS = SetWrapper.createFromList(["var", "null", "undefined", "true", "false"]);

            
        }
    };
});
System.register("angular2/src/change_detection/parser/parser", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/di/decorators", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/lexer", "angular2/src/reflection/reflection", "angular2/src/change_detection/parser/ast"], function (_export) {
    var _createClass, _classCallCheck, Injectable, isBlank, isPresent, BaseException, StringWrapper, RegExpWrapper, ListWrapper, Lexer, EOF, $PERIOD, $COLON, $SEMICOLON, $LBRACKET, $RBRACKET, $COMMA, $LBRACE, $RBRACE, $LPAREN, $RPAREN, reflector, Reflector, EmptyExpr, ImplicitReceiver, AccessMember, SafeAccessMember, LiteralPrimitive, Binary, PrefixNot, Conditional, Pipe, Assignment, Chain, KeyedAccess, LiteralArray, LiteralMap, Interpolation, MethodCall, SafeMethodCall, FunctionCall, TemplateBinding, ASTWithSource, __decorate, __metadata, _implicitReceiver, INTERPOLATION_REGEXP, Parser, _ParseAST;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcDiDecorators) {
            Injectable = _angular2SrcDiDecorators.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcChange_detectionParserLexer) {
            Lexer = _angular2SrcChange_detectionParserLexer.Lexer;
            EOF = _angular2SrcChange_detectionParserLexer.EOF;
            $PERIOD = _angular2SrcChange_detectionParserLexer.$PERIOD;
            $COLON = _angular2SrcChange_detectionParserLexer.$COLON;
            $SEMICOLON = _angular2SrcChange_detectionParserLexer.$SEMICOLON;
            $LBRACKET = _angular2SrcChange_detectionParserLexer.$LBRACKET;
            $RBRACKET = _angular2SrcChange_detectionParserLexer.$RBRACKET;
            $COMMA = _angular2SrcChange_detectionParserLexer.$COMMA;
            $LBRACE = _angular2SrcChange_detectionParserLexer.$LBRACE;
            $RBRACE = _angular2SrcChange_detectionParserLexer.$RBRACE;
            $LPAREN = _angular2SrcChange_detectionParserLexer.$LPAREN;
            $RPAREN = _angular2SrcChange_detectionParserLexer.$RPAREN;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
            Reflector = _angular2SrcReflectionReflection.Reflector;
        }, function (_angular2SrcChange_detectionParserAst) {
            EmptyExpr = _angular2SrcChange_detectionParserAst.EmptyExpr;
            ImplicitReceiver = _angular2SrcChange_detectionParserAst.ImplicitReceiver;
            AccessMember = _angular2SrcChange_detectionParserAst.AccessMember;
            SafeAccessMember = _angular2SrcChange_detectionParserAst.SafeAccessMember;
            LiteralPrimitive = _angular2SrcChange_detectionParserAst.LiteralPrimitive;
            Binary = _angular2SrcChange_detectionParserAst.Binary;
            PrefixNot = _angular2SrcChange_detectionParserAst.PrefixNot;
            Conditional = _angular2SrcChange_detectionParserAst.Conditional;
            Pipe = _angular2SrcChange_detectionParserAst.Pipe;
            Assignment = _angular2SrcChange_detectionParserAst.Assignment;
            Chain = _angular2SrcChange_detectionParserAst.Chain;
            KeyedAccess = _angular2SrcChange_detectionParserAst.KeyedAccess;
            LiteralArray = _angular2SrcChange_detectionParserAst.LiteralArray;
            LiteralMap = _angular2SrcChange_detectionParserAst.LiteralMap;
            Interpolation = _angular2SrcChange_detectionParserAst.Interpolation;
            MethodCall = _angular2SrcChange_detectionParserAst.MethodCall;
            SafeMethodCall = _angular2SrcChange_detectionParserAst.SafeMethodCall;
            FunctionCall = _angular2SrcChange_detectionParserAst.FunctionCall;
            TemplateBinding = _angular2SrcChange_detectionParserAst.TemplateBinding;
            ASTWithSource = _angular2SrcChange_detectionParserAst.ASTWithSource;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _implicitReceiver = new ImplicitReceiver();

            // TODO(tbosch): Cannot make this const/final right now because of the transpiler...
            INTERPOLATION_REGEXP = RegExpWrapper.create("\\{\\{(.*?)\\}\\}");

            Parser = (function () {
                var _class = function Parser(lexer) {
                    var providedReflector = arguments[1] === undefined ? null : arguments[1];

                    _classCallCheck(this, _class);

                    this._lexer = lexer;
                    this._reflector = isPresent(providedReflector) ? providedReflector : reflector;
                };

                _createClass(_class, [{
                    key: "parseAction",
                    value: function parseAction(input, location) {
                        var tokens = this._lexer.tokenize(input);
                        var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
                        return new ASTWithSource(ast, input, location);
                    }
                }, {
                    key: "parseBinding",
                    value: function parseBinding(input, location) {
                        var tokens = this._lexer.tokenize(input);
                        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                        return new ASTWithSource(ast, input, location);
                    }
                }, {
                    key: "addPipes",
                    value: function addPipes(bindingAst, pipes) {
                        if (ListWrapper.isEmpty(pipes)) return bindingAst;
                        var res = ListWrapper.reduce(pipes, function (result, currentPipeName) {
                            return new Pipe(result, currentPipeName, [], false);
                        }, bindingAst.ast);
                        return new ASTWithSource(res, bindingAst.source, bindingAst.location);
                    }
                }, {
                    key: "parseTemplateBindings",
                    value: function parseTemplateBindings(input, location) {
                        var tokens = this._lexer.tokenize(input);
                        return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
                    }
                }, {
                    key: "parseInterpolation",
                    value: function parseInterpolation(input, location) {
                        var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
                        if (parts.length <= 1) {
                            return null;
                        }
                        var strings = [];
                        var expressions = [];
                        for (var i = 0; i < parts.length; i++) {
                            var part = parts[i];
                            if (i % 2 === 0) {
                                // fixed string
                                ListWrapper.push(strings, part);
                            } else {
                                var tokens = this._lexer.tokenize(part);
                                var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
                                ListWrapper.push(expressions, ast);
                            }
                        }
                        return new ASTWithSource(new Interpolation(strings, expressions), input, location);
                    }
                }, {
                    key: "wrapLiteralPrimitive",
                    value: function wrapLiteralPrimitive(input, location) {
                        return new ASTWithSource(new LiteralPrimitive(input), input, location);
                    }
                }]);

                return _class;
            })();

            _export("Parser", Parser);

            _export("Parser", Parser = __decorate([Injectable(), __metadata("design:paramtypes", [Lexer, Reflector])], Parser));

            _ParseAST = (function () {
                function _ParseAST(input, location, tokens, reflector, parseAction) {
                    _classCallCheck(this, _ParseAST);

                    this.input = input;
                    this.location = location;
                    this.tokens = tokens;
                    this.reflector = reflector;
                    this.parseAction = parseAction;
                    this.index = 0;
                }

                _createClass(_ParseAST, [{
                    key: "peek",
                    value: function peek(offset) {
                        var i = this.index + offset;
                        return i < this.tokens.length ? this.tokens[i] : EOF;
                    }
                }, {
                    key: "next",
                    get: function () {
                        return this.peek(0);
                    }
                }, {
                    key: "inputIndex",
                    get: function () {
                        return this.index < this.tokens.length ? this.next.index : this.input.length;
                    }
                }, {
                    key: "advance",
                    value: function advance() {
                        this.index++;
                    }
                }, {
                    key: "optionalCharacter",
                    value: function optionalCharacter(code) {
                        if (this.next.isCharacter(code)) {
                            this.advance();
                            return true;
                        } else {
                            return false;
                        }
                    }
                }, {
                    key: "optionalKeywordVar",
                    value: function optionalKeywordVar() {
                        if (this.peekKeywordVar()) {
                            this.advance();
                            return true;
                        } else {
                            return false;
                        }
                    }
                }, {
                    key: "peekKeywordVar",
                    value: function peekKeywordVar() {
                        return this.next.isKeywordVar() || this.next.isOperator("#");
                    }
                }, {
                    key: "expectCharacter",
                    value: function expectCharacter(code) {
                        if (this.optionalCharacter(code)) return;
                        this.error("Missing expected " + StringWrapper.fromCharCode(code));
                    }
                }, {
                    key: "optionalOperator",
                    value: function optionalOperator(op) {
                        if (this.next.isOperator(op)) {
                            this.advance();
                            return true;
                        } else {
                            return false;
                        }
                    }
                }, {
                    key: "expectOperator",
                    value: function expectOperator(operator) {
                        if (this.optionalOperator(operator)) return;
                        this.error("Missing expected operator " + operator);
                    }
                }, {
                    key: "expectIdentifierOrKeyword",
                    value: function expectIdentifierOrKeyword() {
                        var n = this.next;
                        if (!n.isIdentifier() && !n.isKeyword()) {
                            this.error("Unexpected token " + n + ", expected identifier or keyword");
                        }
                        this.advance();
                        return n.toString();
                    }
                }, {
                    key: "expectIdentifierOrKeywordOrString",
                    value: function expectIdentifierOrKeywordOrString() {
                        var n = this.next;
                        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
                            this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
                        }
                        this.advance();
                        return n.toString();
                    }
                }, {
                    key: "parseChain",
                    value: function parseChain() {
                        var exprs = [];
                        while (this.index < this.tokens.length) {
                            var expr = this.parsePipe();
                            ListWrapper.push(exprs, expr);
                            if (this.optionalCharacter($SEMICOLON)) {
                                if (!this.parseAction) {
                                    this.error("Binding expression cannot contain chained expression");
                                }
                                while (this.optionalCharacter($SEMICOLON)) {} // read all semicolons
                            } else if (this.index < this.tokens.length) {
                                this.error("Unexpected token '" + this.next + "'");
                            }
                        }
                        if (exprs.length == 0) return new EmptyExpr();
                        if (exprs.length == 1) return exprs[0];
                        return new Chain(exprs);
                    }
                }, {
                    key: "parsePipe",
                    value: function parsePipe() {
                        var result = this.parseExpression();
                        if (this.optionalOperator("|")) {
                            return this.parseInlinedPipe(result);
                        } else {
                            return result;
                        }
                    }
                }, {
                    key: "parseExpression",
                    value: function parseExpression() {
                        var start = this.inputIndex;
                        var result = this.parseConditional();
                        while (this.next.isOperator("=")) {
                            if (!result.isAssignable) {
                                var end = this.inputIndex;
                                var expression = this.input.substring(start, end);
                                this.error("Expression " + expression + " is not assignable");
                            }
                            if (!this.parseAction) {
                                this.error("Binding expression cannot contain assignments");
                            }
                            this.expectOperator("=");
                            result = new Assignment(result, this.parseConditional());
                        }
                        return result;
                    }
                }, {
                    key: "parseConditional",
                    value: function parseConditional() {
                        var start = this.inputIndex;
                        var result = this.parseLogicalOr();
                        if (this.optionalOperator("?")) {
                            var yes = this.parseExpression();
                            if (!this.optionalCharacter($COLON)) {
                                var end = this.inputIndex;
                                var expression = this.input.substring(start, end);
                                this.error("Conditional expression " + expression + " requires all 3 expressions");
                            }
                            var no = this.parseExpression();
                            return new Conditional(result, yes, no);
                        } else {
                            return result;
                        }
                    }
                }, {
                    key: "parseLogicalOr",
                    value: function parseLogicalOr() {
                        // '||'
                        var result = this.parseLogicalAnd();
                        while (this.optionalOperator("||")) {
                            result = new Binary("||", result, this.parseLogicalAnd());
                        }
                        return result;
                    }
                }, {
                    key: "parseLogicalAnd",
                    value: function parseLogicalAnd() {
                        // '&&'
                        var result = this.parseEquality();
                        while (this.optionalOperator("&&")) {
                            result = new Binary("&&", result, this.parseEquality());
                        }
                        return result;
                    }
                }, {
                    key: "parseEquality",
                    value: function parseEquality() {
                        // '==','!=','===','!=='
                        var result = this.parseRelational();
                        while (true) {
                            if (this.optionalOperator("==")) {
                                result = new Binary("==", result, this.parseRelational());
                            } else if (this.optionalOperator("===")) {
                                result = new Binary("===", result, this.parseRelational());
                            } else if (this.optionalOperator("!=")) {
                                result = new Binary("!=", result, this.parseRelational());
                            } else if (this.optionalOperator("!==")) {
                                result = new Binary("!==", result, this.parseRelational());
                            } else {
                                return result;
                            }
                        }
                    }
                }, {
                    key: "parseRelational",
                    value: function parseRelational() {
                        // '<', '>', '<=', '>='
                        var result = this.parseAdditive();
                        while (true) {
                            if (this.optionalOperator("<")) {
                                result = new Binary("<", result, this.parseAdditive());
                            } else if (this.optionalOperator(">")) {
                                result = new Binary(">", result, this.parseAdditive());
                            } else if (this.optionalOperator("<=")) {
                                result = new Binary("<=", result, this.parseAdditive());
                            } else if (this.optionalOperator(">=")) {
                                result = new Binary(">=", result, this.parseAdditive());
                            } else {
                                return result;
                            }
                        }
                    }
                }, {
                    key: "parseAdditive",
                    value: function parseAdditive() {
                        // '+', '-'
                        var result = this.parseMultiplicative();
                        while (true) {
                            if (this.optionalOperator("+")) {
                                result = new Binary("+", result, this.parseMultiplicative());
                            } else if (this.optionalOperator("-")) {
                                result = new Binary("-", result, this.parseMultiplicative());
                            } else {
                                return result;
                            }
                        }
                    }
                }, {
                    key: "parseMultiplicative",
                    value: function parseMultiplicative() {
                        // '*', '%', '/'
                        var result = this.parsePrefix();
                        while (true) {
                            if (this.optionalOperator("*")) {
                                result = new Binary("*", result, this.parsePrefix());
                            } else if (this.optionalOperator("%")) {
                                result = new Binary("%", result, this.parsePrefix());
                            } else if (this.optionalOperator("/")) {
                                result = new Binary("/", result, this.parsePrefix());
                            } else {
                                return result;
                            }
                        }
                    }
                }, {
                    key: "parsePrefix",
                    value: function parsePrefix() {
                        if (this.optionalOperator("+")) {
                            return this.parsePrefix();
                        } else if (this.optionalOperator("-")) {
                            return new Binary("-", new LiteralPrimitive(0), this.parsePrefix());
                        } else if (this.optionalOperator("!")) {
                            return new PrefixNot(this.parsePrefix());
                        } else {
                            return this.parseCallChain();
                        }
                    }
                }, {
                    key: "parseCallChain",
                    value: function parseCallChain() {
                        var result = this.parsePrimary();
                        while (true) {
                            if (this.optionalCharacter($PERIOD)) {
                                result = this.parseAccessMemberOrMethodCall(result, false);
                            } else if (this.optionalOperator("?.")) {
                                result = this.parseAccessMemberOrMethodCall(result, true);
                            } else if (this.optionalCharacter($LBRACKET)) {
                                var key = this.parseExpression();
                                this.expectCharacter($RBRACKET);
                                result = new KeyedAccess(result, key);
                            } else if (this.optionalCharacter($LPAREN)) {
                                var args = this.parseCallArguments();
                                this.expectCharacter($RPAREN);
                                result = new FunctionCall(result, args);
                            } else {
                                return result;
                            }
                        }
                    }
                }, {
                    key: "parsePrimary",
                    value: function parsePrimary() {
                        if (this.optionalCharacter($LPAREN)) {
                            var result = this.parsePipe();
                            this.expectCharacter($RPAREN);
                            return result;
                        } else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
                            this.advance();
                            return new LiteralPrimitive(null);
                        } else if (this.next.isKeywordTrue()) {
                            this.advance();
                            return new LiteralPrimitive(true);
                        } else if (this.next.isKeywordFalse()) {
                            this.advance();
                            return new LiteralPrimitive(false);
                        } else if (this.optionalCharacter($LBRACKET)) {
                            var elements = this.parseExpressionList($RBRACKET);
                            this.expectCharacter($RBRACKET);
                            return new LiteralArray(elements);
                        } else if (this.next.isCharacter($LBRACE)) {
                            return this.parseLiteralMap();
                        } else if (this.next.isIdentifier()) {
                            return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
                        } else if (this.next.isNumber()) {
                            var value = this.next.toNumber();
                            this.advance();
                            return new LiteralPrimitive(value);
                        } else if (this.next.isString()) {
                            var literalValue = this.next.toString();
                            this.advance();
                            return new LiteralPrimitive(literalValue);
                        } else if (this.index >= this.tokens.length) {
                            this.error("Unexpected end of expression: " + this.input);
                        } else {
                            this.error("Unexpected token " + this.next);
                        }
                    }
                }, {
                    key: "parseExpressionList",
                    value: function parseExpressionList(terminator) {
                        var result = [];
                        if (!this.next.isCharacter(terminator)) {
                            do {
                                ListWrapper.push(result, this.parseExpression());
                            } while (this.optionalCharacter($COMMA));
                        }
                        return result;
                    }
                }, {
                    key: "parseLiteralMap",
                    value: function parseLiteralMap() {
                        var keys = [];
                        var values = [];
                        this.expectCharacter($LBRACE);
                        if (!this.optionalCharacter($RBRACE)) {
                            do {
                                var key = this.expectIdentifierOrKeywordOrString();
                                ListWrapper.push(keys, key);
                                this.expectCharacter($COLON);
                                ListWrapper.push(values, this.parseExpression());
                            } while (this.optionalCharacter($COMMA));
                            this.expectCharacter($RBRACE);
                        }
                        return new LiteralMap(keys, values);
                    }
                }, {
                    key: "parseAccessMemberOrMethodCall",
                    value: function parseAccessMemberOrMethodCall(receiver) {
                        var isSafe = arguments[1] === undefined ? false : arguments[1];

                        var id = this.expectIdentifierOrKeyword();
                        if (this.optionalCharacter($LPAREN)) {
                            var args = this.parseCallArguments();
                            this.expectCharacter($RPAREN);
                            var fn = this.reflector.method(id);
                            return isSafe ? new SafeMethodCall(receiver, id, fn, args) : new MethodCall(receiver, id, fn, args);
                        } else {
                            var getter = this.reflector.getter(id);
                            var setter = this.reflector.setter(id);
                            var am = isSafe ? new SafeAccessMember(receiver, id, getter, setter) : new AccessMember(receiver, id, getter, setter);
                            if (this.optionalOperator("|")) {
                                return this.parseInlinedPipe(am);
                            } else {
                                return am;
                            }
                        }
                    }
                }, {
                    key: "parseInlinedPipe",
                    value: function parseInlinedPipe(result) {
                        do {
                            if (this.parseAction) {
                                this.error("Cannot have a pipe in an action expression");
                            }
                            var name = this.expectIdentifierOrKeyword();
                            var args = ListWrapper.create();
                            while (this.optionalCharacter($COLON)) {
                                ListWrapper.push(args, this.parseExpression());
                            }
                            result = new Pipe(result, name, args, true);
                        } while (this.optionalOperator("|"));
                        return result;
                    }
                }, {
                    key: "parseCallArguments",
                    value: function parseCallArguments() {
                        if (this.next.isCharacter($RPAREN)) return [];
                        var positionals = [];
                        do {
                            ListWrapper.push(positionals, this.parseExpression());
                        } while (this.optionalCharacter($COMMA));
                        return positionals;
                    }
                }, {
                    key: "expectTemplateBindingKey",

                    /**
                     * An identifier, a keyword, a string with an optional `-` inbetween.
                     */
                    value: function expectTemplateBindingKey() {
                        var result = "";
                        var operatorFound = false;
                        do {
                            result += this.expectIdentifierOrKeywordOrString();
                            operatorFound = this.optionalOperator("-");
                            if (operatorFound) {
                                result += "-";
                            }
                        } while (operatorFound);
                        return result.toString();
                    }
                }, {
                    key: "parseTemplateBindings",
                    value: function parseTemplateBindings() {
                        var bindings = [];
                        var prefix = null;
                        while (this.index < this.tokens.length) {
                            var keyIsVar = this.optionalKeywordVar();
                            var key = this.expectTemplateBindingKey();
                            if (!keyIsVar) {
                                if (prefix == null) {
                                    prefix = key;
                                } else {
                                    key = prefix + "-" + key;
                                }
                            }
                            this.optionalCharacter($COLON);
                            var name = null;
                            var expression = null;
                            if (this.next !== EOF) {
                                if (keyIsVar) {
                                    if (this.optionalOperator("=")) {
                                        name = this.expectTemplateBindingKey();
                                    } else {
                                        name = "$implicit";
                                    }
                                } else if (!this.peekKeywordVar()) {
                                    var start = this.inputIndex;
                                    var ast = this.parsePipe();
                                    var source = this.input.substring(start, this.inputIndex);
                                    expression = new ASTWithSource(ast, source, this.location);
                                }
                            }
                            ListWrapper.push(bindings, new TemplateBinding(key, keyIsVar, name, expression));
                            if (!this.optionalCharacter($SEMICOLON)) {
                                this.optionalCharacter($COMMA);
                            }
                        }
                        return bindings;
                    }
                }, {
                    key: "error",
                    value: function error(message) {
                        var index = arguments[1] === undefined ? null : arguments[1];

                        if (isBlank(index)) index = this.index;
                        var location = index < this.tokens.length ? "at column " + (this.tokens[index].index + 1) + " in" : "at the end of the expression";
                        throw new BaseException("Parser Error: " + message + " " + location + " [" + this.input + "] in " + this.location);
                    }
                }]);

                return _ParseAST;
            })();
        }
    };
});


System.register('angular2/src/change_detection/dynamic_change_detector', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/change_detection/abstract_change_detector', 'angular2/src/change_detection/change_detection_util', 'angular2/src/change_detection/proto_record', 'angular2/src/change_detection/exceptions'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, isPresent, isBlank, BaseException, FunctionWrapper, ListWrapper, AbstractChangeDetector, ChangeDetectionUtil, uninitialized, RECORD_TYPE_SELF, RECORD_TYPE_PROPERTY, RECORD_TYPE_LOCAL, RECORD_TYPE_INVOKE_METHOD, RECORD_TYPE_CONST, RECORD_TYPE_INVOKE_CLOSURE, RECORD_TYPE_PRIMITIVE_OP, RECORD_TYPE_KEYED_ACCESS, RECORD_TYPE_BINDING_PIPE, RECORD_TYPE_INTERPOLATE, RECORD_TYPE_SAFE_PROPERTY, RECORD_TYPE_SAFE_INVOKE_METHOD, ChangeDetectionError, DynamicChangeDetector;

    function isSame(a, b) {
        if (a === b) return true;
        if (a instanceof String && b instanceof String && a == b) return true;
        if (a !== a && b !== b) return true;
        return false;
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
            FunctionWrapper = _angular2SrcFacadeLang.FunctionWrapper;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcChange_detectionAbstract_change_detector) {
            AbstractChangeDetector = _angular2SrcChange_detectionAbstract_change_detector.AbstractChangeDetector;
        }, function (_angular2SrcChange_detectionChange_detection_util) {
            ChangeDetectionUtil = _angular2SrcChange_detectionChange_detection_util.ChangeDetectionUtil;
            uninitialized = _angular2SrcChange_detectionChange_detection_util.uninitialized;
        }, function (_angular2SrcChange_detectionProto_record) {
            RECORD_TYPE_SELF = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SELF;
            RECORD_TYPE_PROPERTY = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PROPERTY;
            RECORD_TYPE_LOCAL = _angular2SrcChange_detectionProto_record.RECORD_TYPE_LOCAL;
            RECORD_TYPE_INVOKE_METHOD = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INVOKE_METHOD;
            RECORD_TYPE_CONST = _angular2SrcChange_detectionProto_record.RECORD_TYPE_CONST;
            RECORD_TYPE_INVOKE_CLOSURE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INVOKE_CLOSURE;
            RECORD_TYPE_PRIMITIVE_OP = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PRIMITIVE_OP;
            RECORD_TYPE_KEYED_ACCESS = _angular2SrcChange_detectionProto_record.RECORD_TYPE_KEYED_ACCESS;
            RECORD_TYPE_BINDING_PIPE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_BINDING_PIPE;
            RECORD_TYPE_INTERPOLATE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INTERPOLATE;
            RECORD_TYPE_SAFE_PROPERTY = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SAFE_PROPERTY;
            RECORD_TYPE_SAFE_INVOKE_METHOD = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SAFE_INVOKE_METHOD;
        }, function (_angular2SrcChange_detectionExceptions) {
            ChangeDetectionError = _angular2SrcChange_detectionExceptions.ChangeDetectionError;
        }],
        execute: function () {
            'use strict';

            DynamicChangeDetector = (function (_AbstractChangeDetector) {
                function DynamicChangeDetector(changeControlStrategy, dispatcher, pipeRegistry, protos, directiveRecords) {
                    _classCallCheck(this, DynamicChangeDetector);

                    _get(Object.getPrototypeOf(DynamicChangeDetector.prototype), 'constructor', this).call(this);
                    this.changeControlStrategy = changeControlStrategy;
                    this.dispatcher = dispatcher;
                    this.pipeRegistry = pipeRegistry;
                    this.protos = protos;
                    this.directiveRecords = directiveRecords;
                    this.locals = null;
                    this.directives = null;
                    this.alreadyChecked = false;
                    this.values = ListWrapper.createFixedSize(protos.length + 1);
                    this.pipes = ListWrapper.createFixedSize(protos.length + 1);
                    this.prevContexts = ListWrapper.createFixedSize(protos.length + 1);
                    this.changes = ListWrapper.createFixedSize(protos.length + 1);
                    ListWrapper.fill(this.values, uninitialized);
                    ListWrapper.fill(this.pipes, null);
                    ListWrapper.fill(this.prevContexts, uninitialized);
                    ListWrapper.fill(this.changes, false);
                }

                _inherits(DynamicChangeDetector, _AbstractChangeDetector);

                _createClass(DynamicChangeDetector, [{
                    key: 'hydrate',
                    value: function hydrate(context, locals, directives) {
                        this.mode = ChangeDetectionUtil.changeDetectionMode(this.changeControlStrategy);
                        this.values[0] = context;
                        this.locals = locals;
                        this.directives = directives;
                        this.alreadyChecked = false;
                    }
                }, {
                    key: 'dehydrate',
                    value: function dehydrate() {
                        this._destroyPipes();
                        ListWrapper.fill(this.values, uninitialized);
                        ListWrapper.fill(this.changes, false);
                        ListWrapper.fill(this.pipes, null);
                        ListWrapper.fill(this.prevContexts, uninitialized);
                        this.locals = null;
                    }
                }, {
                    key: '_destroyPipes',
                    value: function _destroyPipes() {
                        for (var i = 0; i < this.pipes.length; ++i) {
                            if (isPresent(this.pipes[i])) {
                                this.pipes[i].onDestroy();
                            }
                        }
                    }
                }, {
                    key: 'hydrated',
                    value: function hydrated() {
                        return this.values[0] !== uninitialized;
                    }
                }, {
                    key: 'detectChangesInRecords',
                    value: function detectChangesInRecords(throwOnChange) {
                        var protos = this.protos;
                        var changes = null;
                        var isChanged = false;
                        for (var i = 0; i < protos.length; ++i) {
                            var proto = protos[i];
                            var bindingRecord = proto.bindingRecord;
                            var directiveRecord = bindingRecord.directiveRecord;
                            if (proto.isLifeCycleRecord()) {
                                if (proto.name === 'onCheck' && !throwOnChange) {
                                    this._getDirectiveFor(directiveRecord.directiveIndex).onCheck();
                                } else if (proto.name === 'onInit' && !throwOnChange && !this.alreadyChecked) {
                                    this._getDirectiveFor(directiveRecord.directiveIndex).onInit();
                                } else if (proto.name === 'onChange' && isPresent(changes) && !throwOnChange) {
                                    this._getDirectiveFor(directiveRecord.directiveIndex).onChange(changes);
                                }
                            } else {
                                var change = this._check(proto, throwOnChange);
                                if (isPresent(change)) {
                                    this._updateDirectiveOrElement(change, bindingRecord);
                                    isChanged = true;
                                    changes = this._addChange(bindingRecord, change, changes);
                                }
                            }
                            if (proto.lastInDirective) {
                                changes = null;
                                if (isChanged && bindingRecord.isOnPushChangeDetection()) {
                                    this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
                                }
                                isChanged = false;
                            }
                        }
                        this.alreadyChecked = true;
                    }
                }, {
                    key: 'callOnAllChangesDone',
                    value: function callOnAllChangesDone() {
                        var dirs = this.directiveRecords;
                        for (var i = dirs.length - 1; i >= 0; --i) {
                            var dir = dirs[i];
                            if (dir.callOnAllChangesDone) {
                                this._getDirectiveFor(dir.directiveIndex).onAllChangesDone();
                            }
                        }
                    }
                }, {
                    key: '_updateDirectiveOrElement',
                    value: function _updateDirectiveOrElement(change, bindingRecord) {
                        if (isBlank(bindingRecord.directiveRecord)) {
                            this.dispatcher.notifyOnBinding(bindingRecord, change.currentValue);
                        } else {
                            var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
                            bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
                        }
                    }
                }, {
                    key: '_addChange',
                    value: function _addChange(bindingRecord, change, changes) {
                        if (bindingRecord.callOnChange()) {
                            return ChangeDetectionUtil.addChange(changes, bindingRecord.propertyName, change);
                        } else {
                            return changes;
                        }
                    }
                }, {
                    key: '_getDirectiveFor',
                    value: function _getDirectiveFor(directiveIndex) {
                        return this.directives.getDirectiveFor(directiveIndex);
                    }
                }, {
                    key: '_getDetectorFor',
                    value: function _getDetectorFor(directiveIndex) {
                        return this.directives.getDetectorFor(directiveIndex);
                    }
                }, {
                    key: '_check',
                    value: function _check(proto, throwOnChange) {
                        try {
                            if (proto.isPipeRecord()) {
                                return this._pipeCheck(proto, throwOnChange);
                            } else {
                                return this._referenceCheck(proto, throwOnChange);
                            }
                        } catch (e) {
                            throw new ChangeDetectionError(proto, e);
                        }
                    }
                }, {
                    key: '_referenceCheck',
                    value: function _referenceCheck(proto, throwOnChange) {
                        if (this._pureFuncAndArgsDidNotChange(proto)) {
                            this._setChanged(proto, false);
                            return null;
                        }
                        var prevValue = this._readSelf(proto);
                        var currValue = this._calculateCurrValue(proto);
                        if (!isSame(prevValue, currValue)) {
                            if (proto.lastInBinding) {
                                var change = ChangeDetectionUtil.simpleChange(prevValue, currValue);
                                if (throwOnChange) ChangeDetectionUtil.throwOnChange(proto, change);
                                this._writeSelf(proto, currValue);
                                this._setChanged(proto, true);
                                return change;
                            } else {
                                this._writeSelf(proto, currValue);
                                this._setChanged(proto, true);
                                return null;
                            }
                        } else {
                            this._setChanged(proto, false);
                            return null;
                        }
                    }
                }, {
                    key: '_calculateCurrValue',
                    value: function _calculateCurrValue(proto) {
                        switch (proto.mode) {
                            case RECORD_TYPE_SELF:
                                return this._readContext(proto);
                            case RECORD_TYPE_CONST:
                                return proto.funcOrValue;
                            case RECORD_TYPE_PROPERTY:
                                var context = this._readContext(proto);
                                return proto.funcOrValue(context);
                            case RECORD_TYPE_SAFE_PROPERTY:
                                var context = this._readContext(proto);
                                return isBlank(context) ? null : proto.funcOrValue(context);
                            case RECORD_TYPE_LOCAL:
                                return this.locals.get(proto.name);
                            case RECORD_TYPE_INVOKE_METHOD:
                                var context = this._readContext(proto);
                                var args = this._readArgs(proto);
                                return proto.funcOrValue(context, args);
                            case RECORD_TYPE_SAFE_INVOKE_METHOD:
                                var context = this._readContext(proto);
                                if (isBlank(context)) {
                                    return null;
                                }
                                var args = this._readArgs(proto);
                                return proto.funcOrValue(context, args);
                            case RECORD_TYPE_KEYED_ACCESS:
                                var arg = this._readArgs(proto)[0];
                                return this._readContext(proto)[arg];
                            case RECORD_TYPE_INVOKE_CLOSURE:
                                return FunctionWrapper.apply(this._readContext(proto), this._readArgs(proto));
                            case RECORD_TYPE_INTERPOLATE:
                            case RECORD_TYPE_PRIMITIVE_OP:
                                return FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto));
                            default:
                                throw new BaseException('Unknown operation ' + proto.mode);
                        }
                    }
                }, {
                    key: '_pipeCheck',
                    value: function _pipeCheck(proto, throwOnChange) {
                        var context = this._readContext(proto);
                        var pipe = this._pipeFor(proto, context);
                        var prevValue = this._readSelf(proto);
                        var currValue = pipe.transform(context);
                        if (!isSame(prevValue, currValue)) {
                            currValue = ChangeDetectionUtil.unwrapValue(currValue);
                            if (proto.lastInBinding) {
                                var change = ChangeDetectionUtil.simpleChange(prevValue, currValue);
                                if (throwOnChange) ChangeDetectionUtil.throwOnChange(proto, change);
                                this._writeSelf(proto, currValue);
                                this._setChanged(proto, true);
                                return change;
                            } else {
                                this._writeSelf(proto, currValue);
                                this._setChanged(proto, true);
                                return null;
                            }
                        } else {
                            this._setChanged(proto, false);
                            return null;
                        }
                    }
                }, {
                    key: '_pipeFor',
                    value: function _pipeFor(proto, context) {
                        var storedPipe = this._readPipe(proto);
                        if (isPresent(storedPipe) && storedPipe.supports(context)) {
                            return storedPipe;
                        }
                        if (isPresent(storedPipe)) {
                            storedPipe.onDestroy();
                        }
                        // Currently, only pipes that used in bindings in the template get
                        // the changeDetectorRef of the encompassing component.
                        //
                        // In the future, pipes declared in the bind configuration should
                        // be able to access the changeDetectorRef of that component.
                        var cdr = proto.mode === RECORD_TYPE_BINDING_PIPE ? this.ref : null;
                        var pipe = this.pipeRegistry.get(proto.name, context, cdr);
                        this._writePipe(proto, pipe);
                        return pipe;
                    }
                }, {
                    key: '_readContext',
                    value: function _readContext(proto) {
                        if (proto.contextIndex == -1) {
                            return this._getDirectiveFor(proto.directiveIndex);
                        } else {
                            return this.values[proto.contextIndex];
                        }
                        return this.values[proto.contextIndex];
                    }
                }, {
                    key: '_readSelf',
                    value: function _readSelf(proto) {
                        return this.values[proto.selfIndex];
                    }
                }, {
                    key: '_writeSelf',
                    value: function _writeSelf(proto, value) {
                        this.values[proto.selfIndex] = value;
                    }
                }, {
                    key: '_readPipe',
                    value: function _readPipe(proto) {
                        return this.pipes[proto.selfIndex];
                    }
                }, {
                    key: '_writePipe',
                    value: function _writePipe(proto, value) {
                        this.pipes[proto.selfIndex] = value;
                    }
                }, {
                    key: '_setChanged',
                    value: function _setChanged(proto, value) {
                        this.changes[proto.selfIndex] = value;
                    }
                }, {
                    key: '_pureFuncAndArgsDidNotChange',
                    value: function _pureFuncAndArgsDidNotChange(proto) {
                        return proto.isPureFunction() && !this._argsChanged(proto);
                    }
                }, {
                    key: '_argsChanged',
                    value: function _argsChanged(proto) {
                        var args = proto.args;
                        for (var i = 0; i < args.length; ++i) {
                            if (this.changes[args[i]]) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: '_readArgs',
                    value: function _readArgs(proto) {
                        var res = ListWrapper.createFixedSize(proto.args.length);
                        var args = proto.args;
                        for (var i = 0; i < args.length; ++i) {
                            res[i] = this.values[args[i]];
                        }
                        return res;
                    }
                }]);

                return DynamicChangeDetector;
            })(AbstractChangeDetector);

            _export('DynamicChangeDetector', DynamicChangeDetector);
        }
    };
});
System.register("angular2/src/di/binding", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection", "angular2/src/di/key", "angular2/src/di/annotations_impl", "angular2/src/di/exceptions", "angular2/src/di/forward_ref"], function (_export) {
    var _createClass, _classCallCheck, Type, isBlank, isPresent, CONST, BaseException, stringify, ListWrapper, reflector, Key, Inject, InjectLazy, InjectPromise, Optional, DependencyAnnotation, NoAnnotationError, resolveForwardRef, __decorate, __metadata, Dependency, _EMPTY_LIST, Binding, ResolvedBinding, BindingBuilder;

    /**
     * Provides an API for imperatively constructing {@link Binding}s.
     *
     * This is only relevant for JavaScript. See {@link BindingBuilder}.
     *
     * ## Example
     *
     * ```javascript
     * bind(MyInterface).toClass(MyClass)
     *
     * ```
     *
     * @exportedAs angular2/di
     */

    function bind(token) {
        return new BindingBuilder(token);
    }

    function _constructDependencies(factoryFunction, dependencies) {
        return isBlank(dependencies) ? _dependenciesFor(factoryFunction) : ListWrapper.map(dependencies, function (t) {
            return _extractToken(factoryFunction, t);
        });
    }
    function _dependenciesFor(typeOrFunc) {
        var params = reflector.parameters(typeOrFunc);
        if (isBlank(params)) return [];
        if (ListWrapper.any(params, function (p) {
            return isBlank(p);
        })) {
            throw new NoAnnotationError(typeOrFunc);
        }
        return ListWrapper.map(params, function (p) {
            return _extractToken(typeOrFunc, p);
        });
    }
    function _extractToken(typeOrFunc, annotations) {
        var depProps = [];
        var token = null;
        var optional = false;
        var lazy = false;
        var asPromise = false;
        if (!ListWrapper.isList(annotations)) {
            return _createDependency(annotations, asPromise, lazy, optional, depProps);
        }
        for (var i = 0; i < annotations.length; ++i) {
            var paramAnnotation = annotations[i];
            if (paramAnnotation instanceof Type) {
                token = paramAnnotation;
            } else if (paramAnnotation instanceof Inject) {
                token = paramAnnotation.token;
            } else if (paramAnnotation instanceof InjectPromise) {
                token = paramAnnotation.token;
                asPromise = true;
            } else if (paramAnnotation instanceof InjectLazy) {
                token = paramAnnotation.token;
                lazy = true;
            } else if (paramAnnotation instanceof Optional) {
                optional = true;
            } else if (paramAnnotation instanceof DependencyAnnotation) {
                if (isPresent(paramAnnotation.token)) {
                    token = paramAnnotation.token;
                }
                ListWrapper.push(depProps, paramAnnotation);
            }
        }
        token = resolveForwardRef(token);
        if (isPresent(token)) {
            return _createDependency(token, asPromise, lazy, optional, depProps);
        } else {
            throw new NoAnnotationError(typeOrFunc);
        }
    }
    function _createDependency(token, asPromise, lazy, optional, depProps) {
        return new Dependency(Key.get(token), asPromise, lazy, optional, depProps);
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            Type = _angular2SrcFacadeLang.Type;
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            CONST = _angular2SrcFacadeLang.CONST;
            BaseException = _angular2SrcFacadeLang.BaseException;
            stringify = _angular2SrcFacadeLang.stringify;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
        }, function (_angular2SrcDiKey) {
            Key = _angular2SrcDiKey.Key;
        }, function (_angular2SrcDiAnnotations_impl) {
            Inject = _angular2SrcDiAnnotations_impl.Inject;
            InjectLazy = _angular2SrcDiAnnotations_impl.InjectLazy;
            InjectPromise = _angular2SrcDiAnnotations_impl.InjectPromise;
            Optional = _angular2SrcDiAnnotations_impl.Optional;
            DependencyAnnotation = _angular2SrcDiAnnotations_impl.DependencyAnnotation;
        }, function (_angular2SrcDiExceptions) {
            NoAnnotationError = _angular2SrcDiExceptions.NoAnnotationError;
        }, function (_angular2SrcDiForward_ref) {
            resolveForwardRef = _angular2SrcDiForward_ref.resolveForwardRef;
        }],
        execute: function () {
            "use strict";

            _export("bind", bind);

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * @private
             */

            Dependency = (function () {
                function Dependency(key, asPromise, lazy, optional, properties) {
                    _classCallCheck(this, Dependency);

                    this.key = key;
                    this.asPromise = asPromise;
                    this.lazy = lazy;
                    this.optional = optional;
                    this.properties = properties;
                }

                _createClass(Dependency, null, [{
                    key: "fromKey",
                    value: function fromKey(key) {
                        return new Dependency(key, false, false, false, []);
                    }
                }]);

                return Dependency;
            })();

            _export("Dependency", Dependency);

            _EMPTY_LIST = [];
            // TODO: make const when supported
            /**
             * Describes how the {@link Injector} should instantiate a given token.
             *
             * See {@link bind}.
             *
             * ## Example
             *
             * ```javascript
             * var injector = Injector.resolveAndCreate([
             *   new Binding(String, { toValue: 'Hello' })
             * ]);
             *
             * expect(injector.get(String)).toEqual('Hello');
             * ```
             *
             * @exportedAs angular2/di
             */

            Binding = (function () {
                var _class = function Binding(token, _ref) {
                    var toClass = _ref.toClass;
                    var toValue = _ref.toValue;
                    var toAlias = _ref.toAlias;
                    var toFactory = _ref.toFactory;
                    var toAsyncFactory = _ref.toAsyncFactory;
                    var deps = _ref.deps;

                    _classCallCheck(this, _class);

                    this.token = token;
                    this.toClass = toClass;
                    this.toValue = toValue;
                    this.toAlias = toAlias;
                    this.toFactory = toFactory;
                    this.toAsyncFactory = toAsyncFactory;
                    this.dependencies = deps;
                };

                _createClass(_class, [{
                    key: "resolve",

                    /**
                     * Converts the {@link Binding} into {@link ResolvedBinding}.
                     *
                     * {@link Injector} internally only uses {@link ResolvedBinding}, {@link Binding} contains
                     * convenience binding syntax.
                     */
                    value: function resolve() {
                        var _this = this;

                        var factoryFn;
                        var resolvedDeps;
                        var isAsync = false;
                        if (isPresent(this.toClass)) {
                            var toClass = resolveForwardRef(this.toClass);
                            factoryFn = reflector.factory(toClass);
                            resolvedDeps = _dependenciesFor(toClass);
                        } else if (isPresent(this.toAlias)) {
                            factoryFn = function (aliasInstance) {
                                return aliasInstance;
                            };
                            resolvedDeps = [Dependency.fromKey(Key.get(this.toAlias))];
                        } else if (isPresent(this.toFactory)) {
                            factoryFn = this.toFactory;
                            resolvedDeps = _constructDependencies(this.toFactory, this.dependencies);
                        } else if (isPresent(this.toAsyncFactory)) {
                            factoryFn = this.toAsyncFactory;
                            resolvedDeps = _constructDependencies(this.toAsyncFactory, this.dependencies);
                            isAsync = true;
                        } else {
                            factoryFn = function () {
                                return _this.toValue;
                            };
                            resolvedDeps = _EMPTY_LIST;
                        }
                        return new ResolvedBinding(Key.get(this.token), factoryFn, resolvedDeps, isAsync);
                    }
                }]);

                return _class;
            })();

            _export("Binding", Binding);

            _export("Binding", Binding = __decorate([CONST(), __metadata("design:paramtypes", [Object, Object])], Binding));
            /**
             * An internal resolved representation of a {@link Binding} used by the {@link Injector}.
             *
             * A {@link Binding} is resolved when it has a factory function. Binding to a class, alias, or
             * value, are just convenience methods, as {@link Injector} only operates on calling factory
             * functions.
             *
             * @exportedAs angular2/di
             */

            ResolvedBinding = function ResolvedBinding(
            /**
             * A key, usually a `Type`.
             */
            key,
            /**
             * Factory function which can return an instance of an object represented by a key.
             */
            factory,
            /**
             * Arguments (dependencies) to the `factory` function.
             */
            dependencies,
            /**
             * Specifies whether the `factory` function returns a `Promise`.
             */
            providedAsPromise) {
                _classCallCheck(this, ResolvedBinding);

                this.key = key;
                this.factory = factory;
                this.dependencies = dependencies;
                this.providedAsPromise = providedAsPromise;
            };

            _export("ResolvedBinding", ResolvedBinding);

            /**
             * Helper class for the {@link bind} function.
             *
             * @exportedAs angular2/di
             */

            BindingBuilder = (function () {
                function BindingBuilder(token) {
                    _classCallCheck(this, BindingBuilder);

                    this.token = token;
                }

                _createClass(BindingBuilder, [{
                    key: "toClass",

                    /**
                     * Binds an interface to an implementation / subclass.
                     *
                     * ## Example
                     *
                     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
                     * easy comparison.
                     *
                     * ```javascript
                     *
                     * class Vehicle {}
                     *
                     * class Car extends Vehicle {}
                     *
                     * var injectorClass = Injector.resolveAndCreate([
                     *   Car,
                     *   bind(Vehicle).toClass(Car)
                     * ]);
                     * var injectorAlias = Injector.resolveAndCreate([
                     *   Car,
                     *   bind(Vehicle).toAlias(Car)
                     * ]);
                     *
                     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
                     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
                     *
                     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
                     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
                     * ```
                     */
                    value: function toClass(type) {
                        return new Binding(this.token, { toClass: type });
                    }
                }, {
                    key: "toValue",

                    /**
                     * Binds a key to a value.
                     *
                     * ## Example
                     *
                     * ```javascript
                     * var injector = Injector.resolveAndCreate([
                     *   bind(String).toValue('Hello')
                     * ]);
                     *
                     * expect(injector.get(String)).toEqual('Hello');
                     * ```
                     */
                    value: function toValue(value) {
                        return new Binding(this.token, { toValue: value });
                    }
                }, {
                    key: "toAlias",

                    /**
                     * Binds a key to the alias for an existing key.
                     *
                     * An alias means that we will return the same instance as if the alias token was used. (This is
                     * in contrast to `toClass` where a separet instance of `toClass` will be returned.)
                     *
                     * ## Example
                     *
                     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy
                     * comparison.
                     *
                     * ```javascript
                     *
                     * class Vehicle {}
                     *
                     * class Car extends Vehicle {}
                     *
                     * var injectorAlias = Injector.resolveAndCreate([
                     *   Car,
                     *   bind(Vehicle).toAlias(Car)
                     * ]);
                     * var injectorClass = Injector.resolveAndCreate([
                     *   Car,
                     *   bind(Vehicle).toClass(Car)
                     * ]);
                     *
                     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
                     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
                     *
                     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
                     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
                     * ```
                     */
                    value: function toAlias(aliasToken) {
                        if (isBlank(aliasToken)) {
                            throw new BaseException("Can not alias " + stringify(this.token) + " to a blank value!");
                        }
                        return new Binding(this.token, { toAlias: aliasToken });
                    }
                }, {
                    key: "toFactory",

                    /**
                     * Binds a key to a function which computes the value.
                     *
                     * ## Example
                     *
                     * ```javascript
                     * var injector = Injector.resolveAndCreate([
                     *   bind(Number).toFactory(() => { return 1+2; }),
                     *   bind(String).toFactory((v) => { return "Value: " + v; }, [Number])
                     * ]);
                     *
                     * expect(injector.get(Number)).toEqual(3);
                     * expect(injector.get(String)).toEqual('Value: 3');
                     * ```
                     */
                    value: function toFactory(factoryFunction, dependencies) {
                        return new Binding(this.token, { toFactory: factoryFunction, deps: dependencies });
                    }
                }, {
                    key: "toAsyncFactory",

                    /**
                     * Binds a key to a function which computes the value asynchronously.
                     *
                     * ## Example
                     *
                     * ```javascript
                     * var injector = Injector.resolveAndCreate([
                     *   bind(Number).toAsyncFactory(() => {
                     *     return new Promise((resolve) => resolve(1 + 2));
                     *   }),
                     *   bind(String).toFactory((v) => { return "Value: " + v; }, [Number])
                     * ]);
                     *
                     * injector.asyncGet(Number).then((v) => expect(v).toBe(3));
                     * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));
                     * ```
                     *
                     * The interesting thing to note is that event though `Number` has an async factory, the `String`
                     * factory function takes the resolved value. This shows that the {@link Injector} delays
                     * executing of the `String` factory
                     * until after the `Number` is resolved. This can only be done if the `token` is retrieved using
                     * the `asyncGet` API in the {@link Injector}.
                     */
                    value: function toAsyncFactory(factoryFunction, dependencies) {
                        return new Binding(this.token, { toAsyncFactory: factoryFunction, deps: dependencies });
                    }
                }]);

                return BindingBuilder;
            })();

            _export("BindingBuilder", BindingBuilder);
        }
    };
});
System.register("angular2/src/core/compiler/view_manager_utils", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/collection", "angular2/src/core/compiler/element_injector", "angular2/src/facade/lang", "angular2/src/core/compiler/view", "angular2/src/core/compiler/directive_resolver"], function (_export) {
    var _createClass, _classCallCheck, Injectable, ListWrapper, eli, isPresent, isBlank, BaseException, viewModule, DirectiveResolver, __decorate, __metadata, AppViewManagerUtils;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            eli = _angular2SrcCoreCompilerElement_injector;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcCoreCompilerView) {
            viewModule = _angular2SrcCoreCompilerView;
        }, function (_angular2SrcCoreCompilerDirective_resolver) {
            DirectiveResolver = _angular2SrcCoreCompilerDirective_resolver.DirectiveResolver;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            AppViewManagerUtils = (function () {
                var _class = function AppViewManagerUtils(metadataReader) {
                    _classCallCheck(this, _class);

                    this._directiveResolver = metadataReader;
                };

                _createClass(_class, [{
                    key: "getComponentInstance",
                    value: function getComponentInstance(parentView, boundElementIndex) {
                        var binder = parentView.proto.elementBinders[boundElementIndex];
                        var eli = parentView.elementInjectors[boundElementIndex];
                        if (binder.hasDynamicComponent()) {
                            return eli.getDynamicallyLoadedComponent();
                        } else {
                            return eli.getComponent();
                        }
                    }
                }, {
                    key: "createView",
                    value: function createView(protoView, renderView, viewManager, renderer) {
                        var view = new viewModule.AppView(renderer, protoView, protoView.protoLocals);
                        // TODO(tbosch): pass RenderViewRef as argument to AppView!
                        view.render = renderView;
                        var changeDetector = protoView.protoChangeDetector.instantiate(view);
                        var binders = protoView.elementBinders;
                        var elementInjectors = ListWrapper.createFixedSize(binders.length);
                        var rootElementInjectors = [];
                        var preBuiltObjects = ListWrapper.createFixedSize(binders.length);
                        var componentChildViews = ListWrapper.createFixedSize(binders.length);
                        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                            var binder = binders[binderIdx];
                            var elementInjector = null;
                            // elementInjectors and rootElementInjectors
                            var protoElementInjector = binder.protoElementInjector;
                            if (isPresent(protoElementInjector)) {
                                if (isPresent(protoElementInjector.parent)) {
                                    var parentElementInjector = elementInjectors[protoElementInjector.parent.index];
                                    elementInjector = protoElementInjector.instantiate(parentElementInjector);
                                } else {
                                    elementInjector = protoElementInjector.instantiate(null);
                                    ListWrapper.push(rootElementInjectors, elementInjector);
                                }
                            }
                            elementInjectors[binderIdx] = elementInjector;
                            // preBuiltObjects
                            if (isPresent(elementInjector)) {
                                var embeddedProtoView = binder.hasEmbeddedProtoView() ? binder.nestedProtoView : null;
                                preBuiltObjects[binderIdx] = new eli.PreBuiltObjects(viewManager, view, embeddedProtoView);
                            }
                        }
                        view.init(changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, componentChildViews);
                        return view;
                    }
                }, {
                    key: "attachComponentView",
                    value: function attachComponentView(hostView, boundElementIndex, componentView) {
                        var childChangeDetector = componentView.changeDetector;
                        hostView.changeDetector.addShadowDomChild(childChangeDetector);
                        hostView.componentChildViews[boundElementIndex] = componentView;
                    }
                }, {
                    key: "detachComponentView",
                    value: function detachComponentView(hostView, boundElementIndex) {
                        var componentView = hostView.componentChildViews[boundElementIndex];
                        hostView.changeDetector.removeShadowDomChild(componentView.changeDetector);
                        hostView.componentChildViews[boundElementIndex] = null;
                    }
                }, {
                    key: "hydrateComponentView",
                    value: function hydrateComponentView(hostView, boundElementIndex) {
                        var injector = arguments[2] === undefined ? null : arguments[2];

                        var elementInjector = hostView.elementInjectors[boundElementIndex];
                        var componentView = hostView.componentChildViews[boundElementIndex];
                        var component = this.getComponentInstance(hostView, boundElementIndex);
                        this._hydrateView(componentView, injector, elementInjector, component, null);
                    }
                }, {
                    key: "hydrateRootHostView",
                    value: function hydrateRootHostView(hostView) {
                        var injector = arguments[1] === undefined ? null : arguments[1];

                        this._hydrateView(hostView, injector, null, new Object(), null);
                    }
                }, {
                    key: "attachAndHydrateFreeHostView",
                    value: function attachAndHydrateFreeHostView(parentComponentHostView, parentComponentBoundElementIndex, hostView) {
                        var injector = arguments[3] === undefined ? null : arguments[3];

                        var hostElementInjector = parentComponentHostView.elementInjectors[parentComponentBoundElementIndex];
                        var parentView = parentComponentHostView.componentChildViews[parentComponentBoundElementIndex];
                        parentView.changeDetector.addChild(hostView.changeDetector);
                        ListWrapper.push(parentView.freeHostViews, hostView);
                        this._hydrateView(hostView, injector, hostElementInjector, new Object(), null);
                    }
                }, {
                    key: "detachFreeHostView",
                    value: function detachFreeHostView(parentView, hostView) {
                        parentView.changeDetector.removeChild(hostView.changeDetector);
                        ListWrapper.remove(parentView.freeHostViews, hostView);
                    }
                }, {
                    key: "attachViewInContainer",
                    value: function attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view) {
                        if (isBlank(contextView)) {
                            contextView = parentView;
                            contextBoundElementIndex = boundElementIndex;
                        }
                        parentView.changeDetector.addChild(view.changeDetector);
                        var viewContainer = parentView.viewContainers[boundElementIndex];
                        if (isBlank(viewContainer)) {
                            viewContainer = new viewModule.AppViewContainer();
                            parentView.viewContainers[boundElementIndex] = viewContainer;
                        }
                        ListWrapper.insert(viewContainer.views, atIndex, view);
                        var sibling;
                        if (atIndex == 0) {
                            sibling = null;
                        } else {
                            sibling = ListWrapper.last(viewContainer.views[atIndex - 1].rootElementInjectors);
                        }
                        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
                        for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
                            view.rootElementInjectors[i].linkAfter(elementInjector, sibling);
                        }
                    }
                }, {
                    key: "detachViewInContainer",
                    value: function detachViewInContainer(parentView, boundElementIndex, atIndex) {
                        var viewContainer = parentView.viewContainers[boundElementIndex];
                        var view = viewContainer.views[atIndex];
                        view.changeDetector.remove();
                        ListWrapper.removeAt(viewContainer.views, atIndex);
                        for (var i = 0; i < view.rootElementInjectors.length; ++i) {
                            view.rootElementInjectors[i].unlink();
                        }
                    }
                }, {
                    key: "hydrateViewInContainer",
                    value: function hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, injector) {
                        if (isBlank(contextView)) {
                            contextView = parentView;
                            contextBoundElementIndex = boundElementIndex;
                        }
                        var viewContainer = parentView.viewContainers[boundElementIndex];
                        var view = viewContainer.views[atIndex];
                        var elementInjector = contextView.elementInjectors[contextBoundElementIndex].getHost();
                        this._hydrateView(view, injector, elementInjector, contextView.context, contextView.locals);
                    }
                }, {
                    key: "hydrateDynamicComponentInElementInjector",
                    value: function hydrateDynamicComponentInElementInjector(hostView, boundElementIndex, componentBinding) {
                        var injector = arguments[3] === undefined ? null : arguments[3];

                        var elementInjector = hostView.elementInjectors[boundElementIndex];
                        if (isPresent(elementInjector.getDynamicallyLoadedComponent())) {
                            throw new BaseException("There already is a dynamic component loaded at element " + boundElementIndex);
                        }
                        if (isBlank(injector)) {
                            injector = elementInjector.getLightDomAppInjector();
                        }
                        var annotation = this._directiveResolver.resolve(componentBinding.token);
                        var componentDirective = eli.DirectiveBinding.createFromBinding(componentBinding, annotation);
                        elementInjector.dynamicallyCreateComponent(componentDirective, injector);
                    }
                }, {
                    key: "_hydrateView",
                    value: function _hydrateView(view, appInjector, hostElementInjector, context, parentLocals) {
                        if (isBlank(appInjector)) {
                            appInjector = hostElementInjector.getShadowDomAppInjector();
                        }
                        if (isBlank(appInjector)) {
                            appInjector = hostElementInjector.getLightDomAppInjector();
                        }
                        view.context = context;
                        view.locals.parent = parentLocals;
                        var binders = view.proto.elementBinders;
                        for (var i = 0; i < binders.length; ++i) {
                            var elementInjector = view.elementInjectors[i];
                            if (isPresent(elementInjector)) {
                                elementInjector.hydrate(appInjector, hostElementInjector, view.preBuiltObjects[i]);
                                this._setUpEventEmitters(view, elementInjector, i);
                                this._setUpHostActions(view, elementInjector, i);
                                // The exporting of $implicit is a special case. Since multiple elements will all export
                                // the different values as $implicit, directly assign $implicit bindings to the variable
                                // name.
                                var exportImplicitName = elementInjector.getExportImplicitName();
                                if (elementInjector.isExportingComponent()) {
                                    view.locals.set(exportImplicitName, elementInjector.getComponent());
                                } else if (elementInjector.isExportingElement()) {
                                    view.locals.set(exportImplicitName, elementInjector.getElementRef().domElement);
                                }
                            }
                        }
                        view.changeDetector.hydrate(view.context, view.locals, view);
                    }
                }, {
                    key: "_setUpEventEmitters",
                    value: function _setUpEventEmitters(view, elementInjector, boundElementIndex) {
                        var emitters = elementInjector.getEventEmitterAccessors();
                        for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
                            var directiveEmitters = emitters[directiveIndex];
                            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
                            for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
                                var eventEmitterAccessor = directiveEmitters[eventIndex];
                                eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
                            }
                        }
                    }
                }, {
                    key: "_setUpHostActions",
                    value: function _setUpHostActions(view, elementInjector, boundElementIndex) {
                        var hostActions = elementInjector.getHostActionAccessors();
                        for (var directiveIndex = 0; directiveIndex < hostActions.length; ++directiveIndex) {
                            var directiveHostActions = hostActions[directiveIndex];
                            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
                            for (var index = 0; index < directiveHostActions.length; ++index) {
                                var hostActionAccessor = directiveHostActions[index];
                                hostActionAccessor.subscribe(view, boundElementIndex, directive);
                            }
                        }
                    }
                }, {
                    key: "dehydrateView",
                    value: function dehydrateView(view) {
                        var binders = view.proto.elementBinders;
                        for (var i = 0; i < binders.length; ++i) {
                            var elementInjector = view.elementInjectors[i];
                            if (isPresent(elementInjector)) {
                                elementInjector.dehydrate();
                            }
                        }
                        if (isPresent(view.locals)) {
                            view.locals.clearValues();
                        }
                        view.context = null;
                        view.changeDetector.dehydrate();
                    }
                }]);

                return _class;
            })();

            _export("AppViewManagerUtils", AppViewManagerUtils);

            _export("AppViewManagerUtils", AppViewManagerUtils = __decorate([Injectable(), __metadata("design:paramtypes", [DirectiveResolver])], AppViewManagerUtils));
            
        }
    };
});
System.register('angular2/src/core/compiler/base_query_list', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/core-js/symbol/iterator', 'npm:babel-runtime@5.4.7/core-js/get-iterator', 'angular2/src/facade/collection'], function (_export) {
    var _createClass, _classCallCheck, _Symbol$iterator, _getIterator, ListWrapper, BaseQueryList;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547CoreJsSymbolIterator) {
            _Symbol$iterator = _npmBabelRuntime547CoreJsSymbolIterator['default'];
        }, function (_npmBabelRuntime547CoreJsGetIterator) {
            _getIterator = _npmBabelRuntime547CoreJsGetIterator['default'];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            'use strict';

            /**
             * Injectable Objects that contains a live list of child directives in the light Dom of a directive.
             * The directives are kept in depth-first pre-order traversal of the DOM.
             *
             * In the future this class will implement an Observable interface.
             * For now it uses a plain list of observable callbacks.
             *
             * @exportedAs angular2/view
             */

            BaseQueryList = (function () {
                function BaseQueryList() {
                    _classCallCheck(this, BaseQueryList);

                    this._results = [];
                    this._callbacks = [];
                    this._dirty = false;
                }

                _createClass(BaseQueryList, [{
                    key: _Symbol$iterator,
                    value: function () {
                        return _getIterator(this._results);
                    }
                }, {
                    key: 'reset',
                    value: function reset(newList) {
                        this._results = newList;
                        this._dirty = true;
                    }
                }, {
                    key: 'add',
                    value: function add(obj) {
                        ListWrapper.push(this._results, obj);
                        this._dirty = true;
                    }
                }, {
                    key: 'fireCallbacks',

                    // TODO(rado): hook up with change detection after #995.
                    value: function fireCallbacks() {
                        if (this._dirty) {
                            ListWrapper.forEach(this._callbacks, function (c) {
                                return c();
                            });
                            this._dirty = false;
                        }
                    }
                }, {
                    key: 'onChange',
                    value: function onChange(callback) {
                        ListWrapper.push(this._callbacks, callback);
                    }
                }, {
                    key: 'removeCallback',
                    value: function removeCallback(callback) {
                        ListWrapper.remove(this._callbacks, callback);
                    }
                }]);

                return BaseQueryList;
            })();

            _export('BaseQueryList', BaseQueryList);
        }
    };
});


System.register('angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/dom/dom_adapter', 'angular2/src/render/dom/shadow_dom/light_dom', 'angular2/src/render/dom/shadow_dom/shadow_dom_strategy', 'angular2/src/render/dom/shadow_dom/util'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, DOM, LightDom, ShadowDomStrategy, insertSharedStyleText, EmulatedUnscopedShadowDomStrategy;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomShadow_domLight_dom) {
            LightDom = _angular2SrcRenderDomShadow_domLight_dom.LightDom;
        }, function (_angular2SrcRenderDomShadow_domShadow_dom_strategy) {
            ShadowDomStrategy = _angular2SrcRenderDomShadow_domShadow_dom_strategy.ShadowDomStrategy;
        }, function (_angular2SrcRenderDomShadow_domUtil) {
            insertSharedStyleText = _angular2SrcRenderDomShadow_domUtil.insertSharedStyleText;
        }],
        execute: function () {
            'use strict';

            /**
             * This strategy emulates the Shadow DOM for the templates, styles **excluded**:
             * - components templates are added as children of their component element,
             * - styles are moved from the templates to the styleHost (i.e. the document head).
             *
             * Notes:
             * - styles are **not** scoped to their component and will apply to the whole document,
             * - you can **not** use shadow DOM specific selectors in the styles
             */

            EmulatedUnscopedShadowDomStrategy = (function (_ShadowDomStrategy) {
                function EmulatedUnscopedShadowDomStrategy(styleUrlResolver, styleHost) {
                    _classCallCheck(this, EmulatedUnscopedShadowDomStrategy);

                    _get(Object.getPrototypeOf(EmulatedUnscopedShadowDomStrategy.prototype), 'constructor', this).call(this);
                    this.styleUrlResolver = styleUrlResolver;
                    this.styleHost = styleHost;
                }

                _inherits(EmulatedUnscopedShadowDomStrategy, _ShadowDomStrategy);

                _createClass(EmulatedUnscopedShadowDomStrategy, [{
                    key: 'hasNativeContentElement',
                    value: function hasNativeContentElement() {
                        return false;
                    }
                }, {
                    key: 'prepareShadowRoot',
                    value: function prepareShadowRoot(el) {
                        return el;
                    }
                }, {
                    key: 'constructLightDom',
                    value: function constructLightDom(lightDomView, el) {
                        return new LightDom(lightDomView, el);
                    }
                }, {
                    key: 'processStyleElement',
                    value: function processStyleElement(hostComponentId, templateUrl, styleEl) {
                        var cssText = DOM.getText(styleEl);
                        cssText = this.styleUrlResolver.resolveUrls(cssText, templateUrl);
                        DOM.setText(styleEl, cssText);
                        DOM.remove(styleEl);
                        insertSharedStyleText(cssText, this.styleHost, styleEl);
                        return null;
                    }
                }]);

                return EmulatedUnscopedShadowDomStrategy;
            })(ShadowDomStrategy);

            _export('EmulatedUnscopedShadowDomStrategy', EmulatedUnscopedShadowDomStrategy);
        }
    };
});


System.register("angular2/src/render/dom/dom_renderer", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/shadow_dom/content_tag", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/view", "angular2/src/render/dom/view/view_container", "angular2/src/render/dom/util", "angular2/src/render/api"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, Inject, Injectable, OpaqueToken, isPresent, isBlank, BaseException, CONST_EXPR, ListWrapper, DOM, Content, ShadowDomStrategy, EventManager, resolveInternalDomProtoView, DomView, DomViewRef, resolveInternalDomView, DomViewContainer, NG_BINDING_CLASS_SELECTOR, NG_BINDING_CLASS, Renderer, __decorate, __metadata, __param, DOCUMENT_TOKEN, DomRenderer;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Inject = _angular2Di.Inject;
            Injectable = _angular2Di.Injectable;
            OpaqueToken = _angular2Di.OpaqueToken;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomShadow_domContent_tag) {
            Content = _angular2SrcRenderDomShadow_domContent_tag.Content;
        }, function (_angular2SrcRenderDomShadow_domShadow_dom_strategy) {
            ShadowDomStrategy = _angular2SrcRenderDomShadow_domShadow_dom_strategy.ShadowDomStrategy;
        }, function (_angular2SrcRenderDomEventsEvent_manager) {
            EventManager = _angular2SrcRenderDomEventsEvent_manager.EventManager;
        }, function (_angular2SrcRenderDomViewProto_view) {
            resolveInternalDomProtoView = _angular2SrcRenderDomViewProto_view.resolveInternalDomProtoView;
        }, function (_angular2SrcRenderDomViewView) {
            DomView = _angular2SrcRenderDomViewView.DomView;
            DomViewRef = _angular2SrcRenderDomViewView.DomViewRef;
            resolveInternalDomView = _angular2SrcRenderDomViewView.resolveInternalDomView;
        }, function (_angular2SrcRenderDomViewView_container) {
            DomViewContainer = _angular2SrcRenderDomViewView_container.DomViewContainer;
        }, function (_angular2SrcRenderDomUtil) {
            NG_BINDING_CLASS_SELECTOR = _angular2SrcRenderDomUtil.NG_BINDING_CLASS_SELECTOR;
            NG_BINDING_CLASS = _angular2SrcRenderDomUtil.NG_BINDING_CLASS;
        }, function (_angular2SrcRenderApi) {
            Renderer = _angular2SrcRenderApi.Renderer;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            DOCUMENT_TOKEN = CONST_EXPR(new OpaqueToken("DocumentToken"));

            _export("DOCUMENT_TOKEN", DOCUMENT_TOKEN);

            DomRenderer = (function (_Renderer) {
                var _class = function DomRenderer(eventManager, shadowDomStrategy, document) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this._eventManager = eventManager;
                    this._shadowDomStrategy = shadowDomStrategy;
                    this._document = document;
                };

                _inherits(_class, _Renderer);

                _createClass(_class, [{
                    key: "createRootHostView",
                    value: function createRootHostView(hostProtoViewRef, hostElementSelector) {
                        var hostProtoView = resolveInternalDomProtoView(hostProtoViewRef);
                        var element = DOM.querySelector(this._document, hostElementSelector);
                        if (isBlank(element)) {
                            throw new BaseException("The selector \"" + hostElementSelector + "\" did not match any elements");
                        }
                        return new DomViewRef(this._createView(hostProtoView, element));
                    }
                }, {
                    key: "detachFreeHostView",
                    value: function detachFreeHostView(parentHostViewRef, hostViewRef) {
                        var hostView = resolveInternalDomView(hostViewRef);
                        this._removeViewNodes(hostView);
                    }
                }, {
                    key: "createView",
                    value: function createView(protoViewRef) {
                        var protoView = resolveInternalDomProtoView(protoViewRef);
                        return new DomViewRef(this._createView(protoView, null));
                    }
                }, {
                    key: "destroyView",
                    value: function destroyView(view) {}
                }, {
                    key: "attachComponentView",
                    value: function attachComponentView(hostViewRef, elementIndex, componentViewRef) {
                        var hostView = resolveInternalDomView(hostViewRef);
                        var componentView = resolveInternalDomView(componentViewRef);
                        var element = hostView.boundElements[elementIndex];
                        var lightDom = hostView.lightDoms[elementIndex];
                        if (isPresent(lightDom)) {
                            lightDom.attachShadowDomView(componentView);
                        }
                        var shadowRoot = this._shadowDomStrategy.prepareShadowRoot(element);
                        this._moveViewNodesIntoParent(shadowRoot, componentView);
                        componentView.hostLightDom = lightDom;
                        componentView.shadowRoot = shadowRoot;
                    }
                }, {
                    key: "setComponentViewRootNodes",
                    value: function setComponentViewRootNodes(componentViewRef, rootNodes) {
                        var componentView = resolveInternalDomView(componentViewRef);
                        this._removeViewNodes(componentView);
                        componentView.rootNodes = rootNodes;
                        this._moveViewNodesIntoParent(componentView.shadowRoot, componentView);
                    }
                }, {
                    key: "getHostElement",
                    value: function getHostElement(hostViewRef) {
                        var hostView = resolveInternalDomView(hostViewRef);
                        return hostView.boundElements[0];
                    }
                }, {
                    key: "detachComponentView",
                    value: function detachComponentView(hostViewRef, boundElementIndex, componentViewRef) {
                        var hostView = resolveInternalDomView(hostViewRef);
                        var componentView = resolveInternalDomView(componentViewRef);
                        this._removeViewNodes(componentView);
                        var lightDom = hostView.lightDoms[boundElementIndex];
                        if (isPresent(lightDom)) {
                            lightDom.detachShadowDomView();
                        }
                        componentView.hostLightDom = null;
                        componentView.shadowRoot = null;
                    }
                }, {
                    key: "attachViewInContainer",
                    value: function attachViewInContainer(parentViewRef, boundElementIndex, atIndex, viewRef) {
                        var parentView = resolveInternalDomView(parentViewRef);
                        var view = resolveInternalDomView(viewRef);
                        var viewContainer = this._getOrCreateViewContainer(parentView, boundElementIndex);
                        ListWrapper.insert(viewContainer.views, atIndex, view);
                        view.hostLightDom = parentView.hostLightDom;
                        var directParentLightDom = parentView.getDirectParentLightDom(boundElementIndex);
                        if (isBlank(directParentLightDom)) {
                            var siblingToInsertAfter;
                            if (atIndex == 0) {
                                siblingToInsertAfter = parentView.boundElements[boundElementIndex];
                            } else {
                                siblingToInsertAfter = ListWrapper.last(viewContainer.views[atIndex - 1].rootNodes);
                            }
                            this._moveViewNodesAfterSibling(siblingToInsertAfter, view);
                        } else {
                            directParentLightDom.redistribute();
                        }
                        // new content tags might have appeared, we need to redistribute.
                        if (isPresent(parentView.hostLightDom)) {
                            parentView.hostLightDom.redistribute();
                        }
                    }
                }, {
                    key: "detachViewInContainer",
                    value: function detachViewInContainer(parentViewRef, boundElementIndex, atIndex, viewRef) {
                        var parentView = resolveInternalDomView(parentViewRef);
                        var view = resolveInternalDomView(viewRef);
                        var viewContainer = parentView.viewContainers[boundElementIndex];
                        var detachedView = viewContainer.views[atIndex];
                        ListWrapper.removeAt(viewContainer.views, atIndex);
                        var directParentLightDom = parentView.getDirectParentLightDom(boundElementIndex);
                        if (isBlank(directParentLightDom)) {
                            this._removeViewNodes(detachedView);
                        } else {
                            directParentLightDom.redistribute();
                        }
                        view.hostLightDom = null;
                        // content tags might have disappeared we need to do redistribution.
                        if (isPresent(parentView.hostLightDom)) {
                            parentView.hostLightDom.redistribute();
                        }
                    }
                }, {
                    key: "hydrateView",
                    value: function hydrateView(viewRef) {
                        var view = resolveInternalDomView(viewRef);
                        if (view.hydrated) throw new BaseException("The view is already hydrated.");
                        view.hydrated = true;
                        for (var i = 0; i < view.lightDoms.length; ++i) {
                            var lightDom = view.lightDoms[i];
                            if (isPresent(lightDom)) {
                                lightDom.redistribute();
                            }
                        }
                        // add global events
                        view.eventHandlerRemovers = ListWrapper.create();
                        var binders = view.proto.elementBinders;
                        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                            var binder = binders[binderIdx];
                            if (isPresent(binder.globalEvents)) {
                                for (var i = 0; i < binder.globalEvents.length; i++) {
                                    var globalEvent = binder.globalEvents[i];
                                    var remover = this._createGlobalEventListener(view, binderIdx, globalEvent.name, globalEvent.target, globalEvent.fullName);
                                    ListWrapper.push(view.eventHandlerRemovers, remover);
                                }
                            }
                        }
                        if (isPresent(view.hostLightDom)) {
                            view.hostLightDom.redistribute();
                        }
                    }
                }, {
                    key: "dehydrateView",
                    value: function dehydrateView(viewRef) {
                        var view = resolveInternalDomView(viewRef);
                        // remove global events
                        for (var i = 0; i < view.eventHandlerRemovers.length; i++) {
                            view.eventHandlerRemovers[i]();
                        }
                        view.eventHandlerRemovers = null;
                        view.hydrated = false;
                    }
                }, {
                    key: "setElementProperty",
                    value: function setElementProperty(viewRef, elementIndex, propertyName, propertyValue) {
                        var view = resolveInternalDomView(viewRef);
                        view.setElementProperty(elementIndex, propertyName, propertyValue);
                    }
                }, {
                    key: "callAction",
                    value: function callAction(viewRef, elementIndex, actionExpression, actionArgs) {
                        var view = resolveInternalDomView(viewRef);
                        view.callAction(elementIndex, actionExpression, actionArgs);
                    }
                }, {
                    key: "setText",
                    value: function setText(viewRef, textNodeIndex, text) {
                        var view = resolveInternalDomView(viewRef);
                        DOM.setText(view.boundTextNodes[textNodeIndex], text);
                    }
                }, {
                    key: "setEventDispatcher",
                    value: function setEventDispatcher(viewRef, dispatcher /*api.EventDispatcher*/) {
                        var view = resolveInternalDomView(viewRef);
                        view.eventDispatcher = dispatcher;
                    }
                }, {
                    key: "_createView",
                    value: function _createView(protoView, inplaceElement) {
                        var rootElementClone;
                        var elementsWithBindingsDynamic;
                        var viewRootNodes;
                        if (isPresent(inplaceElement)) {
                            rootElementClone = inplaceElement;
                            elementsWithBindingsDynamic = [];
                            viewRootNodes = [inplaceElement];
                        } else if (protoView.isTemplateElement) {
                            rootElementClone = DOM.importIntoDoc(DOM.content(protoView.element));
                            elementsWithBindingsDynamic = DOM.querySelectorAll(rootElementClone, NG_BINDING_CLASS_SELECTOR);
                            var childNode = DOM.firstChild(rootElementClone);
                            // TODO(perf): Should be fixed size, since we could pre-compute in in DomProtoView
                            viewRootNodes = [];
                            // Note: An explicit loop is the fastest way to convert a DOM array into a JS array!
                            while (childNode != null) {
                                ListWrapper.push(viewRootNodes, childNode);
                                childNode = DOM.nextSibling(childNode);
                            }
                        } else {
                            rootElementClone = DOM.importIntoDoc(protoView.element);
                            elementsWithBindingsDynamic = DOM.getElementsByClassName(rootElementClone, NG_BINDING_CLASS);
                            viewRootNodes = [rootElementClone];
                        }
                        var elementsWithBindings = ListWrapper.createFixedSize(elementsWithBindingsDynamic.length);
                        for (var binderIdx = 0; binderIdx < elementsWithBindingsDynamic.length; ++binderIdx) {
                            elementsWithBindings[binderIdx] = elementsWithBindingsDynamic[binderIdx];
                        }
                        var binders = protoView.elementBinders;
                        var boundTextNodes = [];
                        var boundElements = ListWrapper.createFixedSize(binders.length);
                        var contentTags = ListWrapper.createFixedSize(binders.length);
                        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                            var binder = binders[binderIdx];
                            var element;
                            var childNodes;
                            if (binderIdx === 0 && protoView.rootBindingOffset === 1) {
                                // Note: if the root element was a template,
                                // the rootElementClone is a document fragment,
                                // which will be empty as soon as the view gets appended
                                // to a parent. So we store null in the boundElements array.
                                element = protoView.isTemplateElement ? null : rootElementClone;
                                childNodes = DOM.childNodes(rootElementClone);
                            } else {
                                element = elementsWithBindings[binderIdx - protoView.rootBindingOffset];
                                childNodes = DOM.childNodes(element);
                            }
                            boundElements[binderIdx] = element;
                            // boundTextNodes
                            var textNodeIndices = binder.textNodeIndices;
                            for (var i = 0; i < textNodeIndices.length; i++) {
                                ListWrapper.push(boundTextNodes, childNodes[textNodeIndices[i]]);
                            }
                            // contentTags
                            var contentTag = null;
                            if (isPresent(binder.contentTagSelector)) {
                                contentTag = new Content(element, binder.contentTagSelector);
                            }
                            contentTags[binderIdx] = contentTag;
                        }
                        var view = new DomView(protoView, viewRootNodes, boundTextNodes, boundElements, contentTags);
                        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                            var binder = binders[binderIdx];
                            var element = boundElements[binderIdx];
                            // lightDoms
                            var lightDom = null;
                            if (isPresent(binder.componentId)) {
                                lightDom = this._shadowDomStrategy.constructLightDom(view, boundElements[binderIdx]);
                            }
                            view.lightDoms[binderIdx] = lightDom;
                            // init contentTags
                            var contentTag = contentTags[binderIdx];
                            if (isPresent(contentTag)) {
                                var destLightDom = view.getDirectParentLightDom(binderIdx);
                                contentTag.init(destLightDom);
                            }
                            // events
                            if (isPresent(binder.eventLocals) && isPresent(binder.localEvents)) {
                                for (var i = 0; i < binder.localEvents.length; i++) {
                                    this._createEventListener(view, element, binderIdx, binder.localEvents[i].name, binder.eventLocals);
                                }
                            }
                        }
                        return view;
                    }
                }, {
                    key: "_createEventListener",
                    value: function _createEventListener(view, element, elementIndex, eventName, eventLocals) {
                        this._eventManager.addEventListener(element, eventName, function (event) {
                            view.dispatchEvent(elementIndex, eventName, event);
                        });
                    }
                }, {
                    key: "_moveViewNodesAfterSibling",
                    value: function _moveViewNodesAfterSibling(sibling, view) {
                        for (var i = view.rootNodes.length - 1; i >= 0; --i) {
                            DOM.insertAfter(sibling, view.rootNodes[i]);
                        }
                    }
                }, {
                    key: "_moveViewNodesIntoParent",
                    value: function _moveViewNodesIntoParent(parent, view) {
                        for (var i = 0; i < view.rootNodes.length; ++i) {
                            DOM.appendChild(parent, view.rootNodes[i]);
                        }
                    }
                }, {
                    key: "_removeViewNodes",
                    value: function _removeViewNodes(view) {
                        var len = view.rootNodes.length;
                        if (len == 0) return;
                        var parent = view.rootNodes[0].parentNode;
                        for (var i = len - 1; i >= 0; --i) {
                            DOM.removeChild(parent, view.rootNodes[i]);
                        }
                    }
                }, {
                    key: "_getOrCreateViewContainer",
                    value: function _getOrCreateViewContainer(parentView, boundElementIndex) {
                        var vc = parentView.viewContainers[boundElementIndex];
                        if (isBlank(vc)) {
                            vc = new DomViewContainer();
                            parentView.viewContainers[boundElementIndex] = vc;
                        }
                        return vc;
                    }
                }, {
                    key: "_createGlobalEventListener",
                    value: function _createGlobalEventListener(view, elementIndex, eventName, eventTarget, fullName) {
                        return this._eventManager.addGlobalEventListener(eventTarget, eventName, function (event) {
                            view.dispatchEvent(elementIndex, fullName, event);
                        });
                    }
                }]);

                return _class;
            })(Renderer);

            _export("DomRenderer", DomRenderer);

            _export("DomRenderer", DomRenderer = __decorate([Injectable(), __param(2, Inject(DOCUMENT_TOKEN)), __metadata("design:paramtypes", [EventManager, ShadowDomStrategy, Object])], DomRenderer));
            
        }
    };
});

// noop for now
System.register('angular2/src/render/dom/compiler/compile_pipeline', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/dom/dom_adapter', 'angular2/src/render/dom/compiler/compile_element', 'angular2/src/render/dom/compiler/compile_control', 'angular2/src/render/dom/view/proto_view_builder', 'angular2/src/render/api'], function (_export) {
    var _createClass, _classCallCheck, isPresent, isBlank, ListWrapper, DOM, CompileElement, CompileControl, ProtoViewBuilder, ProtoViewDto, CompilePipeline;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderDomCompilerCompile_element) {
            CompileElement = _angular2SrcRenderDomCompilerCompile_element.CompileElement;
        }, function (_angular2SrcRenderDomCompilerCompile_control) {
            CompileControl = _angular2SrcRenderDomCompilerCompile_control.CompileControl;
        }, function (_angular2SrcRenderDomViewProto_view_builder) {
            ProtoViewBuilder = _angular2SrcRenderDomViewProto_view_builder.ProtoViewBuilder;
        }, function (_angular2SrcRenderApi) {
            ProtoViewDto = _angular2SrcRenderApi.ProtoViewDto;
        }],
        execute: function () {
            'use strict';

            /**
             * CompilePipeline for executing CompileSteps recursively for
             * all elements in a template.
             */

            CompilePipeline = (function () {
                function CompilePipeline(steps) {
                    _classCallCheck(this, CompilePipeline);

                    this._control = new CompileControl(steps);
                }

                _createClass(CompilePipeline, [{
                    key: 'process',
                    value: function process(rootElement) {
                        var protoViewType = arguments[1] === undefined ? null : arguments[1];
                        var compilationCtxtDescription = arguments[2] === undefined ? '' : arguments[2];

                        if (isBlank(protoViewType)) {
                            protoViewType = ProtoViewDto.COMPONENT_VIEW_TYPE;
                        }
                        var results = ListWrapper.create();
                        var rootCompileElement = new CompileElement(rootElement, compilationCtxtDescription);
                        rootCompileElement.inheritedProtoView = new ProtoViewBuilder(rootElement, protoViewType);
                        rootCompileElement.isViewRoot = true;
                        this._process(results, null, rootCompileElement, compilationCtxtDescription);
                        return results;
                    }
                }, {
                    key: '_process',
                    value: function _process(results, parent, current) {
                        var compilationCtxtDescription = arguments[3] === undefined ? '' : arguments[3];

                        var additionalChildren = this._control.internalProcess(results, 0, parent, current);
                        if (current.compileChildren) {
                            var node = DOM.firstChild(DOM.templateAwareRoot(current.element));
                            while (isPresent(node)) {
                                // compiliation can potentially move the node, so we need to store the
                                // next sibling before recursing.
                                var nextNode = DOM.nextSibling(node);
                                if (DOM.isElementNode(node)) {
                                    var childCompileElement = new CompileElement(node, compilationCtxtDescription);
                                    childCompileElement.inheritedProtoView = current.inheritedProtoView;
                                    childCompileElement.inheritedElementBinder = current.inheritedElementBinder;
                                    childCompileElement.distanceToInheritedBinder = current.distanceToInheritedBinder + 1;
                                    this._process(results, current, childCompileElement);
                                }
                                node = nextNode;
                            }
                        }
                        if (isPresent(additionalChildren)) {
                            for (var i = 0; i < additionalChildren.length; i++) {
                                this._process(results, current, additionalChildren[i]);
                            }
                        }
                    }
                }]);

                return CompilePipeline;
            })();

            _export('CompilePipeline', CompilePipeline);
        }
    };
});


System.register('angular2/src/render/dom/compiler/compile_step_factory', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'angular2/src/render/dom/compiler/property_binding_parser', 'angular2/src/render/dom/compiler/text_interpolation_parser', 'angular2/src/render/dom/compiler/directive_parser', 'angular2/src/render/dom/compiler/view_splitter', 'angular2/src/render/dom/shadow_dom/shadow_dom_compile_step'], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, PropertyBindingParser, TextInterpolationParser, DirectiveParser, ViewSplitter, ShadowDomCompileStep, CompileStepFactory, DefaultStepFactory;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_angular2SrcRenderDomCompilerProperty_binding_parser) {
            PropertyBindingParser = _angular2SrcRenderDomCompilerProperty_binding_parser.PropertyBindingParser;
        }, function (_angular2SrcRenderDomCompilerText_interpolation_parser) {
            TextInterpolationParser = _angular2SrcRenderDomCompilerText_interpolation_parser.TextInterpolationParser;
        }, function (_angular2SrcRenderDomCompilerDirective_parser) {
            DirectiveParser = _angular2SrcRenderDomCompilerDirective_parser.DirectiveParser;
        }, function (_angular2SrcRenderDomCompilerView_splitter) {
            ViewSplitter = _angular2SrcRenderDomCompilerView_splitter.ViewSplitter;
        }, function (_angular2SrcRenderDomShadow_domShadow_dom_compile_step) {
            ShadowDomCompileStep = _angular2SrcRenderDomShadow_domShadow_dom_compile_step.ShadowDomCompileStep;
        }],
        execute: function () {
            'use strict';

            CompileStepFactory = (function () {
                function CompileStepFactory() {
                    _classCallCheck(this, CompileStepFactory);
                }

                _createClass(CompileStepFactory, [{
                    key: 'createSteps',
                    value: function createSteps(template, subTaskPromises) {
                        return null;
                    }
                }]);

                return CompileStepFactory;
            })();

            _export('CompileStepFactory', CompileStepFactory);

            DefaultStepFactory = (function (_CompileStepFactory) {
                function DefaultStepFactory(parser, shadowDomStrategy) {
                    _classCallCheck(this, DefaultStepFactory);

                    _get(Object.getPrototypeOf(DefaultStepFactory.prototype), 'constructor', this).call(this);
                    this._parser = parser;
                    this._shadowDomStrategy = shadowDomStrategy;
                }

                _inherits(DefaultStepFactory, _CompileStepFactory);

                _createClass(DefaultStepFactory, [{
                    key: 'createSteps',
                    value: function createSteps(template, subTaskPromises) {
                        return [new ViewSplitter(this._parser), new PropertyBindingParser(this._parser), new DirectiveParser(this._parser, template.directives), new TextInterpolationParser(this._parser), new ShadowDomCompileStep(this._shadowDomStrategy, template, subTaskPromises)];
                    }
                }]);

                return DefaultStepFactory;
            })(CompileStepFactory);

            _export('DefaultStepFactory', DefaultStepFactory);
        }
    };
});


System.register('angular2/src/forms/directives', ['angular2/src/facade/lang', 'angular2/src/forms/directives/control_name_directive', 'angular2/src/forms/directives/form_control_directive', 'angular2/src/forms/directives/control_group_directive', 'angular2/src/forms/directives/form_model_directive', 'angular2/src/forms/directives/template_driven_form_directive', 'angular2/src/forms/directives/default_value_accessor', 'angular2/src/forms/directives/checkbox_value_accessor', 'angular2/src/forms/directives/select_control_value_accessor', 'angular2/src/forms/directives/control_directive'], function (_export) {
    'use strict';

    var CONST_EXPR, ControlNameDirective, FormControlDirective, ControlGroupDirective, FormModelDirective, TemplateDrivenFormDirective, DefaultValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, formDirectives;
    return {
        setters: [function (_angular2SrcFacadeLang) {
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcFormsDirectivesControl_name_directive) {
            ControlNameDirective = _angular2SrcFormsDirectivesControl_name_directive.ControlNameDirective;

            _export('ControlNameDirective', _angular2SrcFormsDirectivesControl_name_directive.ControlNameDirective);
        }, function (_angular2SrcFormsDirectivesForm_control_directive) {
            FormControlDirective = _angular2SrcFormsDirectivesForm_control_directive.FormControlDirective;

            _export('FormControlDirective', _angular2SrcFormsDirectivesForm_control_directive.FormControlDirective);
        }, function (_angular2SrcFormsDirectivesControl_group_directive) {
            ControlGroupDirective = _angular2SrcFormsDirectivesControl_group_directive.ControlGroupDirective;

            _export('ControlGroupDirective', _angular2SrcFormsDirectivesControl_group_directive.ControlGroupDirective);
        }, function (_angular2SrcFormsDirectivesForm_model_directive) {
            FormModelDirective = _angular2SrcFormsDirectivesForm_model_directive.FormModelDirective;

            _export('FormModelDirective', _angular2SrcFormsDirectivesForm_model_directive.FormModelDirective);
        }, function (_angular2SrcFormsDirectivesTemplate_driven_form_directive) {
            TemplateDrivenFormDirective = _angular2SrcFormsDirectivesTemplate_driven_form_directive.TemplateDrivenFormDirective;

            _export('TemplateDrivenFormDirective', _angular2SrcFormsDirectivesTemplate_driven_form_directive.TemplateDrivenFormDirective);
        }, function (_angular2SrcFormsDirectivesDefault_value_accessor) {
            DefaultValueAccessor = _angular2SrcFormsDirectivesDefault_value_accessor.DefaultValueAccessor;

            _export('DefaultValueAccessor', _angular2SrcFormsDirectivesDefault_value_accessor.DefaultValueAccessor);
        }, function (_angular2SrcFormsDirectivesCheckbox_value_accessor) {
            CheckboxControlValueAccessor = _angular2SrcFormsDirectivesCheckbox_value_accessor.CheckboxControlValueAccessor;

            _export('CheckboxControlValueAccessor', _angular2SrcFormsDirectivesCheckbox_value_accessor.CheckboxControlValueAccessor);
        }, function (_angular2SrcFormsDirectivesSelect_control_value_accessor) {
            SelectControlValueAccessor = _angular2SrcFormsDirectivesSelect_control_value_accessor.SelectControlValueAccessor;

            _export('SelectControlValueAccessor', _angular2SrcFormsDirectivesSelect_control_value_accessor.SelectControlValueAccessor);
        }, function (_angular2SrcFormsDirectivesControl_directive) {
            _export('ControlDirective', _angular2SrcFormsDirectivesControl_directive.ControlDirective);
        }],
        execute: function () {
            /**
             *
             * A list of all the form directives used as part of a `@View` annotation.
             *
             *  This is a shorthand for importing them each individually.
             *
             * @exportedAs angular2/forms
             */
            formDirectives = CONST_EXPR([ControlNameDirective, ControlGroupDirective, FormControlDirective, FormModelDirective, TemplateDrivenFormDirective, DefaultValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor]);

            

            _export('formDirectives', formDirectives);
        }
    };
});
System.register("angular2/src/change_detection/parser/ast", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "angular2/src/facade/lang", "angular2/src/facade/collection"], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, isBlank, isPresent, FunctionWrapper, BaseException, ListWrapper, StringMapWrapper, AST, EmptyExpr, ImplicitReceiver, Chain, Conditional, AccessMember, SafeAccessMember, KeyedAccess, Pipe, LiteralPrimitive, LiteralArray, LiteralMap, Interpolation, Binary, PrefixNot, Assignment, MethodCall, SafeMethodCall, FunctionCall, ASTWithSource, TemplateBinding, AstVisitor, AstTransformer, _evalListCache;

    function evalList(context, locals, exps) {
        var length = exps.length;
        if (length > 10) {
            throw new BaseException("Cannot have more than 10 argument");
        }
        var result = _evalListCache[length];
        for (var i = 0; i < length; i++) {
            result[i] = exps[i].eval(context, locals);
        }
        return result;
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            FunctionWrapper = _angular2SrcFacadeLang.FunctionWrapper;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }],
        execute: function () {
            "use strict";

            AST = (function () {
                function AST() {
                    _classCallCheck(this, AST);
                }

                _createClass(AST, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        throw new BaseException("Not supported");
                    }
                }, {
                    key: "isAssignable",
                    get: function () {
                        return false;
                    }
                }, {
                    key: "assign",
                    value: function assign(context, locals, value) {
                        throw new BaseException("Not supported");
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return null;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "AST";
                    }
                }]);

                return AST;
            })();

            _export("AST", AST);

            EmptyExpr = (function (_AST) {
                function EmptyExpr() {
                    _classCallCheck(this, EmptyExpr);

                    if (_AST != null) {
                        _AST.apply(this, arguments);
                    }
                }

                _inherits(EmptyExpr, _AST);

                _createClass(EmptyExpr, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return null;
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {}
                }]);

                return EmptyExpr;
            })(AST);

            _export("EmptyExpr", EmptyExpr);

            ImplicitReceiver = (function (_AST2) {
                function ImplicitReceiver() {
                    _classCallCheck(this, ImplicitReceiver);

                    if (_AST2 != null) {
                        _AST2.apply(this, arguments);
                    }
                }

                _inherits(ImplicitReceiver, _AST2);

                _createClass(ImplicitReceiver, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return context;
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitImplicitReceiver(this);
                    }
                }]);

                return ImplicitReceiver;
            })(AST);

            _export("ImplicitReceiver", ImplicitReceiver);

            /**
             * Multiple expressions separated by a semicolon.
             */

            Chain = (function (_AST3) {
                function Chain(expressions) {
                    _classCallCheck(this, Chain);

                    _get(Object.getPrototypeOf(Chain.prototype), "constructor", this).call(this);
                    this.expressions = expressions;
                }

                _inherits(Chain, _AST3);

                _createClass(Chain, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var result;
                        for (var i = 0; i < this.expressions.length; i++) {
                            var last = this.expressions[i].eval(context, locals);
                            if (isPresent(last)) result = last;
                        }
                        return result;
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitChain(this);
                    }
                }]);

                return Chain;
            })(AST);

            _export("Chain", Chain);

            Conditional = (function (_AST4) {
                function Conditional(condition, trueExp, falseExp) {
                    _classCallCheck(this, Conditional);

                    _get(Object.getPrototypeOf(Conditional.prototype), "constructor", this).call(this);
                    this.condition = condition;
                    this.trueExp = trueExp;
                    this.falseExp = falseExp;
                }

                _inherits(Conditional, _AST4);

                _createClass(Conditional, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        if (this.condition.eval(context, locals)) {
                            return this.trueExp.eval(context, locals);
                        } else {
                            return this.falseExp.eval(context, locals);
                        }
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitConditional(this);
                    }
                }]);

                return Conditional;
            })(AST);

            _export("Conditional", Conditional);

            AccessMember = (function (_AST5) {
                function AccessMember(receiver, name, getter, setter) {
                    _classCallCheck(this, AccessMember);

                    _get(Object.getPrototypeOf(AccessMember.prototype), "constructor", this).call(this);
                    this.receiver = receiver;
                    this.name = name;
                    this.getter = getter;
                    this.setter = setter;
                }

                _inherits(AccessMember, _AST5);

                _createClass(AccessMember, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
                            return locals.get(this.name);
                        } else {
                            var evaluatedReceiver = this.receiver.eval(context, locals);
                            return this.getter(evaluatedReceiver);
                        }
                    }
                }, {
                    key: "isAssignable",
                    get: function () {
                        return true;
                    }
                }, {
                    key: "assign",
                    value: function assign(context, locals, value) {
                        var evaluatedContext = this.receiver.eval(context, locals);
                        if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
                            throw new BaseException("Cannot reassign a variable binding " + this.name);
                        } else {
                            return this.setter(evaluatedContext, value);
                        }
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitAccessMember(this);
                    }
                }]);

                return AccessMember;
            })(AST);

            _export("AccessMember", AccessMember);

            SafeAccessMember = (function (_AST6) {
                function SafeAccessMember(receiver, name, getter, setter) {
                    _classCallCheck(this, SafeAccessMember);

                    _get(Object.getPrototypeOf(SafeAccessMember.prototype), "constructor", this).call(this);
                    this.receiver = receiver;
                    this.name = name;
                    this.getter = getter;
                    this.setter = setter;
                }

                _inherits(SafeAccessMember, _AST6);

                _createClass(SafeAccessMember, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var evaluatedReceiver = this.receiver.eval(context, locals);
                        return isBlank(evaluatedReceiver) ? null : this.getter(evaluatedReceiver);
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitSafeAccessMember(this);
                    }
                }]);

                return SafeAccessMember;
            })(AST);

            _export("SafeAccessMember", SafeAccessMember);

            KeyedAccess = (function (_AST7) {
                function KeyedAccess(obj, key) {
                    _classCallCheck(this, KeyedAccess);

                    _get(Object.getPrototypeOf(KeyedAccess.prototype), "constructor", this).call(this);
                    this.obj = obj;
                    this.key = key;
                }

                _inherits(KeyedAccess, _AST7);

                _createClass(KeyedAccess, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var obj = this.obj.eval(context, locals);
                        var key = this.key.eval(context, locals);
                        return obj[key];
                    }
                }, {
                    key: "isAssignable",
                    get: function () {
                        return true;
                    }
                }, {
                    key: "assign",
                    value: function assign(context, locals, value) {
                        var obj = this.obj.eval(context, locals);
                        var key = this.key.eval(context, locals);
                        obj[key] = value;
                        return value;
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitKeyedAccess(this);
                    }
                }]);

                return KeyedAccess;
            })(AST);

            _export("KeyedAccess", KeyedAccess);

            Pipe = (function (_AST8) {
                function Pipe(exp, name, args, inBinding) {
                    _classCallCheck(this, Pipe);

                    _get(Object.getPrototypeOf(Pipe.prototype), "constructor", this).call(this);
                    this.exp = exp;
                    this.name = name;
                    this.args = args;
                    this.inBinding = inBinding;
                }

                _inherits(Pipe, _AST8);

                _createClass(Pipe, [{
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitPipe(this);
                    }
                }]);

                return Pipe;
            })(AST);

            _export("Pipe", Pipe);

            LiteralPrimitive = (function (_AST9) {
                function LiteralPrimitive(value) {
                    _classCallCheck(this, LiteralPrimitive);

                    _get(Object.getPrototypeOf(LiteralPrimitive.prototype), "constructor", this).call(this);
                    this.value = value;
                }

                _inherits(LiteralPrimitive, _AST9);

                _createClass(LiteralPrimitive, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return this.value;
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitLiteralPrimitive(this);
                    }
                }]);

                return LiteralPrimitive;
            })(AST);

            _export("LiteralPrimitive", LiteralPrimitive);

            LiteralArray = (function (_AST10) {
                function LiteralArray(expressions) {
                    _classCallCheck(this, LiteralArray);

                    _get(Object.getPrototypeOf(LiteralArray.prototype), "constructor", this).call(this);
                    this.expressions = expressions;
                }

                _inherits(LiteralArray, _AST10);

                _createClass(LiteralArray, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return ListWrapper.map(this.expressions, function (e) {
                            return e.eval(context, locals);
                        });
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitLiteralArray(this);
                    }
                }]);

                return LiteralArray;
            })(AST);

            _export("LiteralArray", LiteralArray);

            LiteralMap = (function (_AST11) {
                function LiteralMap(keys, values) {
                    _classCallCheck(this, LiteralMap);

                    _get(Object.getPrototypeOf(LiteralMap.prototype), "constructor", this).call(this);
                    this.keys = keys;
                    this.values = values;
                }

                _inherits(LiteralMap, _AST11);

                _createClass(LiteralMap, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var res = StringMapWrapper.create();
                        for (var i = 0; i < this.keys.length; ++i) {
                            StringMapWrapper.set(res, this.keys[i], this.values[i].eval(context, locals));
                        }
                        return res;
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitLiteralMap(this);
                    }
                }]);

                return LiteralMap;
            })(AST);

            _export("LiteralMap", LiteralMap);

            Interpolation = (function (_AST12) {
                function Interpolation(strings, expressions) {
                    _classCallCheck(this, Interpolation);

                    _get(Object.getPrototypeOf(Interpolation.prototype), "constructor", this).call(this);
                    this.strings = strings;
                    this.expressions = expressions;
                }

                _inherits(Interpolation, _AST12);

                _createClass(Interpolation, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        throw new BaseException("evaluating an Interpolation is not supported");
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        visitor.visitInterpolation(this);
                    }
                }]);

                return Interpolation;
            })(AST);

            _export("Interpolation", Interpolation);

            Binary = (function (_AST13) {
                function Binary(operation, left, right) {
                    _classCallCheck(this, Binary);

                    _get(Object.getPrototypeOf(Binary.prototype), "constructor", this).call(this);
                    this.operation = operation;
                    this.left = left;
                    this.right = right;
                }

                _inherits(Binary, _AST13);

                _createClass(Binary, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var left = this.left.eval(context, locals);
                        switch (this.operation) {
                            case "&&":
                                return left && this.right.eval(context, locals);
                            case "||":
                                return left || this.right.eval(context, locals);
                        }
                        var right = this.right.eval(context, locals);
                        switch (this.operation) {
                            case "+":
                                return left + right;
                            case "-":
                                return left - right;
                            case "*":
                                return left * right;
                            case "/":
                                return left / right;
                            case "%":
                                return left % right;
                            case "==":
                                return left == right;
                            case "!=":
                                return left != right;
                            case "===":
                                return left === right;
                            case "!==":
                                return left !== right;
                            case "<":
                                return left < right;
                            case ">":
                                return left > right;
                            case "<=":
                                return left <= right;
                            case ">=":
                                return left >= right;
                            case "^":
                                return left ^ right;
                            case "&":
                                return left & right;
                        }
                        throw "Internal error [$operation] not handled";
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitBinary(this);
                    }
                }]);

                return Binary;
            })(AST);

            _export("Binary", Binary);

            PrefixNot = (function (_AST14) {
                function PrefixNot(expression) {
                    _classCallCheck(this, PrefixNot);

                    _get(Object.getPrototypeOf(PrefixNot.prototype), "constructor", this).call(this);
                    this.expression = expression;
                }

                _inherits(PrefixNot, _AST14);

                _createClass(PrefixNot, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return !this.expression.eval(context, locals);
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitPrefixNot(this);
                    }
                }]);

                return PrefixNot;
            })(AST);

            _export("PrefixNot", PrefixNot);

            Assignment = (function (_AST15) {
                function Assignment(target, value) {
                    _classCallCheck(this, Assignment);

                    _get(Object.getPrototypeOf(Assignment.prototype), "constructor", this).call(this);
                    this.target = target;
                    this.value = value;
                }

                _inherits(Assignment, _AST15);

                _createClass(Assignment, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return this.target.assign(context, locals, this.value.eval(context, locals));
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitAssignment(this);
                    }
                }]);

                return Assignment;
            })(AST);

            _export("Assignment", Assignment);

            MethodCall = (function (_AST16) {
                function MethodCall(receiver, name, fn, args) {
                    _classCallCheck(this, MethodCall);

                    _get(Object.getPrototypeOf(MethodCall.prototype), "constructor", this).call(this);
                    this.receiver = receiver;
                    this.name = name;
                    this.fn = fn;
                    this.args = args;
                }

                _inherits(MethodCall, _AST16);

                _createClass(MethodCall, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var evaluatedArgs = evalList(context, locals, this.args);
                        if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
                            var fn = locals.get(this.name);
                            return FunctionWrapper.apply(fn, evaluatedArgs);
                        } else {
                            var evaluatedReceiver = this.receiver.eval(context, locals);
                            return this.fn(evaluatedReceiver, evaluatedArgs);
                        }
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitMethodCall(this);
                    }
                }]);

                return MethodCall;
            })(AST);

            _export("MethodCall", MethodCall);

            SafeMethodCall = (function (_AST17) {
                function SafeMethodCall(receiver, name, fn, args) {
                    _classCallCheck(this, SafeMethodCall);

                    _get(Object.getPrototypeOf(SafeMethodCall.prototype), "constructor", this).call(this);
                    this.receiver = receiver;
                    this.name = name;
                    this.fn = fn;
                    this.args = args;
                }

                _inherits(SafeMethodCall, _AST17);

                _createClass(SafeMethodCall, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var evaluatedReceiver = this.receiver.eval(context, locals);
                        if (isBlank(evaluatedReceiver)) return null;
                        var evaluatedArgs = evalList(context, locals, this.args);
                        return this.fn(evaluatedReceiver, evaluatedArgs);
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitSafeMethodCall(this);
                    }
                }]);

                return SafeMethodCall;
            })(AST);

            _export("SafeMethodCall", SafeMethodCall);

            FunctionCall = (function (_AST18) {
                function FunctionCall(target, args) {
                    _classCallCheck(this, FunctionCall);

                    _get(Object.getPrototypeOf(FunctionCall.prototype), "constructor", this).call(this);
                    this.target = target;
                    this.args = args;
                }

                _inherits(FunctionCall, _AST18);

                _createClass(FunctionCall, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        var obj = this.target.eval(context, locals);
                        if (!(obj instanceof Function)) {
                            throw new BaseException("" + obj + " is not a function");
                        }
                        return FunctionWrapper.apply(obj, evalList(context, locals, this.args));
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return visitor.visitFunctionCall(this);
                    }
                }]);

                return FunctionCall;
            })(AST);

            _export("FunctionCall", FunctionCall);

            ASTWithSource = (function (_AST19) {
                function ASTWithSource(ast, source, location) {
                    _classCallCheck(this, ASTWithSource);

                    _get(Object.getPrototypeOf(ASTWithSource.prototype), "constructor", this).call(this);
                    this.ast = ast;
                    this.source = source;
                    this.location = location;
                }

                _inherits(ASTWithSource, _AST19);

                _createClass(ASTWithSource, [{
                    key: "eval",
                    value: function _eval(context, locals) {
                        return this.ast.eval(context, locals);
                    }
                }, {
                    key: "isAssignable",
                    get: function () {
                        return this.ast.isAssignable;
                    }
                }, {
                    key: "assign",
                    value: function assign(context, locals, value) {
                        return this.ast.assign(context, locals, value);
                    }
                }, {
                    key: "visit",
                    value: function visit(visitor) {
                        return this.ast.visit(visitor);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "" + this.source + " in " + this.location;
                    }
                }]);

                return ASTWithSource;
            })(AST);

            _export("ASTWithSource", ASTWithSource);

            TemplateBinding = function TemplateBinding(key, keyIsVar, name, expression) {
                _classCallCheck(this, TemplateBinding);

                this.key = key;
                this.keyIsVar = keyIsVar;
                this.name = name;
                this.expression = expression;
            };

            _export("TemplateBinding", TemplateBinding);

            // INTERFACE

            AstVisitor = (function () {
                function AstVisitor() {
                    _classCallCheck(this, AstVisitor);
                }

                _createClass(AstVisitor, [{
                    key: "visitAccessMember",
                    value: function visitAccessMember(ast) {}
                }, {
                    key: "visitAssignment",
                    value: function visitAssignment(ast) {}
                }, {
                    key: "visitBinary",
                    value: function visitBinary(ast) {}
                }, {
                    key: "visitChain",
                    value: function visitChain(ast) {}
                }, {
                    key: "visitConditional",
                    value: function visitConditional(ast) {}
                }, {
                    key: "visitPipe",
                    value: function visitPipe(ast) {}
                }, {
                    key: "visitFunctionCall",
                    value: function visitFunctionCall(ast) {}
                }, {
                    key: "visitImplicitReceiver",
                    value: function visitImplicitReceiver(ast) {}
                }, {
                    key: "visitKeyedAccess",
                    value: function visitKeyedAccess(ast) {}
                }, {
                    key: "visitLiteralArray",
                    value: function visitLiteralArray(ast) {}
                }, {
                    key: "visitLiteralMap",
                    value: function visitLiteralMap(ast) {}
                }, {
                    key: "visitLiteralPrimitive",
                    value: function visitLiteralPrimitive(ast) {}
                }, {
                    key: "visitMethodCall",
                    value: function visitMethodCall(ast) {}
                }, {
                    key: "visitPrefixNot",
                    value: function visitPrefixNot(ast) {}
                }, {
                    key: "visitSafeAccessMember",
                    value: function visitSafeAccessMember(ast) {}
                }, {
                    key: "visitSafeMethodCall",
                    value: function visitSafeMethodCall(ast) {}
                }]);

                return AstVisitor;
            })();

            _export("AstVisitor", AstVisitor);

            AstTransformer = (function () {
                function AstTransformer() {
                    _classCallCheck(this, AstTransformer);
                }

                _createClass(AstTransformer, [{
                    key: "visitImplicitReceiver",
                    value: function visitImplicitReceiver(ast) {
                        return ast;
                    }
                }, {
                    key: "visitInterpolation",
                    value: function visitInterpolation(ast) {
                        return new Interpolation(ast.strings, this.visitAll(ast.expressions));
                    }
                }, {
                    key: "visitLiteralPrimitive",
                    value: function visitLiteralPrimitive(ast) {
                        return new LiteralPrimitive(ast.value);
                    }
                }, {
                    key: "visitAccessMember",
                    value: function visitAccessMember(ast) {
                        return new AccessMember(ast.receiver.visit(this), ast.name, ast.getter, ast.setter);
                    }
                }, {
                    key: "visitSafeAccessMember",
                    value: function visitSafeAccessMember(ast) {
                        return new SafeAccessMember(ast.receiver.visit(this), ast.name, ast.getter, ast.setter);
                    }
                }, {
                    key: "visitMethodCall",
                    value: function visitMethodCall(ast) {
                        return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
                    }
                }, {
                    key: "visitSafeMethodCall",
                    value: function visitSafeMethodCall(ast) {
                        return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
                    }
                }, {
                    key: "visitFunctionCall",
                    value: function visitFunctionCall(ast) {
                        return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
                    }
                }, {
                    key: "visitLiteralArray",
                    value: function visitLiteralArray(ast) {
                        return new LiteralArray(this.visitAll(ast.expressions));
                    }
                }, {
                    key: "visitLiteralMap",
                    value: function visitLiteralMap(ast) {
                        return new LiteralMap(ast.keys, this.visitAll(ast.values));
                    }
                }, {
                    key: "visitBinary",
                    value: function visitBinary(ast) {
                        return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
                    }
                }, {
                    key: "visitPrefixNot",
                    value: function visitPrefixNot(ast) {
                        return new PrefixNot(ast.expression.visit(this));
                    }
                }, {
                    key: "visitConditional",
                    value: function visitConditional(ast) {
                        return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
                    }
                }, {
                    key: "visitPipe",
                    value: function visitPipe(ast) {
                        return new Pipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.inBinding);
                    }
                }, {
                    key: "visitKeyedAccess",
                    value: function visitKeyedAccess(ast) {
                        return new KeyedAccess(ast.obj.visit(this), ast.key.visit(this));
                    }
                }, {
                    key: "visitAll",
                    value: function visitAll(asts) {
                        var res = ListWrapper.createFixedSize(asts.length);
                        for (var i = 0; i < asts.length; ++i) {
                            res[i] = asts[i].visit(this);
                        }
                        return res;
                    }
                }]);

                return AstTransformer;
            })();

            _export("AstTransformer", AstTransformer);

            _evalListCache = [[], [0], [0, 0], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
        }
    };
});

// do nothing
System.register('angular2/src/change_detection/proto_change_detector', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/facade/lang', 'angular2/src/facade/collection', 'angular2/src/change_detection/parser/ast', 'angular2/src/change_detection/interfaces', 'angular2/src/change_detection/change_detection_util', 'angular2/src/change_detection/dynamic_change_detector', 'angular2/src/change_detection/change_detection_jit_generator', 'angular2/src/change_detection/directive_record', 'angular2/src/change_detection/coalesce', 'angular2/src/change_detection/proto_record'], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, BaseException, isPresent, isString, ListWrapper, ImplicitReceiver, ProtoChangeDetector, ChangeDetectionUtil, DynamicChangeDetector, ChangeDetectorJITGenerator, DirectiveIndex, coalesce, ProtoRecord, RECORD_TYPE_PROPERTY, RECORD_TYPE_LOCAL, RECORD_TYPE_INVOKE_METHOD, RECORD_TYPE_CONST, RECORD_TYPE_INVOKE_CLOSURE, RECORD_TYPE_PRIMITIVE_OP, RECORD_TYPE_KEYED_ACCESS, RECORD_TYPE_PIPE, RECORD_TYPE_BINDING_PIPE, RECORD_TYPE_INTERPOLATE, RECORD_TYPE_SAFE_PROPERTY, RECORD_TYPE_SAFE_INVOKE_METHOD, RECORD_TYPE_DIRECTIVE_LIFECYCLE, DynamicProtoChangeDetector, _jitProtoChangeDetectorClassCounter, JitProtoChangeDetector, ProtoRecordBuilder, _ConvertAstIntoProtoRecords;

    function _arrayFn(length) {
        switch (length) {
            case 0:
                return ChangeDetectionUtil.arrayFn0;
            case 1:
                return ChangeDetectionUtil.arrayFn1;
            case 2:
                return ChangeDetectionUtil.arrayFn2;
            case 3:
                return ChangeDetectionUtil.arrayFn3;
            case 4:
                return ChangeDetectionUtil.arrayFn4;
            case 5:
                return ChangeDetectionUtil.arrayFn5;
            case 6:
                return ChangeDetectionUtil.arrayFn6;
            case 7:
                return ChangeDetectionUtil.arrayFn7;
            case 8:
                return ChangeDetectionUtil.arrayFn8;
            case 9:
                return ChangeDetectionUtil.arrayFn9;
            default:
                throw new BaseException('Does not support literal maps with more than 9 elements');
        }
    }
    function _mapPrimitiveName(keys) {
        var stringifiedKeys = ListWrapper.join(ListWrapper.map(keys, function (k) {
            return isString(k) ? '"' + k + '"' : '' + k;
        }), ', ');
        return 'mapFn([' + stringifiedKeys + '])';
    }
    function _operationToPrimitiveName(operation) {
        switch (operation) {
            case '+':
                return 'operation_add';
            case '-':
                return 'operation_subtract';
            case '*':
                return 'operation_multiply';
            case '/':
                return 'operation_divide';
            case '%':
                return 'operation_remainder';
            case '==':
                return 'operation_equals';
            case '!=':
                return 'operation_not_equals';
            case '===':
                return 'operation_identical';
            case '!==':
                return 'operation_not_identical';
            case '<':
                return 'operation_less_then';
            case '>':
                return 'operation_greater_then';
            case '<=':
                return 'operation_less_or_equals_then';
            case '>=':
                return 'operation_greater_or_equals_then';
            case '&&':
                return 'operation_logical_and';
            case '||':
                return 'operation_logical_or';
            default:
                throw new BaseException('Unsupported operation ' + operation);
        }
    }
    function _operationToFunction(operation) {
        switch (operation) {
            case '+':
                return ChangeDetectionUtil.operation_add;
            case '-':
                return ChangeDetectionUtil.operation_subtract;
            case '*':
                return ChangeDetectionUtil.operation_multiply;
            case '/':
                return ChangeDetectionUtil.operation_divide;
            case '%':
                return ChangeDetectionUtil.operation_remainder;
            case '==':
                return ChangeDetectionUtil.operation_equals;
            case '!=':
                return ChangeDetectionUtil.operation_not_equals;
            case '===':
                return ChangeDetectionUtil.operation_identical;
            case '!==':
                return ChangeDetectionUtil.operation_not_identical;
            case '<':
                return ChangeDetectionUtil.operation_less_then;
            case '>':
                return ChangeDetectionUtil.operation_greater_then;
            case '<=':
                return ChangeDetectionUtil.operation_less_or_equals_then;
            case '>=':
                return ChangeDetectionUtil.operation_greater_or_equals_then;
            case '&&':
                return ChangeDetectionUtil.operation_logical_and;
            case '||':
                return ChangeDetectionUtil.operation_logical_or;
            default:
                throw new BaseException('Unsupported operation ' + operation);
        }
    }
    function s(v) {
        return isPresent(v) ? '' + v : '';
    }
    function _interpolationFn(strings) {
        var length = strings.length;
        var c0 = length > 0 ? strings[0] : null;
        var c1 = length > 1 ? strings[1] : null;
        var c2 = length > 2 ? strings[2] : null;
        var c3 = length > 3 ? strings[3] : null;
        var c4 = length > 4 ? strings[4] : null;
        var c5 = length > 5 ? strings[5] : null;
        var c6 = length > 6 ? strings[6] : null;
        var c7 = length > 7 ? strings[7] : null;
        var c8 = length > 8 ? strings[8] : null;
        var c9 = length > 9 ? strings[9] : null;
        switch (length - 1) {
            case 1:
                return function (a1) {
                    return c0 + s(a1) + c1;
                };
            case 2:
                return function (a1, a2) {
                    return c0 + s(a1) + c1 + s(a2) + c2;
                };
            case 3:
                return function (a1, a2, a3) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3;
                };
            case 4:
                return function (a1, a2, a3, a4) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4;
                };
            case 5:
                return function (a1, a2, a3, a4, a5) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
                };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
                };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7;
                };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8;
                };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8 + s(a9) + c9;
                };
            default:
                throw new BaseException('Does not support more than 9 expressions');
        }
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
            isPresent = _angular2SrcFacadeLang.isPresent;
            isString = _angular2SrcFacadeLang.isString;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcChange_detectionParserAst) {
            ImplicitReceiver = _angular2SrcChange_detectionParserAst.ImplicitReceiver;
        }, function (_angular2SrcChange_detectionInterfaces) {
            ProtoChangeDetector = _angular2SrcChange_detectionInterfaces.ProtoChangeDetector;
        }, function (_angular2SrcChange_detectionChange_detection_util) {
            ChangeDetectionUtil = _angular2SrcChange_detectionChange_detection_util.ChangeDetectionUtil;
        }, function (_angular2SrcChange_detectionDynamic_change_detector) {
            DynamicChangeDetector = _angular2SrcChange_detectionDynamic_change_detector.DynamicChangeDetector;
        }, function (_angular2SrcChange_detectionChange_detection_jit_generator) {
            ChangeDetectorJITGenerator = _angular2SrcChange_detectionChange_detection_jit_generator.ChangeDetectorJITGenerator;
        }, function (_angular2SrcChange_detectionDirective_record) {
            DirectiveIndex = _angular2SrcChange_detectionDirective_record.DirectiveIndex;
        }, function (_angular2SrcChange_detectionCoalesce) {
            coalesce = _angular2SrcChange_detectionCoalesce.coalesce;
        }, function (_angular2SrcChange_detectionProto_record) {
            ProtoRecord = _angular2SrcChange_detectionProto_record.ProtoRecord;
            RECORD_TYPE_PROPERTY = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PROPERTY;
            RECORD_TYPE_LOCAL = _angular2SrcChange_detectionProto_record.RECORD_TYPE_LOCAL;
            RECORD_TYPE_INVOKE_METHOD = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INVOKE_METHOD;
            RECORD_TYPE_CONST = _angular2SrcChange_detectionProto_record.RECORD_TYPE_CONST;
            RECORD_TYPE_INVOKE_CLOSURE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INVOKE_CLOSURE;
            RECORD_TYPE_PRIMITIVE_OP = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PRIMITIVE_OP;
            RECORD_TYPE_KEYED_ACCESS = _angular2SrcChange_detectionProto_record.RECORD_TYPE_KEYED_ACCESS;
            RECORD_TYPE_PIPE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_PIPE;
            RECORD_TYPE_BINDING_PIPE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_BINDING_PIPE;
            RECORD_TYPE_INTERPOLATE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_INTERPOLATE;
            RECORD_TYPE_SAFE_PROPERTY = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SAFE_PROPERTY;
            RECORD_TYPE_SAFE_INVOKE_METHOD = _angular2SrcChange_detectionProto_record.RECORD_TYPE_SAFE_INVOKE_METHOD;
            RECORD_TYPE_DIRECTIVE_LIFECYCLE = _angular2SrcChange_detectionProto_record.RECORD_TYPE_DIRECTIVE_LIFECYCLE;
        }],
        execute: function () {
            'use strict';

            DynamicProtoChangeDetector = (function (_ProtoChangeDetector) {
                function DynamicProtoChangeDetector(_pipeRegistry, definition) {
                    _classCallCheck(this, DynamicProtoChangeDetector);

                    _get(Object.getPrototypeOf(DynamicProtoChangeDetector.prototype), 'constructor', this).call(this);
                    this._pipeRegistry = _pipeRegistry;
                    this.definition = definition;
                    this._records = this._createRecords(definition);
                }

                _inherits(DynamicProtoChangeDetector, _ProtoChangeDetector);

                _createClass(DynamicProtoChangeDetector, [{
                    key: 'instantiate',
                    value: function instantiate(dispatcher) {
                        return new DynamicChangeDetector(this.definition.strategy, dispatcher, this._pipeRegistry, this._records, this.definition.directiveRecords);
                    }
                }, {
                    key: '_createRecords',
                    value: function _createRecords(definition) {
                        var recordBuilder = new ProtoRecordBuilder();
                        ListWrapper.forEach(definition.bindingRecords, function (b) {
                            recordBuilder.add(b, definition.variableNames);
                        });
                        return coalesce(recordBuilder.records);
                    }
                }]);

                return DynamicProtoChangeDetector;
            })(ProtoChangeDetector);

            _export('DynamicProtoChangeDetector', DynamicProtoChangeDetector);

            _jitProtoChangeDetectorClassCounter = 0;

            JitProtoChangeDetector = (function (_ProtoChangeDetector2) {
                function JitProtoChangeDetector(_pipeRegistry, definition) {
                    _classCallCheck(this, JitProtoChangeDetector);

                    _get(Object.getPrototypeOf(JitProtoChangeDetector.prototype), 'constructor', this).call(this);
                    this._pipeRegistry = _pipeRegistry;
                    this.definition = definition;
                    this._factory = this._createFactory(definition);
                }

                _inherits(JitProtoChangeDetector, _ProtoChangeDetector2);

                _createClass(JitProtoChangeDetector, [{
                    key: 'instantiate',
                    value: function instantiate(dispatcher) {
                        return this._factory(dispatcher, this._pipeRegistry);
                    }
                }, {
                    key: '_createFactory',
                    value: function _createFactory(definition) {
                        var recordBuilder = new ProtoRecordBuilder();
                        ListWrapper.forEach(definition.bindingRecords, function (b) {
                            recordBuilder.add(b, definition.variableNames);
                        });
                        var c = _jitProtoChangeDetectorClassCounter++;
                        var records = coalesce(recordBuilder.records);
                        var typeName = 'ChangeDetector' + c;
                        return new ChangeDetectorJITGenerator(typeName, definition.strategy, records, this.definition.directiveRecords).generate();
                    }
                }]);

                return JitProtoChangeDetector;
            })(ProtoChangeDetector);

            _export('JitProtoChangeDetector', JitProtoChangeDetector);

            ProtoRecordBuilder = (function () {
                function ProtoRecordBuilder() {
                    _classCallCheck(this, ProtoRecordBuilder);

                    this.records = [];
                }

                _createClass(ProtoRecordBuilder, [{
                    key: 'add',
                    value: function add(b) {
                        var variableNames = arguments[1] === undefined ? null : arguments[1];

                        var oldLast = ListWrapper.last(this.records);
                        if (isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {
                            oldLast.lastInDirective = false;
                        }
                        this._appendRecords(b, variableNames);
                        var newLast = ListWrapper.last(this.records);
                        if (isPresent(newLast) && newLast !== oldLast) {
                            newLast.lastInBinding = true;
                            newLast.lastInDirective = true;
                        }
                    }
                }, {
                    key: '_appendRecords',
                    value: function _appendRecords(b, variableNames) {
                        if (b.isDirectiveLifecycle()) {
                            ;
                            ListWrapper.push(this.records, new ProtoRecord(RECORD_TYPE_DIRECTIVE_LIFECYCLE, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, null, false, false));
                        } else {
                            _ConvertAstIntoProtoRecords.append(this.records, b, variableNames);
                        }
                    }
                }]);

                return ProtoRecordBuilder;
            })();

            _ConvertAstIntoProtoRecords = (function () {
                function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _expressionAsString, _variableNames) {
                    _classCallCheck(this, _ConvertAstIntoProtoRecords);

                    this._records = _records;
                    this._bindingRecord = _bindingRecord;
                    this._expressionAsString = _expressionAsString;
                    this._variableNames = _variableNames;
                }

                _createClass(_ConvertAstIntoProtoRecords, [{
                    key: 'visitImplicitReceiver',
                    value: function visitImplicitReceiver(ast) {
                        return this._bindingRecord.implicitReceiver;
                    }
                }, {
                    key: 'visitInterpolation',
                    value: function visitInterpolation(ast) {
                        var args = this._visitAll(ast.expressions);
                        return this._addRecord(RECORD_TYPE_INTERPOLATE, 'interpolate', _interpolationFn(ast.strings), args, ast.strings, 0);
                    }
                }, {
                    key: 'visitLiteralPrimitive',
                    value: function visitLiteralPrimitive(ast) {
                        return this._addRecord(RECORD_TYPE_CONST, 'literal', ast.value, [], null, 0);
                    }
                }, {
                    key: 'visitAccessMember',
                    value: function visitAccessMember(ast) {
                        var receiver = ast.receiver.visit(this);
                        if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name) && ast.receiver instanceof ImplicitReceiver) {
                            return this._addRecord(RECORD_TYPE_LOCAL, ast.name, ast.name, [], null, receiver);
                        } else {
                            return this._addRecord(RECORD_TYPE_PROPERTY, ast.name, ast.getter, [], null, receiver);
                        }
                    }
                }, {
                    key: 'visitSafeAccessMember',
                    value: function visitSafeAccessMember(ast) {
                        var receiver = ast.receiver.visit(this);
                        return this._addRecord(RECORD_TYPE_SAFE_PROPERTY, ast.name, ast.getter, [], null, receiver);
                    }
                }, {
                    key: 'visitMethodCall',
                    value: function visitMethodCall(ast) {
                        var receiver = ast.receiver.visit(this);
                        var args = this._visitAll(ast.args);
                        if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name)) {
                            var target = this._addRecord(RECORD_TYPE_LOCAL, ast.name, ast.name, [], null, receiver);
                            return this._addRecord(RECORD_TYPE_INVOKE_CLOSURE, 'closure', null, args, null, target);
                        } else {
                            return this._addRecord(RECORD_TYPE_INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
                        }
                    }
                }, {
                    key: 'visitSafeMethodCall',
                    value: function visitSafeMethodCall(ast) {
                        var receiver = ast.receiver.visit(this);
                        var args = this._visitAll(ast.args);
                        return this._addRecord(RECORD_TYPE_SAFE_INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
                    }
                }, {
                    key: 'visitFunctionCall',
                    value: function visitFunctionCall(ast) {
                        var target = ast.target.visit(this);
                        var args = this._visitAll(ast.args);
                        return this._addRecord(RECORD_TYPE_INVOKE_CLOSURE, 'closure', null, args, null, target);
                    }
                }, {
                    key: 'visitLiteralArray',
                    value: function visitLiteralArray(ast) {
                        var primitiveName = 'arrayFn' + ast.expressions.length;
                        return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
                    }
                }, {
                    key: 'visitLiteralMap',
                    value: function visitLiteralMap(ast) {
                        return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, _mapPrimitiveName(ast.keys), ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
                    }
                }, {
                    key: 'visitBinary',
                    value: function visitBinary(ast) {
                        var left = ast.left.visit(this);
                        var right = ast.right.visit(this);
                        return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
                    }
                }, {
                    key: 'visitPrefixNot',
                    value: function visitPrefixNot(ast) {
                        var exp = ast.expression.visit(this);
                        return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, 'operation_negate', ChangeDetectionUtil.operation_negate, [exp], null, 0);
                    }
                }, {
                    key: 'visitConditional',
                    value: function visitConditional(ast) {
                        var c = ast.condition.visit(this);
                        var t = ast.trueExp.visit(this);
                        var f = ast.falseExp.visit(this);
                        return this._addRecord(RECORD_TYPE_PRIMITIVE_OP, 'cond', ChangeDetectionUtil.cond, [c, t, f], null, 0);
                    }
                }, {
                    key: 'visitPipe',
                    value: function visitPipe(ast) {
                        var value = ast.exp.visit(this);
                        var type = ast.inBinding ? RECORD_TYPE_BINDING_PIPE : RECORD_TYPE_PIPE;
                        return this._addRecord(type, ast.name, ast.name, [], null, value);
                    }
                }, {
                    key: 'visitKeyedAccess',
                    value: function visitKeyedAccess(ast) {
                        var obj = ast.obj.visit(this);
                        var key = ast.key.visit(this);
                        return this._addRecord(RECORD_TYPE_KEYED_ACCESS, 'keyedAccess', ChangeDetectionUtil.keyedAccess, [key], null, obj);
                    }
                }, {
                    key: '_visitAll',
                    value: function _visitAll(asts) {
                        var res = ListWrapper.createFixedSize(asts.length);
                        for (var i = 0; i < asts.length; ++i) {
                            res[i] = asts[i].visit(this);
                        }
                        return res;
                    }
                }, {
                    key: '_addRecord',
                    value: function _addRecord(type, name, funcOrValue, args, fixedArgs, context) {
                        var selfIndex = this._records.length + 1;
                        if (context instanceof DirectiveIndex) {
                            ListWrapper.push(this._records, new ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, this._expressionAsString, false, false));
                        } else {
                            ListWrapper.push(this._records, new ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, this._expressionAsString, false, false));
                        }
                        return selfIndex;
                    }
                }], [{
                    key: 'append',
                    value: function append(records, b, variableNames) {
                        var c = new _ConvertAstIntoProtoRecords(records, b, b.ast.toString(), variableNames);
                        b.ast.visit(c);
                    }
                }]);

                return _ConvertAstIntoProtoRecords;
            })();
        }
    };
});
System.register('angular2/src/di/injector', ['npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/create-class', 'angular2/src/facade/collection', 'angular2/src/di/binding', 'angular2/src/di/exceptions', 'angular2/src/facade/lang', 'angular2/src/facade/async', 'angular2/src/di/key', 'angular2/src/di/forward_ref'], function (_export) {
    var _classCallCheck, _createClass, List, MapWrapper, ListWrapper, ResolvedBinding, Binding, BindingBuilder, bind, AbstractBindingError, NoBindingError, AsyncBindingError, CyclicDependencyError, InstantiationError, InvalidBindingError, FunctionWrapper, Type, isPresent, isBlank, CONST_EXPR, PromiseWrapper, Key, resolveForwardRef, _constructing, _notFound, _Waiting, Injector, _SyncInjectorStrategy, _AsyncInjectorStrategy;

    function _isWaiting(obj) {
        return obj instanceof _Waiting;
    }

    function resolveBindings(bindings) {
        var resolvedList = ListWrapper.createFixedSize(bindings.length);
        for (var i = 0; i < bindings.length; i++) {
            var unresolved = resolveForwardRef(bindings[i]);
            var resolved;
            if (unresolved instanceof ResolvedBinding) {
                resolved = unresolved; // ha-ha! I'm easily amused
            } else if (unresolved instanceof Type) {
                resolved = bind(unresolved).toClass(unresolved).resolve();
            } else if (unresolved instanceof Binding) {
                resolved = unresolved.resolve();
            } else if (unresolved instanceof List) {
                resolved = resolveBindings(unresolved);
            } else if (unresolved instanceof BindingBuilder) {
                throw new InvalidBindingError(unresolved.token);
            } else {
                throw new InvalidBindingError(unresolved);
            }
            resolvedList[i] = resolved;
        }
        return resolvedList;
    }

    function flattenBindings(bindings) {
        var map = _flattenBindings(bindings, MapWrapper.create());
        var res = ListWrapper.create();
        MapWrapper.forEach(map, function (binding, keyId) {
            return ListWrapper.push(res, binding);
        });
        return res;
    }
    function _createListOfBindings(flattenedBindings) {
        var bindings = ListWrapper.createFixedSize(Key.numberOfKeys + 1);
        MapWrapper.forEach(flattenedBindings, function (v, keyId) {
            return bindings[keyId] = v;
        });
        return bindings;
    }
    function _flattenBindings(bindings, res) {
        ListWrapper.forEach(bindings, function (b) {
            if (b instanceof ResolvedBinding) {
                MapWrapper.set(res, b.key.id, b);
            } else if (b instanceof List) {
                _flattenBindings(b, res);
            }
        });
        return res;
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_angular2SrcFacadeCollection) {
            List = _angular2SrcFacadeCollection.List;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcDiBinding) {
            ResolvedBinding = _angular2SrcDiBinding.ResolvedBinding;
            Binding = _angular2SrcDiBinding.Binding;
            BindingBuilder = _angular2SrcDiBinding.BindingBuilder;
            bind = _angular2SrcDiBinding.bind;
        }, function (_angular2SrcDiExceptions) {
            AbstractBindingError = _angular2SrcDiExceptions.AbstractBindingError;
            NoBindingError = _angular2SrcDiExceptions.NoBindingError;
            AsyncBindingError = _angular2SrcDiExceptions.AsyncBindingError;
            CyclicDependencyError = _angular2SrcDiExceptions.CyclicDependencyError;
            InstantiationError = _angular2SrcDiExceptions.InstantiationError;
            InvalidBindingError = _angular2SrcDiExceptions.InvalidBindingError;
        }, function (_angular2SrcFacadeLang) {
            FunctionWrapper = _angular2SrcFacadeLang.FunctionWrapper;
            Type = _angular2SrcFacadeLang.Type;
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcDiKey) {
            Key = _angular2SrcDiKey.Key;
        }, function (_angular2SrcDiForward_ref) {
            resolveForwardRef = _angular2SrcDiForward_ref.resolveForwardRef;
        }],
        execute: function () {
            /// <reference path="../../typings/es6-promise/es6-promise.d.ts" />
            'use strict';

            _export('resolveBindings', resolveBindings);

            _constructing = CONST_EXPR(new Object());
            _notFound = CONST_EXPR(new Object());

            _Waiting = function _Waiting(promise) {
                _classCallCheck(this, _Waiting);

                this.promise = promise;
            };

            /**
             * A dependency injection container used for resolving dependencies.
             *
             * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
             * constructor dependencies.
             * In typical use, application code asks for the dependencies in the constructor and they are
             * resolved by the `Injector`.
             *
             * ## Example:
             *
             * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:
             *
             * ```javascript
             * class Engine {
             * }
             *
             * class Car {
             *   constructor(@Inject(Engine) engine) {
             *   }
             * }
             *
             * ```
             *
             * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the
             * `root` object, `Car`, so that the `Injector` can recursively build all of that object's
             *dependencies.
             *
             * ```javascript
             * main() {
             *   var injector = Injector.resolveAndCreate([Car, Engine]);
             *
             *   // Get a reference to the `root` object, which will recursively instantiate the tree.
             *   var car = injector.get(Car);
             * }
             * ```
             * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`
             * resolve all of the object's dependencies automatically.
             *
             * @exportedAs angular2/di
             */

            Injector = (function () {
                /**
                 * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the {@link
                 * Injector}.
                 * @param `parent` Parent Injector or `null` if root Injector.
                 * @param `defaultBindings` Setting to true will auto-create bindings. (Only use with root
                 * injector.)
                 */

                function Injector(_bindings, _parent, _defaultBindings) {
                    _classCallCheck(this, Injector);

                    this._bindings = _bindings;
                    this._parent = _parent;
                    this._defaultBindings = _defaultBindings;
                    this._instances = this._createInstances();
                    this._asyncStrategy = new _AsyncInjectorStrategy(this);
                    this._syncStrategy = new _SyncInjectorStrategy(this);
                }

                _createClass(Injector, [{
                    key: 'parent',

                    /**
                     * Direct parent of this injector.
                     */
                    get: function () {
                        return this._parent;
                    }
                }, {
                    key: 'get',

                    /**
                     * Retrieves an instance from the injector.
                     *
                     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a
                     *binding).
                     * @returns an instance represented by the token. Throws if not found.
                     */
                    value: function get(token) {
                        return this._getByKey(Key.get(token), false, false, false);
                    }
                }, {
                    key: 'getOptional',

                    /**
                     * Retrieves an instance from the injector.
                     *
                     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).
                     * @returns an instance represented by the token. Returns `null` if not found.
                     */
                    value: function getOptional(token) {
                        return this._getByKey(Key.get(token), false, false, true);
                    }
                }, {
                    key: 'asyncGet',

                    /**
                     * Retrieves an instance from the injector asynchronously. Used with asynchronous bindings.
                     *
                     * @param `token`: usually a `Type`. (Same as token used while setting up a binding).
                     * @returns a `Promise` which resolves to the instance represented by the token.
                     */
                    value: function asyncGet(token) {
                        return this._getByKey(Key.get(token), true, false, false);
                    }
                }, {
                    key: 'resolveAndCreateChild',

                    /**
                     * Creates a child injector and loads a new set of bindings into it.
                     *
                     * A resolution is a process of flattening multiple nested lists and converting individual
                     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`
                     * for the {@link Injector} for performance-sensitive code.
                     *
                     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
                     * recursive list of more bindings.
                     *
                     */
                    value: function resolveAndCreateChild(bindings) {
                        return new Injector(Injector.resolve(bindings), this, false);
                    }
                }, {
                    key: 'createChildFromResolved',

                    /**
                     * Creates a child injector and loads a new set of {@link ResolvedBinding}s into it.
                     *
                     * @param `bindings`: A sparse list of {@link ResolvedBinding}s.
                     * See `resolve` for the {@link Injector}.
                     * @returns a new child {@link Injector}.
                     */
                    value: function createChildFromResolved(bindings) {
                        return new Injector(bindings, this, false);
                    }
                }, {
                    key: '_createInstances',
                    value: function _createInstances() {
                        return ListWrapper.createFixedSize(Key.numberOfKeys + 1);
                    }
                }, {
                    key: '_getByKey',
                    value: function _getByKey(key, returnPromise, returnLazy, optional) {
                        var _this = this;

                        if (returnLazy) {
                            return function () {
                                return _this._getByKey(key, returnPromise, false, optional);
                            };
                        }
                        var strategy = returnPromise ? this._asyncStrategy : this._syncStrategy;
                        var instance = strategy.readFromCache(key);
                        if (instance !== _notFound) return instance;
                        instance = strategy.instantiate(key);
                        if (instance !== _notFound) return instance;
                        if (isPresent(this._parent)) {
                            return this._parent._getByKey(key, returnPromise, returnLazy, optional);
                        }
                        if (optional) {
                            return null;
                        } else {
                            throw new NoBindingError(key);
                        }
                    }
                }, {
                    key: '_resolveDependencies',
                    value: function _resolveDependencies(key, binding, forceAsync) {
                        var _this2 = this;

                        try {
                            var getDependency = function getDependency(d) {
                                return _this2._getByKey(d.key, forceAsync || d.asPromise, d.lazy, d.optional);
                            };
                            return ListWrapper.map(binding.dependencies, getDependency);
                        } catch (e) {
                            this._clear(key);
                            if (e instanceof AbstractBindingError) e.addKey(key);
                            throw e;
                        }
                    }
                }, {
                    key: '_getInstance',
                    value: function _getInstance(key) {
                        if (this._instances.length <= key.id) return null;
                        return ListWrapper.get(this._instances, key.id);
                    }
                }, {
                    key: '_setInstance',
                    value: function _setInstance(key, obj) {
                        ListWrapper.set(this._instances, key.id, obj);
                    }
                }, {
                    key: '_getBinding',
                    value: function _getBinding(key) {
                        var binding = this._bindings.length <= key.id ? null : ListWrapper.get(this._bindings, key.id);
                        if (isBlank(binding) && this._defaultBindings) {
                            var token = key.token;
                            return bind(key.token).toClass(token).resolve();
                        } else {
                            return binding;
                        }
                    }
                }, {
                    key: '_markAsConstructing',
                    value: function _markAsConstructing(key) {
                        this._setInstance(key, _constructing);
                    }
                }, {
                    key: '_clear',
                    value: function _clear(key) {
                        this._setInstance(key, null);
                    }
                }], [{
                    key: 'resolve',

                    /**
                     * Turns a list of binding definitions into an internal resolved list of resolved bindings.
                     *
                     * A resolution is a process of flattening multiple nested lists and converting individual
                     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`
                     * for the {@link Injector} for performance-sensitive code.
                     *
                     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
                     * recursive list of more bindings.
                     *
                     * The returned list is sparse, indexed by `id` for the {@link Key}. It is generally not useful to
                     *application code
                     * other than for passing it to {@link Injector} functions that require resolved binding lists,
                     *such as
                     * `fromResolvedBindings` and `createChildFromResolved`.
                     */
                    value: function resolve(bindings) {
                        var resolvedBindings = resolveBindings(bindings);
                        var flatten = _flattenBindings(resolvedBindings, MapWrapper.create());
                        return _createListOfBindings(flatten);
                    }
                }, {
                    key: 'resolveAndCreate',

                    /**
                     * Resolves bindings and creates an injector based on those bindings. This function is slower than
                     * the corresponding `fromResolvedBindings` because it needs to resolve bindings first. See
                     *`resolve`
                     * for the {@link Injector}.
                     *
                     * Prefer `fromResolvedBindings` in performance-critical code that creates lots of injectors.
                     *
                     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
                     *recursive list of more
                     * bindings.
                     * @param `defaultBindings` Setting to true will auto-create bindings.
                     */
                    value: function resolveAndCreate(bindings) {
                        var _ref = arguments[1] === undefined ? {} : arguments[1];

                        var _ref$defaultBindings = _ref.defaultBindings;
                        var defaultBindings = _ref$defaultBindings === undefined ? false : _ref$defaultBindings;

                        return new Injector(Injector.resolve(bindings), null, defaultBindings);
                    }
                }, {
                    key: 'fromResolvedBindings',

                    /**
                     * Creates an injector from previously resolved bindings. This bypasses resolution and flattening.
                     * This API is the recommended way to construct injectors in performance-sensitive parts.
                     *
                     * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the {@link
                     *Injector}.
                     * @param `defaultBindings` Setting to true will auto-create bindings.
                     */
                    value: function fromResolvedBindings(bindings) {
                        var _ref2 = arguments[1] === undefined ? {} : arguments[1];

                        var _ref2$defaultBindings = _ref2.defaultBindings;
                        var defaultBindings = _ref2$defaultBindings === undefined ? false : _ref2$defaultBindings;

                        return new Injector(bindings, null, defaultBindings);
                    }
                }]);

                return Injector;
            })();

            _export('Injector', Injector);

            _SyncInjectorStrategy = (function () {
                function _SyncInjectorStrategy(_injector) {
                    _classCallCheck(this, _SyncInjectorStrategy);

                    this._injector = _injector;
                }

                _createClass(_SyncInjectorStrategy, [{
                    key: 'readFromCache',
                    value: function readFromCache(key) {
                        if (key.token === Injector) {
                            return this._injector;
                        }
                        var instance = this._injector._getInstance(key);
                        if (instance === _constructing) {
                            throw new CyclicDependencyError(key);
                        } else if (isPresent(instance) && !_isWaiting(instance)) {
                            return instance;
                        } else {
                            return _notFound;
                        }
                    }
                }, {
                    key: 'instantiate',
                    value: function instantiate(key) {
                        var binding = this._injector._getBinding(key);
                        if (isBlank(binding)) return _notFound;
                        if (binding.providedAsPromise) throw new AsyncBindingError(key);
                        // add a marker so we can detect cyclic dependencies
                        this._injector._markAsConstructing(key);
                        var deps = this._injector._resolveDependencies(key, binding, false);
                        return this._createInstance(key, binding, deps);
                    }
                }, {
                    key: '_createInstance',
                    value: function _createInstance(key, binding, deps) {
                        try {
                            var instance = FunctionWrapper.apply(binding.factory, deps);
                            this._injector._setInstance(key, instance);
                            return instance;
                        } catch (e) {
                            this._injector._clear(key);
                            throw new InstantiationError(e, key);
                        }
                    }
                }]);

                return _SyncInjectorStrategy;
            })();

            _AsyncInjectorStrategy = (function () {
                function _AsyncInjectorStrategy(_injector) {
                    _classCallCheck(this, _AsyncInjectorStrategy);

                    this._injector = _injector;
                }

                _createClass(_AsyncInjectorStrategy, [{
                    key: 'readFromCache',
                    value: function readFromCache(key) {
                        if (key.token === Injector) {
                            return PromiseWrapper.resolve(this._injector);
                        }
                        var instance = this._injector._getInstance(key);
                        if (instance === _constructing) {
                            throw new CyclicDependencyError(key);
                        } else if (_isWaiting(instance)) {
                            return instance.promise;
                        } else if (isPresent(instance)) {
                            return PromiseWrapper.resolve(instance);
                        } else {
                            return _notFound;
                        }
                    }
                }, {
                    key: 'instantiate',
                    value: function instantiate(key) {
                        var _this3 = this;

                        var binding = this._injector._getBinding(key);
                        if (isBlank(binding)) return _notFound;
                        // add a marker so we can detect cyclic dependencies
                        this._injector._markAsConstructing(key);
                        var deps = this._injector._resolveDependencies(key, binding, true);
                        var depsPromise = PromiseWrapper.all(deps);
                        var promise = PromiseWrapper.then(depsPromise, null, function (e, s) {
                            return _this3._errorHandler(key, e, s);
                        }).then(function (deps) {
                            return _this3._findOrCreate(key, binding, deps);
                        }).then(function (instance) {
                            return _this3._cacheInstance(key, instance);
                        });
                        this._injector._setInstance(key, new _Waiting(promise));
                        return promise;
                    }
                }, {
                    key: '_errorHandler',
                    value: function _errorHandler(key, e, stack) {
                        if (e instanceof AbstractBindingError) e.addKey(key);
                        return PromiseWrapper.reject(e, stack);
                    }
                }, {
                    key: '_findOrCreate',
                    value: function _findOrCreate(key, binding, deps) {
                        try {
                            var instance = this._injector._getInstance(key);
                            if (!_isWaiting(instance)) return instance;
                            return FunctionWrapper.apply(binding.factory, deps);
                        } catch (e) {
                            this._injector._clear(key);
                            throw new InstantiationError(e, key);
                        }
                    }
                }, {
                    key: '_cacheInstance',
                    value: function _cacheInstance(key, instance) {
                        this._injector._setInstance(key, instance);
                        return instance;
                    }
                }]);

                return _AsyncInjectorStrategy;
            })();
        }
    };
});
System.register("angular2/src/core/compiler/view_manager", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref", "angular2/src/render/api", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/view_pool", "angular2/src/core/compiler/view_listener"], function (_export) {
    var _createClass, _classCallCheck, Injectable, isPresent, isBlank, BaseException, ViewRef, internalView, internalProtoView, Renderer, AppViewManagerUtils, AppViewPool, AppViewListener, __decorate, __metadata, AppViewManager;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcCoreCompilerView_ref) {
            ViewRef = _angular2SrcCoreCompilerView_ref.ViewRef;
            internalView = _angular2SrcCoreCompilerView_ref.internalView;
            internalProtoView = _angular2SrcCoreCompilerView_ref.internalProtoView;
        }, function (_angular2SrcRenderApi) {
            Renderer = _angular2SrcRenderApi.Renderer;
        }, function (_angular2SrcCoreCompilerView_manager_utils) {
            AppViewManagerUtils = _angular2SrcCoreCompilerView_manager_utils.AppViewManagerUtils;
        }, function (_angular2SrcCoreCompilerView_pool) {
            AppViewPool = _angular2SrcCoreCompilerView_pool.AppViewPool;
        }, function (_angular2SrcCoreCompilerView_listener) {
            AppViewListener = _angular2SrcCoreCompilerView_listener.AppViewListener;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Entry point for creating, moving views in the view hierarchy and destroying views.
             * This manager contains all recursion and delegates to helper methods
             * in AppViewManagerUtils and the Renderer, so unit tests get simpler.
             */

            AppViewManager = (function () {
                var _class = function AppViewManager(viewPool, viewListener, utils, renderer) {
                    _classCallCheck(this, _class);

                    this._viewPool = viewPool;
                    this._viewListener = viewListener;
                    this._utils = utils;
                    this._renderer = renderer;
                };

                _createClass(_class, [{
                    key: "getComponentView",
                    value: function getComponentView(hostLocation) {
                        var hostView = internalView(hostLocation.parentView);
                        var boundElementIndex = hostLocation.boundElementIndex;
                        return new ViewRef(hostView.componentChildViews[boundElementIndex]);
                    }
                }, {
                    key: "getViewContainer",
                    value: function getViewContainer(location) {
                        var hostView = internalView(location.parentView);
                        return hostView.elementInjectors[location.boundElementIndex].getViewContainerRef();
                    }
                }, {
                    key: "getComponent",
                    value: function getComponent(hostLocation) {
                        var hostView = internalView(hostLocation.parentView);
                        var boundElementIndex = hostLocation.boundElementIndex;
                        return this._utils.getComponentInstance(hostView, boundElementIndex);
                    }
                }, {
                    key: "createDynamicComponentView",
                    value: function createDynamicComponentView(hostLocation, componentProtoViewRef, componentBinding, injector) {
                        var componentProtoView = internalProtoView(componentProtoViewRef);
                        var hostView = internalView(hostLocation.parentView);
                        var boundElementIndex = hostLocation.boundElementIndex;
                        var binder = hostView.proto.elementBinders[boundElementIndex];
                        if (!binder.hasDynamicComponent()) {
                            throw new BaseException("There is no dynamic component directive at element " + boundElementIndex);
                        }
                        var componentView = this._createPooledView(componentProtoView);
                        this._renderer.attachComponentView(hostView.render, boundElementIndex, componentView.render);
                        this._utils.attachComponentView(hostView, boundElementIndex, componentView);
                        this._utils.hydrateDynamicComponentInElementInjector(hostView, boundElementIndex, componentBinding, injector);
                        this._utils.hydrateComponentView(hostView, boundElementIndex);
                        this._viewHydrateRecurse(componentView);
                        return new ViewRef(componentView);
                    }
                }, {
                    key: "createRootHostView",
                    value: function createRootHostView(hostProtoViewRef, overrideSelector, injector) {
                        var hostProtoView = internalProtoView(hostProtoViewRef);
                        var hostElementSelector = overrideSelector;
                        if (isBlank(hostElementSelector)) {
                            hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
                        }
                        var renderView = this._renderer.createRootHostView(hostProtoView.render, hostElementSelector);
                        var hostView = this._utils.createView(hostProtoView, renderView, this, this._renderer);
                        this._renderer.setEventDispatcher(hostView.render, hostView);
                        this._createViewRecurse(hostView);
                        this._viewListener.viewCreated(hostView);
                        this._utils.hydrateRootHostView(hostView, injector);
                        this._viewHydrateRecurse(hostView);
                        return new ViewRef(hostView);
                    }
                }, {
                    key: "destroyRootHostView",
                    value: function destroyRootHostView(hostViewRef) {
                        // Note: Don't detach the hostView as we want to leave the
                        // root element in place. Also don't put the hostView into the view pool
                        // as it is depending on the element for which it was created.
                        var hostView = internalView(hostViewRef);
                        // We do want to destroy the component view though.
                        this._viewDehydrateRecurse(hostView, true);
                        this._renderer.destroyView(hostView.render);
                        this._viewListener.viewDestroyed(hostView);
                    }
                }, {
                    key: "createFreeHostView",
                    value: function createFreeHostView(parentComponentLocation, hostProtoViewRef, injector) {
                        var hostProtoView = internalProtoView(hostProtoViewRef);
                        var hostView = this._createPooledView(hostProtoView);
                        var parentComponentHostView = internalView(parentComponentLocation.parentView);
                        var parentComponentBoundElementIndex = parentComponentLocation.boundElementIndex;
                        this._utils.attachAndHydrateFreeHostView(parentComponentHostView, parentComponentBoundElementIndex, hostView, injector);
                        this._viewHydrateRecurse(hostView);
                        return new ViewRef(hostView);
                    }
                }, {
                    key: "destroyFreeHostView",
                    value: function destroyFreeHostView(parentComponentLocation, hostViewRef) {
                        var hostView = internalView(hostViewRef);
                        var parentView = internalView(parentComponentLocation.parentView).componentChildViews[parentComponentLocation.boundElementIndex];
                        this._destroyFreeHostView(parentView, hostView);
                    }
                }, {
                    key: "createViewInContainer",
                    value: function createViewInContainer(viewContainerLocation, atIndex, protoViewRef) {
                        var context = arguments[3] === undefined ? null : arguments[3];
                        var injector = arguments[4] === undefined ? null : arguments[4];

                        var protoView = internalProtoView(protoViewRef);
                        var parentView = internalView(viewContainerLocation.parentView);
                        var boundElementIndex = viewContainerLocation.boundElementIndex;
                        var contextView = null;
                        var contextBoundElementIndex = null;
                        if (isPresent(context)) {
                            contextView = internalView(context.parentView);
                            contextBoundElementIndex = context.boundElementIndex;
                        }
                        var view = this._createPooledView(protoView);
                        this._renderer.attachViewInContainer(parentView.render, boundElementIndex, atIndex, view.render);
                        this._utils.attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view);
                        this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, injector);
                        this._viewHydrateRecurse(view);
                        return new ViewRef(view);
                    }
                }, {
                    key: "destroyViewInContainer",
                    value: function destroyViewInContainer(viewContainerLocation, atIndex) {
                        var parentView = internalView(viewContainerLocation.parentView);
                        var boundElementIndex = viewContainerLocation.boundElementIndex;
                        this._destroyViewInContainer(parentView, boundElementIndex, atIndex);
                    }
                }, {
                    key: "attachViewInContainer",
                    value: function attachViewInContainer(viewContainerLocation, atIndex, viewRef) {
                        var view = internalView(viewRef);
                        var parentView = internalView(viewContainerLocation.parentView);
                        var boundElementIndex = viewContainerLocation.boundElementIndex;
                        // TODO(tbosch): the public methods attachViewInContainer/detachViewInContainer
                        // are used for moving elements without the same container.
                        // We will change this into an atomic `move` operation, which should preserve the
                        // previous parent injector (see https://github.com/angular/angular/issues/1377).
                        // Right now we are destroying any special
                        // context view that might have been used.
                        this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, atIndex, view);
                        this._renderer.attachViewInContainer(parentView.render, boundElementIndex, atIndex, view.render);
                        return viewRef;
                    }
                }, {
                    key: "detachViewInContainer",
                    value: function detachViewInContainer(viewContainerLocation, atIndex) {
                        var parentView = internalView(viewContainerLocation.parentView);
                        var boundElementIndex = viewContainerLocation.boundElementIndex;
                        var viewContainer = parentView.viewContainers[boundElementIndex];
                        var view = viewContainer.views[atIndex];
                        this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
                        this._renderer.detachViewInContainer(parentView.render, boundElementIndex, atIndex, view.render);
                        return new ViewRef(view);
                    }
                }, {
                    key: "_createPooledView",
                    value: function _createPooledView(protoView) {
                        var view = this._viewPool.getView(protoView);
                        if (isBlank(view)) {
                            view = this._utils.createView(protoView, this._renderer.createView(protoView.render), this, this._renderer);
                            this._renderer.setEventDispatcher(view.render, view);
                            this._createViewRecurse(view);
                            this._viewListener.viewCreated(view);
                        }
                        return view;
                    }
                }, {
                    key: "_createViewRecurse",
                    value: function _createViewRecurse(view) {
                        var binders = view.proto.elementBinders;
                        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                            var binder = binders[binderIdx];
                            if (binder.hasStaticComponent()) {
                                var childView = this._createPooledView(binder.nestedProtoView);
                                this._renderer.attachComponentView(view.render, binderIdx, childView.render);
                                this._utils.attachComponentView(view, binderIdx, childView);
                            }
                        }
                    }
                }, {
                    key: "_destroyPooledView",
                    value: function _destroyPooledView(view) {
                        var wasReturned = this._viewPool.returnView(view);
                        if (!wasReturned) {
                            this._renderer.destroyView(view.render);
                            this._viewListener.viewDestroyed(view);
                        }
                    }
                }, {
                    key: "_destroyViewInContainer",
                    value: function _destroyViewInContainer(parentView, boundElementIndex, atIndex) {
                        var viewContainer = parentView.viewContainers[boundElementIndex];
                        var view = viewContainer.views[atIndex];
                        this._viewDehydrateRecurse(view, false);
                        this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
                        this._renderer.detachViewInContainer(parentView.render, boundElementIndex, atIndex, view.render);
                        this._destroyPooledView(view);
                    }
                }, {
                    key: "_destroyComponentView",
                    value: function _destroyComponentView(hostView, boundElementIndex, componentView) {
                        this._viewDehydrateRecurse(componentView, false);
                        this._renderer.detachComponentView(hostView.render, boundElementIndex, componentView.render);
                        this._utils.detachComponentView(hostView, boundElementIndex);
                        this._destroyPooledView(componentView);
                    }
                }, {
                    key: "_destroyFreeHostView",
                    value: function _destroyFreeHostView(parentView, hostView) {
                        this._viewDehydrateRecurse(hostView, true);
                        this._renderer.detachFreeHostView(parentView.render, hostView.render);
                        this._utils.detachFreeHostView(parentView, hostView);
                        this._destroyPooledView(hostView);
                    }
                }, {
                    key: "_viewHydrateRecurse",
                    value: function _viewHydrateRecurse(view) {
                        this._renderer.hydrateView(view.render);
                        var binders = view.proto.elementBinders;
                        for (var i = 0; i < binders.length; ++i) {
                            if (binders[i].hasStaticComponent()) {
                                this._utils.hydrateComponentView(view, i);
                                this._viewHydrateRecurse(view.componentChildViews[i]);
                            }
                        }
                    }
                }, {
                    key: "_viewDehydrateRecurse",
                    value: function _viewDehydrateRecurse(view, forceDestroyComponents) {
                        this._utils.dehydrateView(view);
                        this._renderer.dehydrateView(view.render);
                        var binders = view.proto.elementBinders;
                        for (var i = 0; i < binders.length; i++) {
                            var componentView = view.componentChildViews[i];
                            if (isPresent(componentView)) {
                                if (binders[i].hasDynamicComponent() || forceDestroyComponents) {
                                    this._destroyComponentView(view, i, componentView);
                                } else {
                                    this._viewDehydrateRecurse(componentView, false);
                                }
                            }
                            var vc = view.viewContainers[i];
                            if (isPresent(vc)) {
                                for (var j = vc.views.length - 1; j >= 0; j--) {
                                    this._destroyViewInContainer(view, i, j);
                                }
                            }
                        }
                        // freeHostViews
                        for (var i = view.freeHostViews.length - 1; i >= 0; i--) {
                            var hostView = view.freeHostViews[i];
                            this._destroyFreeHostView(view, hostView);
                        }
                    }
                }]);

                return _class;
            })();

            _export("AppViewManager", AppViewManager);

            _export("AppViewManager", AppViewManager = __decorate([Injectable(), __metadata("design:paramtypes", [AppViewPool, AppViewListener, AppViewManagerUtils, Renderer])], AppViewManager));
            
        }
    };
});
System.register('angular2/src/core/compiler/query_list', ['npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/src/core/compiler/base_query_list'], function (_export) {
  var _inherits, _get, _createClass, _classCallCheck, BaseQueryList, QueryList;

  return {
    setters: [function (_npmBabelRuntime547HelpersInherits) {
      _inherits = _npmBabelRuntime547HelpersInherits['default'];
    }, function (_npmBabelRuntime547HelpersGet) {
      _get = _npmBabelRuntime547HelpersGet['default'];
    }, function (_npmBabelRuntime547HelpersCreateClass) {
      _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
    }, function (_npmBabelRuntime547HelpersClassCallCheck) {
      _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
    }, function (_angular2SrcCoreCompilerBase_query_list) {
      BaseQueryList = _angular2SrcCoreCompilerBase_query_list.BaseQueryList;
    }],
    execute: function () {
      'use strict';

      /**
       * An iterable live list of components in the Light DOM.
       *
       * Injectable Objects that contains a live list of child directives in the light DOM of a directive.
       * The directives are kept in depth-first pre-order traversal of the DOM.
       *
       * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop
       * as well as in
       * template with `*ng-for="of"` directive.
       *
       * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain
       * list of observable
       * callbacks.
       *
       * # Example:
       *
       * Assume that `<tabs>` component would like to get a list its children which are `<pane>`
       * components as shown in this
       * example:
       *
       * ```html
       * <tabs>
       *   <pane title="Overview">...</pane>
       *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
       * </tabs>
       * ```
       *
       * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so
       * that it could render
       * tabs with the correct titles and in the correct order.
       *
       * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself
       * with `<tabs>`
       * component's on `hydrate` and deregister on `dehydrate` event. While a reasonable approach, this
       * would only work
       * partialy since `*ng-for` could rearange the list of `<pane>` components which would not be
       * reported to `<tabs>`
       * component and thus the list of `<pane>` componets would be out of sync with respect to the list
       * of `<pane>` elements.
       *
       * A preferred solution is to inject a `QueryList` which is a live list of directives in the
       * component`s light DOM.
       *
       * ```javascript
       * @Component({
       *   selector: 'tabs'
       * })
       * @View({
       *  template: `
       *    <ul>
       *      <li *ng-for="#pane of panes">{{pane.title}}</li>
       *    </ul>
       *    <content></content>
       *  `
       * })
       * class Tabs {
       *   panes: QueryList<Pane>
       *
       *   constructor(@Query(Pane) panes:QueryList<Pane>) {
       *     this.panes = panes;
       *   }
       * }
       *
       * @Component({
       *   selector: 'pane',
       *   properties: ['title']
       * })
       * @View(...)
       * class Pane {
       *   title:string;
       * }
       * ```
       *
       * @exportedAs angular2/view
       */

      QueryList = (function (_BaseQueryList) {
        function QueryList() {
          _classCallCheck(this, QueryList);

          if (_BaseQueryList != null) {
            _BaseQueryList.apply(this, arguments);
          }
        }

        _inherits(QueryList, _BaseQueryList);

        _createClass(QueryList, [{
          key: 'onChange',

          /**
           */
          value: function onChange(callback) {
            return _get(Object.getPrototypeOf(QueryList.prototype), 'onChange', this).call(this, callback);
          }
        }, {
          key: 'removeCallback',

          /**
           */
          value: function removeCallback(callback) {
            return _get(Object.getPrototypeOf(QueryList.prototype), 'removeCallback', this).call(this, callback);
          }
        }]);

        return QueryList;
      })(BaseQueryList);

      _export('QueryList', QueryList);
    }
  };
});


System.register("angular2/src/render/dom/compiler/compiler", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/api", "angular2/src/render/dom/compiler/compile_pipeline", "angular2/src/render/dom/compiler/template_loader", "angular2/src/render/dom/compiler/compile_step_factory", "angular2/change_detection", "angular2/src/render/dom/shadow_dom/shadow_dom_strategy"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, Injectable, PromiseWrapper, BaseException, DOM, ViewDefinition, ProtoViewDto, RenderCompiler, CompilePipeline, TemplateLoader, DefaultStepFactory, Parser, ShadowDomStrategy, __decorate, __metadata, DomCompiler, DefaultDomCompiler;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcFacadeLang) {
            BaseException = _angular2SrcFacadeLang.BaseException;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcRenderApi) {
            ViewDefinition = _angular2SrcRenderApi.ViewDefinition;
            ProtoViewDto = _angular2SrcRenderApi.ProtoViewDto;
            RenderCompiler = _angular2SrcRenderApi.RenderCompiler;
        }, function (_angular2SrcRenderDomCompilerCompile_pipeline) {
            CompilePipeline = _angular2SrcRenderDomCompilerCompile_pipeline.CompilePipeline;
        }, function (_angular2SrcRenderDomCompilerTemplate_loader) {
            TemplateLoader = _angular2SrcRenderDomCompilerTemplate_loader.TemplateLoader;
        }, function (_angular2SrcRenderDomCompilerCompile_step_factory) {
            DefaultStepFactory = _angular2SrcRenderDomCompilerCompile_step_factory.DefaultStepFactory;
        }, function (_angular2Change_detection) {
            Parser = _angular2Change_detection.Parser;
        }, function (_angular2SrcRenderDomShadow_domShadow_dom_strategy) {
            ShadowDomStrategy = _angular2SrcRenderDomShadow_domShadow_dom_strategy.ShadowDomStrategy;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * The compiler loads and translates the html templates of components into
             * nested ProtoViews. To decompose its functionality it uses
             * the CompilePipeline and the CompileSteps.
             */

            DomCompiler = (function (_RenderCompiler) {
                function DomCompiler(stepFactory, templateLoader) {
                    _classCallCheck(this, DomCompiler);

                    _get(Object.getPrototypeOf(DomCompiler.prototype), "constructor", this).call(this);
                    this._templateLoader = templateLoader;
                    this._stepFactory = stepFactory;
                }

                _inherits(DomCompiler, _RenderCompiler);

                _createClass(DomCompiler, [{
                    key: "compile",
                    value: function compile(template) {
                        var _this = this;

                        var tplPromise = this._templateLoader.load(template);
                        return PromiseWrapper.then(tplPromise, function (el) {
                            return _this._compileTemplate(template, el, ProtoViewDto.COMPONENT_VIEW_TYPE);
                        }, function (e) {
                            throw new BaseException("Failed to load the template for \"" + template.componentId + "\" : " + e);
                        });
                    }
                }, {
                    key: "compileHost",
                    value: function compileHost(directiveMetadata) {
                        var hostViewDef = new ViewDefinition({
                            componentId: directiveMetadata.id,
                            absUrl: null, template: null,
                            directives: [directiveMetadata]
                        });
                        var element = DOM.createElement(directiveMetadata.selector);
                        return this._compileTemplate(hostViewDef, element, ProtoViewDto.HOST_VIEW_TYPE);
                    }
                }, {
                    key: "_compileTemplate",
                    value: function _compileTemplate(viewDef, tplElement, protoViewType) {
                        var subTaskPromises = [];
                        var pipeline = new CompilePipeline(this._stepFactory.createSteps(viewDef, subTaskPromises));
                        var compileElements = pipeline.process(tplElement, protoViewType, viewDef.componentId);
                        var protoView = compileElements[0].inheritedProtoView.build();
                        if (subTaskPromises.length > 0) {
                            return PromiseWrapper.all(subTaskPromises).then(function (_) {
                                return protoView;
                            });
                        } else {
                            return PromiseWrapper.resolve(protoView);
                        }
                    }
                }]);

                return DomCompiler;
            })(RenderCompiler);

            _export("DomCompiler", DomCompiler);

            DefaultDomCompiler = (function (_DomCompiler) {
                var _class = function DefaultDomCompiler(parser, shadowDomStrategy, templateLoader) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, new DefaultStepFactory(parser, shadowDomStrategy), templateLoader);
                };

                _inherits(_class, _DomCompiler);

                return _class;
            })(DomCompiler);

            _export("DefaultDomCompiler", DefaultDomCompiler);

            _export("DefaultDomCompiler", DefaultDomCompiler = __decorate([Injectable(), __metadata("design:paramtypes", [Parser, ShadowDomStrategy, TemplateLoader])], DefaultDomCompiler));
            
        }
    };
});
System.register('angular2/forms', ['angular2/src/forms/model', 'angular2/src/forms/directives', 'angular2/src/forms/validators', 'angular2/src/forms/validator_directives', 'angular2/src/forms/form_builder'], function (_export) {
  /**
   * @module
   * @public
   * @description
   * This module is used for handling user input, by defining and building a {@link ControlGroup} that
   * consists of
   * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
   * to read information
   * from the form DOM elements.
   *
   * This module is not included in the `angular2` module; you must import the forms module
   * explicitly.
   *
   */

  
  'use strict';

  return {
    setters: [function (_angular2SrcFormsModel) {
      for (var _key in _angular2SrcFormsModel) {
        _export(_key, _angular2SrcFormsModel[_key]);
      }
    }, function (_angular2SrcFormsDirectives) {
      for (var _key2 in _angular2SrcFormsDirectives) {
        _export(_key2, _angular2SrcFormsDirectives[_key2]);
      }
    }, function (_angular2SrcFormsValidators) {
      for (var _key3 in _angular2SrcFormsValidators) {
        _export(_key3, _angular2SrcFormsValidators[_key3]);
      }
    }, function (_angular2SrcFormsValidator_directives) {
      for (var _key4 in _angular2SrcFormsValidator_directives) {
        _export(_key4, _angular2SrcFormsValidator_directives[_key4]);
      }
    }, function (_angular2SrcFormsForm_builder) {
      for (var _key5 in _angular2SrcFormsForm_builder) {
        _export(_key5, _angular2SrcFormsForm_builder[_key5]);
      }
    }],
    execute: function () {}
  };
});
System.register('angular2/di', ['angular2/src/di/annotations', 'angular2/src/di/decorators', 'angular2/src/di/forward_ref', 'angular2/src/di/injector', 'angular2/src/di/binding', 'angular2/src/di/key', 'angular2/src/di/exceptions', 'angular2/src/di/opaque_token'], function (_export) {
  /**
   * @module
   * @public
   * @description
   * The `di` module provides dependency injection container services.
   */

  
  'use strict';

  return {
    setters: [function (_angular2SrcDiAnnotations) {
      for (var _key in _angular2SrcDiAnnotations) {
        _export(_key, _angular2SrcDiAnnotations[_key]);
      }
    }, function (_angular2SrcDiDecorators) {
      for (var _key2 in _angular2SrcDiDecorators) {
        _export(_key2, _angular2SrcDiDecorators[_key2]);
      }
    }, function (_angular2SrcDiForward_ref) {
      for (var _key3 in _angular2SrcDiForward_ref) {
        _export(_key3, _angular2SrcDiForward_ref[_key3]);
      }
    }, function (_angular2SrcDiInjector) {
      _export('resolveBindings', _angular2SrcDiInjector.resolveBindings);

      _export('Injector', _angular2SrcDiInjector.Injector);
    }, function (_angular2SrcDiBinding) {
      _export('Binding', _angular2SrcDiBinding.Binding);

      _export('BindingBuilder', _angular2SrcDiBinding.BindingBuilder);

      _export('ResolvedBinding', _angular2SrcDiBinding.ResolvedBinding);

      _export('Dependency', _angular2SrcDiBinding.Dependency);

      _export('bind', _angular2SrcDiBinding.bind);
    }, function (_angular2SrcDiKey) {
      _export('Key', _angular2SrcDiKey.Key);

      _export('KeyRegistry', _angular2SrcDiKey.KeyRegistry);

      _export('TypeLiteral', _angular2SrcDiKey.TypeLiteral);
    }, function (_angular2SrcDiExceptions) {
      _export('NoBindingError', _angular2SrcDiExceptions.NoBindingError);

      _export('AbstractBindingError', _angular2SrcDiExceptions.AbstractBindingError);

      _export('AsyncBindingError', _angular2SrcDiExceptions.AsyncBindingError);

      _export('CyclicDependencyError', _angular2SrcDiExceptions.CyclicDependencyError);

      _export('InstantiationError', _angular2SrcDiExceptions.InstantiationError);

      _export('InvalidBindingError', _angular2SrcDiExceptions.InvalidBindingError);

      _export('NoAnnotationError', _angular2SrcDiExceptions.NoAnnotationError);
    }, function (_angular2SrcDiOpaque_token) {
      _export('OpaqueToken', _angular2SrcDiOpaque_token.OpaqueToken);
    }],
    execute: function () {}
  };
});
System.register('angular2/src/core/compiler/element_injector', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'npm:babel-runtime@5.4.7/helpers/inherits', 'npm:babel-runtime@5.4.7/helpers/get', 'angular2/src/facade/lang', 'angular2/src/facade/async', 'angular2/src/facade/collection', 'angular2/di', 'angular2/src/core/annotations_impl/visibility', 'angular2/src/core/annotations_impl/di', 'angular2/src/core/compiler/view_manager', 'angular2/src/core/compiler/view_container_ref', 'angular2/src/core/compiler/element_ref', 'angular2/src/core/compiler/view_ref', 'angular2/src/core/annotations_impl/annotations', 'angular2/src/core/compiler/directive_lifecycle_reflector', 'angular2/change_detection', 'angular2/src/core/compiler/query_list', 'angular2/src/reflection/reflection', 'angular2/src/render/api'], function (_export) {
    var _createClass, _classCallCheck, _inherits, _get, isPresent, isBlank, BaseException, stringify, CONST_EXPR, ObservableWrapper, ListWrapper, MapWrapper, Injector, Key, Dependency, Binding, ResolvedBinding, NoBindingError, AbstractBindingError, CyclicDependencyError, resolveForwardRef, resolveBindings, Visibility, self, Attribute, Query, avmModule, ViewContainerRef, ElementRef, ProtoViewRef, ViewRef, Directive, Component, onChange, onDestroy, onCheck, onInit, onAllChangesDone, hasLifecycleHook, ChangeDetectorRef, QueryList, reflector, DirectiveMetadata, _MAX_DIRECTIVE_CONSTRUCTION_COUNTER, _undefined, _staticKeys, StaticKeys, TreeNode, DependencyWithVisibility, DirectiveDependency, DirectiveBinding, PreBuiltObjects, EventEmitterAccessor, HostActionAccessor, LIGHT_DOM, SHADOW_DOM, LIGHT_DOM_AND_SHADOW_DOM, BindingData, ProtoElementInjector, _ProtoElementInjectorInlineStrategy, _ProtoElementInjectorDynamicStrategy, ElementInjector, ElementInjectorInlineStrategy, ElementInjectorDynamicStrategy, OutOfBoundsAccess, QueryError, QueryRef;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits['default'];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet['default'];
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
            isBlank = _angular2SrcFacadeLang.isBlank;
            BaseException = _angular2SrcFacadeLang.BaseException;
            stringify = _angular2SrcFacadeLang.stringify;
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcFacadeAsync) {
            ObservableWrapper = _angular2SrcFacadeAsync.ObservableWrapper;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2Di) {
            Injector = _angular2Di.Injector;
            Key = _angular2Di.Key;
            Dependency = _angular2Di.Dependency;
            Binding = _angular2Di.Binding;
            ResolvedBinding = _angular2Di.ResolvedBinding;
            NoBindingError = _angular2Di.NoBindingError;
            AbstractBindingError = _angular2Di.AbstractBindingError;
            CyclicDependencyError = _angular2Di.CyclicDependencyError;
            resolveForwardRef = _angular2Di.resolveForwardRef;
            resolveBindings = _angular2Di.resolveBindings;
        }, function (_angular2SrcCoreAnnotations_implVisibility) {
            Visibility = _angular2SrcCoreAnnotations_implVisibility.Visibility;
            self = _angular2SrcCoreAnnotations_implVisibility.self;
        }, function (_angular2SrcCoreAnnotations_implDi) {
            Attribute = _angular2SrcCoreAnnotations_implDi.Attribute;
            Query = _angular2SrcCoreAnnotations_implDi.Query;
        }, function (_angular2SrcCoreCompilerView_manager) {
            avmModule = _angular2SrcCoreCompilerView_manager;
        }, function (_angular2SrcCoreCompilerView_container_ref) {
            ViewContainerRef = _angular2SrcCoreCompilerView_container_ref.ViewContainerRef;
        }, function (_angular2SrcCoreCompilerElement_ref) {
            ElementRef = _angular2SrcCoreCompilerElement_ref.ElementRef;
        }, function (_angular2SrcCoreCompilerView_ref) {
            ProtoViewRef = _angular2SrcCoreCompilerView_ref.ProtoViewRef;
            ViewRef = _angular2SrcCoreCompilerView_ref.ViewRef;
        }, function (_angular2SrcCoreAnnotations_implAnnotations) {
            Directive = _angular2SrcCoreAnnotations_implAnnotations.Directive;
            Component = _angular2SrcCoreAnnotations_implAnnotations.Component;
            onChange = _angular2SrcCoreAnnotations_implAnnotations.onChange;
            onDestroy = _angular2SrcCoreAnnotations_implAnnotations.onDestroy;
            onCheck = _angular2SrcCoreAnnotations_implAnnotations.onCheck;
            onInit = _angular2SrcCoreAnnotations_implAnnotations.onInit;
            onAllChangesDone = _angular2SrcCoreAnnotations_implAnnotations.onAllChangesDone;
        }, function (_angular2SrcCoreCompilerDirective_lifecycle_reflector) {
            hasLifecycleHook = _angular2SrcCoreCompilerDirective_lifecycle_reflector.hasLifecycleHook;
        }, function (_angular2Change_detection) {
            ChangeDetectorRef = _angular2Change_detection.ChangeDetectorRef;
        }, function (_angular2SrcCoreCompilerQuery_list) {
            QueryList = _angular2SrcCoreCompilerQuery_list.QueryList;
        }, function (_angular2SrcReflectionReflection) {
            reflector = _angular2SrcReflectionReflection.reflector;
        }, function (_angular2SrcRenderApi) {
            DirectiveMetadata = _angular2SrcRenderApi.DirectiveMetadata;
        }],
        execute: function () {
            'use strict';

            // Threshold for the dynamic version
            _MAX_DIRECTIVE_CONSTRUCTION_COUNTER = 10;
            _undefined = CONST_EXPR(new Object());

            StaticKeys = (function () {
                function StaticKeys() {
                    _classCallCheck(this, StaticKeys);

                    // TODO: vsavkin Key.annotate(Key.get(AppView), 'static')
                    this.viewManagerId = Key.get(avmModule.AppViewManager).id;
                    this.protoViewId = Key.get(ProtoViewRef).id;
                    this.viewContainerId = Key.get(ViewContainerRef).id;
                    this.changeDetectorRefId = Key.get(ChangeDetectorRef).id;
                    this.elementRefId = Key.get(ElementRef).id;
                }

                _createClass(StaticKeys, null, [{
                    key: 'instance',
                    value: function instance() {
                        if (isBlank(_staticKeys)) _staticKeys = new StaticKeys();
                        return _staticKeys;
                    }
                }]);

                return StaticKeys;
            })();

            TreeNode = (function () {
                function TreeNode(parent) {
                    _classCallCheck(this, TreeNode);

                    this._head = null;
                    this._tail = null;
                    this._next = null;
                    if (isPresent(parent)) parent.addChild(this);
                }

                _createClass(TreeNode, [{
                    key: '_assertConsistency',
                    value: function _assertConsistency() {
                        this._assertHeadBeforeTail();
                        this._assertTailReachable();
                        this._assertPresentInParentList();
                    }
                }, {
                    key: '_assertHeadBeforeTail',
                    value: function _assertHeadBeforeTail() {
                        if (isBlank(this._tail) && isPresent(this._head)) throw new BaseException('null tail but non-null head');
                    }
                }, {
                    key: '_assertTailReachable',
                    value: function _assertTailReachable() {
                        if (isBlank(this._tail)) return;
                        if (isPresent(this._tail._next)) throw new BaseException('node after tail');
                        var p = this._head;
                        while (isPresent(p) && p != this._tail) p = p._next;
                        if (isBlank(p) && isPresent(this._tail)) throw new BaseException('tail not reachable.');
                    }
                }, {
                    key: '_assertPresentInParentList',
                    value: function _assertPresentInParentList() {
                        var p = this._parent;
                        if (isBlank(p)) {
                            return;
                        }
                        var cur = p._head;
                        while (isPresent(cur) && cur != this) cur = cur._next;
                        if (isBlank(cur)) throw new BaseException('node not reachable through parent.');
                    }
                }, {
                    key: 'addChild',

                    /**
                     * Adds a child to the parent node. The child MUST NOT be a part of a tree.
                     */
                    value: function addChild(child) {
                        if (isPresent(this._tail)) {
                            this._tail._next = child;
                            this._tail = child;
                        } else {
                            this._tail = this._head = child;
                        }
                        child._next = null;
                        child._parent = this;
                        this._assertConsistency();
                    }
                }, {
                    key: 'addChildAfter',

                    /**
                     * Adds a child to the parent node after a given sibling.
                     * The child MUST NOT be a part of a tree and the sibling must be present.
                     */
                    value: function addChildAfter(child, prevSibling) {
                        this._assertConsistency();
                        if (isBlank(prevSibling)) {
                            var prevHead = this._head;
                            this._head = child;
                            child._next = prevHead;
                            if (isBlank(this._tail)) this._tail = child;
                        } else if (isBlank(prevSibling._next)) {
                            this.addChild(child);
                            return;
                        } else {
                            prevSibling._assertPresentInParentList();
                            child._next = prevSibling._next;
                            prevSibling._next = child;
                        }
                        child._parent = this;
                        this._assertConsistency();
                    }
                }, {
                    key: 'remove',

                    /**
                     * Detaches a node from the parent's tree.
                     */
                    value: function remove() {
                        this._assertConsistency();
                        if (isBlank(this.parent)) return;
                        var nextSibling = this._next;
                        var prevSibling = this._findPrev();
                        if (isBlank(prevSibling)) {
                            this.parent._head = this._next;
                        } else {
                            prevSibling._next = this._next;
                        }
                        if (isBlank(nextSibling)) {
                            this._parent._tail = prevSibling;
                        }
                        this._parent._assertConsistency();
                        this._parent = null;
                        this._next = null;
                        this._assertConsistency();
                    }
                }, {
                    key: '_findPrev',

                    /**
                     * Finds a previous sibling or returns null if first child.
                     * Assumes the node has a parent.
                     * TODO(rado): replace with DoublyLinkedList to avoid O(n) here.
                     */
                    value: function _findPrev() {
                        var node = this.parent._head;
                        if (node == this) return null;
                        while (node._next !== this) node = node._next;
                        return node;
                    }
                }, {
                    key: 'parent',
                    get: function () {
                        return this._parent;
                    }
                }, {
                    key: 'children',

                    // TODO(rado): replace with a function call, does too much work for a getter.
                    get: function () {
                        var res = [];
                        var child = this._head;
                        while (child != null) {
                            ListWrapper.push(res, child);
                            child = child._next;
                        }
                        return res;
                    }
                }]);

                return TreeNode;
            })();

            _export('TreeNode', TreeNode);

            DependencyWithVisibility = (function (_Dependency) {
                function DependencyWithVisibility(key, asPromise, lazy, optional, properties, visibility) {
                    _classCallCheck(this, DependencyWithVisibility);

                    _get(Object.getPrototypeOf(DependencyWithVisibility.prototype), 'constructor', this).call(this, key, asPromise, lazy, optional, properties);
                    this.visibility = visibility;
                }

                _inherits(DependencyWithVisibility, _Dependency);

                _createClass(DependencyWithVisibility, null, [{
                    key: 'createFrom',
                    value: function createFrom(d) {
                        return new DependencyWithVisibility(d.key, d.asPromise, d.lazy, d.optional, d.properties, DependencyWithVisibility._visibility(d.properties));
                    }
                }, {
                    key: '_visibility',
                    value: function _visibility(properties) {
                        if (properties.length == 0) return self;
                        var p = ListWrapper.find(properties, function (p) {
                            return p instanceof Visibility;
                        });
                        return isPresent(p) ? p : self;
                    }
                }]);

                return DependencyWithVisibility;
            })(Dependency);

            _export('DependencyWithVisibility', DependencyWithVisibility);

            DirectiveDependency = (function (_DependencyWithVisibility) {
                function DirectiveDependency(key, asPromise, lazy, optional, properties, visibility, attributeName, queryDirective) {
                    _classCallCheck(this, DirectiveDependency);

                    _get(Object.getPrototypeOf(DirectiveDependency.prototype), 'constructor', this).call(this, key, asPromise, lazy, optional, properties, visibility);
                    this.attributeName = attributeName;
                    this.queryDirective = queryDirective;
                    this._verify();
                }

                _inherits(DirectiveDependency, _DependencyWithVisibility);

                _createClass(DirectiveDependency, [{
                    key: '_verify',
                    value: function _verify() {
                        var count = 0;
                        if (isPresent(this.queryDirective)) count++;
                        if (isPresent(this.attributeName)) count++;
                        if (count > 1) throw new BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
                    }
                }], [{
                    key: 'createFrom',
                    value: function createFrom(d) {
                        return new DirectiveDependency(d.key, d.asPromise, d.lazy, d.optional, d.properties, DependencyWithVisibility._visibility(d.properties), DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
                    }
                }, {
                    key: '_attributeName',
                    value: function _attributeName(properties) {
                        var p = ListWrapper.find(properties, function (p) {
                            return p instanceof Attribute;
                        });
                        return isPresent(p) ? p.attributeName : null;
                    }
                }, {
                    key: '_query',
                    value: function _query(properties) {
                        var p = ListWrapper.find(properties, function (p) {
                            return p instanceof Query;
                        });
                        return isPresent(p) ? resolveForwardRef(p.directive) : null;
                    }
                }]);

                return DirectiveDependency;
            })(DependencyWithVisibility);

            _export('DirectiveDependency', DirectiveDependency);

            DirectiveBinding = (function (_ResolvedBinding) {
                function DirectiveBinding(key, factory, dependencies, providedAsPromise, resolvedAppInjectables, resolvedHostInjectables, resolvedViewInjectables, metadata) {
                    _classCallCheck(this, DirectiveBinding);

                    _get(Object.getPrototypeOf(DirectiveBinding.prototype), 'constructor', this).call(this, key, factory, dependencies, providedAsPromise);
                    this.resolvedAppInjectables = resolvedAppInjectables;
                    this.resolvedHostInjectables = resolvedHostInjectables;
                    this.resolvedViewInjectables = resolvedViewInjectables;
                    this.metadata = metadata;
                }

                _inherits(DirectiveBinding, _ResolvedBinding);

                _createClass(DirectiveBinding, [{
                    key: 'callOnDestroy',
                    get: function () {
                        return this.metadata.callOnDestroy;
                    }
                }, {
                    key: 'callOnChange',
                    get: function () {
                        return this.metadata.callOnChange;
                    }
                }, {
                    key: 'callOnAllChangesDone',
                    get: function () {
                        return this.metadata.callOnAllChangesDone;
                    }
                }, {
                    key: 'displayName',
                    get: function () {
                        return this.key.displayName;
                    }
                }, {
                    key: 'eventEmitters',
                    get: function () {
                        return isPresent(this.metadata) && isPresent(this.metadata.events) ? this.metadata.events : [];
                    }
                }, {
                    key: 'hostActions',
                    get: function () {
                        return isPresent(this.metadata) && isPresent(this.metadata.hostActions) ? this.metadata.hostActions : MapWrapper.create();
                    }
                }, {
                    key: 'changeDetection',
                    get: function () {
                        return this.metadata.changeDetection;
                    }
                }], [{
                    key: 'createFromBinding',
                    value: function createFromBinding(binding, ann) {
                        if (isBlank(ann)) {
                            ann = new Directive();
                        }
                        var rb = binding.resolve();
                        var deps = ListWrapper.map(rb.dependencies, DirectiveDependency.createFrom);
                        var resolvedAppInjectables = ann instanceof Component && isPresent(ann.appInjector) ? Injector.resolve(ann.appInjector) : [];
                        var resolvedHostInjectables = isPresent(ann.hostInjector) ? resolveBindings(ann.hostInjector) : [];
                        var resolvedViewInjectables = ann instanceof Component && isPresent(ann.viewInjector) ? resolveBindings(ann.viewInjector) : [];
                        var metadata = new DirectiveMetadata({
                            id: stringify(rb.key.token),
                            type: ann instanceof Component ? DirectiveMetadata.COMPONENT_TYPE : DirectiveMetadata.DIRECTIVE_TYPE,
                            selector: ann.selector,
                            compileChildren: ann.compileChildren,
                            events: ann.events,
                            hostListeners: isPresent(ann.hostListeners) ? MapWrapper.createFromStringMap(ann.hostListeners) : null,
                            hostProperties: isPresent(ann.hostProperties) ? MapWrapper.createFromStringMap(ann.hostProperties) : null,
                            hostAttributes: isPresent(ann.hostAttributes) ? MapWrapper.createFromStringMap(ann.hostAttributes) : null,
                            hostActions: isPresent(ann.hostActions) ? MapWrapper.createFromStringMap(ann.hostActions) : null,
                            properties: ann.properties,
                            readAttributes: DirectiveBinding._readAttributes(deps),
                            callOnDestroy: hasLifecycleHook(onDestroy, rb.key.token, ann),
                            callOnChange: hasLifecycleHook(onChange, rb.key.token, ann),
                            callOnCheck: hasLifecycleHook(onCheck, rb.key.token, ann),
                            callOnInit: hasLifecycleHook(onInit, rb.key.token, ann),
                            callOnAllChangesDone: hasLifecycleHook(onAllChangesDone, rb.key.token, ann),
                            changeDetection: ann instanceof Component ? ann.changeDetection : null
                        });
                        return new DirectiveBinding(rb.key, rb.factory, deps, rb.providedAsPromise, resolvedAppInjectables, resolvedHostInjectables, resolvedViewInjectables, metadata);
                    }
                }, {
                    key: '_readAttributes',
                    value: function _readAttributes(deps) {
                        var readAttributes = [];
                        ListWrapper.forEach(deps, function (dep) {
                            if (isPresent(dep.attributeName)) {
                                ListWrapper.push(readAttributes, dep.attributeName);
                            }
                        });
                        return readAttributes;
                    }
                }, {
                    key: 'createFromType',
                    value: function createFromType(type, annotation) {
                        var binding = new Binding(type, { toClass: type });
                        return DirectiveBinding.createFromBinding(binding, annotation);
                    }
                }]);

                return DirectiveBinding;
            })(ResolvedBinding);

            _export('DirectiveBinding', DirectiveBinding);

            // TODO(rado): benchmark and consider rolling in as ElementInjector fields.

            PreBuiltObjects = function PreBuiltObjects(viewManager, view, protoView) {
                _classCallCheck(this, PreBuiltObjects);

                this.viewManager = viewManager;
                this.view = view;
                this.protoView = protoView;
            };

            _export('PreBuiltObjects', PreBuiltObjects);

            EventEmitterAccessor = (function () {
                function EventEmitterAccessor(eventName, getter) {
                    _classCallCheck(this, EventEmitterAccessor);

                    this.eventName = eventName;
                    this.getter = getter;
                }

                _createClass(EventEmitterAccessor, [{
                    key: 'subscribe',
                    value: function subscribe(view, boundElementIndex, directive) {
                        var _this = this;

                        var eventEmitter = this.getter(directive);
                        return ObservableWrapper.subscribe(eventEmitter, function (eventObj) {
                            return view.triggerEventHandlers(_this.eventName, eventObj, boundElementIndex);
                        });
                    }
                }]);

                return EventEmitterAccessor;
            })();

            _export('EventEmitterAccessor', EventEmitterAccessor);

            HostActionAccessor = (function () {
                function HostActionAccessor(actionExpression, getter) {
                    _classCallCheck(this, HostActionAccessor);

                    this.actionExpression = actionExpression;
                    this.getter = getter;
                }

                _createClass(HostActionAccessor, [{
                    key: 'subscribe',
                    value: function subscribe(view, boundElementIndex, directive) {
                        var _this2 = this;

                        var eventEmitter = this.getter(directive);
                        return ObservableWrapper.subscribe(eventEmitter, function (actionObj) {
                            return view.callAction(boundElementIndex, _this2.actionExpression, actionObj);
                        });
                    }
                }]);

                return HostActionAccessor;
            })();

            _export('HostActionAccessor', HostActionAccessor);

            LIGHT_DOM = 1;
            SHADOW_DOM = 2;
            LIGHT_DOM_AND_SHADOW_DOM = 3;

            BindingData = (function () {
                function BindingData(binding, visibility) {
                    _classCallCheck(this, BindingData);

                    this.binding = binding;
                    this.visibility = visibility;
                }

                _createClass(BindingData, [{
                    key: 'getKeyId',
                    value: function getKeyId() {
                        return this.binding.key.id;
                    }
                }, {
                    key: 'createEventEmitterAccessors',
                    value: function createEventEmitterAccessors() {
                        if (!(this.binding instanceof DirectiveBinding)) return [];
                        var db = this.binding;
                        return ListWrapper.map(db.eventEmitters, function (eventName) {
                            return new EventEmitterAccessor(eventName, reflector.getter(eventName));
                        });
                    }
                }, {
                    key: 'createHostActionAccessors',
                    value: function createHostActionAccessors() {
                        if (!(this.binding instanceof DirectiveBinding)) return [];
                        var res = [];
                        var db = this.binding;
                        MapWrapper.forEach(db.hostActions, function (actionExpression, actionName) {
                            ListWrapper.push(res, new HostActionAccessor(actionExpression, reflector.getter(actionName)));
                        });
                        return res;
                    }
                }]);

                return BindingData;
            })();

            _export('BindingData', BindingData);

            /**
            
            Difference between di.Injector and ElementInjector
            
            di.Injector:
             - imperative based (can create child injectors imperativly)
             - Lazy loading of code
             - Component/App Level services which are usually not DOM Related.
            
            
            ElementInjector:
              - ProtoBased (Injector structure fixed at compile time)
              - understands @Ancestor, @Parent, @Child, @Descendent
              - Fast
              - Query mechanism for children
              - 1:1 to DOM structure.
            
             PERF BENCHMARK:
            http://www.williambrownstreet.net/blog/2014/04/faster-angularjs-rendering-angularjs-and-reactjs/
             */

            ProtoElementInjector = (function () {
                function ProtoElementInjector(parent, index, bd, distanceToParent, _firstBindingIsComponent) {
                    _classCallCheck(this, ProtoElementInjector);

                    this.parent = parent;
                    this.index = index;
                    this.distanceToParent = distanceToParent;
                    this._firstBindingIsComponent = _firstBindingIsComponent;
                    this.exportComponent = false;
                    this.exportElement = false;
                    var length = bd.length;
                    this.eventEmitterAccessors = ListWrapper.createFixedSize(length);
                    this.hostActionAccessors = ListWrapper.createFixedSize(length);
                    this._strategy = length > _MAX_DIRECTIVE_CONSTRUCTION_COUNTER ? new _ProtoElementInjectorDynamicStrategy(this, bd) : new _ProtoElementInjectorInlineStrategy(this, bd);
                }

                _createClass(ProtoElementInjector, [{
                    key: 'instantiate',
                    value: function instantiate(parent) {
                        return new ElementInjector(this, parent);
                    }
                }, {
                    key: 'directParent',
                    value: function directParent() {
                        return this.distanceToParent < 2 ? this.parent : null;
                    }
                }, {
                    key: 'hasBindings',
                    get: function () {
                        return this._strategy.hasBindings();
                    }
                }, {
                    key: 'getBindingAtIndex',
                    value: function getBindingAtIndex(index) {
                        return this._strategy.getBindingAtIndex(index);
                    }
                }], [{
                    key: 'create',
                    value: function create(parent, index, bindings, firstBindingIsComponent, distanceToParent) {
                        var bd = [];
                        ProtoElementInjector._createDirectiveBindingData(bindings, bd, firstBindingIsComponent);
                        ProtoElementInjector._createHostInjectorBindingData(bindings, bd);
                        if (firstBindingIsComponent) {
                            ProtoElementInjector._createViewInjectorBindingData(bindings, bd);
                        }
                        return new ProtoElementInjector(parent, index, bd, distanceToParent, firstBindingIsComponent);
                    }
                }, {
                    key: '_createDirectiveBindingData',
                    value: function _createDirectiveBindingData(bindings, bd, firstBindingIsComponent) {
                        if (firstBindingIsComponent) {
                            ListWrapper.push(bd, new BindingData(bindings[0], LIGHT_DOM_AND_SHADOW_DOM));
                            for (var i = 1; i < bindings.length; ++i) {
                                ListWrapper.push(bd, new BindingData(bindings[i], LIGHT_DOM));
                            }
                        } else {
                            ListWrapper.forEach(bindings, function (b) {
                                ListWrapper.push(bd, new BindingData(b, LIGHT_DOM));
                            });
                        }
                    }
                }, {
                    key: '_createHostInjectorBindingData',
                    value: function _createHostInjectorBindingData(bindings, bd) {
                        ListWrapper.forEach(bindings, function (b) {
                            ListWrapper.forEach(b.resolvedHostInjectables, function (b) {
                                ListWrapper.push(bd, new BindingData(ProtoElementInjector._createBinding(b), LIGHT_DOM));
                            });
                        });
                    }
                }, {
                    key: '_createViewInjectorBindingData',
                    value: function _createViewInjectorBindingData(bindings, bd) {
                        var db = bindings[0];
                        ListWrapper.forEach(db.resolvedViewInjectables, function (b) {
                            return ListWrapper.push(bd, new BindingData(ProtoElementInjector._createBinding(b), SHADOW_DOM));
                        });
                    }
                }, {
                    key: '_createBinding',
                    value: function _createBinding(b) {
                        var deps = ListWrapper.map(b.dependencies, function (d) {
                            return DependencyWithVisibility.createFrom(d);
                        });
                        return new ResolvedBinding(b.key, b.factory, deps, b.providedAsPromise);
                    }
                }]);

                return ProtoElementInjector;
            })();

            _export('ProtoElementInjector', ProtoElementInjector);

            /**
             * Strategy used by the `ProtoElementInjector` when the number of bindings is 10 or less.
             * In such a case, inlining fields is benefitial for performances.
             */

            _ProtoElementInjectorInlineStrategy = (function () {
                function _ProtoElementInjectorInlineStrategy(protoEI, bd) {
                    _classCallCheck(this, _ProtoElementInjectorInlineStrategy);

                    // only _binding0 can contain a component
                    this._binding0 = null;
                    this._binding1 = null;
                    this._binding2 = null;
                    this._binding3 = null;
                    this._binding4 = null;
                    this._binding5 = null;
                    this._binding6 = null;
                    this._binding7 = null;
                    this._binding8 = null;
                    this._binding9 = null;
                    this._keyId0 = null;
                    this._keyId1 = null;
                    this._keyId2 = null;
                    this._keyId3 = null;
                    this._keyId4 = null;
                    this._keyId5 = null;
                    this._keyId6 = null;
                    this._keyId7 = null;
                    this._keyId8 = null;
                    this._keyId9 = null;
                    this._visibility0 = null;
                    this._visibility1 = null;
                    this._visibility2 = null;
                    this._visibility3 = null;
                    this._visibility4 = null;
                    this._visibility5 = null;
                    this._visibility6 = null;
                    this._visibility7 = null;
                    this._visibility8 = null;
                    this._visibility9 = null;
                    var length = bd.length;
                    if (length > 0) {
                        this._binding0 = bd[0].binding;
                        this._keyId0 = bd[0].getKeyId();
                        this._visibility0 = bd[0].visibility;
                        protoEI.eventEmitterAccessors[0] = bd[0].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[0] = bd[0].createHostActionAccessors();
                    }
                    if (length > 1) {
                        this._binding1 = bd[1].binding;
                        this._keyId1 = bd[1].getKeyId();
                        this._visibility1 = bd[1].visibility;
                        protoEI.eventEmitterAccessors[1] = bd[1].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[1] = bd[1].createHostActionAccessors();
                    }
                    if (length > 2) {
                        this._binding2 = bd[2].binding;
                        this._keyId2 = bd[2].getKeyId();
                        this._visibility2 = bd[2].visibility;
                        protoEI.eventEmitterAccessors[2] = bd[2].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[2] = bd[2].createHostActionAccessors();
                    }
                    if (length > 3) {
                        this._binding3 = bd[3].binding;
                        this._keyId3 = bd[3].getKeyId();
                        this._visibility3 = bd[3].visibility;
                        protoEI.eventEmitterAccessors[3] = bd[3].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[3] = bd[3].createHostActionAccessors();
                    }
                    if (length > 4) {
                        this._binding4 = bd[4].binding;
                        this._keyId4 = bd[4].getKeyId();
                        this._visibility4 = bd[4].visibility;
                        protoEI.eventEmitterAccessors[4] = bd[4].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[4] = bd[4].createHostActionAccessors();
                    }
                    if (length > 5) {
                        this._binding5 = bd[5].binding;
                        this._keyId5 = bd[5].getKeyId();
                        this._visibility5 = bd[5].visibility;
                        protoEI.eventEmitterAccessors[5] = bd[5].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[5] = bd[5].createHostActionAccessors();
                    }
                    if (length > 6) {
                        this._binding6 = bd[6].binding;
                        this._keyId6 = bd[6].getKeyId();
                        this._visibility6 = bd[6].visibility;
                        protoEI.eventEmitterAccessors[6] = bd[6].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[6] = bd[6].createHostActionAccessors();
                    }
                    if (length > 7) {
                        this._binding7 = bd[7].binding;
                        this._keyId7 = bd[7].getKeyId();
                        this._visibility7 = bd[7].visibility;
                        protoEI.eventEmitterAccessors[7] = bd[7].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[7] = bd[7].createHostActionAccessors();
                    }
                    if (length > 8) {
                        this._binding8 = bd[8].binding;
                        this._keyId8 = bd[8].getKeyId();
                        this._visibility8 = bd[8].visibility;
                        protoEI.eventEmitterAccessors[8] = bd[8].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[8] = bd[8].createHostActionAccessors();
                    }
                    if (length > 9) {
                        this._binding9 = bd[9].binding;
                        this._keyId9 = bd[9].getKeyId();
                        this._visibility9 = bd[9].visibility;
                        protoEI.eventEmitterAccessors[9] = bd[9].createEventEmitterAccessors();
                        protoEI.hostActionAccessors[9] = bd[9].createHostActionAccessors();
                    }
                }

                _createClass(_ProtoElementInjectorInlineStrategy, [{
                    key: 'hasBindings',
                    value: function hasBindings() {
                        return isPresent(this._binding0);
                    }
                }, {
                    key: 'getBindingAtIndex',
                    value: function getBindingAtIndex(index) {
                        if (index == 0) return this._binding0;
                        if (index == 1) return this._binding1;
                        if (index == 2) return this._binding2;
                        if (index == 3) return this._binding3;
                        if (index == 4) return this._binding4;
                        if (index == 5) return this._binding5;
                        if (index == 6) return this._binding6;
                        if (index == 7) return this._binding7;
                        if (index == 8) return this._binding8;
                        if (index == 9) return this._binding9;
                        throw new OutOfBoundsAccess(index);
                    }
                }, {
                    key: 'createElementInjectorStrategy',
                    value: function createElementInjectorStrategy(ei) {
                        return new ElementInjectorInlineStrategy(this, ei);
                    }
                }]);

                return _ProtoElementInjectorInlineStrategy;
            })();

            /**
             * Strategy used by the `ProtoElementInjector` when the number of bindings is more than 10.
             */

            _ProtoElementInjectorDynamicStrategy = (function () {
                function _ProtoElementInjectorDynamicStrategy(protoInj, bd) {
                    _classCallCheck(this, _ProtoElementInjectorDynamicStrategy);

                    var len = bd.length;
                    this._bindings = ListWrapper.createFixedSize(len);
                    this._keyIds = ListWrapper.createFixedSize(len);
                    this._visibilities = ListWrapper.createFixedSize(len);
                    for (var i = 0; i < len; i++) {
                        this._bindings[i] = bd[i].binding;
                        this._keyIds[i] = bd[i].getKeyId();
                        this._visibilities[i] = bd[i].visibility;
                        protoInj.eventEmitterAccessors[i] = bd[i].createEventEmitterAccessors();
                        protoInj.hostActionAccessors[i] = bd[i].createHostActionAccessors();
                    }
                }

                _createClass(_ProtoElementInjectorDynamicStrategy, [{
                    key: 'hasBindings',
                    value: function hasBindings() {
                        return isPresent(this._bindings[0]);
                    }
                }, {
                    key: 'getBindingAtIndex',
                    value: function getBindingAtIndex(index) {
                        if (index < 0 || index >= this._bindings.length) {
                            throw new OutOfBoundsAccess(index);
                        }
                        return this._bindings[index];
                    }
                }, {
                    key: 'createElementInjectorStrategy',
                    value: function createElementInjectorStrategy(ei) {
                        return new ElementInjectorDynamicStrategy(this, ei);
                    }
                }]);

                return _ProtoElementInjectorDynamicStrategy;
            })();

            ElementInjector = (function (_TreeNode) {
                function ElementInjector(_proto, parent) {
                    _classCallCheck(this, ElementInjector);

                    _get(Object.getPrototypeOf(ElementInjector.prototype), 'constructor', this).call(this, parent);
                    this._proto = _proto;
                    this._lightDomAppInjector = null;
                    this._shadowDomAppInjector = null;
                    this._preBuiltObjects = null;
                    this._constructionCounter = 0;
                    this._strategy = _proto._strategy.createElementInjectorStrategy(this);
                    this._constructionCounter = 0;
                    this._inheritQueries(parent);
                    this._buildQueries();
                }

                _inherits(ElementInjector, _TreeNode);

                _createClass(ElementInjector, [{
                    key: 'dehydrate',
                    value: function dehydrate() {
                        this._host = null;
                        this._preBuiltObjects = null;
                        this._lightDomAppInjector = null;
                        this._shadowDomAppInjector = null;
                        this._strategy.callOnDestroy();
                        if (isPresent(this._dynamicallyCreatedComponentBinding) && this._dynamicallyCreatedComponentBinding.callOnDestroy) {
                            this._dynamicallyCreatedComponent.onDestroy();
                        }
                        this._strategy.clearInstances();
                        this._dynamicallyCreatedComponent = null;
                        this._dynamicallyCreatedComponentBinding = null;
                        this._constructionCounter = 0;
                    }
                }, {
                    key: 'hydrate',
                    value: function hydrate(injector, host, preBuiltObjects) {
                        var p = this._proto;
                        this._host = host;
                        this._lightDomAppInjector = injector;
                        this._preBuiltObjects = preBuiltObjects;
                        if (p._firstBindingIsComponent) {
                            this._shadowDomAppInjector = this._createShadowDomAppInjector(this._strategy.getComponentBinding(), injector);
                        }
                        this._checkShadowDomAppInjector(this._shadowDomAppInjector);
                        this._strategy.hydrate();
                    }
                }, {
                    key: '_createShadowDomAppInjector',
                    value: function _createShadowDomAppInjector(componentDirective, appInjector) {
                        if (!ListWrapper.isEmpty(componentDirective.resolvedAppInjectables)) {
                            return appInjector.createChildFromResolved(componentDirective.resolvedAppInjectables);
                        } else {
                            return appInjector;
                        }
                    }
                }, {
                    key: 'dynamicallyCreateComponent',
                    value: function dynamicallyCreateComponent(componentDirective, parentInjector) {
                        this._shadowDomAppInjector = this._createShadowDomAppInjector(componentDirective, parentInjector);
                        this._dynamicallyCreatedComponentBinding = componentDirective;
                        this._dynamicallyCreatedComponent = this._new(this._dynamicallyCreatedComponentBinding);
                        return this._dynamicallyCreatedComponent;
                    }
                }, {
                    key: '_checkShadowDomAppInjector',
                    value: function _checkShadowDomAppInjector(shadowDomAppInjector) {
                        if (this._proto._firstBindingIsComponent && isBlank(shadowDomAppInjector)) {
                            throw new BaseException('A shadowDomAppInjector is required as this ElementInjector contains a component');
                        } else if (!this._proto._firstBindingIsComponent && isPresent(shadowDomAppInjector)) {
                            throw new BaseException('No shadowDomAppInjector allowed as there is not component stored in this ElementInjector');
                        }
                    }
                }, {
                    key: 'get',
                    value: function get(token) {
                        if (this._isDynamicallyLoadedComponent(token)) {
                            return this._dynamicallyCreatedComponent;
                        }
                        return this._getByKey(Key.get(token), self, false, null);
                    }
                }, {
                    key: '_isDynamicallyLoadedComponent',
                    value: function _isDynamicallyLoadedComponent(token) {
                        return isPresent(this._dynamicallyCreatedComponentBinding) && Key.get(token) === this._dynamicallyCreatedComponentBinding.key;
                    }
                }, {
                    key: 'hasDirective',
                    value: function hasDirective(type) {
                        return this._strategy.getObjByKeyId(Key.get(type).id, LIGHT_DOM_AND_SHADOW_DOM) !== _undefined;
                    }
                }, {
                    key: 'getEventEmitterAccessors',
                    value: function getEventEmitterAccessors() {
                        return this._proto.eventEmitterAccessors;
                    }
                }, {
                    key: 'getHostActionAccessors',
                    value: function getHostActionAccessors() {
                        return this._proto.hostActionAccessors;
                    }
                }, {
                    key: 'getComponent',
                    value: function getComponent() {
                        return this._strategy.getComponent();
                    }
                }, {
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return new ElementRef(new ViewRef(this._preBuiltObjects.view), this._proto.index);
                    }
                }, {
                    key: 'getViewContainerRef',
                    value: function getViewContainerRef() {
                        return new ViewContainerRef(this._preBuiltObjects.viewManager, this.getElementRef());
                    }
                }, {
                    key: 'getDynamicallyLoadedComponent',
                    value: function getDynamicallyLoadedComponent() {
                        return this._dynamicallyCreatedComponent;
                    }
                }, {
                    key: 'directParent',
                    value: function directParent() {
                        return this._proto.distanceToParent < 2 ? this.parent : null;
                    }
                }, {
                    key: '_isComponentKey',
                    value: function _isComponentKey(key) {
                        return this._strategy.isComponentKey(key);
                    }
                }, {
                    key: '_isDynamicallyLoadedComponentKey',
                    value: function _isDynamicallyLoadedComponentKey(key) {
                        return isPresent(this._dynamicallyCreatedComponentBinding) && key.id === this._dynamicallyCreatedComponentBinding.key.id;
                    }
                }, {
                    key: '_new',
                    value: function _new(binding) {
                        if (this._constructionCounter++ > this._strategy.getMaxDirectives()) {
                            throw new CyclicDependencyError(binding.key);
                        }
                        var factory = binding.factory;
                        var deps = binding.dependencies;
                        var length = deps.length;
                        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
                        try {
                            d0 = length > 0 ? this._getByDependency(deps[0], binding.key) : null;
                            d1 = length > 1 ? this._getByDependency(deps[1], binding.key) : null;
                            d2 = length > 2 ? this._getByDependency(deps[2], binding.key) : null;
                            d3 = length > 3 ? this._getByDependency(deps[3], binding.key) : null;
                            d4 = length > 4 ? this._getByDependency(deps[4], binding.key) : null;
                            d5 = length > 5 ? this._getByDependency(deps[5], binding.key) : null;
                            d6 = length > 6 ? this._getByDependency(deps[6], binding.key) : null;
                            d7 = length > 7 ? this._getByDependency(deps[7], binding.key) : null;
                            d8 = length > 8 ? this._getByDependency(deps[8], binding.key) : null;
                            d9 = length > 9 ? this._getByDependency(deps[9], binding.key) : null;
                        } catch (e) {
                            if (e instanceof AbstractBindingError) e.addKey(binding.key);
                            throw e;
                        }
                        var obj;
                        switch (length) {
                            case 0:
                                obj = factory();
                                break;
                            case 1:
                                obj = factory(d0);
                                break;
                            case 2:
                                obj = factory(d0, d1);
                                break;
                            case 3:
                                obj = factory(d0, d1, d2);
                                break;
                            case 4:
                                obj = factory(d0, d1, d2, d3);
                                break;
                            case 5:
                                obj = factory(d0, d1, d2, d3, d4);
                                break;
                            case 6:
                                obj = factory(d0, d1, d2, d3, d4, d5);
                                break;
                            case 7:
                                obj = factory(d0, d1, d2, d3, d4, d5, d6);
                                break;
                            case 8:
                                obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                                break;
                            case 9:
                                obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                                break;
                            case 10:
                                obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                                break;
                        }
                        this._addToQueries(obj, binding.key.token);
                        return obj;
                    }
                }, {
                    key: '_getByDependency',
                    value: function _getByDependency(dep, requestor) {
                        if (!(dep instanceof DirectiveDependency)) {
                            return this._getByKey(dep.key, dep.visibility, dep.optional, requestor);
                        }
                        var dirDep = dep;
                        if (isPresent(dirDep.attributeName)) return this._buildAttribute(dirDep);
                        if (isPresent(dirDep.queryDirective)) return this._findQuery(dirDep.queryDirective).list;
                        if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
                            var componentView = this._preBuiltObjects.view.componentChildViews[this._proto.index];
                            return componentView.changeDetector.ref;
                        }
                        if (dirDep.key.id === StaticKeys.instance().elementRefId) {
                            return this.getElementRef();
                        }
                        if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
                            return this.getViewContainerRef();
                        }
                        if (dirDep.key.id === StaticKeys.instance().protoViewId) {
                            if (isBlank(this._preBuiltObjects.protoView)) {
                                if (dirDep.optional) {
                                    return null;
                                }
                                throw new NoBindingError(dirDep.key);
                            }
                            return new ProtoViewRef(this._preBuiltObjects.protoView);
                        }
                        return this._getByKey(dirDep.key, dirDep.visibility, dirDep.optional, requestor);
                    }
                }, {
                    key: '_buildAttribute',
                    value: function _buildAttribute(dep) {
                        var attributes = this._proto.attributes;
                        if (isPresent(attributes) && MapWrapper.contains(attributes, dep.attributeName)) {
                            return MapWrapper.get(attributes, dep.attributeName);
                        } else {
                            return null;
                        }
                    }
                }, {
                    key: '_buildQueriesForDeps',
                    value: function _buildQueriesForDeps(deps) {
                        for (var i = 0; i < deps.length; i++) {
                            var dep = deps[i];
                            if (isPresent(dep.queryDirective)) {
                                this._createQueryRef(dep.queryDirective);
                            }
                        }
                    }
                }, {
                    key: '_createQueryRef',
                    value: function _createQueryRef(directive) {
                        var queryList = new QueryList();
                        if (isBlank(this._query0)) {
                            this._query0 = new QueryRef(directive, queryList, this);
                        } else if (isBlank(this._query1)) {
                            this._query1 = new QueryRef(directive, queryList, this);
                        } else if (isBlank(this._query2)) {
                            this._query2 = new QueryRef(directive, queryList, this);
                        } else throw new QueryError();
                    }
                }, {
                    key: '_addToQueries',
                    value: function _addToQueries(obj, token) {
                        if (isPresent(this._query0) && this._query0.directive === token) {
                            this._query0.list.add(obj);
                        }
                        if (isPresent(this._query1) && this._query1.directive === token) {
                            this._query1.list.add(obj);
                        }
                        if (isPresent(this._query2) && this._query2.directive === token) {
                            this._query2.list.add(obj);
                        }
                    }
                }, {
                    key: '_inheritQueries',

                    // TODO(rado): unify with _addParentQueries.
                    value: function _inheritQueries(parent) {
                        if (isBlank(parent)) return;
                        if (isPresent(parent._query0)) {
                            this._query0 = parent._query0;
                        }
                        if (isPresent(parent._query1)) {
                            this._query1 = parent._query1;
                        }
                        if (isPresent(parent._query2)) {
                            this._query2 = parent._query2;
                        }
                    }
                }, {
                    key: '_buildQueries',
                    value: function _buildQueries() {
                        if (isPresent(this._proto)) {
                            this._strategy.buildQueries();
                        }
                    }
                }, {
                    key: '_findQuery',
                    value: function _findQuery(token) {
                        if (isPresent(this._query0) && this._query0.directive === token) {
                            return this._query0;
                        }
                        if (isPresent(this._query1) && this._query1.directive === token) {
                            return this._query1;
                        }
                        if (isPresent(this._query2) && this._query2.directive === token) {
                            return this._query2;
                        }
                        throw new BaseException('Cannot find query for directive ' + token + '.');
                    }
                }, {
                    key: 'link',
                    value: function link(parent) {
                        parent.addChild(this);
                        this._addParentQueries();
                    }
                }, {
                    key: 'linkAfter',
                    value: function linkAfter(parent, prevSibling) {
                        parent.addChildAfter(this, prevSibling);
                        this._addParentQueries();
                    }
                }, {
                    key: '_addParentQueries',
                    value: function _addParentQueries() {
                        if (isPresent(this.parent._query0)) {
                            this._addQueryToTree(this.parent._query0);
                            this.parent._query0.update();
                        }
                        if (isPresent(this.parent._query1)) {
                            this._addQueryToTree(this.parent._query1);
                            this.parent._query1.update();
                        }
                        if (isPresent(this.parent._query2)) {
                            this._addQueryToTree(this.parent._query2);
                            this.parent._query2.update();
                        }
                    }
                }, {
                    key: 'unlink',
                    value: function unlink() {
                        var queriesToUpDate = [];
                        if (isPresent(this.parent._query0)) {
                            this._pruneQueryFromTree(this.parent._query0);
                            ListWrapper.push(queriesToUpDate, this.parent._query0);
                        }
                        if (isPresent(this.parent._query1)) {
                            this._pruneQueryFromTree(this.parent._query1);
                            ListWrapper.push(queriesToUpDate, this.parent._query1);
                        }
                        if (isPresent(this.parent._query2)) {
                            this._pruneQueryFromTree(this.parent._query2);
                            ListWrapper.push(queriesToUpDate, this.parent._query2);
                        }
                        this.remove();
                        ListWrapper.forEach(queriesToUpDate, function (q) {
                            return q.update();
                        });
                    }
                }, {
                    key: '_pruneQueryFromTree',
                    value: function _pruneQueryFromTree(query) {
                        this._removeQueryRef(query);
                        var child = this._head;
                        while (isPresent(child)) {
                            child._pruneQueryFromTree(query);
                            child = child._next;
                        }
                    }
                }, {
                    key: '_addQueryToTree',
                    value: function _addQueryToTree(query) {
                        this._assignQueryRef(query);
                        var child = this._head;
                        while (isPresent(child)) {
                            child._addQueryToTree(query);
                            child = child._next;
                        }
                    }
                }, {
                    key: '_assignQueryRef',
                    value: function _assignQueryRef(query) {
                        if (isBlank(this._query0)) {
                            this._query0 = query;
                            return;
                        } else if (isBlank(this._query1)) {
                            this._query1 = query;
                            return;
                        } else if (isBlank(this._query2)) {
                            this._query2 = query;
                            return;
                        }
                        throw new QueryError();
                    }
                }, {
                    key: '_removeQueryRef',
                    value: function _removeQueryRef(query) {
                        if (this._query0 == query) this._query0 = null;
                        if (this._query1 == query) this._query1 = null;
                        if (this._query2 == query) this._query2 = null;
                    }
                }, {
                    key: '_getByKey',
                    value: function _getByKey(key, visibility, optional, requestor) {
                        var ei = this;
                        var currentVisibility = this._isComponentKey(requestor) ? LIGHT_DOM_AND_SHADOW_DOM :
                        // and light dom dependencies
                        LIGHT_DOM;
                        var depth = visibility.depth;
                        if (!visibility.includeSelf) {
                            depth -= ei._proto.distanceToParent;
                            if (isPresent(ei._parent)) {
                                ei = ei._parent;
                            } else {
                                ei = ei._host;
                                currentVisibility = visibility.crossComponentBoundaries ? LIGHT_DOM : SHADOW_DOM;
                            }
                        }
                        while (ei != null && depth >= 0) {
                            var preBuiltObj = ei._getPreBuiltObjectByKeyId(key.id);
                            if (preBuiltObj !== _undefined) return preBuiltObj;
                            var dir = ei._getObjByKeyId(key.id, currentVisibility);
                            if (dir !== _undefined) return dir;
                            depth -= ei._proto.distanceToParent;
                            // we check only one mode with the SHADOW_DOM visibility
                            if (currentVisibility === SHADOW_DOM) break;
                            if (isPresent(ei._parent)) {
                                ei = ei._parent;
                            } else {
                                ei = ei._host;
                                currentVisibility = visibility.crossComponentBoundaries ? LIGHT_DOM : SHADOW_DOM;
                            }
                        }
                        if (isPresent(this._host) && this._host._isComponentKey(key)) {
                            return this._host.getComponent();
                        } else if (isPresent(this._host) && this._host._isDynamicallyLoadedComponentKey(key)) {
                            return this._host.getDynamicallyLoadedComponent();
                        } else if (optional) {
                            return this._appInjector(requestor).getOptional(key);
                        } else {
                            return this._appInjector(requestor).get(key);
                        }
                    }
                }, {
                    key: '_appInjector',
                    value: function _appInjector(requestor) {
                        if (isPresent(requestor) && (this._isComponentKey(requestor) || this._isDynamicallyLoadedComponentKey(requestor))) {
                            return this._shadowDomAppInjector;
                        } else {
                            return this._lightDomAppInjector;
                        }
                    }
                }, {
                    key: '_getPreBuiltObjectByKeyId',
                    value: function _getPreBuiltObjectByKeyId(keyId) {
                        var staticKeys = StaticKeys.instance();
                        if (keyId === staticKeys.viewManagerId) return this._preBuiltObjects.viewManager;
                        return _undefined;
                    }
                }, {
                    key: '_getObjByKeyId',
                    value: function _getObjByKeyId(keyId, visibility) {
                        return this._strategy.getObjByKeyId(keyId, visibility);
                    }
                }, {
                    key: 'getDirectiveAtIndex',
                    value: function getDirectiveAtIndex(index) {
                        return this._strategy.getDirectiveAtIndex(index);
                    }
                }, {
                    key: 'hasInstances',
                    value: function hasInstances() {
                        return this._constructionCounter > 0;
                    }
                }, {
                    key: 'isExportingComponent',

                    /** Gets whether this element is exporting a component instance as $implicit. */
                    value: function isExportingComponent() {
                        return this._proto.exportComponent;
                    }
                }, {
                    key: 'isExportingElement',

                    /** Gets whether this element is exporting its element as $implicit. */
                    value: function isExportingElement() {
                        return this._proto.exportElement;
                    }
                }, {
                    key: 'getExportImplicitName',

                    /** Get the name to which this element's $implicit is to be assigned. */
                    value: function getExportImplicitName() {
                        return this._proto.exportImplicitName;
                    }
                }, {
                    key: 'getLightDomAppInjector',
                    value: function getLightDomAppInjector() {
                        return this._lightDomAppInjector;
                    }
                }, {
                    key: 'getShadowDomAppInjector',
                    value: function getShadowDomAppInjector() {
                        return this._shadowDomAppInjector;
                    }
                }, {
                    key: 'getHost',
                    value: function getHost() {
                        return this._host;
                    }
                }, {
                    key: 'getBoundElementIndex',
                    value: function getBoundElementIndex() {
                        return this._proto.index;
                    }
                }]);

                return ElementInjector;
            })(TreeNode);

            _export('ElementInjector', ElementInjector);

            /**
             * Strategy used by the `ElementInjector` when the number of bindings is 10 or less.
             * In such a case, inlining fields is benefitial for performances.
             */

            ElementInjectorInlineStrategy = (function () {
                function ElementInjectorInlineStrategy(_protoStrategy, _ei) {
                    _classCallCheck(this, ElementInjectorInlineStrategy);

                    this._protoStrategy = _protoStrategy;
                    this._ei = _ei;
                    // If this element injector has a component, the component instance will be stored in _obj0
                    this._obj0 = null;
                    this._obj1 = null;
                    this._obj2 = null;
                    this._obj3 = null;
                    this._obj4 = null;
                    this._obj5 = null;
                    this._obj6 = null;
                    this._obj7 = null;
                    this._obj8 = null;
                    this._obj9 = null;
                }

                _createClass(ElementInjectorInlineStrategy, [{
                    key: 'callOnDestroy',
                    value: function callOnDestroy() {
                        var p = this._protoStrategy;
                        if (p._binding0 instanceof DirectiveBinding && p._binding0.callOnDestroy) {
                            this._obj0.onDestroy();
                        }
                        if (p._binding1 instanceof DirectiveBinding && p._binding1.callOnDestroy) {
                            this._obj1.onDestroy();
                        }
                        if (p._binding2 instanceof DirectiveBinding && p._binding2.callOnDestroy) {
                            this._obj2.onDestroy();
                        }
                        if (p._binding3 instanceof DirectiveBinding && p._binding3.callOnDestroy) {
                            this._obj3.onDestroy();
                        }
                        if (p._binding4 instanceof DirectiveBinding && p._binding4.callOnDestroy) {
                            this._obj4.onDestroy();
                        }
                        if (p._binding5 instanceof DirectiveBinding && p._binding5.callOnDestroy) {
                            this._obj5.onDestroy();
                        }
                        if (p._binding6 instanceof DirectiveBinding && p._binding6.callOnDestroy) {
                            this._obj6.onDestroy();
                        }
                        if (p._binding7 instanceof DirectiveBinding && p._binding7.callOnDestroy) {
                            this._obj7.onDestroy();
                        }
                        if (p._binding8 instanceof DirectiveBinding && p._binding8.callOnDestroy) {
                            this._obj8.onDestroy();
                        }
                        if (p._binding9 instanceof DirectiveBinding && p._binding9.callOnDestroy) {
                            this._obj9.onDestroy();
                        }
                    }
                }, {
                    key: 'clearInstances',
                    value: function clearInstances() {
                        this._obj0 = null;
                        this._obj1 = null;
                        this._obj2 = null;
                        this._obj3 = null;
                        this._obj4 = null;
                        this._obj5 = null;
                        this._obj6 = null;
                        this._obj7 = null;
                        this._obj8 = null;
                        this._obj9 = null;
                    }
                }, {
                    key: 'hydrate',
                    value: function hydrate() {
                        var p = this._protoStrategy;
                        if (isPresent(p._keyId0)) this.getObjByKeyId(p._keyId0, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId1)) this.getObjByKeyId(p._keyId1, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId2)) this.getObjByKeyId(p._keyId2, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId3)) this.getObjByKeyId(p._keyId3, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId4)) this.getObjByKeyId(p._keyId4, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId5)) this.getObjByKeyId(p._keyId5, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId6)) this.getObjByKeyId(p._keyId6, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId7)) this.getObjByKeyId(p._keyId7, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId8)) this.getObjByKeyId(p._keyId8, LIGHT_DOM_AND_SHADOW_DOM);
                        if (isPresent(p._keyId9)) this.getObjByKeyId(p._keyId9, LIGHT_DOM_AND_SHADOW_DOM);
                    }
                }, {
                    key: 'getComponent',
                    value: function getComponent() {
                        return this._obj0;
                    }
                }, {
                    key: 'isComponentKey',
                    value: function isComponentKey(key) {
                        return this._ei._proto._firstBindingIsComponent && isPresent(key) && key.id === this._protoStrategy._keyId0;
                    }
                }, {
                    key: 'buildQueries',
                    value: function buildQueries() {
                        var p = this._protoStrategy;
                        if (p._binding0 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding0.dependencies);
                        }
                        if (p._binding1 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding1.dependencies);
                        }
                        if (p._binding2 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding2.dependencies);
                        }
                        if (p._binding3 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding3.dependencies);
                        }
                        if (p._binding4 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding4.dependencies);
                        }
                        if (p._binding5 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding5.dependencies);
                        }
                        if (p._binding6 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding6.dependencies);
                        }
                        if (p._binding7 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding7.dependencies);
                        }
                        if (p._binding8 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding8.dependencies);
                        }
                        if (p._binding9 instanceof DirectiveBinding) {
                            this._ei._buildQueriesForDeps(p._binding9.dependencies);
                        }
                    }
                }, {
                    key: 'getObjByKeyId',
                    value: function getObjByKeyId(keyId, visibility) {
                        var p = this._protoStrategy;
                        if (p._keyId0 === keyId && (p._visibility0 & visibility) > 0) {
                            if (isBlank(this._obj0)) {
                                this._obj0 = this._ei._new(p._binding0);
                            }
                            return this._obj0;
                        }
                        if (p._keyId1 === keyId && (p._visibility1 & visibility) > 0) {
                            if (isBlank(this._obj1)) {
                                this._obj1 = this._ei._new(p._binding1);
                            }
                            return this._obj1;
                        }
                        if (p._keyId2 === keyId && (p._visibility2 & visibility) > 0) {
                            if (isBlank(this._obj2)) {
                                this._obj2 = this._ei._new(p._binding2);
                            }
                            return this._obj2;
                        }
                        if (p._keyId3 === keyId && (p._visibility3 & visibility) > 0) {
                            if (isBlank(this._obj3)) {
                                this._obj3 = this._ei._new(p._binding3);
                            }
                            return this._obj3;
                        }
                        if (p._keyId4 === keyId && (p._visibility4 & visibility) > 0) {
                            if (isBlank(this._obj4)) {
                                this._obj4 = this._ei._new(p._binding4);
                            }
                            return this._obj4;
                        }
                        if (p._keyId5 === keyId && (p._visibility5 & visibility) > 0) {
                            if (isBlank(this._obj5)) {
                                this._obj5 = this._ei._new(p._binding5);
                            }
                            return this._obj5;
                        }
                        if (p._keyId6 === keyId && (p._visibility6 & visibility) > 0) {
                            if (isBlank(this._obj6)) {
                                this._obj6 = this._ei._new(p._binding6);
                            }
                            return this._obj6;
                        }
                        if (p._keyId7 === keyId && (p._visibility7 & visibility) > 0) {
                            if (isBlank(this._obj7)) {
                                this._obj7 = this._ei._new(p._binding7);
                            }
                            return this._obj7;
                        }
                        if (p._keyId8 === keyId && (p._visibility8 & visibility) > 0) {
                            if (isBlank(this._obj8)) {
                                this._obj8 = this._ei._new(p._binding8);
                            }
                            return this._obj8;
                        }
                        if (p._keyId9 === keyId && (p._visibility9 & visibility) > 0) {
                            if (isBlank(this._obj9)) {
                                this._obj9 = this._ei._new(p._binding9);
                            }
                            return this._obj9;
                        }
                        return _undefined;
                    }
                }, {
                    key: 'getDirectiveAtIndex',
                    value: function getDirectiveAtIndex(index) {
                        if (index == 0) return this._obj0;
                        if (index == 1) return this._obj1;
                        if (index == 2) return this._obj2;
                        if (index == 3) return this._obj3;
                        if (index == 4) return this._obj4;
                        if (index == 5) return this._obj5;
                        if (index == 6) return this._obj6;
                        if (index == 7) return this._obj7;
                        if (index == 8) return this._obj8;
                        if (index == 9) return this._obj9;
                        throw new OutOfBoundsAccess(index);
                    }
                }, {
                    key: 'getComponentBinding',
                    value: function getComponentBinding() {
                        return this._protoStrategy._binding0;
                    }
                }, {
                    key: 'getMaxDirectives',
                    value: function getMaxDirectives() {
                        return _MAX_DIRECTIVE_CONSTRUCTION_COUNTER;
                    }
                }]);

                return ElementInjectorInlineStrategy;
            })();

            /**
             * Strategy used by the `ElementInjector` when the number of bindings is 10 or less.
             * In such a case, inlining fields is benefitial for performances.
             */

            ElementInjectorDynamicStrategy = (function () {
                function ElementInjectorDynamicStrategy(_protoStrategy, _ei) {
                    _classCallCheck(this, ElementInjectorDynamicStrategy);

                    this._protoStrategy = _protoStrategy;
                    this._ei = _ei;
                    this._objs = ListWrapper.createFixedSize(_protoStrategy._bindings.length);
                }

                _createClass(ElementInjectorDynamicStrategy, [{
                    key: 'callOnDestroy',
                    value: function callOnDestroy() {
                        var p = this._protoStrategy;
                        for (var i = 0; i < p._bindings.length; i++) {
                            if (p._bindings[i] instanceof DirectiveBinding && p._bindings[i].callOnDestroy) {
                                this._objs[i].onDestroy();
                            }
                        }
                    }
                }, {
                    key: 'clearInstances',
                    value: function clearInstances() {
                        ListWrapper.fill(this._objs, null);
                    }
                }, {
                    key: 'hydrate',
                    value: function hydrate() {
                        var p = this._protoStrategy;
                        for (var i = 0; i < p._keyIds.length; i++) {
                            if (isPresent(p._keyIds[i])) {
                                this.getObjByKeyId(p._keyIds[i], LIGHT_DOM_AND_SHADOW_DOM);
                            }
                        }
                    }
                }, {
                    key: 'getComponent',
                    value: function getComponent() {
                        return this._objs[0];
                    }
                }, {
                    key: 'isComponentKey',
                    value: function isComponentKey(key) {
                        return this._ei._proto._firstBindingIsComponent && isPresent(key) && key.id === this._protoStrategy._keyIds[0];
                    }
                }, {
                    key: 'buildQueries',
                    value: function buildQueries() {
                        var p = this._protoStrategy;
                        for (var i = 0; i < p._bindings.length; i++) {
                            if (p._bindings[i] instanceof DirectiveBinding) {
                                this._ei._buildQueriesForDeps(p._bindings[i].dependencies);
                            }
                        }
                    }
                }, {
                    key: 'getObjByKeyId',
                    value: function getObjByKeyId(keyId, visibility) {
                        var p = this._protoStrategy;
                        // TODO(vicb): optimize lookup ?
                        for (var i = 0; i < p._keyIds.length; i++) {
                            if (p._keyIds[i] === keyId && (p._visibilities[i] & visibility) > 0) {
                                if (isBlank(this._objs[i])) {
                                    this._objs[i] = this._ei._new(p._bindings[i]);
                                }
                                return this._objs[i];
                            }
                        }
                        return _undefined;
                    }
                }, {
                    key: 'getDirectiveAtIndex',
                    value: function getDirectiveAtIndex(index) {
                        if (index < 0 || index >= this._objs.length) {
                            throw new OutOfBoundsAccess(index);
                        }
                        return this._objs[index];
                    }
                }, {
                    key: 'getComponentBinding',
                    value: function getComponentBinding() {
                        return this._protoStrategy._bindings[0];
                    }
                }, {
                    key: 'getMaxDirectives',
                    value: function getMaxDirectives() {
                        return this._objs.length;
                    }
                }]);

                return ElementInjectorDynamicStrategy;
            })();

            OutOfBoundsAccess = (function (_BaseException) {
                function OutOfBoundsAccess(index) {
                    _classCallCheck(this, OutOfBoundsAccess);

                    _get(Object.getPrototypeOf(OutOfBoundsAccess.prototype), 'constructor', this).call(this);
                    this.message = 'Index ' + index + ' is out-of-bounds.';
                }

                _inherits(OutOfBoundsAccess, _BaseException);

                _createClass(OutOfBoundsAccess, [{
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return OutOfBoundsAccess;
            })(BaseException);

            QueryError = (function (_BaseException2) {
                // TODO(rado): pass the names of the active directives.

                function QueryError() {
                    _classCallCheck(this, QueryError);

                    _get(Object.getPrototypeOf(QueryError.prototype), 'constructor', this).call(this);
                    this.message = 'Only 3 queries can be concurrently active in a template.';
                }

                _inherits(QueryError, _BaseException2);

                _createClass(QueryError, [{
                    key: 'toString',
                    value: function toString() {
                        return this.message;
                    }
                }]);

                return QueryError;
            })(BaseException);

            QueryRef = (function () {
                function QueryRef(directive, list, originator) {
                    _classCallCheck(this, QueryRef);

                    this.directive = directive;
                    this.list = list;
                    this.originator = originator;
                }

                _createClass(QueryRef, [{
                    key: 'update',
                    value: function update() {
                        var aggregator = [];
                        this.visit(this.originator, aggregator);
                        this.list.reset(aggregator);
                    }
                }, {
                    key: 'visit',
                    value: function visit(inj, aggregator) {
                        if (isBlank(inj)) return;
                        if (inj.hasDirective(this.directive)) {
                            ListWrapper.push(aggregator, inj.get(this.directive));
                        }
                        var child = inj._head;
                        while (isPresent(child)) {
                            this.visit(child, aggregator);
                            child = child._next;
                        }
                    }
                }]);

                return QueryRef;
            })();
        }
    };
});


System.register("angular2/src/core/compiler/compiler", ["npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/di", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/core/compiler/directive_resolver", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/element_injector", "angular2/src/core/compiler/template_resolver", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/proto_view_factory", "angular2/src/services/url_resolver", "angular2/src/render/api"], function (_export) {
    var _createClass, _classCallCheck, Binding, resolveForwardRef, Injectable, Type, isBlank, isPresent, BaseException, normalizeBlank, stringify, PromiseWrapper, ListWrapper, MapWrapper, DirectiveResolver, ProtoViewRef, DirectiveBinding, TemplateResolver, ComponentUrlMapper, ProtoViewFactory, UrlResolver, renderApi, __decorate, __metadata, CompilerCache, Compiler;

    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2Di) {
            Binding = _angular2Di.Binding;
            resolveForwardRef = _angular2Di.resolveForwardRef;
            Injectable = _angular2Di.Injectable;
        }, function (_angular2SrcFacadeLang) {
            Type = _angular2SrcFacadeLang.Type;
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
            normalizeBlank = _angular2SrcFacadeLang.normalizeBlank;
            stringify = _angular2SrcFacadeLang.stringify;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
        }, function (_angular2SrcCoreCompilerDirective_resolver) {
            DirectiveResolver = _angular2SrcCoreCompilerDirective_resolver.DirectiveResolver;
        }, function (_angular2SrcCoreCompilerView_ref) {
            ProtoViewRef = _angular2SrcCoreCompilerView_ref.ProtoViewRef;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_angular2SrcCoreCompilerTemplate_resolver) {
            TemplateResolver = _angular2SrcCoreCompilerTemplate_resolver.TemplateResolver;
        }, function (_angular2SrcCoreCompilerComponent_url_mapper) {
            ComponentUrlMapper = _angular2SrcCoreCompilerComponent_url_mapper.ComponentUrlMapper;
        }, function (_angular2SrcCoreCompilerProto_view_factory) {
            ProtoViewFactory = _angular2SrcCoreCompilerProto_view_factory.ProtoViewFactory;
        }, function (_angular2SrcServicesUrl_resolver) {
            UrlResolver = _angular2SrcServicesUrl_resolver.UrlResolver;
        }, function (_angular2SrcRenderApi) {
            renderApi = _angular2SrcRenderApi;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Cache that stores the AppProtoView of the template of a component.
             * Used to prevent duplicate work and resolve cyclic dependencies.
             */

            CompilerCache = (function () {
                var _class = function CompilerCache() {
                    _classCallCheck(this, _class);

                    this._cache = MapWrapper.create();
                };

                _createClass(_class, [{
                    key: "set",
                    value: function set(component, protoView) {
                        MapWrapper.set(this._cache, component, protoView);
                    }
                }, {
                    key: "get",
                    value: function get(component) {
                        var result = MapWrapper.get(this._cache, component);
                        return normalizeBlank(result);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        MapWrapper.clear(this._cache);
                    }
                }]);

                return _class;
            })();

            _export("CompilerCache", CompilerCache);

            _export("CompilerCache", CompilerCache = __decorate([Injectable(), __metadata("design:paramtypes", [])], CompilerCache));
            /**
             * @exportedAs angular2/view
             */

            Compiler = (function () {
                var _class2 = function Compiler(reader, cache, templateResolver, componentUrlMapper, urlResolver, render, protoViewFactory) {
                    _classCallCheck(this, _class2);

                    this._reader = reader;
                    this._compilerCache = cache;
                    this._compiling = MapWrapper.create();
                    this._templateResolver = templateResolver;
                    this._componentUrlMapper = componentUrlMapper;
                    this._urlResolver = urlResolver;
                    this._appUrl = urlResolver.resolve(null, "./");
                    this._render = render;
                    this._protoViewFactory = protoViewFactory;
                };

                _createClass(_class2, [{
                    key: "_bindDirective",
                    value: function _bindDirective(directiveTypeOrBinding) {
                        if (directiveTypeOrBinding instanceof DirectiveBinding) {
                            return directiveTypeOrBinding;
                        } else if (directiveTypeOrBinding instanceof Binding) {
                            var annotation = this._reader.resolve(directiveTypeOrBinding.token);
                            return DirectiveBinding.createFromBinding(directiveTypeOrBinding, annotation);
                        } else {
                            var annotation = this._reader.resolve(directiveTypeOrBinding);
                            return DirectiveBinding.createFromType(directiveTypeOrBinding, annotation);
                        }
                    }
                }, {
                    key: "compileInHost",

                    // Create a hostView as if the compiler encountered <hostcmp></hostcmp>.
                    // Used for bootstrapping.
                    value: function compileInHost(componentTypeOrBinding) {
                        var _this = this;

                        var componentBinding = this._bindDirective(componentTypeOrBinding);
                        Compiler._assertTypeIsComponent(componentBinding);
                        var directiveMetadata = componentBinding.metadata;
                        return this._render.compileHost(directiveMetadata).then(function (hostRenderPv) {
                            return _this._compileNestedProtoViews(componentBinding, hostRenderPv, [componentBinding]);
                        }).then(function (appProtoView) {
                            return new ProtoViewRef(appProtoView);
                        });
                    }
                }, {
                    key: "compile",
                    value: function compile(component) {
                        var componentBinding = this._bindDirective(component);
                        Compiler._assertTypeIsComponent(componentBinding);
                        var pvOrPromise = this._compile(componentBinding);
                        var pvPromise = PromiseWrapper.isPromise(pvOrPromise) ? pvOrPromise : PromiseWrapper.resolve(pvOrPromise);
                        return pvPromise.then(function (appProtoView) {
                            return new ProtoViewRef(appProtoView);
                        });
                    }
                }, {
                    key: "_compile",
                    value: function _compile(componentBinding) {
                        var _this2 = this;

                        var component = componentBinding.key.token;
                        var protoView = this._compilerCache.get(component);
                        if (isPresent(protoView)) {
                            // The component has already been compiled into an AppProtoView,
                            // returns a plain AppProtoView, not wrapped inside of a Promise.
                            // Needed for recursive components.
                            return protoView;
                        }
                        var pvPromise = MapWrapper.get(this._compiling, component);
                        if (isPresent(pvPromise)) {
                            // The component is already being compiled, attach to the existing Promise
                            // instead of re-compiling the component.
                            // It happens when a template references a component multiple times.
                            return pvPromise;
                        }
                        var template = this._templateResolver.resolve(component);
                        if (isBlank(template)) {
                            return null;
                        }
                        var directives = this._flattenDirectives(template);
                        for (var i = 0; i < directives.length; i++) {
                            if (!Compiler._isValidDirective(directives[i])) {
                                throw new BaseException("Unexpected directive value '" + stringify(directives[i]) + "' on the View of component '" + stringify(component) + "'");
                            }
                        }
                        var boundDirectives = ListWrapper.map(directives, function (directive) {
                            return _this2._bindDirective(directive);
                        });
                        var renderTemplate = this._buildRenderTemplate(component, template, boundDirectives);
                        pvPromise = this._render.compile(renderTemplate).then(function (renderPv) {
                            return _this2._compileNestedProtoViews(componentBinding, renderPv, boundDirectives);
                        });
                        MapWrapper.set(this._compiling, component, pvPromise);
                        return pvPromise;
                    }
                }, {
                    key: "_compileNestedProtoViews",
                    value: function _compileNestedProtoViews(componentBinding, renderPv, directives) {
                        var _this3 = this;

                        var protoViews = this._protoViewFactory.createAppProtoViews(componentBinding, renderPv, directives);
                        var protoView = protoViews[0];
                        // TODO(tbosch): we should be caching host protoViews as well!
                        // -> need a separate cache for this...
                        if (renderPv.type === renderApi.ProtoViewDto.COMPONENT_VIEW_TYPE && isPresent(componentBinding)) {
                            // Populate the cache before compiling the nested components,
                            // so that components can reference themselves in their template.
                            var component = componentBinding.key.token;
                            this._compilerCache.set(component, protoView);
                            MapWrapper["delete"](this._compiling, component);
                        }
                        var nestedPVPromises = [];
                        ListWrapper.forEach(this._collectComponentElementBinders(protoViews), function (elementBinder) {
                            var nestedComponent = elementBinder.componentDirective;
                            var elementBinderDone = function elementBinderDone(nestedPv) {
                                elementBinder.nestedProtoView = nestedPv;
                            };
                            var nestedCall = _this3._compile(nestedComponent);
                            if (PromiseWrapper.isPromise(nestedCall)) {
                                ListWrapper.push(nestedPVPromises, nestedCall.then(elementBinderDone));
                            } else if (isPresent(nestedCall)) {
                                elementBinderDone(nestedCall);
                            }
                        });
                        if (nestedPVPromises.length > 0) {
                            return PromiseWrapper.all(nestedPVPromises).then(function (_) {
                                return protoView;
                            });
                        } else {
                            return protoView;
                        }
                    }
                }, {
                    key: "_collectComponentElementBinders",
                    value: function _collectComponentElementBinders(protoViews) {
                        var componentElementBinders = [];
                        ListWrapper.forEach(protoViews, function (protoView) {
                            ListWrapper.forEach(protoView.elementBinders, function (elementBinder) {
                                if (isPresent(elementBinder.componentDirective)) {
                                    ListWrapper.push(componentElementBinders, elementBinder);
                                }
                            });
                        });
                        return componentElementBinders;
                    }
                }, {
                    key: "_buildRenderTemplate",
                    value: function _buildRenderTemplate(component, view, directives) {
                        var componentUrl = this._urlResolver.resolve(this._appUrl, this._componentUrlMapper.getUrl(component));
                        var templateAbsUrl = null;
                        if (isPresent(view.templateUrl)) {
                            templateAbsUrl = this._urlResolver.resolve(componentUrl, view.templateUrl);
                        } else if (isPresent(view.template)) {
                            // Note: If we have an inline template, we also need to send
                            // the url for the component to the render so that it
                            // is able to resolve urls in stylesheets.
                            templateAbsUrl = componentUrl;
                        }
                        return new renderApi.ViewDefinition({
                            componentId: stringify(component),
                            absUrl: templateAbsUrl, template: view.template,
                            directives: ListWrapper.map(directives, function (directiveBinding) {
                                return directiveBinding.metadata;
                            })
                        });
                    }
                }, {
                    key: "_flattenDirectives",
                    value: function _flattenDirectives(template) {
                        if (isBlank(template.directives)) return [];
                        var directives = [];
                        this._flattenList(template.directives, directives);
                        return directives;
                    }
                }, {
                    key: "_flattenList",
                    value: function _flattenList(tree, out) {
                        for (var i = 0; i < tree.length; i++) {
                            var item = resolveForwardRef(tree[i]);
                            if (ListWrapper.isList(item)) {
                                this._flattenList(item, out);
                            } else {
                                ListWrapper.push(out, item);
                            }
                        }
                    }
                }], [{
                    key: "_isValidDirective",
                    value: function _isValidDirective(value) {
                        return isPresent(value) && (value instanceof Type || value instanceof Binding);
                    }
                }, {
                    key: "_assertTypeIsComponent",
                    value: function _assertTypeIsComponent(directiveBinding) {
                        if (directiveBinding.metadata.type !== renderApi.DirectiveMetadata.COMPONENT_TYPE) {
                            throw new BaseException("Could not load '" + stringify(directiveBinding.key.token) + "' because it is not a component.");
                        }
                    }
                }]);

                return _class2;
            })();

            _export("Compiler", Compiler);

            _export("Compiler", Compiler = __decorate([Injectable(), __metadata("design:paramtypes", [DirectiveResolver, CompilerCache, TemplateResolver, ComponentUrlMapper, UrlResolver, renderApi.RenderCompiler, ProtoViewFactory])], Compiler));
            
        }
    };
});
System.register("angular2/src/change_detection/pipes/keyvalue_changes", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "npm:babel-runtime@5.4.7/core-js/map", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, _Map, ListWrapper, MapWrapper, StringMapWrapper, stringify, looseIdentical, isJsObject, CONST, WrappedValue, Pipe, PipeFactory, __decorate, __metadata, KeyValueChangesFactory, KeyValueChanges, KVChangeRecord;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime547CoreJsMap) {
            _Map = _npmBabelRuntime547CoreJsMap["default"];
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
            MapWrapper = _angular2SrcFacadeCollection.MapWrapper;
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2SrcFacadeLang) {
            stringify = _angular2SrcFacadeLang.stringify;
            looseIdentical = _angular2SrcFacadeLang.looseIdentical;
            isJsObject = _angular2SrcFacadeLang.isJsObject;
            CONST = _angular2SrcFacadeLang.CONST;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            WrappedValue = _angular2SrcChange_detectionPipesPipe.WrappedValue;
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
            PipeFactory = _angular2SrcChange_detectionPipesPipe.PipeFactory;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * @exportedAs angular2/pipes
             */

            KeyValueChangesFactory = (function (_PipeFactory) {
                var _class = function KeyValueChangesFactory() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                };

                _inherits(_class, _PipeFactory);

                _createClass(_class, [{
                    key: "supports",
                    value: function supports(obj) {
                        return KeyValueChanges.supportsObj(obj);
                    }
                }, {
                    key: "create",
                    value: function create(cdRef) {
                        return new KeyValueChanges();
                    }
                }]);

                return _class;
            })(PipeFactory);

            _export("KeyValueChangesFactory", KeyValueChangesFactory);

            _export("KeyValueChangesFactory", KeyValueChangesFactory = __decorate([CONST(), __metadata("design:paramtypes", [])], KeyValueChangesFactory));
            /**
             * @exportedAs angular2/pipes
             */

            KeyValueChanges = (function (_Pipe) {
                function KeyValueChanges() {
                    _classCallCheck(this, KeyValueChanges);

                    _get(Object.getPrototypeOf(KeyValueChanges.prototype), "constructor", this).call(this);
                    this._records = MapWrapper.create();
                    this._mapHead = null;
                    this._previousMapHead = null;
                    this._changesHead = null;
                    this._changesTail = null;
                    this._additionsHead = null;
                    this._additionsTail = null;
                    this._removalsHead = null;
                    this._removalsTail = null;
                }

                _inherits(KeyValueChanges, _Pipe);

                _createClass(KeyValueChanges, [{
                    key: "supports",
                    value: function supports(obj) {
                        return KeyValueChanges.supportsObj(obj);
                    }
                }, {
                    key: "transform",
                    value: function transform(map) {
                        if (this.check(map)) {
                            return WrappedValue.wrap(this);
                        } else {
                            return this;
                        }
                    }
                }, {
                    key: "isDirty",
                    get: function () {
                        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
                    }
                }, {
                    key: "forEachItem",
                    value: function forEachItem(fn) {
                        var record;
                        for (record = this._mapHead; record !== null; record = record._next) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachPreviousItem",
                    value: function forEachPreviousItem(fn) {
                        var record;
                        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachChangedItem",
                    value: function forEachChangedItem(fn) {
                        var record;
                        for (record = this._changesHead; record !== null; record = record._nextChanged) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachAddedItem",
                    value: function forEachAddedItem(fn) {
                        var record;
                        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                            fn(record);
                        }
                    }
                }, {
                    key: "forEachRemovedItem",
                    value: function forEachRemovedItem(fn) {
                        var record;
                        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                            fn(record);
                        }
                    }
                }, {
                    key: "check",
                    value: function check(map) {
                        var _this = this;

                        this._reset();
                        var records = this._records;
                        var oldSeqRecord = this._mapHead;
                        var lastOldSeqRecord = null;
                        var lastNewSeqRecord = null;
                        var seqChanged = false;
                        this._forEach(map, function (value, key) {
                            var newSeqRecord;
                            if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                                newSeqRecord = oldSeqRecord;
                                if (!looseIdentical(value, oldSeqRecord.currentValue)) {
                                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                                    oldSeqRecord.currentValue = value;
                                    _this._addToChanges(oldSeqRecord);
                                }
                            } else {
                                seqChanged = true;
                                if (oldSeqRecord !== null) {
                                    oldSeqRecord._next = null;
                                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                                    _this._addToRemovals(oldSeqRecord);
                                }
                                if (MapWrapper.contains(records, key)) {
                                    newSeqRecord = MapWrapper.get(records, key);
                                } else {
                                    newSeqRecord = new KVChangeRecord(key);
                                    MapWrapper.set(records, key, newSeqRecord);
                                    newSeqRecord.currentValue = value;
                                    _this._addToAdditions(newSeqRecord);
                                }
                            }
                            if (seqChanged) {
                                if (_this._isInRemovals(newSeqRecord)) {
                                    _this._removeFromRemovals(newSeqRecord);
                                }
                                if (lastNewSeqRecord == null) {
                                    _this._mapHead = newSeqRecord;
                                } else {
                                    lastNewSeqRecord._next = newSeqRecord;
                                }
                            }
                            lastOldSeqRecord = oldSeqRecord;
                            lastNewSeqRecord = newSeqRecord;
                            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
                        });
                        this._truncate(lastOldSeqRecord, oldSeqRecord);
                        return this.isDirty;
                    }
                }, {
                    key: "_reset",
                    value: function _reset() {
                        if (this.isDirty) {
                            var record;
                            // Record the state of the mapping
                            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                                record._nextPrevious = record._next;
                            }
                            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                                record.previousValue = record.currentValue;
                            }
                            for (record = this._additionsHead; record != null; record = record._nextAdded) {
                                record.previousValue = record.currentValue;
                            }
                            // todo(vicb) once assert is supported
                            // assert(() {
                            //  var r = _changesHead;
                            //  while (r != null) {
                            //    var nextRecord = r._nextChanged;
                            //    r._nextChanged = null;
                            //    r = nextRecord;
                            //  }
                            //
                            //  r = _additionsHead;
                            //  while (r != null) {
                            //    var nextRecord = r._nextAdded;
                            //    r._nextAdded = null;
                            //    r = nextRecord;
                            //  }
                            //
                            //  r = _removalsHead;
                            //  while (r != null) {
                            //    var nextRecord = r._nextRemoved;
                            //    r._nextRemoved = null;
                            //    r = nextRecord;
                            //  }
                            //
                            //  return true;
                            //});
                            this._changesHead = this._changesTail = null;
                            this._additionsHead = this._additionsTail = null;
                            this._removalsHead = this._removalsTail = null;
                        }
                    }
                }, {
                    key: "_truncate",
                    value: function _truncate(lastRecord, record) {
                        while (record !== null) {
                            if (lastRecord === null) {
                                this._mapHead = null;
                            } else {
                                lastRecord._next = null;
                            }
                            var nextRecord = record._next;
                            // todo(vicb) assert
                            // assert((() {
                            //  record._next = null;
                            //  return true;
                            //}));
                            this._addToRemovals(record);
                            lastRecord = record;
                            record = nextRecord;
                        }
                        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
                            rec.previousValue = rec.currentValue;
                            rec.currentValue = null;
                            MapWrapper["delete"](this._records, rec.key);
                        }
                    }
                }, {
                    key: "_isInRemovals",
                    value: function _isInRemovals(record) {
                        return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
                    }
                }, {
                    key: "_addToRemovals",
                    value: function _addToRemovals(record) {
                        // todo(vicb) assert
                        // assert(record._next == null);
                        // assert(record._nextAdded == null);
                        // assert(record._nextChanged == null);
                        // assert(record._nextRemoved == null);
                        // assert(record._prevRemoved == null);
                        if (this._removalsHead === null) {
                            this._removalsHead = this._removalsTail = record;
                        } else {
                            this._removalsTail._nextRemoved = record;
                            record._prevRemoved = this._removalsTail;
                            this._removalsTail = record;
                        }
                    }
                }, {
                    key: "_removeFromSeq",
                    value: function _removeFromSeq(prev, record) {
                        var next = record._next;
                        if (prev === null) {
                            this._mapHead = next;
                        } else {
                            prev._next = next;
                        }
                        // todo(vicb) assert
                        // assert((() {
                        //  record._next = null;
                        //  return true;
                        //})());
                    }
                }, {
                    key: "_removeFromRemovals",
                    value: function _removeFromRemovals(record) {
                        // todo(vicb) assert
                        // assert(record._next == null);
                        // assert(record._nextAdded == null);
                        // assert(record._nextChanged == null);
                        var prev = record._prevRemoved;
                        var next = record._nextRemoved;
                        if (prev === null) {
                            this._removalsHead = next;
                        } else {
                            prev._nextRemoved = next;
                        }
                        if (next === null) {
                            this._removalsTail = prev;
                        } else {
                            next._prevRemoved = prev;
                        }
                        record._prevRemoved = record._nextRemoved = null;
                    }
                }, {
                    key: "_addToAdditions",
                    value: function _addToAdditions(record) {
                        // todo(vicb): assert
                        // assert(record._next == null);
                        // assert(record._nextAdded == null);
                        // assert(record._nextChanged == null);
                        // assert(record._nextRemoved == null);
                        // assert(record._prevRemoved == null);
                        if (this._additionsHead === null) {
                            this._additionsHead = this._additionsTail = record;
                        } else {
                            this._additionsTail._nextAdded = record;
                            this._additionsTail = record;
                        }
                    }
                }, {
                    key: "_addToChanges",
                    value: function _addToChanges(record) {
                        // todo(vicb) assert
                        // assert(record._nextAdded == null);
                        // assert(record._nextChanged == null);
                        // assert(record._nextRemoved == null);
                        // assert(record._prevRemoved == null);
                        if (this._changesHead === null) {
                            this._changesHead = this._changesTail = record;
                        } else {
                            this._changesTail._nextChanged = record;
                            this._changesTail = record;
                        }
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var items = [];
                        var previous = [];
                        var changes = [];
                        var additions = [];
                        var removals = [];
                        var record;
                        for (record = this._mapHead; record !== null; record = record._next) {
                            ListWrapper.push(items, stringify(record));
                        }
                        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                            ListWrapper.push(previous, stringify(record));
                        }
                        for (record = this._changesHead; record !== null; record = record._nextChanged) {
                            ListWrapper.push(changes, stringify(record));
                        }
                        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                            ListWrapper.push(additions, stringify(record));
                        }
                        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                            ListWrapper.push(removals, stringify(record));
                        }
                        return "map: " + items.join(", ") + "\n" + "previous: " + previous.join(", ") + "\n" + "additions: " + additions.join(", ") + "\n" + "changes: " + changes.join(", ") + "\n" + "removals: " + removals.join(", ") + "\n";
                    }
                }, {
                    key: "_forEach",
                    value: function _forEach(obj, fn) {
                        if (obj instanceof _Map) {
                            MapWrapper.forEach(obj, fn);
                        } else {
                            StringMapWrapper.forEach(obj, fn);
                        }
                    }
                }], [{
                    key: "supportsObj",
                    value: function supportsObj(obj) {
                        return obj instanceof _Map || isJsObject(obj);
                    }
                }]);

                return KeyValueChanges;
            })(Pipe);

            _export("KeyValueChanges", KeyValueChanges);

            /**
             * @exportedAs angular2/pipes
             */

            KVChangeRecord = (function () {
                function KVChangeRecord(key) {
                    _classCallCheck(this, KVChangeRecord);

                    this.key = key;
                    this.previousValue = null;
                    this.currentValue = null;
                    this._nextPrevious = null;
                    this._next = null;
                    this._nextAdded = null;
                    this._nextRemoved = null;
                    this._prevRemoved = null;
                    this._nextChanged = null;
                }

                _createClass(KVChangeRecord, [{
                    key: "toString",
                    value: function toString() {
                        return looseIdentical(this.previousValue, this.currentValue) ? stringify(this.key) : stringify(this.key) + "[" + stringify(this.previousValue) + "->" + stringify(this.currentValue) + "]";
                    }
                }]);

                return KVChangeRecord;
            })();

            _export("KVChangeRecord", KVChangeRecord);
        }
    };
});


System.register('angular2/src/core/application', ['npm:babel-runtime@5.4.7/helpers/create-class', 'npm:babel-runtime@5.4.7/helpers/class-call-check', 'angular2/di', 'angular2/src/facade/lang', 'angular2/src/dom/browser_adapter', 'angular2/src/dom/dom_adapter', 'angular2/src/core/compiler/compiler', 'angular2/src/reflection/reflection', 'angular2/change_detection', 'angular2/src/core/exception_handler', 'angular2/src/render/dom/compiler/template_loader', 'angular2/src/core/compiler/template_resolver', 'angular2/src/core/compiler/directive_resolver', 'angular2/src/facade/collection', 'angular2/src/facade/async', 'angular2/src/core/zone/ng_zone', 'angular2/src/core/life_cycle/life_cycle', 'angular2/src/render/dom/shadow_dom/shadow_dom_strategy', 'angular2/src/render/dom/shadow_dom/emulated_unscoped_shadow_dom_strategy', 'angular2/src/services/xhr', 'angular2/src/services/xhr_impl', 'angular2/src/render/dom/events/event_manager', 'angular2/src/render/dom/events/key_events', 'angular2/src/render/dom/events/hammer_gestures', 'angular2/src/core/compiler/component_url_mapper', 'angular2/src/services/url_resolver', 'angular2/src/render/dom/shadow_dom/style_url_resolver', 'angular2/src/render/dom/shadow_dom/style_inliner', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/testability/testability', 'angular2/src/core/compiler/view_pool', 'angular2/src/core/compiler/view_manager', 'angular2/src/core/compiler/view_manager_utils', 'angular2/src/core/compiler/view_listener', 'angular2/src/core/compiler/proto_view_factory', 'angular2/src/render/api', 'angular2/src/render/dom/dom_renderer', 'angular2/src/render/dom/view/view', 'angular2/src/render/dom/compiler/compiler', 'angular2/src/core/compiler/view_ref', 'angular2/src/core/application_tokens'], function (_export) {
    var _createClass, _classCallCheck, Injector, bind, isBlank, isPresent, assertionsEnabled, BrowserDomAdapter, DOM, Compiler, CompilerCache, Reflector, reflector, Parser, Lexer, ChangeDetection, DynamicChangeDetection, PipeRegistry, defaultPipeRegistry, ExceptionHandler, TemplateLoader, TemplateResolver, DirectiveResolver, ListWrapper, PromiseWrapper, NgZone, LifeCycle, ShadowDomStrategy, EmulatedUnscopedShadowDomStrategy, XHR, XHRImpl, EventManager, DomEventsPlugin, KeyEventsPlugin, HammerGesturesPlugin, ComponentUrlMapper, UrlResolver, StyleUrlResolver, StyleInliner, DynamicComponentLoader, TestabilityRegistry, Testability, AppViewPool, APP_VIEW_POOL_CAPACITY, AppViewManager, AppViewManagerUtils, AppViewListener, ProtoViewFactory, Renderer, RenderCompiler, DomRenderer, DOCUMENT_TOKEN, resolveInternalDomView, DefaultDomCompiler, internalView, appComponentRefToken, appComponentTypeToken, _rootInjector, _rootBindings, ApplicationRef;

    function _injectorBindings(appComponentType) {
        return [bind(DOCUMENT_TOKEN).toValue(DOM.defaultDoc()), bind(appComponentTypeToken).toValue(appComponentType), bind(appComponentRefToken).toAsyncFactory(function (dynamicComponentLoader, injector, testability, registry) {
            // TODO(rado): investigate whether to support bindings on root component.
            return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector).then(function (componentRef) {
                var domView = resolveInternalDomView(componentRef.hostView.render);
                // We need to do this here to ensure that we create Testability and
                // it's ready on the window for users.
                registry.registerApplication(domView.boundElements[0], testability);
                return componentRef;
            });
        }, [DynamicComponentLoader, Injector, Testability, TestabilityRegistry]), bind(appComponentType).toFactory(function (ref) {
            return ref.instance;
        }, [appComponentRefToken]), bind(LifeCycle).toFactory(function (exceptionHandler) {
            return new LifeCycle(exceptionHandler, null, assertionsEnabled());
        }, [ExceptionHandler]), bind(EventManager).toFactory(function (ngZone) {
            var plugins = [new HammerGesturesPlugin(), new KeyEventsPlugin(), new DomEventsPlugin()];
            return new EventManager(plugins, ngZone);
        }, [NgZone]), bind(ShadowDomStrategy).toFactory(function (styleUrlResolver, doc) {
            return new EmulatedUnscopedShadowDomStrategy(styleUrlResolver, doc.head);
        }, [StyleUrlResolver, DOCUMENT_TOKEN]), DomRenderer, DefaultDomCompiler, bind(Renderer).toAlias(DomRenderer), bind(RenderCompiler).toAlias(DefaultDomCompiler), ProtoViewFactory, AppViewPool, bind(APP_VIEW_POOL_CAPACITY).toValue(10000), AppViewManager, AppViewManagerUtils, AppViewListener, Compiler, CompilerCache, TemplateResolver, bind(PipeRegistry).toValue(defaultPipeRegistry), bind(ChangeDetection).toClass(DynamicChangeDetection), TemplateLoader, DirectiveResolver, Parser, Lexer, ExceptionHandler, bind(XHR).toValue(new XHRImpl()), ComponentUrlMapper, UrlResolver, StyleUrlResolver, StyleInliner, DynamicComponentLoader, Testability];
    }
    function _createNgZone(givenReporter) {
        var defaultErrorReporter = function defaultErrorReporter(exception, stackTrace) {
            var longStackTrace = ListWrapper.join(stackTrace, '\n\n-----async gap-----\n');
            DOM.logError('' + exception + '\n\n' + longStackTrace);
            throw exception;
        };
        var reporter = isPresent(givenReporter) ? givenReporter : defaultErrorReporter;
        var zone = new NgZone({ enableLongStackTrace: assertionsEnabled() });
        zone.initCallbacks({ onErrorHandler: reporter });
        return zone;
    }
    /**
     * Bootstrapping for Angular applications.
     *
     * You instantiate an Angular application by explicitly specifying a component to use as the root
     * component for your
     * application via the `bootstrap()` method.
     *
     * ## Simple Example
     *
     * Assuming this `index.html`:
     *
     * ```html
     * <html>
     *   <!-- load Angular script tags here. -->
     *   <body>
     *     <my-app>loading...</my-app>
     *   </body>
     * </html>
     * ```
     *
     * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike
     * Angular 1, Angular 2
     * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well
     * as architectural
     * changes in Angular 2. This means that `index.html` can safely be processed using server-side
     * technologies such as
     * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2
     * component double-curly
     * `{{ syntax }}`.
     *
     * We can use this script code:
     *
     * ```
     * @Component({
     *    selector: 'my-app'
     * })
     * @View({
     *    template: 'Hello {{ name }}!'
     * })
     * class MyApp {
     *   name:string;
     *
     *   constructor() {
     *     this.name = 'World';
     *   }
     * }
     *
     * main() {
     *   return bootstrap(MyApp);
     * }
     * ```
     *
     * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument,
     * Angular performs the
     * following tasks:
     *
     *  1. It uses the component's `selector` property to locate the DOM element which needs to be
     * upgraded into
     *     the angular component.
     *  2. It creates a new child injector (from the platform injector) and configures the injector with
     * the component's
     *     `appInjector`. Optionally, you can also override the injector configuration for an app by
     * invoking
     *     `bootstrap` with the `componentInjectableBindings` argument.
     *  3. It creates a new `Zone` and connects it to the angular application's change detection domain
     * instance.
     *  4. It creates a shadow DOM on the selected component's host element and loads the template into
     * it.
     *  5. It instantiates the specified component.
     *  6. Finally, Angular performs change detection to apply the initial data bindings for the
     * application.
     *
     *
     * ## Instantiating Multiple Applications on a Single Page
     *
     * There are two ways to do this.
     *
     *
     * ### Isolated Applications
     *
     * Angular creates a new application each time that the `bootstrap()` method is invoked. When
     * multiple applications
     * are created for a page, Angular treats each application as independent within an isolated change
     * detection and
     * `Zone` domain. If you need to share data between applications, use the strategy described in the
     * next
     * section, "Applications That Share Change Detection."
     *
     *
     * ### Applications That Share Change Detection
     *
     * If you need to bootstrap multiple applications that share common data, the applications must
     * share a common
     * change detection and zone. To do that, create a meta-component that lists the application
     * components in its template.
     * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you
     * ensure that only a
     * single change detection zone is created and therefore data can be shared across the applications.
     *
     *
     * ## Platform Injector
     *
     * When working within a browser window, there are many singleton resources: cookies, title,
     * location, and others.
     * Angular services that represent these resources must likewise be shared across all Angular
     * applications that
     * occupy the same browser window.  For this reason, Angular creates exactly one global platform
     * injector which stores
     * all shared services, and each angular application injector has the platform injector as its
     * parent.
     *
     * Each application has its own private injector as well. When there are multiple applications on a
     * page, Angular treats
     * each application injector's services as private to that application.
     *
     *
     * # API
     * - `appComponentType`: The root component which should act as the application. This is a reference
     * to a `Type`
     *   which is annotated with `@Component(...)`.
     * - `componentInjectableBindings`: An additional set of bindings that can be added to `appInjector`
     * for the
     * {@link Component} to override default injection behavior.
     * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for
     * unhandled exceptions.
     *
     * Returns a `Promise` with the application`s private {@link Injector}.
     *
     * @exportedAs angular2/core
     */

    function bootstrap(appComponentType) {
        var componentInjectableBindings = arguments[1] === undefined ? null : arguments[1];
        var errorReporter = arguments[2] === undefined ? null : arguments[2];

        BrowserDomAdapter.makeCurrent();
        var bootstrapProcess = PromiseWrapper.completer();
        var zone = _createNgZone(errorReporter);
        zone.run(function () {
            // TODO(rado): prepopulate template cache, so applications with only
            // index.html and main.js are possible.
            var appInjector = _createAppInjector(appComponentType, componentInjectableBindings, zone);
            PromiseWrapper.then(appInjector.asyncGet(appComponentRefToken), function (componentRef) {
                var appChangeDetector = internalView(componentRef.hostView).changeDetector;
                // retrieve life cycle: may have already been created if injected in root component
                var lc = appInjector.get(LifeCycle);
                lc.registerWith(zone, appChangeDetector);
                lc.tick(); // the first tick that will bootstrap the app
                bootstrapProcess.resolve(new ApplicationRef(componentRef, appComponentType, appInjector));
            }, function (err, stackTrace) {
                bootstrapProcess.reject(err, stackTrace);
            });
        });
        return bootstrapProcess.promise;
    }

    function _createAppInjector(appComponentType, bindings, zone) {
        if (isBlank(_rootInjector)) _rootInjector = Injector.resolveAndCreate(_rootBindings);
        var mergedBindings = isPresent(bindings) ? ListWrapper.concat(_injectorBindings(appComponentType), bindings) : _injectorBindings(appComponentType);
        ListWrapper.push(mergedBindings, bind(NgZone).toValue(zone));
        return _rootInjector.resolveAndCreateChild(mergedBindings);
    }
    
    return {
        setters: [function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass['default'];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck['default'];
        }, function (_angular2Di) {
            Injector = _angular2Di.Injector;
            bind = _angular2Di.bind;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            assertionsEnabled = _angular2SrcFacadeLang.assertionsEnabled;
        }, function (_angular2SrcDomBrowser_adapter) {
            BrowserDomAdapter = _angular2SrcDomBrowser_adapter.BrowserDomAdapter;
        }, function (_angular2SrcDomDom_adapter) {
            DOM = _angular2SrcDomDom_adapter.DOM;
        }, function (_angular2SrcCoreCompilerCompiler) {
            Compiler = _angular2SrcCoreCompilerCompiler.Compiler;
            CompilerCache = _angular2SrcCoreCompilerCompiler.CompilerCache;
        }, function (_angular2SrcReflectionReflection) {
            Reflector = _angular2SrcReflectionReflection.Reflector;
            reflector = _angular2SrcReflectionReflection.reflector;
        }, function (_angular2Change_detection) {
            Parser = _angular2Change_detection.Parser;
            Lexer = _angular2Change_detection.Lexer;
            ChangeDetection = _angular2Change_detection.ChangeDetection;
            DynamicChangeDetection = _angular2Change_detection.DynamicChangeDetection;
            PipeRegistry = _angular2Change_detection.PipeRegistry;
            defaultPipeRegistry = _angular2Change_detection.defaultPipeRegistry;
        }, function (_angular2SrcCoreException_handler) {
            ExceptionHandler = _angular2SrcCoreException_handler.ExceptionHandler;
        }, function (_angular2SrcRenderDomCompilerTemplate_loader) {
            TemplateLoader = _angular2SrcRenderDomCompilerTemplate_loader.TemplateLoader;
        }, function (_angular2SrcCoreCompilerTemplate_resolver) {
            TemplateResolver = _angular2SrcCoreCompilerTemplate_resolver.TemplateResolver;
        }, function (_angular2SrcCoreCompilerDirective_resolver) {
            DirectiveResolver = _angular2SrcCoreCompilerDirective_resolver.DirectiveResolver;
        }, function (_angular2SrcFacadeCollection) {
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }, function (_angular2SrcFacadeAsync) {
            PromiseWrapper = _angular2SrcFacadeAsync.PromiseWrapper;
        }, function (_angular2SrcCoreZoneNg_zone) {
            NgZone = _angular2SrcCoreZoneNg_zone.NgZone;
        }, function (_angular2SrcCoreLife_cycleLife_cycle) {
            LifeCycle = _angular2SrcCoreLife_cycleLife_cycle.LifeCycle;
        }, function (_angular2SrcRenderDomShadow_domShadow_dom_strategy) {
            ShadowDomStrategy = _angular2SrcRenderDomShadow_domShadow_dom_strategy.ShadowDomStrategy;
        }, function (_angular2SrcRenderDomShadow_domEmulated_unscoped_shadow_dom_strategy) {
            EmulatedUnscopedShadowDomStrategy = _angular2SrcRenderDomShadow_domEmulated_unscoped_shadow_dom_strategy.EmulatedUnscopedShadowDomStrategy;
        }, function (_angular2SrcServicesXhr) {
            XHR = _angular2SrcServicesXhr.XHR;
        }, function (_angular2SrcServicesXhr_impl) {
            XHRImpl = _angular2SrcServicesXhr_impl.XHRImpl;
        }, function (_angular2SrcRenderDomEventsEvent_manager) {
            EventManager = _angular2SrcRenderDomEventsEvent_manager.EventManager;
            DomEventsPlugin = _angular2SrcRenderDomEventsEvent_manager.DomEventsPlugin;
        }, function (_angular2SrcRenderDomEventsKey_events) {
            KeyEventsPlugin = _angular2SrcRenderDomEventsKey_events.KeyEventsPlugin;
        }, function (_angular2SrcRenderDomEventsHammer_gestures) {
            HammerGesturesPlugin = _angular2SrcRenderDomEventsHammer_gestures.HammerGesturesPlugin;
        }, function (_angular2SrcCoreCompilerComponent_url_mapper) {
            ComponentUrlMapper = _angular2SrcCoreCompilerComponent_url_mapper.ComponentUrlMapper;
        }, function (_angular2SrcServicesUrl_resolver) {
            UrlResolver = _angular2SrcServicesUrl_resolver.UrlResolver;
        }, function (_angular2SrcRenderDomShadow_domStyle_url_resolver) {
            StyleUrlResolver = _angular2SrcRenderDomShadow_domStyle_url_resolver.StyleUrlResolver;
        }, function (_angular2SrcRenderDomShadow_domStyle_inliner) {
            StyleInliner = _angular2SrcRenderDomShadow_domStyle_inliner.StyleInliner;
        }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
            DynamicComponentLoader = _angular2SrcCoreCompilerDynamic_component_loader.DynamicComponentLoader;
        }, function (_angular2SrcCoreTestabilityTestability) {
            TestabilityRegistry = _angular2SrcCoreTestabilityTestability.TestabilityRegistry;
            Testability = _angular2SrcCoreTestabilityTestability.Testability;
        }, function (_angular2SrcCoreCompilerView_pool) {
            AppViewPool = _angular2SrcCoreCompilerView_pool.AppViewPool;
            APP_VIEW_POOL_CAPACITY = _angular2SrcCoreCompilerView_pool.APP_VIEW_POOL_CAPACITY;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_angular2SrcCoreCompilerView_manager_utils) {
            AppViewManagerUtils = _angular2SrcCoreCompilerView_manager_utils.AppViewManagerUtils;
        }, function (_angular2SrcCoreCompilerView_listener) {
            AppViewListener = _angular2SrcCoreCompilerView_listener.AppViewListener;
        }, function (_angular2SrcCoreCompilerProto_view_factory) {
            ProtoViewFactory = _angular2SrcCoreCompilerProto_view_factory.ProtoViewFactory;
        }, function (_angular2SrcRenderApi) {
            Renderer = _angular2SrcRenderApi.Renderer;
            RenderCompiler = _angular2SrcRenderApi.RenderCompiler;
        }, function (_angular2SrcRenderDomDom_renderer) {
            DomRenderer = _angular2SrcRenderDomDom_renderer.DomRenderer;
            DOCUMENT_TOKEN = _angular2SrcRenderDomDom_renderer.DOCUMENT_TOKEN;
        }, function (_angular2SrcRenderDomViewView) {
            resolveInternalDomView = _angular2SrcRenderDomViewView.resolveInternalDomView;
        }, function (_angular2SrcRenderDomCompilerCompiler) {
            DefaultDomCompiler = _angular2SrcRenderDomCompilerCompiler.DefaultDomCompiler;
        }, function (_angular2SrcCoreCompilerView_ref) {
            internalView = _angular2SrcCoreCompilerView_ref.internalView;
        }, function (_angular2SrcCoreApplication_tokens) {
            appComponentRefToken = _angular2SrcCoreApplication_tokens.appComponentRefToken;
            appComponentTypeToken = _angular2SrcCoreApplication_tokens.appComponentTypeToken;
        }],
        execute: function () {
            'use strict';

            _export('bootstrap', bootstrap);

            // Contains everything that is safe to share between applications.
            _rootBindings = [bind(Reflector).toValue(reflector), TestabilityRegistry];

            ApplicationRef = (function () {
                function ApplicationRef(hostComponent, hostComponentType, injector) {
                    _classCallCheck(this, ApplicationRef);

                    this._hostComponent = hostComponent;
                    this._injector = injector;
                    this._hostComponentType = hostComponentType;
                }

                _createClass(ApplicationRef, [{
                    key: 'hostComponentType',
                    get: function () {
                        return this._hostComponentType;
                    }
                }, {
                    key: 'hostComponent',
                    get: function () {
                        return this._hostComponent.instance;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        // TODO: We also need to clean up the Zone, ... here!
                        return this._hostComponent.dispose();
                    }
                }, {
                    key: 'injector',
                    get: function () {
                        return this._injector;
                    }
                }]);

                return ApplicationRef;
            })();

            _export('ApplicationRef', ApplicationRef);
        }
    };
});
System.register('angular2/core', ['angular2/src/core/annotations/visibility', 'angular2/src/core/annotations/view', 'angular2/src/core/application', 'angular2/src/core/application_tokens', 'angular2/src/core/annotations/di', 'angular2/src/core/compiler/compiler', 'angular2/src/core/compiler/interfaces', 'angular2/src/core/compiler/query_list', 'angular2/src/core/compiler/directive_resolver', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/compiler/view_ref', 'angular2/src/core/compiler/view_container_ref', 'angular2/src/core/compiler/element_ref', 'angular2/src/core/zone/ng_zone'], function (_export) {
  /**
   * @module
   * @public
   * @description
   * Define angular core API here.
   */

  
  'use strict';

  return {
    setters: [function (_angular2SrcCoreAnnotationsVisibility) {
      for (var _key in _angular2SrcCoreAnnotationsVisibility) {
        _export(_key, _angular2SrcCoreAnnotationsVisibility[_key]);
      }
    }, function (_angular2SrcCoreAnnotationsView) {
      for (var _key2 in _angular2SrcCoreAnnotationsView) {
        _export(_key2, _angular2SrcCoreAnnotationsView[_key2]);
      }
    }, function (_angular2SrcCoreApplication) {
      for (var _key3 in _angular2SrcCoreApplication) {
        _export(_key3, _angular2SrcCoreApplication[_key3]);
      }
    }, function (_angular2SrcCoreApplication_tokens) {
      for (var _key4 in _angular2SrcCoreApplication_tokens) {
        _export(_key4, _angular2SrcCoreApplication_tokens[_key4]);
      }
    }, function (_angular2SrcCoreAnnotationsDi) {
      for (var _key5 in _angular2SrcCoreAnnotationsDi) {
        _export(_key5, _angular2SrcCoreAnnotationsDi[_key5]);
      }
    }, function (_angular2SrcCoreCompilerCompiler) {
      for (var _key6 in _angular2SrcCoreCompilerCompiler) {
        _export(_key6, _angular2SrcCoreCompilerCompiler[_key6]);
      }
    }, function (_angular2SrcCoreCompilerInterfaces) {
      for (var _key7 in _angular2SrcCoreCompilerInterfaces) {
        _export(_key7, _angular2SrcCoreCompilerInterfaces[_key7]);
      }
    }, function (_angular2SrcCoreCompilerQuery_list) {
      for (var _key8 in _angular2SrcCoreCompilerQuery_list) {
        _export(_key8, _angular2SrcCoreCompilerQuery_list[_key8]);
      }
    }, function (_angular2SrcCoreCompilerDirective_resolver) {
      for (var _key9 in _angular2SrcCoreCompilerDirective_resolver) {
        _export(_key9, _angular2SrcCoreCompilerDirective_resolver[_key9]);
      }
    }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
      for (var _key10 in _angular2SrcCoreCompilerDynamic_component_loader) {
        _export(_key10, _angular2SrcCoreCompilerDynamic_component_loader[_key10]);
      }
    }, function (_angular2SrcCoreCompilerView_ref) {
      _export('ViewRef', _angular2SrcCoreCompilerView_ref.ViewRef);

      _export('ProtoViewRef', _angular2SrcCoreCompilerView_ref.ProtoViewRef);
    }, function (_angular2SrcCoreCompilerView_container_ref) {
      _export('ViewContainerRef', _angular2SrcCoreCompilerView_container_ref.ViewContainerRef);
    }, function (_angular2SrcCoreCompilerElement_ref) {
      _export('ElementRef', _angular2SrcCoreCompilerElement_ref.ElementRef);
    }, function (_angular2SrcCoreZoneNg_zone) {
      _export('NgZone', _angular2SrcCoreZoneNg_zone.NgZone);
    }],
    execute: function () {}
  };
});
System.register("angular2/src/change_detection/pipes/observable_pipe", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, ObservableWrapper, isBlank, isPresent, CONST, Pipe, WrappedValue, PipeFactory, __decorate, __metadata, ObservablePipe, ObservablePipeFactory;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeAsync) {
            ObservableWrapper = _angular2SrcFacadeAsync.ObservableWrapper;
        }, function (_angular2SrcFacadeLang) {
            isBlank = _angular2SrcFacadeLang.isBlank;
            isPresent = _angular2SrcFacadeLang.isPresent;
            CONST = _angular2SrcFacadeLang.CONST;
        }, function (_angular2SrcChange_detectionPipesPipe) {
            Pipe = _angular2SrcChange_detectionPipesPipe.Pipe;
            WrappedValue = _angular2SrcChange_detectionPipesPipe.WrappedValue;
            PipeFactory = _angular2SrcChange_detectionPipesPipe.PipeFactory;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Implements async bindings to Observable.
             *
             * # Example
             *
             * In this example we bind the description observable to the DOM. The async pipe will convert an
             *observable to the
             * latest value it emitted. It will also request a change detection check when a new value is
             *emitted.
             *
             *  ```
             * @Component({
             *   selector: "task-cmp",
             *   changeDetection: ON_PUSH
             * })
             * @View({
             *   template: "Task Description {{ description | async }}"
             * })
             * class Task {
             *  description:Observable<string>;
             * }
             *
             * ```
             *
             * @exportedAs angular2/pipes
             */

            ObservablePipe = (function (_Pipe) {
                function ObservablePipe(ref) {
                    _classCallCheck(this, ObservablePipe);

                    _get(Object.getPrototypeOf(ObservablePipe.prototype), "constructor", this).call(this);
                    this._ref = ref;
                    this._latestValue = null;
                    this._latestReturnedValue = null;
                    this._subscription = null;
                    this._observable = null;
                }

                _inherits(ObservablePipe, _Pipe);

                _createClass(ObservablePipe, [{
                    key: "supports",
                    value: function supports(obs) {
                        return ObservableWrapper.isObservable(obs);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        if (isPresent(this._subscription)) {
                            this._dispose();
                        }
                    }
                }, {
                    key: "transform",
                    value: function transform(obs) {
                        if (isBlank(this._subscription)) {
                            this._subscribe(obs);
                            return null;
                        }
                        if (obs !== this._observable) {
                            this._dispose();
                            return this.transform(obs);
                        }
                        if (this._latestValue === this._latestReturnedValue) {
                            return this._latestReturnedValue;
                        } else {
                            this._latestReturnedValue = this._latestValue;
                            return WrappedValue.wrap(this._latestValue);
                        }
                    }
                }, {
                    key: "_subscribe",
                    value: function _subscribe(obs) {
                        var _this = this;

                        this._observable = obs;
                        this._subscription = ObservableWrapper.subscribe(obs, function (value) {
                            _this._updateLatestValue(value);
                        }, function (e) {
                            throw e;
                        });
                    }
                }, {
                    key: "_dispose",
                    value: function _dispose() {
                        ObservableWrapper.dispose(this._subscription);
                        this._latestValue = null;
                        this._latestReturnedValue = null;
                        this._subscription = null;
                        this._observable = null;
                    }
                }, {
                    key: "_updateLatestValue",
                    value: function _updateLatestValue(value) {
                        this._latestValue = value;
                        this._ref.requestCheck();
                    }
                }]);

                return ObservablePipe;
            })(Pipe);

            _export("ObservablePipe", ObservablePipe);

            /**
             * Provides a factory for [ObervablePipe].
             *
             * @exportedAs angular2/pipes
             */

            ObservablePipeFactory = (function (_PipeFactory) {
                var _class = function ObservablePipeFactory() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                };

                _inherits(_class, _PipeFactory);

                _createClass(_class, [{
                    key: "supports",
                    value: function supports(obs) {
                        return ObservableWrapper.isObservable(obs);
                    }
                }, {
                    key: "create",
                    value: function create(cdRef) {
                        return new ObservablePipe(cdRef);
                    }
                }]);

                return _class;
            })(PipeFactory);

            _export("ObservablePipeFactory", ObservablePipeFactory);

            _export("ObservablePipeFactory", ObservablePipeFactory = __decorate([CONST(), __metadata("design:paramtypes", [])], ObservablePipeFactory));
            
        }
    };
});
System.register('angular2/angular2', ['angular2/change_detection', 'angular2/core', 'angular2/annotations', 'angular2/directives', 'angular2/forms', 'angular2/di', 'angular2/src/facade/async', 'angular2/src/render/api', 'angular2/src/render/dom/dom_renderer'], function (_export) {
  'use strict';

  
  return {
    setters: [function (_angular2Change_detection) {
      for (var _key in _angular2Change_detection) {
        _export(_key, _angular2Change_detection[_key]);
      }
    }, function (_angular2Core) {
      for (var _key2 in _angular2Core) {
        _export(_key2, _angular2Core[_key2]);
      }
    }, function (_angular2Annotations) {
      for (var _key3 in _angular2Annotations) {
        _export(_key3, _angular2Annotations[_key3]);
      }
    }, function (_angular2Directives) {
      for (var _key4 in _angular2Directives) {
        _export(_key4, _angular2Directives[_key4]);
      }
    }, function (_angular2Forms) {
      for (var _key5 in _angular2Forms) {
        _export(_key5, _angular2Forms[_key5]);
      }
    }, function (_angular2Di) {
      for (var _key6 in _angular2Di) {
        _export(_key6, _angular2Di[_key6]);
      }
    }, function (_angular2SrcFacadeAsync) {
      _export('Observable', _angular2SrcFacadeAsync.Observable);

      _export('EventEmitter', _angular2SrcFacadeAsync.EventEmitter);
    }, function (_angular2SrcRenderApi) {
      for (var _key7 in _angular2SrcRenderApi) {
        _export(_key7, _angular2SrcRenderApi[_key7]);
      }
    }, function (_angular2SrcRenderDomDom_renderer) {
      _export('DomRenderer', _angular2SrcRenderDomDom_renderer.DomRenderer);

      _export('DOCUMENT_TOKEN', _angular2SrcRenderDomDom_renderer.DOCUMENT_TOKEN);
    }],
    execute: function () {}
  };
});
System.register("angular2/src/change_detection/change_detection", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/create-class", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/change_detection/proto_change_detector", "angular2/src/change_detection/pipes/pipe_registry", "angular2/src/change_detection/pipes/iterable_changes", "angular2/src/change_detection/pipes/keyvalue_changes", "angular2/src/change_detection/pipes/observable_pipe", "angular2/src/change_detection/pipes/promise_pipe", "angular2/src/change_detection/pipes/uppercase_pipe", "angular2/src/change_detection/pipes/lowercase_pipe", "angular2/src/change_detection/pipes/json_pipe", "angular2/src/change_detection/pipes/null_pipe", "angular2/src/change_detection/interfaces", "angular2/src/di/decorators", "angular2/src/facade/collection", "angular2/src/facade/lang"], function (_export) {
    var _inherits, _get, _createClass, _classCallCheck, DynamicProtoChangeDetector, JitProtoChangeDetector, PipeRegistry, IterableChangesFactory, KeyValueChangesFactory, ObservablePipeFactory, PromisePipeFactory, UpperCaseFactory, LowerCaseFactory, JsonPipeFactory, NullPipeFactory, ChangeDetection, Injectable, StringMapWrapper, isPresent, __decorate, __metadata, keyValDiff, iterableDiff, async, uppercase, lowercase, json, defaultPipes, preGeneratedProtoDetectors, PreGeneratedChangeDetection, DynamicChangeDetection, JitChangeDetection, defaultPipeRegistry;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersCreateClass) {
            _createClass = _npmBabelRuntime547HelpersCreateClass["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcChange_detectionProto_change_detector) {
            DynamicProtoChangeDetector = _angular2SrcChange_detectionProto_change_detector.DynamicProtoChangeDetector;
            JitProtoChangeDetector = _angular2SrcChange_detectionProto_change_detector.JitProtoChangeDetector;
        }, function (_angular2SrcChange_detectionPipesPipe_registry) {
            PipeRegistry = _angular2SrcChange_detectionPipesPipe_registry.PipeRegistry;
        }, function (_angular2SrcChange_detectionPipesIterable_changes) {
            IterableChangesFactory = _angular2SrcChange_detectionPipesIterable_changes.IterableChangesFactory;
        }, function (_angular2SrcChange_detectionPipesKeyvalue_changes) {
            KeyValueChangesFactory = _angular2SrcChange_detectionPipesKeyvalue_changes.KeyValueChangesFactory;
        }, function (_angular2SrcChange_detectionPipesObservable_pipe) {
            ObservablePipeFactory = _angular2SrcChange_detectionPipesObservable_pipe.ObservablePipeFactory;
        }, function (_angular2SrcChange_detectionPipesPromise_pipe) {
            PromisePipeFactory = _angular2SrcChange_detectionPipesPromise_pipe.PromisePipeFactory;
        }, function (_angular2SrcChange_detectionPipesUppercase_pipe) {
            UpperCaseFactory = _angular2SrcChange_detectionPipesUppercase_pipe.UpperCaseFactory;
        }, function (_angular2SrcChange_detectionPipesLowercase_pipe) {
            LowerCaseFactory = _angular2SrcChange_detectionPipesLowercase_pipe.LowerCaseFactory;
        }, function (_angular2SrcChange_detectionPipesJson_pipe) {
            JsonPipeFactory = _angular2SrcChange_detectionPipesJson_pipe.JsonPipeFactory;
        }, function (_angular2SrcChange_detectionPipesNull_pipe) {
            NullPipeFactory = _angular2SrcChange_detectionPipesNull_pipe.NullPipeFactory;
        }, function (_angular2SrcChange_detectionInterfaces) {
            ChangeDetection = _angular2SrcChange_detectionInterfaces.ChangeDetection;
        }, function (_angular2SrcDiDecorators) {
            Injectable = _angular2SrcDiDecorators.Injectable;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
        }, function (_angular2SrcFacadeLang) {
            isPresent = _angular2SrcFacadeLang.isPresent;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * Structural diffing for `Object`s and `Map`s.
             *
             * @exportedAs angular2/pipes
             */
            keyValDiff = [new KeyValueChangesFactory(), new NullPipeFactory()];

            _export("keyValDiff", keyValDiff);

            /**
             * Structural diffing for `Iterable` types such as `Array`s.
             *
             * @exportedAs angular2/pipes
             */
            iterableDiff = [new IterableChangesFactory(), new NullPipeFactory()];

            _export("iterableDiff", iterableDiff);

            /**
             * Async binding to such types as Observable.
             *
             * @exportedAs angular2/pipes
             */
            async = [new ObservablePipeFactory(), new PromisePipeFactory(), new NullPipeFactory()];

            _export("async", async);

            /**
             * Uppercase text transform.
             *
             * @exportedAs angular2/pipes
             */
            uppercase = [new UpperCaseFactory(), new NullPipeFactory()];

            _export("uppercase", uppercase);

            /**
             * Lowercase text transform.
             *
             * @exportedAs angular2/pipes
             */
            lowercase = [new LowerCaseFactory(), new NullPipeFactory()];

            _export("lowercase", lowercase);

            /**
             * Json stringify transform.
             *
             * @exportedAs angular2/pipes
             */
            json = [new JsonPipeFactory(), new NullPipeFactory()];

            _export("json", json);

            defaultPipes = {
                "iterableDiff": iterableDiff,
                "keyValDiff": keyValDiff,
                "async": async,
                "uppercase": uppercase,
                "lowercase": lowercase,
                "json": json
            };

            _export("defaultPipes", defaultPipes);

            preGeneratedProtoDetectors = {};

            _export("preGeneratedProtoDetectors", preGeneratedProtoDetectors);

            /**
             * Implements change detection using a map of pregenerated proto detectors.
             *
             * @exportedAs angular2/change_detection
             */

            PreGeneratedChangeDetection = (function (_ChangeDetection) {
                function PreGeneratedChangeDetection(registry, protoChangeDetectors) {
                    _classCallCheck(this, PreGeneratedChangeDetection);

                    _get(Object.getPrototypeOf(PreGeneratedChangeDetection.prototype), "constructor", this).call(this);
                    this.registry = registry;
                    this._dynamicChangeDetection = new DynamicChangeDetection(registry);
                    this._protoChangeDetectorFactories = isPresent(protoChangeDetectors) ? protoChangeDetectors : preGeneratedProtoDetectors;
                }

                _inherits(PreGeneratedChangeDetection, _ChangeDetection);

                _createClass(PreGeneratedChangeDetection, [{
                    key: "createProtoChangeDetector",
                    value: function createProtoChangeDetector(definition) {
                        var id = definition.id;
                        if (StringMapWrapper.contains(this._protoChangeDetectorFactories, id)) {
                            return StringMapWrapper.get(this._protoChangeDetectorFactories, id)(this.registry);
                        }
                        return this._dynamicChangeDetection.createProtoChangeDetector(definition);
                    }
                }]);

                return PreGeneratedChangeDetection;
            })(ChangeDetection);

            _export("PreGeneratedChangeDetection", PreGeneratedChangeDetection);

            /**
             * Implements change detection that does not require `eval()`.
             *
             * This is slower than {@link JitChangeDetection}.
             *
             * @exportedAs angular2/change_detection
             */

            DynamicChangeDetection = (function (_ChangeDetection2) {
                var _class = function DynamicChangeDetection(registry) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this.registry = registry;
                };

                _inherits(_class, _ChangeDetection2);

                _createClass(_class, [{
                    key: "createProtoChangeDetector",
                    value: function createProtoChangeDetector(definition) {
                        return new DynamicProtoChangeDetector(this.registry, definition);
                    }
                }]);

                return _class;
            })(ChangeDetection);

            _export("DynamicChangeDetection", DynamicChangeDetection);

            _export("DynamicChangeDetection", DynamicChangeDetection = __decorate([Injectable(), __metadata("design:paramtypes", [PipeRegistry])], DynamicChangeDetection));
            /**
             * Implements faster change detection, by generating source code.
             *
             * This requires `eval()`. For change detection that does not require `eval()`, see
             * {@link DynamicChangeDetection}.
             *
             * @exportedAs angular2/change_detection
             */

            JitChangeDetection = (function (_ChangeDetection3) {
                var _class2 = function JitChangeDetection(registry) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this);
                    this.registry = registry;
                };

                _inherits(_class2, _ChangeDetection3);

                _createClass(_class2, [{
                    key: "createProtoChangeDetector",
                    value: function createProtoChangeDetector(definition) {
                        return new JitProtoChangeDetector(this.registry, definition);
                    }
                }]);

                return _class2;
            })(ChangeDetection);

            _export("JitChangeDetection", JitChangeDetection);

            _export("JitChangeDetection", JitChangeDetection = __decorate([Injectable(), __metadata("design:paramtypes", [PipeRegistry])], JitChangeDetection));
            defaultPipeRegistry = new PipeRegistry(defaultPipes);

            

            _export("defaultPipeRegistry", defaultPipeRegistry);
        }
    };
});
System.register('angular2/change_detection', ['angular2/src/change_detection/parser/ast', 'angular2/src/change_detection/parser/lexer', 'angular2/src/change_detection/parser/parser', 'angular2/src/change_detection/parser/locals', 'angular2/src/change_detection/exceptions', 'angular2/src/change_detection/interfaces', 'angular2/src/change_detection/constants', 'angular2/src/change_detection/proto_change_detector', 'angular2/src/change_detection/binding_record', 'angular2/src/change_detection/directive_record', 'angular2/src/change_detection/dynamic_change_detector', 'angular2/src/change_detection/change_detector_ref', 'angular2/src/change_detection/pipes/pipe_registry', 'angular2/src/change_detection/change_detection_util', 'angular2/src/change_detection/pipes/pipe', 'angular2/src/change_detection/pipes/null_pipe', 'angular2/src/change_detection/change_detection'], function (_export) {
  /**
   * @module
   * @public
   * @description
   * Change detection enables data binding in Angular.
   */
  'use strict';

  
  return {
    setters: [function (_angular2SrcChange_detectionParserAst) {
      _export('ASTWithSource', _angular2SrcChange_detectionParserAst.ASTWithSource);

      _export('AST', _angular2SrcChange_detectionParserAst.AST);

      _export('AstTransformer', _angular2SrcChange_detectionParserAst.AstTransformer);

      _export('AccessMember', _angular2SrcChange_detectionParserAst.AccessMember);

      _export('LiteralArray', _angular2SrcChange_detectionParserAst.LiteralArray);

      _export('ImplicitReceiver', _angular2SrcChange_detectionParserAst.ImplicitReceiver);
    }, function (_angular2SrcChange_detectionParserLexer) {
      _export('Lexer', _angular2SrcChange_detectionParserLexer.Lexer);
    }, function (_angular2SrcChange_detectionParserParser) {
      _export('Parser', _angular2SrcChange_detectionParserParser.Parser);
    }, function (_angular2SrcChange_detectionParserLocals) {
      _export('Locals', _angular2SrcChange_detectionParserLocals.Locals);
    }, function (_angular2SrcChange_detectionExceptions) {
      _export('ExpressionChangedAfterItHasBeenChecked', _angular2SrcChange_detectionExceptions.ExpressionChangedAfterItHasBeenChecked);

      _export('ChangeDetectionError', _angular2SrcChange_detectionExceptions.ChangeDetectionError);
    }, function (_angular2SrcChange_detectionInterfaces) {
      _export('ProtoChangeDetector', _angular2SrcChange_detectionInterfaces.ProtoChangeDetector);

      _export('ChangeDispatcher', _angular2SrcChange_detectionInterfaces.ChangeDispatcher);

      _export('ChangeDetector', _angular2SrcChange_detectionInterfaces.ChangeDetector);

      _export('ChangeDetection', _angular2SrcChange_detectionInterfaces.ChangeDetection);

      _export('ChangeDetectorDefinition', _angular2SrcChange_detectionInterfaces.ChangeDetectorDefinition);
    }, function (_angular2SrcChange_detectionConstants) {
      _export('CHECK_ONCE', _angular2SrcChange_detectionConstants.CHECK_ONCE);

      _export('CHECK_ALWAYS', _angular2SrcChange_detectionConstants.CHECK_ALWAYS);

      _export('DETACHED', _angular2SrcChange_detectionConstants.DETACHED);

      _export('CHECKED', _angular2SrcChange_detectionConstants.CHECKED);

      _export('ON_PUSH', _angular2SrcChange_detectionConstants.ON_PUSH);

      _export('DEFAULT', _angular2SrcChange_detectionConstants.DEFAULT);
    }, function (_angular2SrcChange_detectionProto_change_detector) {
      _export('DynamicProtoChangeDetector', _angular2SrcChange_detectionProto_change_detector.DynamicProtoChangeDetector);

      _export('JitProtoChangeDetector', _angular2SrcChange_detectionProto_change_detector.JitProtoChangeDetector);
    }, function (_angular2SrcChange_detectionBinding_record) {
      _export('BindingRecord', _angular2SrcChange_detectionBinding_record.BindingRecord);
    }, function (_angular2SrcChange_detectionDirective_record) {
      _export('DirectiveIndex', _angular2SrcChange_detectionDirective_record.DirectiveIndex);

      _export('DirectiveRecord', _angular2SrcChange_detectionDirective_record.DirectiveRecord);
    }, function (_angular2SrcChange_detectionDynamic_change_detector) {
      _export('DynamicChangeDetector', _angular2SrcChange_detectionDynamic_change_detector.DynamicChangeDetector);
    }, function (_angular2SrcChange_detectionChange_detector_ref) {
      _export('ChangeDetectorRef', _angular2SrcChange_detectionChange_detector_ref.ChangeDetectorRef);
    }, function (_angular2SrcChange_detectionPipesPipe_registry) {
      _export('PipeRegistry', _angular2SrcChange_detectionPipesPipe_registry.PipeRegistry);
    }, function (_angular2SrcChange_detectionChange_detection_util) {
      _export('uninitialized', _angular2SrcChange_detectionChange_detection_util.uninitialized);
    }, function (_angular2SrcChange_detectionPipesPipe) {
      _export('WrappedValue', _angular2SrcChange_detectionPipesPipe.WrappedValue);

      _export('Pipe', _angular2SrcChange_detectionPipesPipe.Pipe);

      _export('PipeFactory', _angular2SrcChange_detectionPipesPipe.PipeFactory);
    }, function (_angular2SrcChange_detectionPipesNull_pipe) {
      _export('NullPipe', _angular2SrcChange_detectionPipesNull_pipe.NullPipe);

      _export('NullPipeFactory', _angular2SrcChange_detectionPipesNull_pipe.NullPipeFactory);
    }, function (_angular2SrcChange_detectionChange_detection) {
      _export('defaultPipes', _angular2SrcChange_detectionChange_detection.defaultPipes);

      _export('DynamicChangeDetection', _angular2SrcChange_detectionChange_detection.DynamicChangeDetection);

      _export('JitChangeDetection', _angular2SrcChange_detectionChange_detection.JitChangeDetection);

      _export('PreGeneratedChangeDetection', _angular2SrcChange_detectionChange_detection.PreGeneratedChangeDetection);

      _export('preGeneratedProtoDetectors', _angular2SrcChange_detectionChange_detection.preGeneratedProtoDetectors);

      _export('defaultPipeRegistry', _angular2SrcChange_detectionChange_detection.defaultPipeRegistry);
    }],
    execute: function () {}
  };
});
System.register("angular2/src/core/annotations_impl/annotations", ["npm:babel-runtime@5.4.7/helpers/inherits", "npm:babel-runtime@5.4.7/helpers/get", "npm:babel-runtime@5.4.7/helpers/class-call-check", "angular2/src/facade/lang", "angular2/src/di/annotations_impl", "angular2/change_detection"], function (_export) {
    var _inherits, _get, _classCallCheck, CONST, CONST_EXPR, Injectable, DEFAULT, __decorate, __metadata, Directive, Component, LifecycleEvent, onDestroy, onChange, onCheck, onInit, onAllChangesDone;

    return {
        setters: [function (_npmBabelRuntime547HelpersInherits) {
            _inherits = _npmBabelRuntime547HelpersInherits["default"];
        }, function (_npmBabelRuntime547HelpersGet) {
            _get = _npmBabelRuntime547HelpersGet["default"];
        }, function (_npmBabelRuntime547HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime547HelpersClassCallCheck["default"];
        }, function (_angular2SrcFacadeLang) {
            CONST = _angular2SrcFacadeLang.CONST;
            CONST_EXPR = _angular2SrcFacadeLang.CONST_EXPR;
        }, function (_angular2SrcDiAnnotations_impl) {
            Injectable = _angular2SrcDiAnnotations_impl.Injectable;
        }, function (_angular2Change_detection) {
            DEFAULT = _angular2Change_detection.DEFAULT;
        }],
        execute: function () {
            "use strict";

            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            // type StringMap = {[idx: string]: string};
            /**
             * Directives allow you to attach behavior to elements in the DOM.
             *
             * {@link Directive}s with an embedded view are called {@link Component}s.
             *
             * A directive consists of a single directive annotation and a controller class. When the
             * directive's `selector` matches
             * elements in the DOM, the following steps occur:
             *
             * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
             * arguments.
             * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
             * depth-first order,
             *    as declared in the HTML.
             *
             * ## Understanding How Injection Works
             *
             * There are three stages of injection resolution.
             * - *Pre-existing Injectors*:
             *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
             * the dependency was
             *     specified as `@Optional`, returns `null`.
             *   - The platform injector resolves browser singleton resources, such as: cookies, title,
             * location, and others.
             * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
             * the same parent-child hierarchy
             *     as the component instances in the DOM.
             * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
             * element has an `ElementInjector`
             *     which follow the same parent-child hierarchy as the DOM elements themselves.
             *
             * When a template is instantiated, it also must instantiate the corresponding directives in a
             * depth-first order. The
             * current `ElementInjector` resolves the constructor dependencies for each directive.
             *
             * Angular then resolves dependencies as follows, according to the order in which they appear in the
             * {@link View}:
             *
             * 1. Dependencies on the current element
             * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
             * 3. Dependencies on component injectors and their parents until it encounters the root component
             * 4. Dependencies on pre-existing injectors
             *
             *
             * The `ElementInjector` can inject other directives, element-specific special objects, or it can
             * delegate to the parent
             * injector.
             *
             * To inject other directives, declare the constructor parameter as:
             * - `directive:DirectiveType`: a directive on the current element only
             * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current
             * element and the
             *    Shadow DOM root. Current element is not included in the resolution, therefore even if it could
             * resolve it, it will
             *    be ignored.
             * - `@Parent() directive:DirectiveType`: any directive that matches the type on a direct parent
             * element only.
             * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
             * directives.
             * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
             * child directives.
             *
             * To inject element-specific special objects, declare the constructor parameter as:
             * - `element: ElementRef` to obtain a reference to logical element in the view.
             * - `viewContainer: ViewContainerRef` to control child template instantiation, for {@link
             * Directive} directives only
             * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
             *
             * ## Example
             *
             * The following example demonstrates how dependency injection resolves constructor arguments in
             * practice.
             *
             *
             * Assume this HTML template:
             *
             * ```
             * <div dependency="1">
             *   <div dependency="2">
             *     <div dependency="3" my-directive>
             *       <div dependency="4">
             *         <div dependency="5"></div>
             *       </div>
             *       <div dependency="6"></div>
             *     </div>
             *   </div>
             * </div>
             * ```
             *
             * With the following `dependency` decorator and `SomeService` injectable class.
             *
             * ```
             * @Injectable()
             * class SomeService {
             * }
             *
             * @Directive({
             *   selector: '[dependency]',
             *   properties: [
             *     'id: dependency'
             *   ]
             * })
             * class Dependency {
             *   id:string;
             * }
             * ```
             *
             * Let's step through the different ways in which `MyDirective` could be declared...
             *
             *
             * ### No injection
             *
             * Here the constructor is declared with no arguments, therefore nothing is injected into
             * `MyDirective`.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor() {
             *   }
             * }
             * ```
             *
             * This directive would be instantiated with no dependencies.
             *
             *
             * ### Component-level injection
             *
             * Directives can inject any injectable instance from the closest component injector or any of its
             * parents.
             *
             * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
             * from the parent
             * component's injector.
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(someService: SomeService) {
             *   }
             * }
             * ```
             *
             * This directive would be instantiated with a dependency on `SomeService`.
             *
             *
             * ### Injecting a directive from the current element
             *
             * Directives can inject other directives declared on the current element.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(dependency: Dependency) {
             *     expect(dependency.id).toEqual(3);
             *   }
             * }
             * ```
             * This directive would be instantiated with `Dependency` declared at the same element, in this case
             * `dependency="3"`.
             *
             *
             * ### Injecting a directive from a direct parent element
             *
             * Directives can inject other directives declared on a direct parent element. By definition, a
             * directive with a
             * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if
             * this would satisfy
             * the dependency.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(@Parent() dependency: Dependency) {
             *     expect(dependency.id).toEqual(2);
             *   }
             * }
             * ```
             * This directive would be instantiated with `Dependency` declared at the parent element, in this
             * case `dependency="2"`.
             *
             *
             * ### Injecting a directive from any ancestor elements
             *
             * Directives can inject other directives declared on any ancestor element (in the current Shadow
             * DOM), i.e. on the
             * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does
             * not attempt to
             * resolve dependencies for the current element, even if this would satisfy the dependency.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(@Ancestor() dependency: Dependency) {
             *     expect(dependency.id).toEqual(2);
             *   }
             * }
             * ```
             *
             * Unlike the `@Parent` which only checks the parent, `@Ancestor` checks the parent, as well as its
             * parents recursively. If `dependency="2"` didn't exist on the direct parent, this injection would
             * have returned
             * `dependency="1"`.
             *
             *
             * ### Injecting a live collection of direct child directives
             *
             *
             * A directive can also query for other child directives. Since parent directives are instantiated
             * before child
             * directives, a directive can't simply inject the list of child directives. Instead, the directive
             * injects a {@link QueryList}, which updates its contents as children are added, removed, or moved
             * by a directive
             * that uses a {@link ViewContainerRef} such as a `for`, an `if`, or a `switch`.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
             *   }
             * }
             * ```
             *
             * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
             * 6. Here, `Dependency`
             * 5 would not be included, because it is not a direct child.
             *
             * ### Injecting a live collection of descendant directives
             *
             * Note: This is will be implemented in later release. ()
             *
             * Similar to `@Query` above, but also includes the children of the child elements.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(@QueryDescendents(Dependency) dependencies:QueryList<Dependency>) {
             *   }
             * }
             * ```
             *
             * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
             *
             * ### Optional injection
             *
             * The normal behavior of directives is to return an error when a specified dependency cannot be
             * resolved. If you
             * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
             * with `@Optional()`.
             * This explicitly permits the author of a template to treat some of the surrounding directives as
             * optional.
             *
             * ```
             * @Directive({ selector: '[my-directive]' })
             * class MyDirective {
             *   constructor(@Optional() dependency:Dependency) {
             *   }
             * }
             * ```
             *
             * This directive would be instantiated with a `Dependency` directive found on the current element.
             * If none can be
             * found, the injector supplies `null` instead of throwing an error.
             *
             * ## Example
             *
             * Here we use a decorator directive to simply define basic tool-tip behavior.
             *
             * ```
             * @Directive({
             *   selector: '[tooltip]',
             *   properties: [
             *     'text: tooltip'
             *   ],
             *   hostListeners: {
             *     'onmouseenter': 'onMouseEnter()',
             *     'onmouseleave': 'onMouseLeave()'
             *   }
             * })
             * class Tooltip{
             *   text:string;
             *   overlay:Overlay; // NOT YET IMPLEMENTED
             *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
             *
             *   constructor(overlayManager:OverlayManager) {
             *     this.overlay = overlay;
             *   }
             *
             *   onMouseEnter() {
             *     // exact signature to be determined
             *     this.overlay = this.overlayManager.open(text, ...);
             *   }
             *
             *   onMouseLeave() {
             *     this.overlay.close();
             *     this.overlay = null;
             *   }
             * }
             * ```
             * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
             * `tooltip` selector,
             * like so:
             *
             * ```
             * <div tooltip="some text here"></div>
             * ```
             *
             * Directives can also control the instantiation, destruction, and positioning of inline template
             * elements:
             *
             * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
             * runtime.
             * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
             * location in the current view
             * where these actions are performed.
             *
             * Views are always created as children of the current {@link View}, and as siblings of the
             * `<template>` element. Thus a
             * directive in a child view cannot inject the directive that created it.
             *
             * Since directives that create views via ViewContainers are common in Angular, and using the full
             * `<template>` element syntax is wordy, Angular
             * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
             * equivalent.
             *
             * Thus,
             *
             * ```
             * <ul>
             *   <li *foo="bar" title="text"></li>
             * </ul>
             * ```
             *
             * Expands in use to:
             *
             * ```
             * <ul>
             *   <template [foo]="bar">
             *     <li title="text"></li>
             *   </template>
             * </ul>
             * ```
             *
             * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
             * the directive
             * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
             *
             *
             * ## Example
             *
             * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
             *
             * Here is a simple directive that triggers on an `unless` selector:
             *
             * ```
             * @Directive({
             *   selector: '[unless]',
             *   properties: ['unless']
             * })
             * export class Unless {
             *   viewContainer: ViewContainerRef;
             *   protoViewRef: ProtoViewRef;
             *   prevCondition: boolean;
             *
             *   constructor(viewContainer: ViewContainerRef, protoViewRef: ProtoViewRef) {
             *     this.viewContainer = viewContainer;
             *     this.protoViewRef = protoViewRef;
             *     this.prevCondition = null;
             *   }
             *
             *   set unless(newCondition) {
             *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
             *       this.prevCondition = true;
             *       this.viewContainer.clear();
             *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
             *       this.prevCondition = false;
             *       this.viewContainer.create(this.protoViewRef);
             *     }
             *   }
             * }
             * ```
             *
             * We can then use this `unless` selector in a template:
             * ```
             * <ul>
             *   <li *unless="expr"></li>
             * </ul>
             * ```
             *
             * Once the directive instantiates the child view, the shorthand notation for the template expands
             * and the result is:
             *
             * ```
             * <ul>
             *   <template [unless]="exp">
             *     <li></li>
             *   </template>
             *   <li></li>
             * </ul>
             * ```
             *
             * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
             * the instantiated
             * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
             *
             * @exportedAs angular2/annotations
             */

            Directive = (function (_Injectable) {
                var _class = function Directive() {
                    var _ref = arguments[0] === undefined ? {} : arguments[0];

                    var selector = _ref.selector;
                    var properties = _ref.properties;
                    var events = _ref.events;
                    var hostListeners = _ref.hostListeners;
                    var hostProperties = _ref.hostProperties;
                    var hostAttributes = _ref.hostAttributes;
                    var hostActions = _ref.hostActions;
                    var lifecycle = _ref.lifecycle;
                    var hostInjector = _ref.hostInjector;
                    var _ref$compileChildren = _ref.compileChildren;
                    var compileChildren = _ref$compileChildren === undefined ? true : _ref$compileChildren;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this);
                    this.selector = selector;
                    this.properties = properties;
                    this.events = events;
                    this.hostListeners = hostListeners;
                    this.hostProperties = hostProperties;
                    this.hostAttributes = hostAttributes;
                    this.hostActions = hostActions;
                    this.lifecycle = lifecycle;
                    this.compileChildren = compileChildren;
                    this.hostInjector = hostInjector;
                };

                _inherits(_class, _Injectable);

                return _class;
            })(Injectable);

            _export("Directive", Directive);

            _export("Directive", Directive = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Directive));
            /**
             * Declare reusable UI building blocks for an application.
             *
             * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
             * `@Component`
             * annotation specifies when a component is instantiated, and which properties and hostListeners it
             * binds to.
             *
             * When a component is instantiated, Angular
             * - creates a shadow DOM for the component.
             * - loads the selected template into the shadow DOM.
             * - creates a child {@link Injector} which is configured with the `appInjector` for the {@link
             * Component}.
             *
             * All template expressions and statements are then evaluated against the component instance.
             *
             * For details on the `@View` annotation, see {@link View}.
             *
             * ## Example
             *
             * ```
             * @Component({
             *   selector: 'greet'
             * })
             * @View({
             *   template: 'Hello {{name}}!'
             * })
             * class Greet {
             *   name: string;
             *
             *   constructor() {
             *     this.name = 'World';
             *   }
             * }
             * ```
             *
             *
             * Dynamically loading a component at runtime:
             *
             * Regular Angular components are statically resolved. Dynamic components allows to resolve a
             * component at runtime
             * instead by providing a placeholder into which a regular Angular component can be dynamically
             * loaded. Once loaded,
             * the dynamically-loaded component becomes permanent and cannot be changed.
             * Dynamic components are declared just like components, but without a `@View` annotation.
             *
             *
             * ## Example
             *
             * Here we have `DynamicComp` which acts as the placeholder for `HelloCmp`. At runtime, the dynamic
             * component
             * `DynamicComp` requests loading of the `HelloCmp` component.
             *
             * There is nothing special about `HelloCmp`, which is a regular Angular component. It can also be
             * used in other static
             * locations.
             *
             * ```
             * @Component({
             *   selector: 'dynamic-comp'
             * })
             * class DynamicComp {
             *   helloCmp:HelloCmp;
             *   constructor(loader:DynamicComponentLoader, location:ElementRef) {
             *     loader.load(HelloCmp, location).then((helloCmp) => {
             *       this.helloCmp = helloCmp;
             *     });
             *   }
             * }
             *
             * @Component({
             *   selector: 'hello-cmp'
             * })
             * @View({
             *   template: "{{greeting}}"
             * })
             * class HelloCmp {
             *   greeting:string;
             *   constructor() {
             *     this.greeting = "hello";
             *   }
             * }
             * ```
             *
             *
             * @exportedAs angular2/annotations
             */

            Component = (function (_Directive) {
                var _class2 = function Component() {
                    var _ref2 = arguments[0] === undefined ? {} : arguments[0];

                    var selector = _ref2.selector;
                    var properties = _ref2.properties;
                    var events = _ref2.events;
                    var hostListeners = _ref2.hostListeners;
                    var hostProperties = _ref2.hostProperties;
                    var hostAttributes = _ref2.hostAttributes;
                    var hostActions = _ref2.hostActions;
                    var appInjector = _ref2.appInjector;
                    var lifecycle = _ref2.lifecycle;
                    var hostInjector = _ref2.hostInjector;
                    var viewInjector = _ref2.viewInjector;
                    var _ref2$changeDetection = _ref2.changeDetection;
                    var changeDetection = _ref2$changeDetection === undefined ? DEFAULT : _ref2$changeDetection;
                    var _ref2$compileChildren = _ref2.compileChildren;
                    var compileChildren = _ref2$compileChildren === undefined ? true : _ref2$compileChildren;

                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, {
                        selector: selector,
                        properties: properties,
                        events: events,
                        hostListeners: hostListeners,
                        hostProperties: hostProperties,
                        hostAttributes: hostAttributes,
                        hostActions: hostActions,
                        hostInjector: hostInjector,
                        lifecycle: lifecycle,
                        compileChildren: compileChildren
                    });
                    this.changeDetection = changeDetection;
                    this.appInjector = appInjector;
                    this.viewInjector = viewInjector;
                };

                _inherits(_class2, _Directive);

                return _class2;
            })(Directive);

            _export("Component", Component);

            _export("Component", Component = __decorate([CONST(), __metadata("design:paramtypes", [Object])], Component));

            LifecycleEvent = (function () {
                var _class3 = function LifecycleEvent(name) {
                    _classCallCheck(this, _class3);

                    this.name = name;
                };

                return _class3;
            })();

            _export("LifecycleEvent", LifecycleEvent);

            _export("LifecycleEvent", LifecycleEvent = __decorate([CONST(), __metadata("design:paramtypes", [String])], LifecycleEvent));
            /**
             * Notify a directive whenever a {@link View} that contains it is destroyed.
             *
             * ## Example
             *
             * ```
             * @Directive({
             *   ...,
             *   lifecycle: [onDestroy]
             * })
             * class ClassSet {
             *   onDestroy() {
             *     // invoked to notify directive of the containing view destruction.
             *   }
             * }
             * ```
             * @exportedAs angular2/annotations
             */
            onDestroy = CONST_EXPR(new LifecycleEvent("onDestroy"));

            _export("onDestroy", onDestroy);

            /**
             * Notify a directive when any of its bindings have changed.
             *
             * This method is called right after the directive's bindings have been checked,
             * and before any of its children's bindings have been checked.
             *
             * It is invoked only if at least one of the directive's bindings has changed.
             *
             * ## Example:
             *
             * ```
             * @Directive({
             *   selector: '[class-set]',
             *   properties: [
             *     'propA',
             *     'propB'
             *   ],
             *   lifecycle: [onChange]
             * })
             * class ClassSet {
             *   propA;
             *   propB;
             *   onChange(changes:{[idx: string, PropertyUpdate]}) {
             *     // This will get called after any of the properties have been updated.
             *     if (changes['propA']) {
             *       // if propA was updated
             *     }
             *     if (changes['propA']) {
             *       // if propB was updated
             *     }
             *   }
             * }
             *  ```
             * @exportedAs angular2/annotations
             */
            onChange = CONST_EXPR(new LifecycleEvent("onChange"));

            _export("onChange", onChange);

            /**
             * Notify a directive when it has been checked.
             *
             * This method is called right after the directive's bindings have been checked,
             * and before any of its children's bindings have been checked.
             *
             * It is invoked every time even when none of the directive's bindings has changed.
             *
             * ## Example:
             *
             * ```
             * @Directive({
             *   selector: '[class-set]',
             *   lifecycle: [onCheck]
             * })
             * class ClassSet {
             *   onCheck() {
             *   }
             * }
             *  ```
             * @exportedAs angular2/annotations
             */
            onCheck = CONST_EXPR(new LifecycleEvent("onCheck"));

            _export("onCheck", onCheck);

            /**
             * Notify a directive when it has been checked the first itme.
             *
             * This method is called right after the directive's bindings have been checked,
             * and before any of its children's bindings have been checked.
             *
             * It is invoked only once.
             *
             * ## Example:
             *
             * ```
             * @Directive({
             *   selector: '[class-set]',
             *   lifecycle: [onInit]
             * })
             * class ClassSet {
             *   onInit() {
             *   }
             * }
             *  ```
             * @exportedAs angular2/annotations
             */
            onInit = CONST_EXPR(new LifecycleEvent("onInit"));

            _export("onInit", onInit);

            /**
             * Notify a directive when the bindings of all its children have been changed.
             *
             * ## Example:
             *
             * ```
             * @Directive({
             *   selector: '[class-set]',
             *   lifecycle: [onAllChangesDone]
             * })
             * class ClassSet {
             *
             *   onAllChangesDone() {
             *   }
             *
             * }
             *  ```
             * @exportedAs angular2/annotations
             */
            onAllChangesDone = CONST_EXPR(new LifecycleEvent("onAllChangesDone"));

            

            _export("onAllChangesDone", onAllChangesDone);
        }
    };
});