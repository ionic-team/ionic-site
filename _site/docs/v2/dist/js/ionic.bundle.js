(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $Object.defineProperties;
  var $defineProperty = $Object.defineProperty;
  var $freeze = $Object.freeze;
  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
  var $keys = $Object.keys;
  var $hasOwnProperty = $Object.prototype.hasOwnProperty;
  var $toString = $Object.prototype.toString;
  var $preventExtensions = Object.preventExtensions;
  var $seal = Object.seal;
  var $isExtensible = Object.isExtensible;
  var $apply = Function.prototype.call.bind(Function.prototype.apply);
  function $bind(operand, thisArg, args) {
    var argArray = [thisArg];
    for (var i = 0; i < args.length; i++) {
      argArray[i + 1] = args[i];
    }
    var func = $apply(Function.prototype.bind, operand, argArray);
    return func;
  }
  function $construct(func, argArray) {
    var object = new ($bind(func, null, argArray));
    return object;
  }
  var counter = 0;
  function newUniqueString() {
    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
  }
  var privateNames = $create(null);
  function isPrivateName(s) {
    return privateNames[s];
  }
  function createPrivateName() {
    var s = newUniqueString();
    privateNames[s] = true;
    return s;
  }
  var CONTINUATION_TYPE = Object.create(null);
  function createContinuation(operand, thisArg, argsArray) {
    return [CONTINUATION_TYPE, operand, thisArg, argsArray];
  }
  function isContinuation(object) {
    return object && object[0] === CONTINUATION_TYPE;
  }
  var isTailRecursiveName = null;
  function setupProperTailCalls() {
    isTailRecursiveName = createPrivateName();
    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {
      var result = tailCall(function(thisArg) {
        var argArray = [];
        for (var i = 1; i < arguments.length; ++i) {
          argArray[i - 1] = arguments[i];
        }
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {
      var result = tailCall(function(thisArg, argArray) {
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
  }
  function initTailRecursiveFunction(func) {
    if (isTailRecursiveName === null) {
      setupProperTailCalls();
    }
    func[isTailRecursiveName] = true;
    return func;
  }
  function isTailRecursive(func) {
    return !!func[isTailRecursiveName];
  }
  function tailCall(func, thisArg, argArray) {
    var continuation = argArray[0];
    if (isContinuation(continuation)) {
      continuation = $apply(func, thisArg, continuation[3]);
      return continuation;
    }
    continuation = createContinuation(func, thisArg, argArray);
    while (true) {
      if (isTailRecursive(func)) {
        continuation = $apply(func, continuation[2], [continuation]);
      } else {
        continuation = $apply(func, continuation[2], continuation[3]);
      }
      if (!isContinuation(continuation)) {
        return continuation;
      }
      func = continuation[1];
    }
  }
  function construct() {
    var object;
    if (isTailRecursive(this)) {
      object = $construct(this, [createContinuation(null, null, arguments)]);
    } else {
      object = $construct(this, arguments);
    }
    return object;
  }
  var $traceurRuntime = {
    initTailRecursiveFunction: initTailRecursiveFunction,
    call: tailCall,
    continuation: createContinuation,
    construct: construct
  };
  (function() {
    function nonEnum(value) {
      return {
        configurable: true,
        enumerable: false,
        value: value,
        writable: true
      };
    }
    var method = nonEnum;
    var symbolInternalProperty = newUniqueString();
    var symbolDescriptionProperty = newUniqueString();
    var symbolDataProperty = newUniqueString();
    var symbolValues = $create(null);
    function isShimSymbol(symbol) {
      return typeof symbol === 'object' && symbol instanceof SymbolValue;
    }
    function typeOf(v) {
      if (isShimSymbol(v))
        return 'symbol';
      return typeof v;
    }
    function Symbol(description) {
      var value = new SymbolValue(description);
      if (!(this instanceof Symbol))
        return value;
      throw new TypeError('Symbol cannot be new\'ed');
    }
    $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
    $defineProperty(Symbol.prototype, 'toString', method(function() {
      var symbolValue = this[symbolDataProperty];
      return symbolValue[symbolInternalProperty];
    }));
    $defineProperty(Symbol.prototype, 'valueOf', method(function() {
      var symbolValue = this[symbolDataProperty];
      if (!symbolValue)
        throw TypeError('Conversion from symbol to string');
      if (!getOption('symbols'))
        return symbolValue[symbolInternalProperty];
      return symbolValue;
    }));
    function SymbolValue(description) {
      var key = newUniqueString();
      $defineProperty(this, symbolDataProperty, {value: this});
      $defineProperty(this, symbolInternalProperty, {value: key});
      $defineProperty(this, symbolDescriptionProperty, {value: description});
      freeze(this);
      symbolValues[key] = this;
    }
    $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
    $defineProperty(SymbolValue.prototype, 'toString', {
      value: Symbol.prototype.toString,
      enumerable: false
    });
    $defineProperty(SymbolValue.prototype, 'valueOf', {
      value: Symbol.prototype.valueOf,
      enumerable: false
    });
    var hashProperty = createPrivateName();
    var hashPropertyDescriptor = {value: undefined};
    var hashObjectProperties = {
      hash: {value: undefined},
      self: {value: undefined}
    };
    var hashCounter = 0;
    function getOwnHashObject(object) {
      var hashObject = object[hashProperty];
      if (hashObject && hashObject.self === object)
        return hashObject;
      if ($isExtensible(object)) {
        hashObjectProperties.hash.value = hashCounter++;
        hashObjectProperties.self.value = object;
        hashPropertyDescriptor.value = $create(null, hashObjectProperties);
        $defineProperty(object, hashProperty, hashPropertyDescriptor);
        return hashPropertyDescriptor.value;
      }
      return undefined;
    }
    function freeze(object) {
      getOwnHashObject(object);
      return $freeze.apply(this, arguments);
    }
    function preventExtensions(object) {
      getOwnHashObject(object);
      return $preventExtensions.apply(this, arguments);
    }
    function seal(object) {
      getOwnHashObject(object);
      return $seal.apply(this, arguments);
    }
    freeze(SymbolValue.prototype);
    function isSymbolString(s) {
      return symbolValues[s] || privateNames[s];
    }
    function toProperty(name) {
      if (isShimSymbol(name))
        return name[symbolInternalProperty];
      return name;
    }
    function removeSymbolKeys(array) {
      var rv = [];
      for (var i = 0; i < array.length; i++) {
        if (!isSymbolString(array[i])) {
          rv.push(array[i]);
        }
      }
      return rv;
    }
    function getOwnPropertyNames(object) {
      return removeSymbolKeys($getOwnPropertyNames(object));
    }
    function keys(object) {
      return removeSymbolKeys($keys(object));
    }
    function getOwnPropertySymbols(object) {
      var rv = [];
      var names = $getOwnPropertyNames(object);
      for (var i = 0; i < names.length; i++) {
        var symbol = symbolValues[names[i]];
        if (symbol) {
          rv.push(symbol);
        }
      }
      return rv;
    }
    function getOwnPropertyDescriptor(object, name) {
      return $getOwnPropertyDescriptor(object, toProperty(name));
    }
    function hasOwnProperty(name) {
      return $hasOwnProperty.call(this, toProperty(name));
    }
    function getOption(name) {
      return global.$traceurRuntime.options[name];
    }
    function defineProperty(object, name, descriptor) {
      if (isShimSymbol(name)) {
        name = name[symbolInternalProperty];
      }
      $defineProperty(object, name, descriptor);
      return object;
    }
    function polyfillObject(Object) {
      $defineProperty(Object, 'defineProperty', {value: defineProperty});
      $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});
      $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});
      $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});
      $defineProperty(Object, 'freeze', {value: freeze});
      $defineProperty(Object, 'preventExtensions', {value: preventExtensions});
      $defineProperty(Object, 'seal', {value: seal});
      $defineProperty(Object, 'keys', {value: keys});
    }
    function exportStar(object) {
      for (var i = 1; i < arguments.length; i++) {
        var names = $getOwnPropertyNames(arguments[i]);
        for (var j = 0; j < names.length; j++) {
          var name = names[j];
          if (name === '__esModule' || name === 'default' || isSymbolString(name))
            continue;
          (function(mod, name) {
            $defineProperty(object, name, {
              get: function() {
                return mod[name];
              },
              enumerable: true
            });
          })(arguments[i], names[j]);
        }
      }
      return object;
    }
    function isObject(x) {
      return x != null && (typeof x === 'object' || typeof x === 'function');
    }
    function toObject(x) {
      if (x == null)
        throw $TypeError();
      return $Object(x);
    }
    function checkObjectCoercible(argument) {
      if (argument == null) {
        throw new TypeError('Value cannot be converted to an Object');
      }
      return argument;
    }
    var hasNativeSymbol;
    function polyfillSymbol(global, Symbol) {
      if (!global.Symbol) {
        global.Symbol = Symbol;
        Object.getOwnPropertySymbols = getOwnPropertySymbols;
        hasNativeSymbol = false;
      } else {
        hasNativeSymbol = true;
      }
      if (!global.Symbol.iterator) {
        global.Symbol.iterator = Symbol('Symbol.iterator');
      }
      if (!global.Symbol.observer) {
        global.Symbol.observer = Symbol('Symbol.observer');
      }
    }
    function hasNativeSymbolFunc() {
      return hasNativeSymbol;
    }
    function setupGlobals(global) {
      polyfillSymbol(global, Symbol);
      global.Reflect = global.Reflect || {};
      global.Reflect.global = global.Reflect.global || global;
      polyfillObject(global.Object);
    }
    setupGlobals(global);
    global.$traceurRuntime = {
      call: tailCall,
      checkObjectCoercible: checkObjectCoercible,
      construct: construct,
      continuation: createContinuation,
      createPrivateName: createPrivateName,
      defineProperties: $defineProperties,
      defineProperty: $defineProperty,
      exportStar: exportStar,
      getOwnHashObject: getOwnHashObject,
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
      getOwnPropertyNames: $getOwnPropertyNames,
      hasNativeSymbol: hasNativeSymbolFunc,
      initTailRecursiveFunction: initTailRecursiveFunction,
      isObject: isObject,
      isPrivateName: isPrivateName,
      isSymbolString: isSymbolString,
      keys: $keys,
      options: {},
      setupGlobals: setupGlobals,
      toObject: toObject,
      toProperty: toProperty,
      typeof: typeOf
    };
  })();
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__3 = $traceurRuntime,
      canonicalizeUrl = $__3.canonicalizeUrl,
      resolveUrl = $__3.resolveUrl,
      isAbsolute = $__3.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  }
  function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  }
  ModuleEvaluationError.prototype = Object.create(Error.prototype);
  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;
  ModuleEvaluationError.prototype.stripError = function(message) {
    return message.replace(/.*Error:/, this.constructor.name + ':');
  };
  ModuleEvaluationError.prototype.stripCause = function(cause) {
    if (!cause)
      return '';
    if (!cause.message)
      return cause + '';
    return this.stripError(cause.message);
  };
  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {
    this.stack += '\n loaded by ' + moduleName;
  };
  ModuleEvaluationError.prototype.stripStack = function(causeStack) {
    var stack = [];
    causeStack.split('\n').some(function(frame) {
      if (/UncoatedModuleInstantiator/.test(frame))
        return true;
      stack.push(frame);
    });
    stack[0] = this.stripError(stack[0]);
    return stack.join('\n');
  };
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  function UncoatedModuleInstantiator(url, func) {
    UncoatedModuleEntry.call(this, url, null);
    this.func = func;
  }
  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);
  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {
    var $__2 = this;
    if (this.value_)
      return this.value_;
    try {
      var relativeRequire;
      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {
        relativeRequire = $traceurRuntime.require.bind(null, this.url);
      }
      return this.value_ = this.func.call(global, relativeRequire);
    } catch (ex) {
      if (ex instanceof ModuleEvaluationError) {
        ex.loadedBy(this.url);
        throw ex;
      }
      if (ex.stack) {
        var lines = this.func.toString().split('\n');
        var evaled = [];
        ex.stack.split('\n').some(function(frame, index) {
          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
            return true;
          var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
          if (m) {
            var line = parseInt(m[2], 10);
            evaled = evaled.concat(beforeLines(lines, line));
            if (index === 1) {
              evaled.push(columnSpacing(m[3]) + '^ ' + $__2.url);
            } else {
              evaled.push(columnSpacing(m[3]) + '^');
            }
            evaled = evaled.concat(afterLines(lines, line));
            evaled.push('= = = = = = = = =');
          } else {
            evaled.push(frame);
          }
        });
        ex.stack = evaled.join('\n');
      }
      throw new ModuleEvaluationError(this.url, ex);
    }
  };
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    });
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {
        return module;
      });
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__2 = arguments;
            var depMap = {};
            deps.forEach(function(dep, index) {
              return depMap[dep] = $__2[index];
            });
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func.call(global), liveModuleSentinel);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  global.System = {
    register: ModuleStore.register.bind(ModuleStore),
    registerModule: ModuleStore.registerModule.bind(ModuleStore),
    get: ModuleStore.get,
    set: ModuleStore.set,
    normalize: ModuleStore.normalize
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
System.registerModule("traceur-runtime@0.0.91/src/runtime/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/async.js";
  if (typeof $traceurRuntime !== 'object') {
    throw new Error('traceur runtime not found.');
  }
  var $createPrivateName = $traceurRuntime.createPrivateName;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $create = Object.create;
  var thisName = $createPrivateName();
  var argsName = $createPrivateName();
  var observeName = $createPrivateName();
  function AsyncGeneratorFunction() {}
  function AsyncGeneratorFunctionPrototype() {}
  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;
  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;
  $defineProperty(AsyncGeneratorFunctionPrototype, 'constructor', {enumerable: false});
  var AsyncGeneratorContext = function() {
    function AsyncGeneratorContext(observer) {
      var $__2 = this;
      this.decoratedObserver = $traceurRuntime.createDecoratedGenerator(observer, function() {
        $__2.done = true;
      });
      this.done = false;
      this.inReturn = false;
    }
    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {
      throw: function(error) {
        if (!this.inReturn) {
          throw error;
        }
      },
      yield: function(value) {
        if (this.done) {
          this.inReturn = true;
          throw undefined;
        }
        var result;
        try {
          result = this.decoratedObserver.next(value);
        } catch (e) {
          this.done = true;
          throw e;
        }
        if (result === undefined) {
          return;
        }
        if (result.done) {
          this.done = true;
          this.inReturn = true;
          throw undefined;
        }
        return result.value;
      },
      yieldFor: function(observable) {
        var ctx = this;
        return $traceurRuntime.observeForEach(observable[$traceurRuntime.toProperty(Symbol.observer)].bind(observable), function(value) {
          if (ctx.done) {
            this.return();
            return;
          }
          var result;
          try {
            result = ctx.decoratedObserver.next(value);
          } catch (e) {
            ctx.done = true;
            throw e;
          }
          if (result === undefined) {
            return;
          }
          if (result.done) {
            ctx.done = true;
          }
          return result;
        });
      }
    }, {});
  }();
  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {
    var observe = this[observeName];
    var ctx = new AsyncGeneratorContext(observer);
    $traceurRuntime.schedule(function() {
      return observe(ctx);
    }).then(function(value) {
      if (!ctx.done) {
        ctx.decoratedObserver.return(value);
      }
    }).catch(function(error) {
      if (!ctx.done) {
        ctx.decoratedObserver.throw(error);
      }
    });
    return ctx.decoratedObserver;
  };
  $defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});
  function initAsyncGeneratorFunction(functionObject) {
    functionObject.prototype = $create(AsyncGeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;
    return functionObject;
  }
  function createAsyncGeneratorInstance(observe, functionObject) {
    for (var args = [],
        $__10 = 2; $__10 < arguments.length; $__10++)
      args[$__10 - 2] = arguments[$__10];
    var object = $create(functionObject.prototype);
    object[thisName] = this;
    object[argsName] = args;
    object[observeName] = observe;
    return object;
  }
  function observeForEach(observe, next) {
    return new Promise(function(resolve, reject) {
      var generator = observe({
        next: function(value) {
          return next.call(generator, value);
        },
        throw: function(error) {
          reject(error);
        },
        return: function(value) {
          resolve(value);
        }
      });
    });
  }
  function schedule(asyncF) {
    return Promise.resolve().then(asyncF);
  }
  var generator = Symbol();
  var onDone = Symbol();
  var DecoratedGenerator = function() {
    function DecoratedGenerator(_generator, _onDone) {
      this[generator] = _generator;
      this[onDone] = _onDone;
    }
    return ($traceurRuntime.createClass)(DecoratedGenerator, {
      next: function(value) {
        var result = this[generator].next(value);
        if (result !== undefined && result.done) {
          this[onDone].call(this);
        }
        return result;
      },
      throw: function(error) {
        this[onDone].call(this);
        return this[generator].throw(error);
      },
      return: function(value) {
        this[onDone].call(this);
        return this[generator].return(value);
      }
    }, {});
  }();
  function createDecoratedGenerator(generator, onDone) {
    return new DecoratedGenerator(generator, onDone);
  }
  Array.prototype[$traceurRuntime.toProperty(Symbol.observer)] = function(observer) {
    var done = false;
    var decoratedObserver = createDecoratedGenerator(observer, function() {
      return done = true;
    });
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      for (var $__4 = void 0,
          $__3 = (this)[$traceurRuntime.toProperty(Symbol.iterator)](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        var value = $__4.value;
        {
          decoratedObserver.next(value);
          if (done) {
            return;
          }
        }
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
    decoratedObserver.return();
    return decoratedObserver;
  };
  $defineProperty(Array.prototype, $traceurRuntime.toProperty(Symbol.observer), {enumerable: false});
  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;
  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;
  $traceurRuntime.observeForEach = observeForEach;
  $traceurRuntime.schedule = schedule;
  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/classes.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/classes.js";
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $traceurRuntime.getOwnPropertyNames;
  var $getPrototypeOf = Object.getPrototypeOf;
  var $__1 = Object,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols;
  function superDescriptor(homeObject, name) {
    var proto = $getPrototypeOf(homeObject);
    do {
      var result = $getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = $getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      var value = descriptor.value;
      if (value)
        return value;
      if (!descriptor.get)
        return value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  function forEachPropertyKey(object, f) {
    getOwnPropertyNames(object).forEach(f);
    getOwnPropertySymbols(object).forEach(f);
  }
  function getDescriptors(object) {
    var descriptors = {};
    forEachPropertyKey(object, function(key) {
      descriptors[key] = $getOwnPropertyDescriptor(object, key);
      descriptors[key].enumerable = false;
    });
    return descriptors;
  }
  var nonEnum = {enumerable: false};
  function makePropertiesNonEnumerable(object) {
    forEachPropertyKey(object, function(key) {
      $defineProperty(object, key, nonEnum);
    });
  }
  function createClass(ctor, object, staticObject, superClass) {
    $defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
    } else {
      makePropertiesNonEnumerable(object);
      ctor.prototype = object;
    }
    $defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return $defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/destructuring.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/destructuring.js";
  function iteratorToArray(iter) {
    var rv = [];
    var i = 0;
    var tmp;
    while (!(tmp = iter.next()).done) {
      rv[i++] = tmp.value;
    }
    return rv;
  }
  $traceurRuntime.iteratorToArray = iteratorToArray;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/generators.js";
  if (typeof $traceurRuntime !== 'object') {
    throw new Error('traceur runtime not found.');
  }
  var createPrivateName = $traceurRuntime.createPrivateName;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $create = Object.create;
  var $TypeError = TypeError;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  var RETURN_SENTINEL = {};
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.oldReturnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    maybeUncatchable: function() {
      if (this.storedException === RETURN_SENTINEL) {
        throw RETURN_SENTINEL;
      }
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    },
    wrapYieldStar: function(iterator) {
      var ctx = this;
      return {
        next: function(v) {
          return iterator.next(v);
        },
        throw: function(e) {
          var result;
          if (e === RETURN_SENTINEL) {
            if (iterator.return) {
              result = iterator.return(ctx.returnValue);
              if (!result.done) {
                ctx.returnValue = ctx.oldReturnValue;
                return result;
              }
              ctx.returnValue = result.value;
            }
            throw e;
          }
          if (iterator.throw) {
            return iterator.throw(e);
          }
          iterator.return && iterator.return();
          throw $TypeError('Inner iterator does not have a throw method');
        }
      };
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        if (x === RETURN_SENTINEL) {
          return {
            value: ctx.returnValue,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          if (x === RETURN_SENTINEL) {
            return {
              value: ctx.returnValue,
              done: true
            };
          }
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value;
        try {
          value = moveNext(ctx);
        } catch (ex) {
          if (ex === RETURN_SENTINEL) {
            value = ctx;
          } else {
            throw ex;
          }
        }
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateName();
  var moveNextName = createPrivateName();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  $defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', v);
    },
    return: function(v) {
      this[ctxName].oldReturnValue = this[ctxName].returnValue;
      this[ctxName].returnValue = v;
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', RETURN_SENTINEL);
    }
  };
  $defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false},
    return: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = $create(functionObject.prototype);
    object[ctxName] = ctx;
    object[moveNextName] = moveNext;
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = $create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = $create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return;
    }
    ctx.state = last.catch !== undefined ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/relativeRequire.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/relativeRequire.js";
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/spread.js";
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  $traceurRuntime.spread = spread;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/template.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/template.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      freeze = $__1.freeze;
  var slice = Array.prototype.slice;
  var map = Object.create(null);
  function getTemplateObject(raw) {
    var cooked = arguments[1];
    var key = raw.join('${}');
    var templateObject = map[key];
    if (templateObject)
      return templateObject;
    if (!cooked) {
      cooked = slice.call(raw);
    }
    return map[key] = freeze(defineProperty(cooked, 'raw', {value: freeze(raw)}));
  }
  $traceurRuntime.getTemplateObject = getTemplateObject;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/type-assertions.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/type-assertions.js";
  var types = {
    any: {name: 'any'},
    boolean: {name: 'boolean'},
    number: {name: 'number'},
    string: {name: 'string'},
    symbol: {name: 'symbol'},
    void: {name: 'void'}
  };
  var GenericType = function() {
    function GenericType(type, argumentTypes) {
      this.type = type;
      this.argumentTypes = argumentTypes;
    }
    return ($traceurRuntime.createClass)(GenericType, {}, {});
  }();
  var typeRegister = Object.create(null);
  function genericType(type) {
    for (var argumentTypes = [],
        $__2 = 1; $__2 < arguments.length; $__2++)
      argumentTypes[$__2 - 1] = arguments[$__2];
    var typeMap = typeRegister;
    var key = $traceurRuntime.getOwnHashObject(type).hash;
    if (!typeMap[key]) {
      typeMap[key] = Object.create(null);
    }
    typeMap = typeMap[key];
    for (var i = 0; i < argumentTypes.length - 1; i++) {
      key = $traceurRuntime.getOwnHashObject(argumentTypes[i]).hash;
      if (!typeMap[key]) {
        typeMap[key] = Object.create(null);
      }
      typeMap = typeMap[key];
    }
    var tail = argumentTypes[argumentTypes.length - 1];
    key = $traceurRuntime.getOwnHashObject(tail).hash;
    if (!typeMap[key]) {
      typeMap[key] = new GenericType(type, argumentTypes);
    }
    return typeMap[key];
  }
  $traceurRuntime.GenericType = GenericType;
  $traceurRuntime.genericType = genericType;
  $traceurRuntime.type = types;
  return {};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/runtime-modules.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/runtime-modules.js";
  System.get("traceur-runtime@0.0.91/src/runtime/relativeRequire.js");
  System.get("traceur-runtime@0.0.91/src/runtime/spread.js");
  System.get("traceur-runtime@0.0.91/src/runtime/destructuring.js");
  System.get("traceur-runtime@0.0.91/src/runtime/classes.js");
  System.get("traceur-runtime@0.0.91/src/runtime/async.js");
  System.get("traceur-runtime@0.0.91/src/runtime/generators.js");
  System.get("traceur-runtime@0.0.91/src/runtime/template.js");
  System.get("traceur-runtime@0.0.91/src/runtime/type-assertions.js");
  return {};
});
System.get("traceur-runtime@0.0.91/src/runtime/runtime-modules.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var toObject = $traceurRuntime.toObject;
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach(function(f) {
      return f(global);
    });
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Map.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      registerPolyfill = $__0.registerPolyfill;
  var $__10 = $traceurRuntime,
      getOwnHashObject = $__10.getOwnHashObject,
      hasNativeSymbol = $__10.hasNativeSymbol;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  var deletedSentinel = {};
  function lookupIndex(map, key) {
    if (isObject(key)) {
      var hashObject = getOwnHashObject(key);
      return hashObject && map.objectIndex_[hashObject.hash];
    }
    if (typeof key === 'string')
      return map.stringIndex_[key];
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.deletedCount_ = 0;
  }
  var Map = function() {
    function Map() {
      var $__12,
          $__13;
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Map called on incompatible type');
      if ($hasOwnProperty.call(this, 'entries_')) {
        throw new TypeError('Map can not be reentrantly initialised');
      }
      initMap(this);
      if (iterable !== null && iterable !== undefined) {
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (iterable)[$traceurRuntime.toProperty(Symbol.iterator)](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__11 = $__4.value,
                key = ($__12 = $__11[$traceurRuntime.toProperty(Symbol.iterator)](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
                value = ($__13 = $__12.next()).done ? void 0 : $__13.value;
            {
              this.set(key, value);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Map, {
      get size() {
        return this.entries_.length / 2 - this.deletedCount_;
      },
      get: function(key) {
        var index = lookupIndex(this, key);
        if (index !== undefined)
          return this.entries_[index + 1];
      },
      set: function(key, value) {
        var objectMode = isObject(key);
        var stringMode = typeof key === 'string';
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          this.entries_[index + 1] = value;
        } else {
          index = this.entries_.length;
          this.entries_[index] = key;
          this.entries_[index + 1] = value;
          if (objectMode) {
            var hashObject = getOwnHashObject(key);
            var hash = hashObject.hash;
            this.objectIndex_[hash] = index;
          } else if (stringMode) {
            this.stringIndex_[key] = index;
          } else {
            this.primitiveIndex_[key] = index;
          }
        }
        return this;
      },
      has: function(key) {
        return lookupIndex(this, key) !== undefined;
      },
      delete: function(key) {
        var objectMode = isObject(key);
        var stringMode = typeof key === 'string';
        var index;
        var hash;
        if (objectMode) {
          var hashObject = getOwnHashObject(key);
          if (hashObject) {
            index = this.objectIndex_[hash = hashObject.hash];
            delete this.objectIndex_[hash];
          }
        } else if (stringMode) {
          index = this.stringIndex_[key];
          delete this.stringIndex_[key];
        } else {
          index = this.primitiveIndex_[key];
          delete this.primitiveIndex_[key];
        }
        if (index !== undefined) {
          this.entries_[index] = deletedSentinel;
          this.entries_[index + 1] = undefined;
          this.deletedCount_++;
          return true;
        }
        return false;
      },
      clear: function() {
        initMap(this);
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        for (var i = 0; i < this.entries_.length; i += 2) {
          var key = this.entries_[i];
          var value = this.entries_[i + 1];
          if (key === deletedSentinel)
            continue;
          callbackFn.call(thisArg, value, key, this);
        }
      },
      entries: $traceurRuntime.initGeneratorFunction(function $__14() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return [key, value];
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__14, this);
      }),
      keys: $traceurRuntime.initGeneratorFunction(function $__15() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return key;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      }),
      values: $traceurRuntime.initGeneratorFunction(function $__16() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return value;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__16, this);
      })
    }, {});
  }();
  Object.defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function needsPolyfill(global) {
    var $__11 = global,
        Map = $__11.Map,
        Symbol = $__11.Symbol;
    if (!Map || !$traceurRuntime.hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {
      return true;
    }
    try {
      return new Map([[]]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillMap(global) {
    if (needsPolyfill(global)) {
      global.Map = Map;
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Map.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Set.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      registerPolyfill = $__0.registerPolyfill;
  var Map = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Map.js").Map;
  var getOwnHashObject = $traceurRuntime.getOwnHashObject;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  function initSet(set) {
    set.map_ = new Map();
  }
  var Set = function() {
    function Set() {
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Set called on incompatible type');
      if ($hasOwnProperty.call(this, 'map_')) {
        throw new TypeError('Set can not be reentrantly initialised');
      }
      initSet(this);
      if (iterable !== null && iterable !== undefined) {
        var $__8 = true;
        var $__9 = false;
        var $__10 = undefined;
        try {
          for (var $__6 = void 0,
              $__5 = (iterable)[$traceurRuntime.toProperty(Symbol.iterator)](); !($__8 = ($__6 = $__5.next()).done); $__8 = true) {
            var item = $__6.value;
            {
              this.add(item);
            }
          }
        } catch ($__11) {
          $__9 = true;
          $__10 = $__11;
        } finally {
          try {
            if (!$__8 && $__5.return != null) {
              $__5.return();
            }
          } finally {
            if ($__9) {
              throw $__10;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Set, {
      get size() {
        return this.map_.size;
      },
      has: function(key) {
        return this.map_.has(key);
      },
      add: function(key) {
        this.map_.set(key, key);
        return this;
      },
      delete: function(key) {
        return this.map_.delete(key);
      },
      clear: function() {
        return this.map_.clear();
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        var $__4 = this;
        return this.map_.forEach(function(value, key) {
          callbackFn.call(thisArg, key, key, $__4);
        });
      },
      values: $traceurRuntime.initGeneratorFunction(function $__13() {
        var $__14,
            $__15;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__14 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__15 = $__14[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__15.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__15.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__15.value;
              default:
                return $ctx.end();
            }
        }, $__13, this);
      }),
      entries: $traceurRuntime.initGeneratorFunction(function $__16() {
        var $__17,
            $__18;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__17 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__18 = $__17[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__18.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__18.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__18.value;
              default:
                return $ctx.end();
            }
        }, $__16, this);
      })
    }, {});
  }();
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function needsPolyfill(global) {
    var $__12 = global,
        Set = $__12.Set,
        Symbol = $__12.Symbol;
    if (!Set || !$traceurRuntime.hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {
      return true;
    }
    try {
      return new Set([1]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillSet(global) {
    if (needsPolyfill(global)) {
      global.Set = Set;
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Set.js" + '');
System.registerModule("traceur-runtime@0.0.91/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  var toString = {}.toString;
  var vertxNext;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var $__default = asap;
  var browserWindow = (typeof window !== 'undefined') ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    var nextTick = process.nextTick;
    var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
      nextTick = setImmediate;
    }
    return function() {
      nextTick(flush);
    };
  }
  function useVertxTimer() {
    return function() {
      vertxNext(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  function attemptVertex() {
    try {
      var r = require;
      var vertx = r('vertx');
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }
  var scheduleFlush;
  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && typeof require === 'function') {
    scheduleFlush = attemptVertex();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return $__default;
    }};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Promise.js";
  var async = System.get("traceur-runtime@0.0.91/node_modules/rsvp/lib/rsvp/asap.js").default;
  var registerPolyfill = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js").registerPolyfill;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: function(x) {
          promiseResolve(promise, x);
        },
        reject: function(r) {
          promiseReject(promise, r);
        }
      };
    } else {
      var result = {};
      result.promise = new C(function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      });
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function() {
    function Promise(resolver) {
      if (resolver === promiseRaw)
        return;
      if (typeof resolver !== 'function')
        throw new TypeError;
      var promise = promiseInit(this);
      try {
        resolver(function(x) {
          promiseResolve(promise, x);
        }, function(r) {
          promiseReject(promise, r);
        });
      } catch (e) {
        promiseReject(promise, e);
      }
    }
    return ($traceurRuntime.createClass)(Promise, {
      catch: function(onReject) {
        return this.then(undefined, onReject);
      },
      then: function(onResolve, onReject) {
        if (typeof onResolve !== 'function')
          onResolve = idResolveHandler;
        if (typeof onReject !== 'function')
          onReject = idRejectHandler;
        var that = this;
        var constructor = this.constructor;
        return chain(this, function(x) {
          x = promiseCoerce(constructor, x);
          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
        }, onReject);
      }
    }, {
      resolve: function(x) {
        if (this === $Promise) {
          if (isPromise(x)) {
            return x;
          }
          return promiseSet(new $Promise(promiseRaw), +1, x);
        } else {
          return new this(function(resolve, reject) {
            resolve(x);
          });
        }
      },
      reject: function(r) {
        if (this === $Promise) {
          return promiseSet(new $Promise(promiseRaw), -1, r);
        } else {
          return new this(function(resolve, reject) {
            reject(r);
          });
        }
      },
      all: function(values) {
        var deferred = getDeferred(this);
        var resolutions = [];
        try {
          var makeCountdownFunction = function(i) {
            return function(x) {
              resolutions[i] = x;
              if (--count === 0)
                deferred.resolve(resolutions);
            };
          };
          var count = 0;
          var i = 0;
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (values)[$traceurRuntime.toProperty(Symbol.iterator)](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var value = $__4.value;
              {
                var countdownFunction = makeCountdownFunction(i);
                this.resolve(value).then(countdownFunction, function(r) {
                  deferred.reject(r);
                });
                ++i;
                ++count;
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
          if (count === 0) {
            deferred.resolve(resolutions);
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      },
      race: function(values) {
        var deferred = getDeferred(this);
        try {
          for (var i = 0; i < values.length; i++) {
            this.resolve(values[i]).then(function(x) {
              deferred.resolve(x);
            }, function(r) {
              deferred.reject(r);
            });
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      }
    });
  }();
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async(function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    });
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = '@@thenable';
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        x[thenableSymbol] = promise;
        return promise;
      }
      if (typeof then === 'function') {
        var p = x[thenableSymbol];
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          x[thenableSymbol] = deferred.promise;
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Promise.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/StringIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      createIteratorResultObject = $__0.createIteratorResultObject,
      isObject = $__0.isObject;
  var toProperty = $traceurRuntime.toProperty;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function() {
    var $__3;
    function StringIterator() {}
    return ($traceurRuntime.createClass)(StringIterator, ($__3 = {}, Object.defineProperty($__3, "next", {
      value: function() {
        var o = this;
        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
          throw new TypeError('this must be a StringIterator object');
        }
        var s = o[toProperty(iteratedString)];
        if (s === undefined) {
          return createIteratorResultObject(undefined, true);
        }
        var position = o[toProperty(stringIteratorNextIndex)];
        var len = s.length;
        if (position >= len) {
          o[toProperty(iteratedString)] = undefined;
          return createIteratorResultObject(undefined, true);
        }
        var first = s.charCodeAt(position);
        var resultString;
        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
          resultString = String.fromCharCode(first);
        } else {
          var second = s.charCodeAt(position + 1);
          if (second < 0xDC00 || second > 0xDFFF) {
            resultString = String.fromCharCode(first);
          } else {
            resultString = String.fromCharCode(first) + String.fromCharCode(second);
          }
        }
        o[toProperty(stringIteratorNextIndex)] = position + resultString.length;
        return createIteratorResultObject(resultString, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__3, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__3), {});
  }();
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[toProperty(iteratedString)] = s;
    iterator[toProperty(stringIteratorNextIndex)] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/String.js";
  var createStringIterator = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/StringIterator.js").createStringIterator;
  var $__1 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint(_) {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = $traceurRuntime.checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/String.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/ArrayIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      toObject = $__0.toObject,
      toUint32 = $__0.toUint32,
      createIteratorResultObject = $__0.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function() {
    var $__3;
    function ArrayIterator() {}
    return ($traceurRuntime.createClass)(ArrayIterator, ($__3 = {}, Object.defineProperty($__3, "next", {
      value: function() {
        var iterator = toObject(this);
        var array = iterator.iteratorObject_;
        if (!array) {
          throw new TypeError('Object is not an ArrayIterator');
        }
        var index = iterator.arrayIteratorNextIndex_;
        var itemKind = iterator.arrayIterationKind_;
        var length = toUint32(array.length);
        if (index >= length) {
          iterator.arrayIteratorNextIndex_ = Infinity;
          return createIteratorResultObject(undefined, true);
        }
        iterator.arrayIteratorNextIndex_ = index + 1;
        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
          return createIteratorResultObject(array[index], false);
        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
          return createIteratorResultObject([index, array[index]], false);
        return createIteratorResultObject(index, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__3, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__3), {});
  }();
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Array.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/ArrayIterator.js"),
      entries = $__0.entries,
      keys = $__0.keys,
      jsValues = $__0.values;
  var $__1 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      checkIterable = $__1.checkIterable,
      isCallable = $__1.isCallable,
      isConstructor = $__1.isConstructor,
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger,
      toLength = $__1.toLength,
      toObject = $__1.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      var $__6 = true;
      var $__7 = false;
      var $__8 = undefined;
      try {
        for (var $__4 = void 0,
            $__3 = (items)[$traceurRuntime.toProperty(Symbol.iterator)](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
          var item = $__4.value;
          {
            if (mapping) {
              arr[k] = mapFn.call(thisArg, item, k);
            } else {
              arr[k] = item;
            }
            k++;
          }
        }
      } catch ($__9) {
        $__7 = true;
        $__8 = $__9;
      } finally {
        try {
          if (!$__6 && $__3.return != null) {
            $__3.return();
          }
        } finally {
          if ($__7) {
            throw $__8;
          }
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__10 = 0; $__10 < arguments.length; $__10++)
      items[$__10] = arguments[$__10];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__11 = global,
        Array = $__11.Array,
        Object = $__11.Object,
        Symbol = $__11.Symbol;
    var values = jsValues;
    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {
      values = Array.prototype[Symbol.iterator];
    }
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Array.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Object.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill;
  var $__2 = $traceurRuntime,
      defineProperty = $__2.defineProperty,
      getOwnPropertyDescriptor = $__2.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__2.getOwnPropertyNames,
      isPrivateName = $__2.isPrivateName,
      keys = $__2.keys;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p = void 0,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        if (isPrivateName(name))
          continue;
        target[name] = source[name];
      }
    }
    return target;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      if (isPrivateName(name))
        continue;
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get is() {
      return is;
    },
    get assign() {
      return assign;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Object.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Number.js";
  var $__0 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      isNumber = $__0.isNumber,
      maybeAddConsts = $__0.maybeAddConsts,
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill,
      toInteger = $__0.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Number.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/fround.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/fround.js";
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__1 = Math,
      LN2 = $__1.LN2,
      abs = $__1.abs,
      floor = $__1.floor,
      log = $__1.log,
      min = $__1.min,
      pow = $__1.pow;
  function packIEEE754(v, ebits, fbits) {
    var bias = (1 << (ebits - 1)) - 1,
        s,
        e,
        f,
        ln,
        i,
        bits,
        str,
        bytes;
    function roundToEven(n) {
      var w = floor(n),
          f = n - w;
      if (f < 0.5)
        return w;
      if (f > 0.5)
        return w + 1;
      return w % 2 ? w + 1 : w;
    }
    if (v !== v) {
      e = (1 << ebits) - 1;
      f = pow(2, fbits - 1);
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << ebits) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = abs(v);
      if (v >= pow(2, 1 - bias)) {
        e = min(floor(log(v) / LN2), 1023);
        f = roundToEven(v / pow(2, e) * pow(2, fbits));
        if (f / pow(2, fbits) >= 2) {
          e = e + 1;
          f = 1;
        }
        if (e > bias) {
          e = (1 << ebits) - 1;
          f = 0;
        } else {
          e = e + bias;
          f = f - pow(2, fbits);
        }
      } else {
        e = 0;
        f = roundToEven(v / pow(2, 1 - bias - fbits));
      }
    }
    bits = [];
    for (i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  }
  function unpackIEEE754(bytes, ebits, fbits) {
    var bits = [],
        i,
        j,
        b,
        str,
        bias,
        s,
        e,
        f;
    for (i = bytes.length; i; i -= 1) {
      b = bytes[i - 1];
      for (j = 8; j; j -= 1) {
        bits.push(b % 2 ? 1 : 0);
        b = b >> 1;
      }
    }
    bits.reverse();
    str = bits.join('');
    bias = (1 << (ebits - 1)) - 1;
    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    e = parseInt(str.substring(1, 1 + ebits), 2);
    f = parseInt(str.substring(1 + ebits), 2);
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    } else if (e > 0) {
      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
    } else if (f !== 0) {
      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
    } else {
      return s < 0 ? -0 : 0;
    }
  }
  function unpackF32(b) {
    return unpackIEEE754(b, 8, 23);
  }
  function packF32(v) {
    return packIEEE754(v, 8, 23);
  }
  function fround(x) {
    if (x === 0 || !$isFinite(x) || $isNaN(x)) {
      return x;
    }
    return unpackF32(packF32(Number(x)));
  }
  return {get fround() {
      return fround;
    }};
});
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/Math.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/Math.js";
  var jsFround = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/fround.js").fround;
  var $__1 = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__1.maybeAddFunctions,
      registerPolyfill = $__1.registerPolyfill,
      toUint32 = $__1.toUint32;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__3 = Math,
      abs = $__3.abs,
      ceil = $__3.ceil,
      exp = $__3.exp,
      floor = $__3.floor,
      log = $__3.log,
      pow = $__3.pow,
      sqrt = $__3.sqrt;
  function clz32(x) {
    x = toUint32(+x);
    if (x == 0)
      return 32;
    var result = 0;
    if ((x & 0xFFFF0000) === 0) {
      x <<= 16;
      result += 16;
    }
    ;
    if ((x & 0xFF000000) === 0) {
      x <<= 8;
      result += 8;
    }
    ;
    if ((x & 0xF0000000) === 0) {
      x <<= 4;
      result += 4;
    }
    ;
    if ((x & 0xC0000000) === 0) {
      x <<= 2;
      result += 2;
    }
    ;
    if ((x & 0x80000000) === 0) {
      x <<= 1;
      result += 1;
    }
    ;
    return result;
  }
  function imul(x, y) {
    x = toUint32(+x);
    y = toUint32(+y);
    var xh = (x >>> 16) & 0xffff;
    var xl = x & 0xffff;
    var yh = (y >>> 16) & 0xffff;
    var yl = y & 0xffff;
    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;
  }
  function sign(x) {
    x = +x;
    if (x > 0)
      return 1;
    if (x < 0)
      return -1;
    return x;
  }
  function log10(x) {
    return log(x) * 0.434294481903251828;
  }
  function log2(x) {
    return log(x) * 1.442695040888963407;
  }
  function log1p(x) {
    x = +x;
    if (x < -1 || $isNaN(x)) {
      return NaN;
    }
    if (x === 0 || x === Infinity) {
      return x;
    }
    if (x === -1) {
      return -Infinity;
    }
    var result = 0;
    var n = 50;
    if (x < 0 || x > 1) {
      return log(1 + x);
    }
    for (var i = 1; i < n; i++) {
      if ((i % 2) === 0) {
        result -= pow(x, i) / i;
      } else {
        result += pow(x, i) / i;
      }
    }
    return result;
  }
  function expm1(x) {
    x = +x;
    if (x === -Infinity) {
      return -1;
    }
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return exp(x) - 1;
  }
  function cosh(x) {
    x = +x;
    if (x === 0) {
      return 1;
    }
    if ($isNaN(x)) {
      return NaN;
    }
    if (!$isFinite(x)) {
      return Infinity;
    }
    if (x < 0) {
      x = -x;
    }
    if (x > 21) {
      return exp(x) / 2;
    }
    return (exp(x) + exp(-x)) / 2;
  }
  function sinh(x) {
    x = +x;
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  }
  function tanh(x) {
    x = +x;
    if (x === 0)
      return x;
    if (!$isFinite(x))
      return sign(x);
    var exp1 = exp(x);
    var exp2 = exp(-x);
    return (exp1 - exp2) / (exp1 + exp2);
  }
  function acosh(x) {
    x = +x;
    if (x < 1)
      return NaN;
    if (!$isFinite(x))
      return x;
    return log(x + sqrt(x + 1) * sqrt(x - 1));
  }
  function asinh(x) {
    x = +x;
    if (x === 0 || !$isFinite(x))
      return x;
    if (x > 0)
      return log(x + sqrt(x * x + 1));
    return -log(-x + sqrt(x * x + 1));
  }
  function atanh(x) {
    x = +x;
    if (x === -1) {
      return -Infinity;
    }
    if (x === 1) {
      return Infinity;
    }
    if (x === 0) {
      return x;
    }
    if ($isNaN(x) || x < -1 || x > 1) {
      return NaN;
    }
    return 0.5 * log((1 + x) / (1 - x));
  }
  function hypot(x, y) {
    var length = arguments.length;
    var args = new Array(length);
    var max = 0;
    for (var i = 0; i < length; i++) {
      var n = arguments[i];
      n = +n;
      if (n === Infinity || n === -Infinity)
        return Infinity;
      n = abs(n);
      if (n > max)
        max = n;
      args[i] = n;
    }
    if (max === 0)
      max = 1;
    var sum = 0;
    var compensation = 0;
    for (var i = 0; i < length; i++) {
      var n = args[i] / max;
      var summand = n * n - compensation;
      var preliminary = sum + summand;
      compensation = (preliminary - sum) - summand;
      sum = preliminary;
    }
    return sqrt(sum) * max;
  }
  function trunc(x) {
    x = +x;
    if (x > 0)
      return floor(x);
    if (x < 0)
      return ceil(x);
    return x;
  }
  var fround,
      f32;
  if (typeof Float32Array === 'function') {
    f32 = new Float32Array(1);
    fround = function(x) {
      f32[0] = Number(x);
      return f32[0];
    };
  } else {
    fround = jsFround;
  }
  function cbrt(x) {
    x = +x;
    if (x === 0)
      return x;
    var negate = x < 0;
    if (negate)
      x = -x;
    var result = pow(x, 1 / 3);
    return negate ? -result : result;
  }
  function polyfillMath(global) {
    var Math = global.Math;
    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);
  }
  registerPolyfill(polyfillMath);
  return {
    get clz32() {
      return clz32;
    },
    get imul() {
      return imul;
    },
    get sign() {
      return sign;
    },
    get log10() {
      return log10;
    },
    get log2() {
      return log2;
    },
    get log1p() {
      return log1p;
    },
    get expm1() {
      return expm1;
    },
    get cosh() {
      return cosh;
    },
    get sinh() {
      return sinh;
    },
    get tanh() {
      return tanh;
    },
    get acosh() {
      return acosh;
    },
    get asinh() {
      return asinh;
    },
    get atanh() {
      return atanh;
    },
    get hypot() {
      return hypot;
    },
    get trunc() {
      return trunc;
    },
    get fround() {
      return fround;
    },
    get cbrt() {
      return cbrt;
    },
    get polyfillMath() {
      return polyfillMath;
    }
  };
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/Math.js" + '');
System.registerModule("traceur-runtime@0.0.91/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.91/src/runtime/polyfills/polyfills.js";
  var polyfillAll = System.get("traceur-runtime@0.0.91/src/runtime/polyfills/utils.js").polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
System.get("traceur-runtime@0.0.91/src/runtime/polyfills/polyfills.js" + '');

/*
 *  es6-module-loader v0.17.6
 *  https://github.com/ModuleLoader/es6-module-loader
 *  Copyright (c) 2015 Guy Bedford, Luke Hoban, Addy Osmani; Licensed MIT
 */

!function(a){function b(a,c){if("string"!=typeof a)throw new TypeError("URL must be a string");var d=String(a).replace(/^\s+|\s+$/g,"").match(/^([^:\/?#]+:)?(?:\/\/(?:([^:@\/?#]*)(?::([^:@\/?#]*))?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);if(!d)throw new RangeError;var e=d[1]||"",f=d[2]||"",g=d[3]||"",h=d[4]||"",i=d[5]||"",j=d[6]||"",k=d[7]||"",l=d[8]||"",m=d[9]||"";if(void 0!==c){var n=c instanceof b?c:new b(c),o=""===e&&""===h&&""===f;o&&""===k&&""===l&&(l=n.search),o&&"/"!==k.charAt(0)&&(k=""!==k?(""===n.host&&""===n.username||""!==n.pathname?"":"/")+n.pathname.slice(0,n.pathname.lastIndexOf("/")+1)+k:n.pathname);var p=[];k.replace(/^(\.\.?(\/|$))+/,"").replace(/\/(\.(\/|$))+/g,"/").replace(/\/\.\.$/,"/../").replace(/\/?[^\/]*/g,function(a){"/.."===a?p.pop():p.push(a)}),k=p.join("").replace(/^\//,"/"===k.charAt(0)?"/":""),o&&(j=n.port,i=n.hostname,h=n.host,g=n.password,f=n.username),""===e&&(e=n.protocol)}"file:"==e&&(k=k.replace(/\\/g,"/")),this.origin=e+(""!==e||""!==h?"//":"")+h,this.href=e+(""!==e||""!==h?"//":"")+(""!==f?f+(""!==g?":"+g:"")+"@":"")+h+k+l+m,this.protocol=e,this.username=f,this.password=g,this.host=h,this.hostname=i,this.port=j,this.pathname=k,this.search=l,this.hash=m}a.URLPolyfill=b}("undefined"!=typeof self?self:global),function(a){function b(a,b){var c;if(a instanceof Error){var c=new Error(a.message,a.fileName,a.lineNumber);i?(c.message=a.message+"\n	"+b,c.stack=a.stack):(c.message=a.message,c.stack=a.stack+"\n	"+b)}else c=a+"\n	"+b;return c}function c(a,c,d){try{new Function(a).call(d)}catch(e){throw b(e,"Evaluating "+c)}}function d(){}function e(){this._loader={loaderObj:this,loads:[],modules:{},importPromises:{},moduleRecords:{}},k(this,"global",{get:function(){return a}})}function f(){e.call(this),this.paths={}}function g(a,b){var c,d="",e=0;for(var f in a){var g=f.split("*");if(g.length>2)throw new TypeError("Only one wildcard in a path is permitted");if(1==g.length){if(b==f){d=f;break}}else{var h=f.split("/").length;h>=e&&b.substr(0,g[0].length)==g[0]&&b.substr(b.length-g[1].length)==g[1]&&(e=h,d=f,c=b.substr(g[0].length,b.length-g[1].length-g[0].length))}}var i=a[d]||b;return c&&(i=i.replace("*",c)),i}function h(){}var i=("undefined"==typeof window&&"undefined"!=typeof self&&"undefined"!=typeof importScripts,"undefined"!=typeof window&&"undefined"!=typeof document),j="undefined"!=typeof process&&!!process.platform.match(/^win/);a.console||(a.console={assert:function(){}});var k,l=Array.prototype.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1};!function(){try{Object.defineProperty({},"a",{})&&(k=Object.defineProperty)}catch(a){k=function(a,b,c){try{a[b]=c.value||c.get.call(a)}catch(d){}}}}();var m;if("undefined"!=typeof document&&document.getElementsByTagName){if(m=document.baseURI,!m){var n=document.getElementsByTagName("base");m=n[0]&&n[0].href||window.location.href}m=m.split("#")[0].split("?")[0],m=m.substr(0,m.lastIndexOf("/")+1)}else if("undefined"!=typeof process&&process.cwd)m="file://"+(j?"/":"")+process.cwd()+"/",j&&(m=m.replace(/\\/g,"/"));else{if("undefined"==typeof location)throw new TypeError("No environment baseURI");m=a.location.href}var o=a.URLPolyfill||a.URL;k(d.prototype,"toString",{value:function(){return"Module"}}),function(){function f(a){return{status:"loading",name:a,linkSets:[],dependencies:[],metadata:{}}}function g(a,b,c){return new Promise(n({step:c.address?"fetch":"locate",loader:a,moduleName:b,moduleMetadata:c&&c.metadata||{},moduleSource:c.source,moduleAddress:c.address}))}function h(a,b,c,d){return new Promise(function(e){e(a.loaderObj.normalize(b,c,d))}).then(function(b){var c;if(a.modules[b])return c=f(b),c.status="linked",c.module=a.modules[b],c;for(var d=0,e=a.loads.length;e>d;d++)if(c=a.loads[d],c.name==b)return c;return c=f(b),a.loads.push(c),i(a,c),c})}function i(a,b){j(a,b,Promise.resolve().then(function(){return a.loaderObj.locate({name:b.name,metadata:b.metadata})}))}function j(a,b,c){m(a,b,c.then(function(c){return"loading"==b.status?(b.address=c,a.loaderObj.fetch({name:b.name,metadata:b.metadata,address:c})):void 0}))}function m(b,d,e){e.then(function(e){return"loading"==d.status?Promise.resolve(b.loaderObj.translate({name:d.name,metadata:d.metadata,address:d.address,source:e})).then(function(a){return d.source=a,b.loaderObj.instantiate({name:d.name,metadata:d.metadata,address:d.address,source:a})}).then(function(e){if(void 0===e)return d.address=d.address||"<Anonymous Module "+ ++A+">",d.isDeclarative=!0,z.call(b.loaderObj,d).then(function(b){var e=a.System,f=e.register;e.register=function(a,b,c){"string"!=typeof a&&(c=b,b=a),d.declare=c,d.depsList=b},c(b,d.address,{}),e.register=f});if("object"!=typeof e)throw TypeError("Invalid instantiate return value");d.depsList=e.deps||[],d.execute=e.execute,d.isDeclarative=!1}).then(function(){d.dependencies=[];for(var a=d.depsList,c=[],e=0,f=a.length;f>e;e++)(function(a,e){c.push(h(b,a,d.name,d.address).then(function(b){if(d.dependencies[e]={key:a,value:b.name},"linked"!=b.status)for(var c=d.linkSets.concat([]),f=0,g=c.length;g>f;f++)p(c[f],b)}))})(a[e],e);return Promise.all(c)}).then(function(){d.status="loaded";for(var a=d.linkSets.concat([]),b=0,c=a.length;c>b;b++)r(a[b],d)}):void 0})["catch"](function(a){d.status="failed",d.exception=a;for(var b=d.linkSets.concat([]),c=0,e=b.length;e>c;c++)s(b[c],d,a)})}function n(a){return function(b){var c=a.loader,d=a.moduleName,e=a.step;if(c.modules[d])throw new TypeError('"'+d+'" already exists in the module table');for(var g,h=0,k=c.loads.length;k>h;h++)if(c.loads[h].name==d&&(g=c.loads[h],"translate"!=e||g.source||(g.address=a.moduleAddress,m(c,g,Promise.resolve(a.moduleSource))),g.linkSets.length))return g.linkSets[0].done.then(function(){b(g)});var l=g||f(d);l.metadata=a.moduleMetadata;var n=o(c,l);c.loads.push(l),b(n.done),"locate"==e?i(c,l):"fetch"==e?j(c,l,Promise.resolve(a.moduleAddress)):(l.address=a.moduleAddress,m(c,l,Promise.resolve(a.moduleSource)))}}function o(a,b){var c={loader:a,loads:[],startingLoad:b,loadingCount:0};return c.done=new Promise(function(a,b){c.resolve=a,c.reject=b}),p(c,b),c}function p(a,b){if("failed"!=b.status){for(var c=0,d=a.loads.length;d>c;c++)if(a.loads[c]==b)return;a.loads.push(b),b.linkSets.push(a),"loaded"!=b.status&&a.loadingCount++;for(var e=a.loader,c=0,d=b.dependencies.length;d>c;c++)if(b.dependencies[c]){var f=b.dependencies[c].value;if(!e.modules[f])for(var g=0,h=e.loads.length;h>g;g++)if(e.loads[g].name==f){p(a,e.loads[g]);break}}}}function q(a){var b=!1;try{w(a,function(c,d){s(a,c,d),b=!0})}catch(c){s(a,null,c),b=!0}return b}function r(a,b){if(a.loadingCount--,!(a.loadingCount>0)){var c=a.startingLoad;if(a.loader.loaderObj.execute===!1){for(var d=[].concat(a.loads),e=0,f=d.length;f>e;e++){var b=d[e];b.module=b.isDeclarative?{name:b.name,module:B({}),evaluated:!0}:{module:B({})},b.status="linked",t(a.loader,b)}return a.resolve(c)}var g=q(a);g||a.resolve(c)}}function s(a,c,d){var e=a.loader;a:if(c)if(a.loads[0].name==c.name)d=b(d,"Error loading "+c.name);else{for(var f=0;f<a.loads.length;f++)for(var g=a.loads[f],h=0;h<g.dependencies.length;h++){var i=g.dependencies[h];if(i.value==c.name){d=b(d,"Error loading "+c.name+' as "'+i.key+'" from '+g.name);break a}}d=b(d,"Error loading "+c.name+" from "+a.loads[0].name)}else d=b(d,"Error linking "+a.loads[0].name);for(var j=a.loads.concat([]),f=0,k=j.length;k>f;f++){var c=j[f];e.loaderObj.failed=e.loaderObj.failed||[],-1==l.call(e.loaderObj.failed,c)&&e.loaderObj.failed.push(c);var m=l.call(c.linkSets,a);if(c.linkSets.splice(m,1),0==c.linkSets.length){var n=l.call(a.loader.loads,c);-1!=n&&a.loader.loads.splice(n,1)}}a.reject(d)}function t(a,b){if(a.loaderObj.trace){a.loaderObj.loads||(a.loaderObj.loads={});var c={};b.dependencies.forEach(function(a){c[a.key]=a.value}),a.loaderObj.loads[b.name]={name:b.name,deps:b.dependencies.map(function(a){return a.key}),depMap:c,address:b.address,metadata:b.metadata,source:b.source,kind:b.isDeclarative?"declarative":"dynamic"}}b.name&&(a.modules[b.name]=b.module);var d=l.call(a.loads,b);-1!=d&&a.loads.splice(d,1);for(var e=0,f=b.linkSets.length;f>e;e++)d=l.call(b.linkSets[e].loads,b),-1!=d&&b.linkSets[e].loads.splice(d,1);b.linkSets.splice(0,b.linkSets.length)}function u(a,b,c){try{var e=b.execute()}catch(f){return void c(b,f)}return e&&e instanceof d?e:void c(b,new TypeError("Execution must define a Module instance"))}function v(a,b,c){var d=a._loader.importPromises;return d[b]=c.then(function(a){return d[b]=void 0,a},function(a){throw d[b]=void 0,a})}function w(a,b){var c=a.loader;if(a.loads.length)for(var d=a.loads.concat([]),e=0;e<d.length;e++){var f=d[e],g=u(a,f,b);if(!g)return;f.module={name:f.name,module:g},f.status="linked",t(c,f)}}function x(a,b){return b.module.module}function y(){}function z(){throw new TypeError("ES6 transpilation is only provided in the dev module loader build.")}var A=0;e.prototype={constructor:e,define:function(a,b,c){if(this._loader.importPromises[a])throw new TypeError("Module is already loading.");return v(this,a,new Promise(n({step:"translate",loader:this._loader,moduleName:a,moduleMetadata:c&&c.metadata||{},moduleSource:b,moduleAddress:c&&c.address})))},"delete":function(a){var b=this._loader;return delete b.importPromises[a],delete b.moduleRecords[a],b.modules[a]?delete b.modules[a]:!1},get:function(a){return this._loader.modules[a]?(y(this._loader.modules[a],[],this),this._loader.modules[a].module):void 0},has:function(a){return!!this._loader.modules[a]},"import":function(a,b){"object"==typeof b&&(b=b.name);var c=this;return Promise.resolve(c.normalize(a,b)).then(function(a){var b=c._loader;return b.modules[a]?(y(b.modules[a],[],b._loader),b.modules[a].module):b.importPromises[a]||v(c,a,g(b,a,{}).then(function(c){return delete b.importPromises[a],x(b,c)}))})},load:function(a){var b=this._loader;return b.modules[a]?(y(b.modules[a],[],b),Promise.resolve(b.modules[a].module)):b.importPromises[a]||v(this,a,g(b,a,{}).then(function(c){return delete b.importPromises[a],x(b,c)}))},module:function(a,b){var c=f();c.address=b&&b.address;var d=o(this._loader,c),e=Promise.resolve(a),g=this._loader,h=d.done.then(function(){return x(g,c)});return m(g,c,e),h},newModule:function(a){if("object"!=typeof a)throw new TypeError("Expected object");var b,c=new d;if(Object.getOwnPropertyNames&&null!=a)b=Object.getOwnPropertyNames(a);else{b=[];for(var e in a)b.push(e)}for(var f=0;f<b.length;f++)(function(b){k(c,b,{configurable:!1,enumerable:!0,get:function(){return a[b]}})})(b[f]);return Object.preventExtensions&&Object.preventExtensions(c),c},set:function(a,b){if(!(b instanceof d))throw new TypeError("Loader.set("+a+", module) must be a module");this._loader.modules[a]={module:b}},normalize:function(a){return a},locate:function(a){return a.name},fetch:function(){},translate:function(a){return a.source},instantiate:function(){}};var B=e.prototype.newModule}();var p;h.prototype=e.prototype,f.prototype=new h;var q=/^([^\/]+:\/\/|\/)/;f.prototype.normalize=function(a,b){return a=a.match(q)||"."==a[0]?new o(a,b||m).href:new o(g(this.paths,a),m).href},f.prototype.locate=function(a){return a.name},f.prototype.instantiate=function(b){var d=this;return Promise.resolve(d.normalize(d.transpiler)).then(function(e){return b.address===e?{deps:[],execute:function(){var e=a.System,f=a.Reflect.Loader;return c("(function(require,exports,module){"+b.source+"})();",b.address,a),a.System=e,a.Reflect.Loader=f,d.newModule({"default":a[d.transpiler],__useDefault:!0})}}:void 0})};var r;if("undefined"!=typeof XMLHttpRequest)r=function(a,b,c){function d(){b(f.responseText)}function e(){c(new Error("XHR error"+(f.status?" ("+f.status+(f.statusText?" "+f.statusText:"")+")":"")+" loading "+a))}var f=new XMLHttpRequest,g=!0,h=!1;if(!("withCredentials"in f)){var i=/^(\w+:)?\/\/([^\/]+)/.exec(a);i&&(g=i[2]===window.location.host,i[1]&&(g&=i[1]===window.location.protocol))}g||"undefined"==typeof XDomainRequest||(f=new XDomainRequest,f.onload=d,f.onerror=e,f.ontimeout=e,f.onprogress=function(){},f.timeout=0,h=!0),f.onreadystatechange=function(){4===f.readyState&&(200===f.status||0==f.status&&f.responseText?d():e())},f.open("GET",a,!0),f.setRequestHeader&&f.setRequestHeader("Accept","application/x-es-module */*"),h&&setTimeout(function(){f.send()},0),f.send(null)};else{if("undefined"==typeof require)throw new TypeError("No environment fetch API available.");var s;r=function(a,b,c){if("file:///"!=a.substr(0,8))throw new Error('Unable to fetch "'+a+'". Only file URLs of the form file:/// allowed running in Node.');return s=s||require("fs"),a=j?a.replace(/\//g,"\\").substr(8):a.substr(7),s.readFile(a,function(a,d){if(a)return c(a);var e=d+"";"\ufeff"===e[0]&&(e=e.substr(1)),b(e)})}}f.prototype.fetch=function(a){return new Promise(function(b,c){r(a.address,b,c)})},"object"==typeof exports&&(module.exports=e),a.Reflect=a.Reflect||{},a.Reflect.Loader=a.Reflect.Loader||e,a.Reflect.global=a.Reflect.global||a,a.LoaderPolyfill=e,p||(p=new f,p.constructor=f),"object"==typeof exports&&(module.exports=p),a.System=p}("undefined"!=typeof self?self:global);
//# sourceMappingURL=es6-module-loader.js.map
/*
 * SystemJS v0.18.10
 */
!function(){function e(){!function(e){function t(e,t){var n;if(e instanceof Error){var n=new Error(e.message,e.fileName,e.lineNumber);b?(n.message=e.message+"\n	"+t,n.stack=e.stack):(n.message=e.message,n.stack=e.stack+"\n	"+t)}else n=e+"\n	"+t;return n}function n(e,n,a){try{new Function(e).call(a)}catch(r){throw t(r,"Evaluating "+n)}}function a(){}function r(t){this._loader={loaderObj:this,loads:[],modules:{},importPromises:{},moduleRecords:{}},x(this,"global",{get:function(){return e}})}function o(){r.call(this),this.paths={}}function s(e,t){var n,a="",r=0;for(var o in e){var s=o.split("*");if(s.length>2)throw new TypeError("Only one wildcard in a path is permitted");if(1==s.length){if(t==o){a=o;break}}else{var i=o.split("/").length;i>=r&&t.substr(0,s[0].length)==s[0]&&t.substr(t.length-s[1].length)==s[1]&&(r=i,a=o,n=t.substr(s[0].length,t.length-s[1].length-s[0].length))}}var l=e[a]||t;return n&&(l=l.replace("*",n)),l}function i(){}function l(){o.call(this),O.call(this)}function u(){}function d(e,t){l.prototype[e]=t(l.prototype[e])}function c(e){O=e(O||function(){})}function f(e){for(var t=[],n=[],a=0,r=e.length;r>a;a++){var o=w.call(t,e[a]);-1===o?(t.push(e[a]),n.push([a])):n[o].push(a)}return{names:t,indices:n}}function m(e,t,n){for(var a in t)n&&a in e||(e[a]=t[a]);return e}function p(e,t,n){for(var a in t){var r=t[a];a in e?r instanceof Array&&e[a]instanceof Array?e[a]=[].concat(n?r:e[a]).concat(n?e[a]:r):"object"==typeof r&&"object"==typeof e[a]?e[a]=m(m({},e[a]),r,n):n||(e[a]=r):e[a]=r}}function h(e,t){for(var n=e.split(".");n.length;)t=t[n.shift()];return t}function v(){if(T[this.baseURL])return T[this.baseURL];"/"!=this.baseURL[this.baseURL.length-1]&&(this.baseURL+="/");var e=new _(this.baseURL,S);return this.baseURL=e.href,T[this.baseURL]=e}var g="undefined"==typeof window&&"undefined"!=typeof self&&"undefined"!=typeof importScripts,b="undefined"!=typeof window&&"undefined"!=typeof document,y="undefined"!=typeof process&&!!process.platform.match(/^win/);e.console||(e.console={assert:function(){}});var x,w=Array.prototype.indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(this[t]===e)return t;return-1};!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,t,n){try{e[t]=n.value||n.get.call(e)}catch(a){}}}}();var S;if("undefined"!=typeof document&&document.getElementsByTagName){if(S=document.baseURI,!S){var E=document.getElementsByTagName("base");S=E[0]&&E[0].href||window.location.href}S=S.split("#")[0].split("?")[0],S=S.substr(0,S.lastIndexOf("/")+1)}else if("undefined"!=typeof process&&process.cwd)S="file://"+(y?"/":"")+process.cwd()+"/",y&&(S=S.replace(/\\/g,"/"));else{if("undefined"==typeof location)throw new TypeError("No environment baseURI");S=e.location.href}var _=e.URLPolyfill||e.URL;x(a.prototype,"toString",{value:function(){return"Module"}}),function(){function o(e){return{status:"loading",name:e,linkSets:[],dependencies:[],metadata:{}}}function s(e,t,n){return new Promise(c({step:n.address?"fetch":"locate",loader:e,moduleName:t,moduleMetadata:n&&n.metadata||{},moduleSource:n.source,moduleAddress:n.address}))}function i(e,t,n,a){return new Promise(function(r,o){r(e.loaderObj.normalize(t,n,a))}).then(function(t){var n;if(e.modules[t])return n=o(t),n.status="linked",n.module=e.modules[t],n;for(var a=0,r=e.loads.length;r>a;a++)if(n=e.loads[a],n.name==t)return n;return n=o(t),e.loads.push(n),l(e,n),n})}function l(e,t){u(e,t,Promise.resolve().then(function(){return e.loaderObj.locate({name:t.name,metadata:t.metadata})}))}function u(e,t,n){d(e,t,n.then(function(n){return"loading"==t.status?(t.address=n,e.loaderObj.fetch({name:t.name,metadata:t.metadata,address:n})):void 0}))}function d(t,a,r){r.then(function(r){return"loading"==a.status?Promise.resolve(t.loaderObj.translate({name:a.name,metadata:a.metadata,address:a.address,source:r})).then(function(e){return a.source=e,t.loaderObj.instantiate({name:a.name,metadata:a.metadata,address:a.address,source:e})}).then(function(r){if(void 0===r)return a.address=a.address||"<Anonymous Module "+ ++M+">",a.isDeclarative=!0,j.call(t.loaderObj,a).then(function(t){var r=e.System,o=r.register;r.register=function(e,t,n){"string"!=typeof e&&(n=t,t=e),a.declare=n,a.depsList=t},n(t,a.address,{}),r.register=o});if("object"!=typeof r)throw TypeError("Invalid instantiate return value");a.depsList=r.deps||[],a.execute=r.execute,a.isDeclarative=!1}).then(function(){a.dependencies=[];for(var e=a.depsList,n=[],r=0,o=e.length;o>r;r++)(function(e,r){n.push(i(t,e,a.name,a.address).then(function(t){if(a.dependencies[r]={key:e,value:t.name},"linked"!=t.status)for(var n=a.linkSets.concat([]),o=0,s=n.length;s>o;o++)m(n[o],t)}))})(e[r],r);return Promise.all(n)}).then(function(){a.status="loaded";for(var e=a.linkSets.concat([]),t=0,n=e.length;n>t;t++)h(e[t],a)}):void 0})["catch"](function(e){a.status="failed",a.exception=e;for(var t=a.linkSets.concat([]),n=0,r=t.length;r>n;n++)v(t[n],a,e)})}function c(e){return function(t,n){var a=e.loader,r=e.moduleName,s=e.step;if(a.modules[r])throw new TypeError('"'+r+'" already exists in the module table');for(var i,c=0,m=a.loads.length;m>c;c++)if(a.loads[c].name==r&&(i=a.loads[c],"translate"!=s||i.source||(i.address=e.moduleAddress,d(a,i,Promise.resolve(e.moduleSource))),i.linkSets.length))return i.linkSets[0].done.then(function(){t(i)});var p=i||o(r);p.metadata=e.moduleMetadata;var h=f(a,p);a.loads.push(p),t(h.done),"locate"==s?l(a,p):"fetch"==s?u(a,p,Promise.resolve(e.moduleAddress)):(p.address=e.moduleAddress,d(a,p,Promise.resolve(e.moduleSource)))}}function f(e,t){var n={loader:e,loads:[],startingLoad:t,loadingCount:0};return n.done=new Promise(function(e,t){n.resolve=e,n.reject=t}),m(n,t),n}function m(e,t){if("failed"!=t.status){for(var n=0,a=e.loads.length;a>n;n++)if(e.loads[n]==t)return;e.loads.push(t),t.linkSets.push(e),"loaded"!=t.status&&e.loadingCount++;for(var r=e.loader,n=0,a=t.dependencies.length;a>n;n++)if(t.dependencies[n]){var o=t.dependencies[n].value;if(!r.modules[o])for(var s=0,i=r.loads.length;i>s;s++)if(r.loads[s].name==o){m(e,r.loads[s]);break}}}}function p(e){var t=!1;try{S(e,function(n,a){v(e,n,a),t=!0})}catch(n){v(e,null,n),t=!0}return t}function h(e,t){if(e.loadingCount--,!(e.loadingCount>0)){var n=e.startingLoad;if(e.loader.loaderObj.execute===!1){for(var a=[].concat(e.loads),r=0,o=a.length;o>r;r++){var t=a[r];t.module=t.isDeclarative?{name:t.name,module:D({}),evaluated:!0}:{module:D({})},t.status="linked",g(e.loader,t)}return e.resolve(n)}var s=p(e);s||e.resolve(n)}}function v(e,n,a){var r=e.loader;e:if(n)if(e.loads[0].name==n.name)a=t(a,"Error loading "+n.name);else{for(var o=0;o<e.loads.length;o++)for(var s=e.loads[o],i=0;i<s.dependencies.length;i++){var l=s.dependencies[i];if(l.value==n.name){a=t(a,"Error loading "+n.name+' as "'+l.key+'" from '+s.name);break e}}a=t(a,"Error loading "+n.name+" from "+e.loads[0].name)}else a=t(a,"Error linking "+e.loads[0].name);for(var u=e.loads.concat([]),o=0,d=u.length;d>o;o++){var n=u[o];r.loaderObj.failed=r.loaderObj.failed||[],-1==w.call(r.loaderObj.failed,n)&&r.loaderObj.failed.push(n);var c=w.call(n.linkSets,e);if(n.linkSets.splice(c,1),0==n.linkSets.length){var f=w.call(e.loader.loads,n);-1!=f&&e.loader.loads.splice(f,1)}}e.reject(a)}function g(e,t){if(e.loaderObj.trace){e.loaderObj.loads||(e.loaderObj.loads={});var n={};t.dependencies.forEach(function(e){n[e.key]=e.value}),e.loaderObj.loads[t.name]={name:t.name,deps:t.dependencies.map(function(e){return e.key}),depMap:n,address:t.address,metadata:t.metadata,source:t.source,kind:t.isDeclarative?"declarative":"dynamic"}}t.name&&(e.modules[t.name]=t.module);var a=w.call(e.loads,t);-1!=a&&e.loads.splice(a,1);for(var r=0,o=t.linkSets.length;o>r;r++)a=w.call(t.linkSets[r].loads,t),-1!=a&&t.linkSets[r].loads.splice(a,1);t.linkSets.splice(0,t.linkSets.length)}function b(e,t,n){try{var r=t.execute()}catch(o){return void n(t,o)}return r&&r instanceof a?r:void n(t,new TypeError("Execution must define a Module instance"))}function y(e,t,n){var a=e._loader.importPromises;return a[t]=n.then(function(e){return a[t]=void 0,e},function(e){throw a[t]=void 0,e})}function S(e,t){var n=e.loader;if(e.loads.length)for(var a=e.loads.concat([]),r=0;r<a.length;r++){var o=a[r],s=b(e,o,t);if(!s)return;o.module={name:o.name,module:s},o.status="linked",g(n,o)}}function E(e,t){return t.module.module}function _(){}function j(){throw new TypeError("ES6 transpilation is only provided in the dev module loader build.")}var M=0;r.prototype={constructor:r,define:function(e,t,n){if(this._loader.importPromises[e])throw new TypeError("Module is already loading.");return y(this,e,new Promise(c({step:"translate",loader:this._loader,moduleName:e,moduleMetadata:n&&n.metadata||{},moduleSource:t,moduleAddress:n&&n.address})))},"delete":function(e){var t=this._loader;return delete t.importPromises[e],delete t.moduleRecords[e],t.modules[e]?delete t.modules[e]:!1},get:function(e){return this._loader.modules[e]?(_(this._loader.modules[e],[],this),this._loader.modules[e].module):void 0},has:function(e){return!!this._loader.modules[e]},"import":function(e,t,n){"object"==typeof t&&(t=t.name);var a=this;return Promise.resolve(a.normalize(e,t)).then(function(e){var t=a._loader;return t.modules[e]?(_(t.modules[e],[],t._loader),t.modules[e].module):t.importPromises[e]||y(a,e,s(t,e,{}).then(function(n){return delete t.importPromises[e],E(t,n)}))})},load:function(e,t){var n=this._loader;return n.modules[e]?(_(n.modules[e],[],n),Promise.resolve(n.modules[e].module)):n.importPromises[e]||y(this,e,s(n,e,{}).then(function(t){return delete n.importPromises[e],E(n,t)}))},module:function(e,t){var n=o();n.address=t&&t.address;var a=f(this._loader,n),r=Promise.resolve(e),s=this._loader,i=a.done.then(function(){return E(s,n)});return d(s,n,r),i},newModule:function(e){if("object"!=typeof e)throw new TypeError("Expected object");var t,n=new a;if(Object.getOwnPropertyNames&&null!=e)t=Object.getOwnPropertyNames(e);else{t=[];for(var r in e)t.push(r)}for(var o=0;o<t.length;o++)(function(t){x(n,t,{configurable:!1,enumerable:!0,get:function(){return e[t]}})})(t[o]);return Object.preventExtensions&&Object.preventExtensions(n),n},set:function(e,t){if(!(t instanceof a))throw new TypeError("Loader.set("+e+", module) must be a module");this._loader.modules[e]={module:t}},normalize:function(e,t,n){return e},locate:function(e){return e.name},fetch:function(e){},translate:function(e){return e.source},instantiate:function(e){}};var D=r.prototype.newModule}();var j;i.prototype=r.prototype,o.prototype=new i;var M;if("undefined"!=typeof XMLHttpRequest)M=function(e,t,n){function a(){t(o.responseText)}function r(){n(new Error("XHR error"+(o.status?" ("+o.status+(o.statusText?" "+o.statusText:"")+")":"")+" loading "+e))}var o=new XMLHttpRequest,s=!0,i=!1;if(!("withCredentials"in o)){var l=/^(\w+:)?\/\/([^\/]+)/.exec(e);l&&(s=l[2]===window.location.host,l[1]&&(s&=l[1]===window.location.protocol))}s||"undefined"==typeof XDomainRequest||(o=new XDomainRequest,o.onload=a,o.onerror=r,o.ontimeout=r,o.onprogress=function(){},o.timeout=0,i=!0),o.onreadystatechange=function(){4===o.readyState&&(200===o.status||0==o.status&&o.responseText?a():r())},o.open("GET",e,!0),o.setRequestHeader&&o.setRequestHeader("Accept","application/x-es-module */*"),i&&setTimeout(function(){o.send()},0),o.send(null)};else{if("undefined"==typeof require)throw new TypeError("No environment fetch API available.");var D;M=function(e,t,n){if("file:///"!=e.substr(0,8))throw new Error('Unable to fetch "'+e+'". Only file URLs of the form file:/// allowed running in Node.');return D=D||require("fs"),e=y?e.replace(/\//g,"\\").substr(8):e.substr(7),D.readFile(e,function(e,a){if(e)return n(e);var r=a+"";"\ufeff"===r[0]&&(r=r.substr(1)),t(r)})}}o.prototype.fetch=function(e){return new Promise(function(t,n){M(e.address,t,n)})};var R,k=function(){function t(t){var a=this;return Promise.resolve(e["typescript"==a.transpiler?"ts":a.transpiler]||(a.pluginLoader||a)["import"](a.transpiler)).then(function(e){e.__useDefault&&(e=e["default"]);var r;return r=e.Compiler?n:e.createLanguageService?s:o,"(function(__moduleName){"+r.call(a,t,e)+'\n})("'+t.name+'");\n//# sourceURL='+t.address+"!transpiled"})}function n(e,t){var n=this.traceurOptions||{};n.modules="instantiate",n.script=!1,void 0===n.sourceMaps&&(n.sourceMaps="inline"),n.filename=e.address,n.inputSourceMap=e.metadata.sourceMap,n.moduleName=!1;var r=new t.Compiler(n);return a(e.source,r,n.filename)}function a(e,t,n){try{return t.compile(e,n)}catch(a){throw a[0]}}function o(e,t){var n=this.babelOptions||{};return n.modules="system",void 0===n.sourceMap&&(n.sourceMap="inline"),n.inputSourceMap=e.metadata.sourceMap,n.filename=e.address,n.code=!0,n.ast=!1,t.transform(e.source,n).code}function s(e,t){var n=this.typescriptOptions||{};return n.target=n.target||t.ScriptTarget.ES5,void 0===n.sourceMap&&(n.sourceMap=!0),n.sourceMap&&(n.inlineSourceMap=!0),n.module=t.ModuleKind.System,t.transpile(e.source,n,e.address)}return r.prototype.transpiler="traceur",t}();!function(){function n(t){o=e.System,e.System=t}function a(){e.System=o}function r(e){var t=e.source.lastIndexOf("\n");return e.source+("\n//# sourceURL="!=e.source.substr(t,15)?"\n//# sourceURL="+e.address+(e.metadata.sourceMap?"!transpiled":""):"")+(e.metadata.sourceMap&&s&&"\n//# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(e.metadata.sourceMap)))||"")}var o,s="undefined"!=typeof btoa;if(g||b&&window.chrome&&window.chrome.extension)R=function(o){try{n(this),new Function(r(o)).call(e),a()}catch(s){throw t(s,"Evaluating "+o.address)}};else if("undefined"!=typeof document){var i,l=document.getElementsByTagName("script");$__curScript=l[l.length-1],R=function(e){i||(i=document.head||document.body||document.documentElement);var o=document.createElement("script");o.text=r(e);var s,l=window.onerror;if(window.onerror=function(n){s=t(n,"Evaluating "+e.address)},n(this),i.appendChild(o),i.removeChild(o),a(),window.onerror=l,s)throw s}}else{var u="vm",d=require(u);R=function(e){try{n(this),d.runInThisContext(r(e)),a()}catch(o){throw t(o.toString(),"Evaluating "+e.address)}}}}(),u.prototype=o.prototype,l.prototype=new u;var O,L=/^[^\/]+:\/\//,T={},F=new _(S);!function(){c(function(e){return function(){e.call(this),this.baseURL=S.substr(0,S.lastIndexOf("/")+1),this.set("@empty",this.newModule({}))}}),d("normalize",function(){return function(e,t){return"."==e[0]||"/"==e[0]?new _(e,t||F).href:e}}),d("import",function(e){return function(t,n,a){return e.call(this,t,n,a).then(function(e){return e.__useDefault?e["default"]:e})}});var e=["main","format","defaultExtension","meta","map"];l.prototype.config=function(t){function n(e){for(var t in e)return!0}if(t.baseURL){if(n(this.packages)||n(this.meta)||n(this.depCache)||n(this.bundles))throw new TypeError("baseURL should only be configured once and must be configured first.");this.baseURL=t.baseURL,v.call(this)}if(t.defaultJSExtensions&&(this.defaultJSExtensions=t.defaultJSExtensions),t.pluginFirst&&(this.pluginFirst=t.pluginFirst),t.paths)for(var a in t.paths)this.paths[a]=t.paths[a];if(t.map)for(var a in t.map){var r=t.map[a];if("string"!=typeof r){var o=this.normalizeSync(a);this.defaultJSExtensions&&".js"!=a.substr(a.length-3,3)&&(o=o.substr(0,o.length-3));var s="";for(var i in this.packages)o.substr(0,i.length)==i&&(!o[i.length]||"/"==o[i.length])&&s.split("/").length<i.split("/").length&&(s=i);s&&this.packages[s].main&&(o=o.substr(0,o.length-this.packages[s].main.length-1));var i=this.packages[o]=this.packages[o]||{};i.map=r}else this.map[a]=r}if(t.packages)for(var a in t.packages){var l=this.normalizeSync(a);this.defaultJSExtensions&&".js"!=a.substr(a.length-3,3)&&(l=l.substr(0,l.length-3)),this.packages[l]=this.packages[l]||{};for(var u in t.packages[a])-1==w.call(e,u)&&"undefined"!=typeof console&&console.warn,this.packages[l][u]=t.packages[a][u]}if(t.bundles)for(var a in t.bundles){for(var d=[],c=0;c<t.bundles[a].length;c++)d.push(this.normalizeSync(t.bundles[a][c]));this.bundles[a]=d}for(var f in t){var r=t[f],m=!1;if("baseURL"!=f&&"map"!=f&&"packages"!=f&&"bundles"!=f&&"paths"!=f)if("object"!=typeof r||r instanceof Array)this[f]=r;else{this[f]=this[f]||{},("meta"==f||"depCache"==f)&&(m=!0);for(var a in r)"meta"==f&&"*"==a[0]?this[f][a]=r[a]:m?this[f][this.normalizeSync(a)]=r[a]:this[f][a]=r[a]}}}}(),function(){function t(e,t){return new Promise(function(n,a){try{importScripts(t.address)}catch(r){a(r)}e.onScriptLoad(t),t.metadata.registered||a(t.address+" did not call System.register or AMD define"),n("")})}if("undefined"!=typeof document)var n=document.getElementsByTagName("head")[0];var a;l.prototype.onScriptLoad=function(){e.System=a},d("fetch",function(r){return function(o){var s=this;return o.metadata.scriptLoad&&(b||g)?g?t(s,o):new Promise(function(t,r){function i(e){d.readyState&&"loaded"!=d.readyState&&"complete"!=d.readyState||(u(),s.onScriptLoad(o),o.metadata.registered||r(o.address+" did not call System.register or AMD define"),t(""))}function l(e){u(),r(new Error("Unable to load script "+o.address))}function u(){d.detachEvent?d.detachEvent("onreadystatechange",i):(d.removeEventListener("load",i,!1),d.removeEventListener("error",l,!1)),n.removeChild(d)}var d=document.createElement("script");d.async=!0,d.attachEvent?d.attachEvent("onreadystatechange",i):(d.addEventListener("load",i,!1),d.addEventListener("error",l,!1)),a=e.System,e.System=s,d.src=o.address,n.appendChild(d)}):r.call(this,o)}})}(),function(){function t(e,t,n){if(g=!0,t)t=(e.normalizeSync||e.normalize).call(e,t),n.name=t,t in e.defined||(e.defined[t]=n);else{if(v)throw new TypeError("Invalid anonymous System.register module load. If loading a single module, ensure anonymous System.register is loaded via System.import. If loading a bundle, ensure all the System.register calls are named.");v=n}}function n(e,t,a){if(a[e.groupIndex]=a[e.groupIndex]||[],-1==w.call(a[e.groupIndex],e)){a[e.groupIndex].push(e);for(var r=0,o=e.normalizedDeps.length;o>r;r++){var s=e.normalizedDeps[r],i=t.defined[s];if(i&&!i.evaluated){var l=e.groupIndex+(i.declarative!=e.declarative);if(void 0===i.groupIndex||i.groupIndex<l){if(void 0!==i.groupIndex&&(a[i.groupIndex].splice(w.call(a[i.groupIndex],i),1),0==a[i.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");i.groupIndex=l}n(i,t,a)}}}}function a(e,t){var a=t.defined[e];if(!a.module){a.groupIndex=0;var r=[];n(a,t,r);for(var o=!!a.declarative==r.length%2,i=r.length-1;i>=0;i--){for(var l=r[i],d=0;d<l.length;d++){var c=l[d];o?s(c,t):u(c,t)}o=!o}}}function r(){}function o(e,t){return t[e]||(t[e]={name:e,dependencies:[],exports:new r,importers:[]})}function s(t,n){if(!t.module){var a=n._loader.moduleRecords,r=t.module=o(t.name,a),i=t.module.exports,l=t.declare.call(e,function(e,t){if(r.locked=!0,"object"==typeof e)for(var n in e)i[n]=e[n];else i[e]=t;for(var a=0,o=r.importers.length;o>a;a++){var s=r.importers[a];if(!s.locked){var l=w.call(s.dependencies,r);s.setters[l](i)}}return r.locked=!1,t});if(r.setters=l.setters,r.execute=l.execute,!r.setters||!r.execute)throw new TypeError("Invalid System.register form for "+t.name);for(var u=0,d=t.normalizedDeps.length;d>u;u++){var c,f=t.normalizedDeps[u],m=n.defined[f],p=a[f];p?c=p.exports:m&&!m.declarative?c=m.esModule:m?(s(m,n),p=m.module,c=p.exports):c=n.get(f),p&&p.importers?(p.importers.push(r),r.dependencies.push(p)):r.dependencies.push(null);for(var h=t.originalIndices[u],v=0,g=h.length;g>v;++v){var b=h[v];r.setters[b]&&r.setters[b](c)}}}}function i(e,t){var n,a=t.defined[e];if(a)a.declarative?m(e,[],t):a.evaluated||u(a,t),n=a.module.exports;else if(n=t.get(e),!n)throw new Error("Unable to load dependency "+e+".");return(!a||a.declarative)&&n&&n.__useDefault?n["default"]:n}function u(t,n){if(!t.module){var a={},r=t.module={exports:a,id:t.name};if(!t.executingRequire)for(var o=0,s=t.normalizedDeps.length;s>o;o++){var l=t.normalizedDeps[o],d=n.defined[l];d&&u(d,n)}t.evaluated=!0;var c=t.execute.call(e,function(e){for(var a=0,r=t.deps.length;r>a;a++)if(t.deps[a]==e)return i(t.normalizedDeps[a],n);throw new TypeError("Module "+e+" not declared as a dependency.")},a,r);if(c&&(r.exports=c),a=r.exports,a&&a.__esModule)t.esModule=a;else{if(t.esModule={},"object"==typeof a||"function"==typeof a)if(p){var f;for(var m in a)(f=Object.getOwnPropertyDescriptor(a,m))&&x(t.esModule,m,f)}else{var h=a&&a.hasOwnProperty;for(var m in a)(!h||a.hasOwnProperty(m))&&(t.esModule[m]=a[m])}t.esModule["default"]=a,x(t.esModule,"__useDefault",{value:!0})}}}function m(t,n,a){var r=a.defined[t];if(r&&!r.evaluated&&r.declarative){n.push(t);for(var o=0,s=r.normalizedDeps.length;s>o;o++){var i=r.normalizedDeps[o];-1==w.call(n,i)&&(a.defined[i]?m(i,n,a):a.get(i))}r.evaluated||(r.evaluated=!0,r.module.execute.call(e))}}var p=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){p=!1}var v,g=!1;l.prototype.register=function(e,n,a){return"string"!=typeof e&&(a=n,n=e,e=null),"boolean"==typeof a?this.registerDynamic.apply(this,arguments):void t(this,e,{declarative:!0,deps:n,declare:a})},l.prototype.registerDynamic=function(e,n,a,r){"string"!=typeof e&&(r=a,a=n,n=e,e=null),t(this,e,{declarative:!1,deps:n,execute:r,executingRequire:a})},c(function(e){return function(){e.call(this),this.defined={},this._loader.moduleRecords={}}}),d("onScriptLoad",function(e){return function(t){e.call(this,t),g&&(v&&(t.metadata.entry=v),t.metadata.format=t.metadata.format||"defined",t.metadata.registered=!0,g=!1,v=null)}}),x(r,"toString",{value:function(){return"Module"}}),d("delete",function(e){return function(t){return delete this._loader.moduleRecords[t],delete this.defined[t],e.call(this,t)}});var b=/^\s*(\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)*\s*System\.register(Dynamic)?\s*\(/;d("fetch",function(e){return function(t){return this.defined[t.name]?(t.metadata.format="defined",""):(v=null,g=!1,"register"==t.metadata.format&&(t.metadata.scriptLoad=!0),t.metadata.deps=t.metadata.deps||[],e.call(this,t))}}),d("translate",function(e){return function(t){return Promise.resolve(e.call(this,t)).then(function(e){return"string"==typeof t.metadata.deps&&(t.metadata.deps=t.metadata.deps.split(",")),t.metadata.deps=t.metadata.deps||[],("register"==t.metadata.format||!t.metadata.format&&t.source.match(b))&&(t.metadata.format="register"),e})}}),d("instantiate",function(e){return function(e){var t,n=this;if(n.defined[e.name])t=n.defined[e.name],t.deps=t.deps.concat(e.metadata.deps);else if(e.metadata.entry)t=e.metadata.entry;else if(e.metadata.execute)t={declarative:!1,deps:e.metadata.deps||[],execute:e.metadata.execute,executingRequire:e.metadata.executingRequire};else if("register"==e.metadata.format||"esm"==e.metadata.format||"es6"==e.metadata.format){if(v=null,g=!1,R.call(n,e),!g&&!e.metadata.registered)throw new TypeError(e.name+" detected as System.register but didn't execute.");v?t=v:e.metadata.bundle=!0,!t&&n.defined[e.name]&&(t=n.defined[e.name]),v=null,g=!1}t||(t={declarative:!1,deps:e.metadata.deps,execute:function(){return n.newModule({})}}),n.defined[e.name]=t;var r=f(t.deps);t.deps=r.names,t.originalIndices=r.indices,t.name=e.name;for(var o=[],s=0,i=t.deps.length;i>s;s++)o.push(Promise.resolve(n.normalize(t.deps[s],e.name)));return Promise.all(o).then(function(r){return t.normalizedDeps=r,{deps:t.deps,execute:function(){return a(e.name,n),m(e.name,[],n),n.defined[e.name]=void 0,n.newModule(t.declarative?t.module.exports:t.esModule)}}})}})}(),function(){var t=/(^\s*|[}\);\n]\s*)(import\s+(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s+from\s+['"]|\{)|export\s+\*\s+from\s+["']|export\s+(\{|default|function|class|var|const|let|async\s+function))/,n=/\$traceurRuntime\s*\./,a=/babelHelpers\s*\./;d("translate",function(r){return function(o){var s=this;return r.call(s,o).then(function(r){if("esm"==o.metadata.format||"es6"==o.metadata.format||!o.metadata.format&&r.match(t))return o.metadata.format="esm",s._loadedTranspiler=s._loadedTranspiler||!1,s.pluginLoader&&(s.pluginLoader._loadedTranspiler=s._loadedTranspiler||!1),s.builder&&(o.metadata.originalSource=o.source),k.call(s,o).then(function(e){return o.metadata.sourceMap=void 0,e});if(s._loadedTranspiler===!1&&o.name==s.normalizeSync(s.transpiler)&&(r.length>100&&(o.metadata.format=o.metadata.format||"global","traceur"===s.transpiler&&(o.metadata.exports="traceur"),"typescript"===s.transpiler&&(o.metadata.exports="ts")),s._loadedTranspiler=!0),s._loadedTranspilerRuntime===!1&&(o.name==s.normalizeSync("traceur-runtime")||o.name==s.normalizeSync("babel/external-helpers*"))&&(r.length>100&&(o.metadata.format=o.metadata.format||"global"),s._loadedTranspilerRuntime=!0),"register"==o.metadata.format&&s._loadedTranspilerRuntime!==!0){if(!e.$traceurRuntime&&o.source.match(n))return s._loadedTranspilerRuntime=s._loadedTranspilerRuntime||!1,s["import"]("traceur-runtime").then(function(){return r});if(!e.babelHelpers&&o.source.match(a))return s._loadedTranspilerRuntime=s._loadedTranspilerRuntime||!1,s["import"]("babel/external-helpers").then(function(){return r})}return r})}})}();var P="undefined"!=typeof self?"self":"global";d("onScriptLoad",function(t){return function(n){if("global"==n.metadata.format){n.metadata.registered=!0;var a=h(n.metadata.exports,e);n.metadata.execute=function(){return a}}return t.call(this,n)}}),d("fetch",function(e){return function(t){return t.metadata.exports&&(t.metadata.format="global"),"global"!=t.metadata.format||!t.metadata.exports||t.metadata.globals||t.metadata.deps&&0!=t.metadata.deps.length||(t.metadata.scriptLoad=!0),e.call(this,t)}}),d("instantiate",function(e){return function(t){var n=this;if(t.metadata.format||(t.metadata.format="global"),t.metadata.globals&&t.metadata.globals instanceof Array){for(var a={},r=0;r<t.metadata.globals.length;r++)a[t.metadata.globals[r]]=t.metadata.globals[r];t.metadata.globals=a}if("global"==t.metadata.format&&!t.metadata.registered){for(var o in t.metadata.globals)t.metadata.deps.push(t.metadata.globals[o]);t.metadata.execute=function(e,a,r){var o;if(t.metadata.globals){o={};for(var s in t.metadata.globals)o[s]=e(t.metadata.globals[s])}var i=t.metadata.exports;i&&(t.source+="\n"+P+'["'+i+'"] = '+i+";");var l=n.get("@@global-helpers").prepareGlobal(r.id,i,o);return R.call(n,t),l()}}return e.call(this,t)}}),c(function(t){return function(){function n(t){if(Object.keys)Object.keys(e).forEach(t);else for(var n in e)s.call(e,n)&&t(n)}function a(t){n(function(n){if(-1==w.call(i,n)){try{var a=e[n]}catch(r){i.push(n)}t(n,a)}})}var r=this;t.call(r);var o,s=Object.prototype.hasOwnProperty,i=["_g","sessionStorage","localStorage","clipboardData","frames","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB"];r.set("@@global-helpers",r.newModule({prepareGlobal:function(t,n,r){var s=e.define;e.define=void 0,e.exports=void 0,e.module&&e.module.exports&&(e.module=void 0);var i;if(r){i={};for(var l in r)i[l]=r[l],e[l]=r[l]}return n||(o={},a(function(e,t){o[e]=t})),function(){var t;if(n)t=h(n,e);else{var r,l,u={};a(function(e,t){o[e]!==t&&"undefined"!=typeof t&&(u[e]=t,"undefined"!=typeof r?l||r===t||(l=!0):r=t)}),t=l?u:r}if(i)for(var d in i)e[d]=i[d];return e.define=s,t}}}))}}),function(){function t(e){a.lastIndex=0;var t=[];e.length/e.split("\n").length<200&&(e=e.replace(r,""));for(var n;n=a.exec(e);)t.push(n[1].substr(1,n[1].length-2));return t}var n=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.]|module\.)exports\s*(\[['"]|\.)|(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])module\.exports\s*[=,]/,a=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g,r=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm;if("undefined"!=typeof window&&"undefined"!=typeof document&&window.location)var o=location.protocol+"//"+location.hostname+(location.port?":"+location.port:"");c(function(e){return function(){e.call(this),"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&(this._nodeRequire=require)}}),d("instantiate",function(r){return function(s){var i=this;if(s.metadata.format||(n.lastIndex=0,a.lastIndex=0,(a.exec(s.source)||n.exec(s.source))&&(s.metadata.format="cjs")),"cjs"==s.metadata.format){var l=s.metadata.deps||[];s.metadata.deps=l.concat(t(s.source));for(var u in s.metadata.globals)s.metadata.deps.push(s.metadata.globals[u]);s.metadata.executingRequire=!0,s.metadata.execute=function(t,n,a){for(var r=0;r<l.length;r++)t(l[r]);var u=s.address||"",d=u.split("/");d.pop(),d=d.join("/"),o&&u.substr(0,o.length)===o?(u=u.substr(o.length),d=d.substr(o.length)):"file:///"==u.substr(0,8)&&(u=u.substr(7),d=d.substr(7),y&&(u=u.substr(1),d=d.substr(1)));var c=e.define;e.define=void 0,e.__cjsWrapper={exports:n,args:[t,n,a,u,d,e]};var f="";if(s.metadata.globals)for(var m in s.metadata.globals)f+="var "+m+' = require("'+s.metadata.globals[m]+'");';s.source="(function(require, exports, module, __filename, __dirname, global) {"+f+s.source+"\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);",R.call(i,s),e.__cjsWrapper=void 0,e.define=c}}return r.call(i,s)}})}(),c(function(t){return function(){function n(e,t){e=e.replace(i,"");var n=e.match(d),a=(n[1].split(",")[t]||"require").replace(c,""),r=f[a]||(f[a]=new RegExp(l+a+u,"g"));r.lastIndex=0;for(var o,s=[];o=r.exec(e);)s.push(o[2]||o[3]);return s}function a(e,t,n,r){if("object"==typeof e&&!(e instanceof Array))return a.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof t&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var o=s.get(s.normalizeSync(e,r));if(!o)throw new Error('Module not already loaded loading "'+e+'" from "'+r+'".');return o.__useDefault?o["default"]:o}throw new TypeError("Invalid require")}for(var i=[],l=0;l<e.length;l++)i.push(s["import"](e[l],r));Promise.all(i).then(function(e){t&&t.apply(null,e)},n)}function r(t,r,o){"string"!=typeof t&&(o=r,r=t,t=null),r instanceof Array||(o=r,r=["require","exports","module"].splice(0,o.length)),"function"!=typeof o&&(o=function(e){return function(){return e}}(o)),void 0===r[r.length-1]&&r.pop();var i,l,u;-1!=(i=w.call(r,"require"))&&(r.splice(i,1),t||(r=r.concat(n(o.toString(),i)))),-1!=(l=w.call(r,"exports"))&&r.splice(l,1),-1!=(u=w.call(r,"module"))&&r.splice(u,1);var d={name:t,deps:r,execute:function(t,n,d){function c(e,n,r){return"string"==typeof e&&"function"!=typeof n?t(e):a.call(s,e,n,r,d.id)}for(var f=[],m=0;m<r.length;m++)f.push(t(r[m]));d.uri=d.id,d.config=function(){},-1!=u&&f.splice(u,0,d),-1!=l&&f.splice(l,0,n),-1!=i&&(c.toUrl=function(e){var t=s.defaultJSExtensions&&".js"!=e.substr(e.length-3,3),n=s.normalizeSync(e,d.id);return t&&".js"==n.substr(n.length-3,3)&&(n=n.substr(0,n.length-3)),n},f.splice(i,0,c));var p=e.require;e.require=a;var h=o.apply(-1==l?e:n,f);return e.require=p,"undefined"==typeof h&&d&&(h=d.exports),"undefined"!=typeof h?h:void 0}};if(t)m.anonDefine||m.isBundle?(m.anonDefine&&m.anonDefine.name&&s.registerDynamic(m.anonDefine.name,m.anonDefine.deps,!1,m.anonDefine.execute),m.anonDefine=null):m.anonDefine=d,m.isBundle=!0,s.registerDynamic(t,d.deps,!1,d.execute);else{if(m.anonDefine)throw new TypeError("Multiple defines for anonymous module");m.anonDefine=d}}function o(t){m.anonDefine=null,m.isBundle=!1;var n=e.module,a=e.exports,o=e.define;return e.module=void 0,e.exports=void 0,e.define=r,function(){e.define=o,e.module=n,e.exports=a}}var s=this;t.call(this);var i=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,l="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",u="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",d=/\(([^\)]*)\)/,c=/^\s+|\s+$/g,f={};r.amd={};var m={isBundle:!1,anonDefine:null};s.set("@@amd-helpers",s.newModule({createDefine:o,require:a,define:r,lastModule:m})),s.amdDefine=r,s.amdRequire=a}}),function(){var e=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/;
d("onScriptLoad",function(e){return function(t){e.call(this,t);var n=this.get("@@amd-helpers").lastModule;(n.anonDefine||n.isBundle)&&(t.metadata.format="defined",t.metadata.registered=!0,n.isBundle=!1),n.anonDefine&&(t.metadata.deps=t.metadata.deps?t.metadata.deps.concat(n.anonDefine.deps):n.anonDefine.deps,t.metadata.execute=n.anonDefine.execute,n.anonDefine=null)}}),d("fetch",function(e){return function(t){return"amd"===t.metadata.format&&(t.metadata.scriptLoad=!0),t.metadata.scriptLoad&&this.get("@@amd-helpers").createDefine(this),e.call(this,t)}}),d("instantiate",function(t){return function(n){var a=this;if("amd"==n.metadata.format||!n.metadata.format&&n.source.match(e)){if(n.metadata.format="amd",a.builder||a.execute===!1)n.metadata.execute=function(){return n.metadata.builderExecute()};else{var r=this.get("@@amd-helpers").createDefine(a);R.call(a,n),r(a);var o=this.get("@@amd-helpers").lastModule;if(!o.anonDefine&&!o.isBundle)throw new TypeError("AMD module "+n.name+" did not define");o.anonDefine&&(n.metadata.deps=n.metadata.deps?n.metadata.deps.concat(o.anonDefine.deps):o.anonDefine.deps,n.metadata.execute=o.anonDefine.execute),o.isBundle=!1,o.anonDefine=null}return t.call(a,n)}return t.call(a,n)}})}(),c(function(e){return function(){e.call(this),this.map={}}}),d("normalize",function(e){return function(t,n,a){if("."!=t.substr(0,1)&&"/"!=t.substr(0,1)&&!t.match(L)){var r,o=0;for(var s in this.map)if(t.substr(0,s.length)==s&&(t.length==s.length||"/"==t[s.length])){var i=s.split("/").length;if(o>=i)continue;r=s,o=i}r&&(t=this.map[r]+t.substr(r.length))}return e.call(this,t,n,a)}}),d("normalize",function(e){return function(t,n){var a=e.call(this,t,n);return this.has(a)?a:(b&&(a=a.replace(/#/g,"%23")),a.match(L)?(this.defaultJSExtensions&&".js"!=a.substr(a.length-3,3)&&(a+=".js"),a):(a=s(this.paths,a)||a,this.defaultJSExtensions&&".js"!=a.substr(a.length-3,3)&&(a+=".js"),"."==a[0]||"/"==a[0]?new _(a,F).href:new _(a,v.call(this)).href))}}),function(){function e(e){for(var t in this.packages)if(e.substr(0,t.length)===t&&(e.length===t.length||"/"===e[t.length]))return t}function t(e,t){var n,a=0;for(var r in e)if(t.substr(0,r.length)==r&&(t.length==r.length||"/"==t[r.length])){var o=r.split("/").length;if(a>=o)continue;n=r,a=o}return n}function n(e,n,a,r){var o=t(a,r),s=a[o];return s?"object"==typeof s?e["import"](a["@env"]||"@system-env",n).then(function(e){for(var t in s){var n="~"==t[0],a=h(n?t.substr(1):t,e);if(!n&&a||n&&!a)return s[t]+r.substr(o.length)}}):s+r.substr(o.length):void 0}function a(a,r){return function(o,s){if(s)var i=e.call(this,s)||this.defaultJSExtensions&&".js"==s.substr(s.length-3,3)&&e.call(this,s.substr(0,s.length-3));if(i&&"."!==o[0]){var l=this.packages[i].map;if(l){var u=t(l,o);u&&(o=l[u]+o.substr(u.length),"."===o[0]&&(s=i+"/"))}}var d=this.defaultJSExtensions&&".js"!=o.substr(o.length-3,3),c=a.call(this,o,s);".js"!=c.substr(c.length-3,3)&&(d=!1),d&&(c=c.substr(0,c.length-3));var f=e.call(this,c),m=this;if(f){var p=m.packages[f];if(f===c&&p.main&&(c+="/"+("./"==p.main.substr(0,2)?p.main.substr(2):p.main)),"/"==c.substr(f.length))return c;var h="";if(p.meta&&(p.meta[c.substr(f.length+1)]||p.meta["./"+c.substr(f.length+1)])||("defaultExtension"in p?p.defaultExtension!==!1&&-1==c.split("/").pop().lastIndexOf(".")&&(h="."+p.defaultExtension):d&&(h=".js")),r||!p.map)return c+h;var v="."+c.substr(f.length);return Promise.resolve(n(m,f,p.map,v)).then(function(e){return e?e:h?n(m,f,p.map,v+h):void 0}).then(function(e){return e?c="./"==e.substr(0,2)?f+e.substr(1):a.call(m,e):c+=h,c})}return d&&(c+=".js"),c}}c(function(e){return function(){e.call(this),this.packages={}}}),l.prototype.normalizeSync=l.prototype.normalize,d("normalizeSync",function(e){return a(e,!0)}),d("normalize",function(e){return a(e,!1)}),d("locate",function(t){return function(n){var a=this;return Promise.resolve(t.call(this,n)).then(function(t){var r=e.call(a,n.name);if(r){var o=a.packages[r];if(o.format&&(n.metadata.format=n.metadata.format||o.format),o.loader&&(n.metadata.loader=n.metadata.loader||o.loader),o.meta){var s,i={},l=0;for(var u in o.meta){var d="./"==u.substr(0,2)?"./":"";if(d&&(u=u.substr(2)),s=u.indexOf("*"),-1!==s&&u.substr(0,s)===n.name.substr(0,s)&&u.substr(s+1)===n.name.substr(n.name.length-u.length+s+1)){var c=u.split("/").length;c>l&&(bestDetph=c),p(i,o.meta[d+u],l!=c)}}var f=n.name.substr(r.length+1),m=o.meta[f]||o.meta["./"+f];m&&p(i,m),i.alias&&"./"==i.alias.substr(0,2)&&(i.alias=r+i.alias.substr(1)),i.loader&&"./"==i.loader.substr(0,2)&&(i.loader=r+i.loader.substr(1)),p(n.metadata,i)}}return t})}})}(),function(){function e(e,t,n,a){function r(e,t){return d&&".js"==e.substr(e.length-3,3)&&(e=e.substr(0,e.length-3)),o.pluginFirst?t+"!"+e:e+"!"+t}var o=this;if(n){var s;o.pluginFirst?-1!=(s=n.lastIndexOf("!"))&&(n=n.substr(s+1)):-1!=(s=n.indexOf("!"))&&(n=n.substr(0,s))}var i=t.lastIndexOf("!");if(-1!=i){var l,u;o.pluginFirst?(l=t.substr(i+1),u=t.substr(0,i)):(l=t.substr(0,i),u=t.substr(i+1)||l.substr(l.lastIndexOf(".")+1));var d=o.defaultJSExtensions&&".js"!=l.substr(l.length-3,3);return a?(l=o.normalizeSync(l,n),u=o.normalizeSync(u,n),r(l,u)):Promise.all([o.normalize(l,n),o.normalize(u,n)]).then(function(e){return r(e[0],e[1])})}return e.call(o,t,n)}d("normalize",function(t){return function(n,a){return e.call(this,t,n,a,!1)}}),d("normalizeSync",function(t){return function(n,a){return e.call(this,t,n,a,!0)}}),d("locate",function(e){return function(t){var n,a=this,r=t.name;return a.pluginFirst?-1!=(n=r.indexOf("!"))&&(t.metadata.loader=r.substr(0,n),t.name=r.substr(n+1)):-1!=(n=r.lastIndexOf("!"))&&(t.metadata.loader=r.substr(n+1),t.name=r.substr(0,n)),e.call(a,t).then(function(e){var n=t.metadata.loader;if(!n)return e;if(a.defined&&a.defined[r])return e;var o=a.pluginLoader||a;return o["import"](n).then(function(n){return t.metadata.loaderModule=n,t.metadata.loaderArgument=r,t.address=e,n.locate?n.locate.call(a,t):e})})}}),d("fetch",function(e){return function(t){var n=this;return t.metadata.loaderModule&&t.metadata.loaderModule.fetch?(t.metadata.scriptLoad=!1,t.metadata.loaderModule.fetch.call(n,t,function(t){return e.call(n,t)})):e.call(n,t)}}),d("translate",function(e){return function(t){var n=this;return t.metadata.loaderModule&&t.metadata.loaderModule.translate?Promise.resolve(t.metadata.loaderModule.translate.call(n,t)).then(function(a){return"string"==typeof a&&(t.source=a),e.call(n,t)}):e.call(n,t)}}),d("instantiate",function(e){return function(t){var n=this,a=t.metadata.sourceMap;if(a&&"object"==typeof a){var r=t.name.split("!")[0];a.file=r+"!transpiled",a.sources&&1!=a.sources.length||(a.sources=[r]),t.metadata.sourceMap=JSON.stringify(a)}return t.metadata.loaderModule&&t.metadata.loaderModule.instantiate?Promise.resolve(t.metadata.loaderModule.instantiate.call(n,t)).then(function(a){return t.metadata.format="defined",t.metadata.execute=function(){return a},e.call(n,t)}):e.call(n,t)}})}(),function(){d("fetch",function(e){return function(t){var n=t.metadata.alias,a=t.metadata.deps||[];return n?(t.metadata.format="defined",this.defined[t.name]={declarative:!0,deps:a.concat([n]),declare:function(e){return{setters:[function(t){for(var n in t)e(n,t[n])}],execute:function(){}}}},""):e.call(this,t)}})}(),function(){function e(e,t,n){for(var a,r=t.split(".");r.length>1;)a=r.shift(),e=e[a]=e[a]||{};a=r.shift(),a in e||(e[a]=n)}c(function(e){return function(){this.meta={},e.call(this)}}),d("locate",function(e){return function(t){var n,a=this.meta,r=t.name,o=0;for(var s in a)if(n=s.indexOf("*"),-1!==n&&s.substr(0,n)===r.substr(0,n)&&s.substr(n+1)===r.substr(r.length-s.length+n+1)){var i=s.split("/").length;i>o&&(bestDetph=i),p(t.metadata,a[s],o!=i)}return a[r]&&p(t.metadata,a[r]),e.call(this,t)}});var t=/^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/,n=/\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;d("translate",function(a){return function(r){var o=r.source.match(t);if(o)for(var s=o[0].match(n),i=0;i<s.length;i++){var l=s[i],u=l.length,d=l.substr(0,1);if(";"==l.substr(u-1,1)&&u--,'"'==d||"'"==d){var c=l.substr(1,l.length-3),f=c.substr(0,c.indexOf(" "));if(f){var m=c.substr(f.length+1,c.length-f.length-1);"[]"==f.substr(f.length-2,2)&&(f=f.substr(0,f.length-2),r.metadata[f]=r.metadata[f]||[]),r.metadata[f]instanceof Array?r.metadata[f].push(m):e(r.metadata,f,m)}else r.metadata[c]=!0}}return a.call(this,r)}})}(),function(){function e(e,t){return Promise.resolve(e.normalize(t)).then(function(n){return e.loadedBundles_[n]=!0,e.bundles[n]=e.bundles[n]||e.bundles[t],e.load(n)}).then(function(){return""})}c(function(e){return function(){e.call(this),this.bundles={},this.loadedBundles_={}}}),d("locate",function(e){return function(t){return(t.name in this.loadedBundles_||t.name in this.bundles)&&(t.metadata.bundle=!0),e.call(this,t)}}),d("fetch",function(t){return function(n){var a=this;if(a.trace)return t.call(a,n);if(n.name in a.defined)return"";for(var r in a.loadedBundles_)if(-1!=w.call(a.bundles[r],n.name))return e(a,r);for(var r in a.bundles)if(-1!=w.call(a.bundles[r],n.name))return e(a,r);return t.call(a,n)}})}(),function(){c(function(e){return function(){e.call(this),this.depCache={}}}),d("locate",function(e){return function(t){var n=this,a=n.depCache[t.name];if(a)for(var r=0;r<a.length;r++)n["import"](a[r]);return e.call(n,t)}})}(),function(){var e=/#\{[^\}]+\}|#\?.+$/;c(function(e){return function(){e.call(this),this.set("@system-env",this.newModule({browser:b}))}}),d("normalize",function(t){return function(n,a,r){var o=this,s=n.match(e);if(s){var i="?"!=s[0][1],l=i?s[0].substr(2,s[0].length-3):s[0].substr(2);if("."==l[0]||-1!=l.indexOf("/"))throw new TypeError("Invalid condition "+s[0]+"\n	Condition modules cannot contain . or / in the name.");var u,d=l.indexOf(".");-1!=d&&(u=l.substr(d+1),l=l.substr(0,d));var c=!i&&"~"==l[0];c&&(l=l.substr(1));var f=o.pluginLoader||o;return f["import"](l,a,r).then(function(e){return void 0===u?"string"==typeof e?e:e["default"]:h(u,e)}).then(function(s){if(i){if("string"!=typeof s)throw new TypeError("The condition value for "+l+" doesn't resolve to a string.");n=n.replace(e,s)}else{if("boolean"!=typeof s)throw new TypeError("The condition value for "+l+" isn't resolving to a boolean.");c&&(s=!s),n=s?n.replace(e,""):"@empty"}return t.call(o,n,a,r)})}return Promise.resolve(t.call(o,n,a,r))}})}(),j=new l,j.constructor=l,"object"==typeof exports&&(module.exports=r),e.Reflect=e.Reflect||{},e.Reflect.Loader=e.Reflect.Loader||r,e.Reflect.global=e.Reflect.global||e,e.LoaderPolyfill=r,j||(j=new o,j.constructor=o),"object"==typeof exports&&(module.exports=j),e.System=j}("undefined"!=typeof self?self:global)}try{var t="undefined"!=typeof URLPolyfill||"test:"==new URL("test:///").protocol}catch(n){}if("undefined"!=typeof Promise&&t)e();else if("undefined"!=typeof document){var a=document.getElementsByTagName("script");$__curScript=a[a.length-1];var r=$__curScript.src,o=r.substr(0,r.lastIndexOf("/")+1);window.systemJSBootstrap=e,document.write('<script type="text/javascript" src="'+o+'system-polyfills.js"></script>')}else if("undefined"!=typeof importScripts){var o="";try{throw new Error("_")}catch(n){n.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/,function(e,t){o=t.replace(/\/[^\/]*$/,"/")})}importScripts(o+"system-polyfills.js"),e()}else e()}();
//# sourceMappingURL=system.js.map

/**
 @license
Copyright 2014-2015 Google, Inc. http://angularjs.org

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

 */

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

var core = require('../core');
var microtask = require('../microtask');
var browserPatch = require('../patch/browser');
var es6Promise = require('es6-promise');

if (global.Zone) {
  console.warn('Zone already exported on window the object!');
}

global.Zone = microtask.addMicrotaskSupport(core.Zone);
global.zone = new global.Zone();

// Monkey path he Promise implementation to add support for microtasks
global.Promise = es6Promise.Promise;

browserPatch.apply();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core":2,"../microtask":3,"../patch/browser":4,"es6-promise":15}],2:[function(require,module,exports){
(function (global){
'use strict';

function Zone(parentZone, data) {
  var zone = (arguments.length) ? Object.create(parentZone) : this;

  zone.parent = parentZone || null;

  Object.keys(data || {}).forEach(function(property) {

    var _property = property.substr(1);

    // augment the new zone with a hook decorates the parent's hook
    if (property[0] === '$') {
      zone[_property] = data[property](parentZone[_property] || function () {});

    // augment the new zone with a hook that runs after the parent's hook
    } else if (property[0] === '+') {
      if (parentZone[_property]) {
        zone[_property] = function () {
          var result = parentZone[_property].apply(this, arguments);
          data[property].apply(this, arguments);
          return result;
        };
      } else {
        zone[_property] = data[property];
      }

    // augment the new zone with a hook that runs before the parent's hook
    } else if (property[0] === '-') {
      if (parentZone[_property]) {
        zone[_property] = function () {
          data[property].apply(this, arguments);
          return parentZone[_property].apply(this, arguments);
        };
      } else {
        zone[_property] = data[property];
      }

    // set the new zone's hook (replacing the parent zone's)
    } else {
      zone[property] = (typeof data[property] === 'object') ?
                        JSON.parse(JSON.stringify(data[property])) :
                        data[property];
    }
  });

  zone.$id = Zone.nextId++;

  return zone;
}

Zone.prototype = {
  constructor: Zone,

  fork: function (locals) {
    this.onZoneCreated();
    return new Zone(this, locals);
  },

  bind: function (fn, skipEnqueue) {
    if (typeof fn !== 'function') {
      throw new Error('Expecting function got: ' + fn);
    }
    skipEnqueue || this.enqueueTask(fn);
    var zone = this.isRootZone() ? this : this.fork();
    return function zoneBoundFn() {
      return zone.run(fn, this, arguments);
    };
  },

  bindOnce: function (fn) {
    var boundZone = this;
    return this.bind(function () {
      var result = fn.apply(this, arguments);
      boundZone.dequeueTask(fn);
      return result;
    });
  },

  isRootZone: function() {
    return this.parent === null;
  },

  run: function run (fn, applyTo, applyWith) {
    applyWith = applyWith || [];

    var oldZone = global.zone;

    // MAKE THIS ZONE THE CURRENT ZONE
    global.zone = this;

    try {
      this.beforeTask();
      return fn.apply(applyTo, applyWith);
    } catch (e) {
      if (this.onError) {
        this.onError(e);
      } else {
        throw e;
      }
    } finally {
      this.afterTask();
      // REVERT THE CURRENT ZONE BACK TO THE ORIGINAL ZONE
      global.zone = oldZone;
    }
  },

  // onError is used to override error handling.
  // When a custom error handler is provided, it should most probably rethrow the exception
  // not to break the expected control flow:
  //
  // `promise.then(fnThatThrows).catch(fn);`
  //
  // When this code is executed in a zone with a custom onError handler that doesn't rethrow, the
  // `.catch()` branch will not be taken as the `fnThatThrows` exception will be swallowed by the
  // handler.
  onError: null,
  beforeTask: function () {},
  onZoneCreated: function () {},
  afterTask: function () {},
  enqueueTask: function () {},
  dequeueTask: function () {}
};

// Root zone ID === 1
Zone.nextId = 1;

Zone.bindPromiseFn = require('./patch/promise').bindPromiseFn;

module.exports = {
  Zone: Zone
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./patch/promise":10}],3:[function(require,module,exports){
(function (global){
'use strict';

var es6Promise = require('es6-promise').Promise;

// es6-promise asap should schedule microtasks via zone.scheduleMicrotask so that any
// user defined hooks are triggered
es6Promise._setAsap(function(fn, arg) {
  global.zone.scheduleMicrotask(function() {
    fn(arg);
  });
});

// The default implementation of scheduleMicrotask use the original es6-promise implementation
// to schedule a microtask
function scheduleMicrotask(fn) {
  es6Promise._asap(this.bind(fn));
}

function addMicrotaskSupport(zoneClass) {
  zoneClass.prototype.scheduleMicrotask = scheduleMicrotask;
  return zoneClass;
}

module.exports = {
  addMicrotaskSupport: addMicrotaskSupport
};

// TODO(vicb): Create a benchmark for the different methods & the usage of the queue
// see https://github.com/angular/zone.js/issues/97

var hasNativePromise = typeof Promise !== "undefined" &&
                       Promise.toString().indexOf("[native code]") !== -1;

var isFirefox = global.navigator &&
                global.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

// TODO(vicb): remove '!isFirefox' when the bug gets fixed:
// https://bugzilla.mozilla.org/show_bug.cgi?id=1162013
if (hasNativePromise && !isFirefox) {
  // When available use a native Promise to schedule microtasks.
  // When not available, es6-promise fallback will be used
  var resolvedPromise = Promise.resolve();
  es6Promise._setScheduler(function(fn) {
    resolvedPromise.then(fn);
  });
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"es6-promise":15}],4:[function(require,module,exports){
(function (global){
'use strict';

var fnPatch = require('./functions');
var promisePatch = require('./promise');
var mutationObserverPatch = require('./mutation-observer');
var definePropertyPatch = require('./define-property');
var registerElementPatch = require('./register-element');
var webSocketPatch = require('./websocket');
var eventTargetPatch = require('./event-target');
var propertyDescriptorPatch = require('./property-descriptor');
var geolocationPatch = require('./geolocation');

function apply() {
  fnPatch.patchSetClearFunction(global, [
    'timeout',
    'interval',
    'immediate'
  ]);

  fnPatch.patchSetFunction(global, [
    'requestAnimationFrame',
    'mozRequestAnimationFrame',
    'webkitRequestAnimationFrame'
  ]);

  fnPatch.patchFunction(global, [
    'alert',
    'prompt'
  ]);

  eventTargetPatch.apply();

  propertyDescriptorPatch.apply();

  promisePatch.apply();

  mutationObserverPatch.patchClass('MutationObserver');
  mutationObserverPatch.patchClass('WebKitMutationObserver');

  definePropertyPatch.apply();

  registerElementPatch.apply();

  geolocationPatch.apply();
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./define-property":5,"./event-target":6,"./functions":7,"./geolocation":8,"./mutation-observer":9,"./promise":10,"./property-descriptor":11,"./register-element":12,"./websocket":13}],5:[function(require,module,exports){
'use strict';

// might need similar for object.freeze
// i regret nothing

var _defineProperty = Object.defineProperty;
var _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var _create = Object.create;

function apply() {
  Object.defineProperty = function (obj, prop, desc) {
    if (isUnconfigurable(obj, prop)) {
      throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
    }
    if (prop !== 'prototype') {
      desc = rewriteDescriptor(obj, prop, desc);
    }
    return _defineProperty(obj, prop, desc);
  };

  Object.defineProperties = function (obj, props) {
    Object.keys(props).forEach(function (prop) {
      Object.defineProperty(obj, prop, props[prop]);
    });
    return obj;
  };

  Object.create = function (obj, proto) {
    if (typeof proto === 'object') {
      Object.keys(proto).forEach(function (prop) {
        proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
      });
    }
    return _create(obj, proto);
  };

  Object.getOwnPropertyDescriptor = function (obj, prop) {
    var desc = _getOwnPropertyDescriptor(obj, prop);
    if (isUnconfigurable(obj, prop)) {
      desc.configurable = false;
    }
    return desc;
  };
};

function _redefineProperty(obj, prop, desc) {
  desc = rewriteDescriptor(obj, prop, desc);
  return _defineProperty(obj, prop, desc);
};

function isUnconfigurable (obj, prop) {
  return obj && obj.__unconfigurables && obj.__unconfigurables[prop];
}

function rewriteDescriptor (obj, prop, desc) {
  desc.configurable = true;
  if (!desc.configurable) {
    if (!obj.__unconfigurables) {
      _defineProperty(obj, '__unconfigurables', { writable: true, value: {} });
    }
    obj.__unconfigurables[prop] = true;
  }
  return desc;
}

module.exports = {
  apply: apply,
  _redefineProperty: _redefineProperty
};



},{}],6:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

function apply() {
  // patched properties depend on addEventListener, so this needs to come first
  if (global.EventTarget) {
    utils.patchEventTargetMethods(global.EventTarget.prototype);

  // Note: EventTarget is not available in all browsers,
  // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
  } else {
    var apis = [ 'ApplicationCache',
      'EventSource',
      'FileReader',
      'InputMethodContext',
      'MediaController',
      'MessagePort',
      'Node',
      'Performance',
      'SVGElementInstance',
      'SharedWorker',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebKitNamedFlow',
      'Window',
      'Worker',
      'WorkerGlobalScope',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload'
    ];

    apis.forEach(function(thing) {
      global[thing] && utils.patchEventTargetMethods(global[thing].prototype);
    });
  }
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],7:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

function patchSetClearFunction(obj, fnNames) {
  fnNames.map(function (name) {
    return name[0].toUpperCase() + name.substr(1);
  }).forEach(function (name) {
    var setName = 'set' + name;
    var delegate = obj[setName];

    if (delegate) {
      var clearName = 'clear' + name;
      var ids = {};

      var bindArgs = setName === 'setInterval' ? utils.bindArguments : utils.bindArgumentsOnce;

      global.zone[setName] = function (fn) {
        var id, fnRef = fn;
        arguments[0] = function () {
          delete ids[id];
          return fnRef.apply(this, arguments);
        };
        var args = bindArgs(arguments);
        id = delegate.apply(obj, args);
        ids[id] = true;
        return id;
      };

      obj[setName] = function () {
        return global.zone[setName].apply(this, arguments);
      };

      var clearDelegate = obj[clearName];

      global.zone[clearName] = function (id) {
        if (ids[id]) {
          delete ids[id];
          global.zone.dequeueTask();
        }
        return clearDelegate.apply(this, arguments);
      };

      obj[clearName] = function () {
        return global.zone[clearName].apply(this, arguments);
      };
    }
  });
};

function patchSetFunction(obj, fnNames) {
  fnNames.forEach(function (name) {
    var delegate = obj[name];

    if (delegate) {
      global.zone[name] = function (fn) {
        var fnRef = fn;
        arguments[0] = function () {
          return fnRef.apply(this, arguments);
        };
        var args = utils.bindArgumentsOnce(arguments);
        return delegate.apply(obj, args);
      };

      obj[name] = function () {
        return zone[name].apply(this, arguments);
      };
    }
  });
};

function patchFunction(obj, fnNames) {
  fnNames.forEach(function (name) {
    var delegate = obj[name];
    global.zone[name] = function () {
      return delegate.apply(obj, arguments);
    };

    obj[name] = function () {
      return global.zone[name].apply(this, arguments);
    };
  });
};


module.exports = {
  patchSetClearFunction: patchSetClearFunction,
  patchSetFunction: patchSetFunction,
  patchFunction: patchFunction
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],8:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

function apply() {
  if (global.navigator && global.navigator.geolocation) {
    utils.patchPrototype(global.navigator.geolocation, [
      'getCurrentPosition',
      'watchPosition'
    ]);
  }
}

module.exports = {
  apply: apply
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],9:[function(require,module,exports){
(function (global){
'use strict';

// wrap some native API on `window`
function patchClass(className) {
  var OriginalClass = global[className];
  if (!OriginalClass) return;

  global[className] = function (fn) {
    this._o = new OriginalClass(global.zone.bind(fn, true));
    // Remember where the class was instantiate to execute the enqueueTask and dequeueTask hooks
    this._creationZone = global.zone;
  };

  var instance = new OriginalClass(function () {});

  global[className].prototype.disconnect = function () {
    var result = this._o.disconnect.apply(this._o, arguments);
    if (this._active) {
      this._creationZone.dequeueTask();
      this._active = false;
    }
    return result;
  };

  global[className].prototype.observe = function () {
    if (!this._active) {
      this._creationZone.enqueueTask();
      this._active = true;
    }
    return this._o.observe.apply(this._o, arguments);
  };

  var prop;
  for (prop in instance) {
    (function (prop) {
      if (typeof global[className].prototype !== undefined) {
        return;
      }
      if (typeof instance[prop] === 'function') {
        global[className].prototype[prop] = function () {
          return this._o[prop].apply(this._o, arguments);
        };
      } else {
        Object.defineProperty(global[className].prototype, prop, {
          set: function (fn) {
            if (typeof fn === 'function') {
              this._o[prop] = global.zone.bind(fn);
            } else {
              this._o[prop] = fn;
            }
          },
          get: function () {
            return this._o[prop];
          }
        });
      }
    }(prop));
  }
};

module.exports = {
  patchClass: patchClass
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

/*
 * Patches a function that returns a Promise-like instance.
 *
 * This function must be used when either:
 * - Native Promises are not available,
 * - The function returns a Promise-like object.
 *
 * This is required because zones rely on a Promise monkey patch that could not be applied when
 * Promise is not natively available or when the returned object is not an instance of Promise.
 *
 * Note that calling `bindPromiseFn` on a function that returns a native Promise will also work
 * with minimal overhead.
 *
 * ```
 * var boundFunction = bindPromiseFn(FunctionReturningAPromise);
 *
 * boundFunction.then(successHandler, errorHandler);
 * ```
 */
var bindPromiseFn;

if (global.Promise) {
  bindPromiseFn = function (delegate) {
    return function() {
      var delegatePromise = delegate.apply(this, arguments);

      // if the delegate returned an instance of Promise, forward it.
      if (delegatePromise instanceof Promise) {
        return delegatePromise;
      }

      // Otherwise wrap the Promise-like in a global Promise
      return new Promise(function(resolve, reject) {
        delegatePromise.then(resolve, reject);
      });
    };
  };
} else {
  bindPromiseFn = function (delegate) {
    return function () {
      return _patchThenable(delegate.apply(this, arguments));
    };
  };
}


function _patchPromiseFnsOnObject(objectPath, fnNames) {
  var obj = global;

  var exists = objectPath.every(function (segment) {
    obj = obj[segment];
    return obj;
  });

  if (!exists) {
    return;
  }

  fnNames.forEach(function (name) {
    var fn = obj[name];
    if (fn) {
      obj[name] = bindPromiseFn(fn);
    }
  });
}

function _patchThenable(thenable) {
  var then = thenable.then;
  thenable.then = function () {
    var args = utils.bindArguments(arguments);
    var nextThenable = then.apply(thenable, args);
    return _patchThenable(nextThenable);
  };

  var ocatch = thenable.catch;
  thenable.catch = function () {
    var args = utils.bindArguments(arguments);
    var nextThenable = ocatch.apply(thenable, args);
    return _patchThenable(nextThenable);
  };

  return thenable;
}


function apply() {
  // Patch .then() and .catch() on native Promises to execute callbacks in the zone where
  // those functions are called.
  if (global.Promise) {
    utils.patchPrototype(Promise.prototype, [
      'then',
      'catch'
    ]);

    // Patch browser APIs that return a Promise
    var patchFns = [
      // fetch
      [[], ['fetch']],
      [['Response', 'prototype'], ['arrayBuffer', 'blob', 'json', 'text']]
    ];

    patchFns.forEach(function(objPathAndFns) {
      _patchPromiseFnsOnObject(objPathAndFns[0], objPathAndFns[1]);
    });
  }
}

module.exports = {
  apply: apply,
  bindPromiseFn: bindPromiseFn
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],11:[function(require,module,exports){
(function (global){
'use strict';

var webSocketPatch = require('./websocket');
var utils = require('../utils');

var eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');

function apply() {
  if (utils.isWebWorker()){
    // on WebWorker so don't apply patch
    return;
  }

  var supportsWebSocket = typeof WebSocket !== 'undefined';
  if (canPatchViaPropertyDescriptor()) {
    // for browsers that we can patch the descriptor:  Chrome & Firefox
    var onEventNames = eventNames.map(function (property) {
      return 'on' + property;
    });
    utils.patchProperties(HTMLElement.prototype, onEventNames);
    utils.patchProperties(XMLHttpRequest.prototype);
    if (supportsWebSocket) {
      utils.patchProperties(WebSocket.prototype);
    }
  } else {
    // Safari, Android browsers (Jelly Bean)
    patchViaCapturingAllTheEvents();
    utils.patchClass('XMLHttpRequest');
    if (supportsWebSocket) {
      webSocketPatch.apply();
    }
  }
}

function canPatchViaPropertyDescriptor() {
  if (!Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {
    // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
    // IDL interface attributes are not configurable
    var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
    if (desc && !desc.configurable) return false;
  }

  Object.defineProperty(HTMLElement.prototype, 'onclick', {
    get: function () {
      return true;
    }
  });
  var elt = document.createElement('div');
  var result = !!elt.onclick;
  Object.defineProperty(HTMLElement.prototype, 'onclick', {});
  return result;
};

// Whenever any event fires, we check the event target and all parents
// for `onwhatever` properties and replace them with zone-bound functions
// - Chrome (for now)
function patchViaCapturingAllTheEvents() {
  eventNames.forEach(function (property) {
    var onproperty = 'on' + property;
    document.addEventListener(property, function (event) {
      var elt = event.target, bound;
      while (elt) {
        if (elt[onproperty] && !elt[onproperty]._unbound) {
          bound = global.zone.bind(elt[onproperty]);
          bound._unbound = elt[onproperty];
          elt[onproperty] = bound;
        }
        elt = elt.parentElement;
      }
    }, true);
  });
};

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14,"./websocket":13}],12:[function(require,module,exports){
(function (global){
'use strict';

var _redefineProperty = require('./define-property')._redefineProperty;
var utils = require("../utils");

function apply() {
  if (utils.isWebWorker() || !('registerElement' in global.document)) {
    return;
  }

  var _registerElement = document.registerElement;
  var callbacks = [
    'createdCallback',
    'attachedCallback',
    'detachedCallback',
    'attributeChangedCallback'
  ];

  document.registerElement = function (name, opts) {
    if (opts && opts.prototype) {
      callbacks.forEach(function (callback) {
        if (opts.prototype.hasOwnProperty(callback)) {
          var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
          if (descriptor.value) {
            descriptor.value = global.zone.bind(descriptor.value);
            _redefineProperty(opts.prototype, callback, descriptor);
          } else {
            opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);
          }
        } else if (opts.prototype[callback]) {
          opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);
        }
      });
    }

    return _registerElement.apply(document, [name, opts]);
  };
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14,"./define-property":5}],13:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

// we have to patch the instance since the proto is non-configurable
function apply() {
  var WS = global.WebSocket;
  utils.patchEventTargetMethods(WS.prototype);
  global.WebSocket = function(a, b) {
    var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
    var proxySocket;

    // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance
    var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
    if (onmessageDesc && onmessageDesc.configurable === false) {
      proxySocket = Object.create(socket);
      ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function(propName) {
        proxySocket[propName] = function() {
          return socket[propName].apply(socket, arguments);
        };
      });
    } else {
      // we can patch the real socket
      proxySocket = socket;
    }

    utils.patchProperties(proxySocket, ['onclose', 'onerror', 'onmessage', 'onopen']);

    return proxySocket;
  };
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],14:[function(require,module,exports){
(function (global){
'use strict';

function bindArguments(args) {
  for (var i = args.length - 1; i >= 0; i--) {
    if (typeof args[i] === 'function') {
      args[i] = global.zone.bind(args[i]);
    }
  }
  return args;
};

function bindArgumentsOnce(args) {
  for (var i = args.length - 1; i >= 0; i--) {
    if (typeof args[i] === 'function') {
      args[i] = global.zone.bindOnce(args[i]);
    }
  }
  return args;
};

function patchPrototype(obj, fnNames) {
  fnNames.forEach(function (name) {
    var delegate = obj[name];
    if (delegate) {
      obj[name] = function () {
        return delegate.apply(this, bindArguments(arguments));
      };
    }
  });
};

function isWebWorker() {
  return (typeof document === "undefined");
}

function patchProperty(obj, prop) {
  var desc = Object.getOwnPropertyDescriptor(obj, prop) || {
    enumerable: true,
    configurable: true
  };

  // A property descriptor cannot have getter/setter and be writable
  // deleting the writable and value properties avoids this error:
  //
  // TypeError: property descriptors must not specify a value or be writable when a
  // getter or setter has been specified
  delete desc.writable;
  delete desc.value;

  // substr(2) cuz 'onclick' -> 'click', etc
  var eventName = prop.substr(2);
  var _prop = '_' + prop;

  desc.set = function (fn) {
    if (this[_prop]) {
      this.removeEventListener(eventName, this[_prop]);
    }

    if (typeof fn === 'function') {
      this[_prop] = fn;
      this.addEventListener(eventName, fn, false);
    } else {
      this[_prop] = null;
    }
  };

  desc.get = function () {
    return this[_prop];
  };

  Object.defineProperty(obj, prop, desc);
};

function patchProperties(obj, properties) {

  (properties || (function () {
      var props = [];
      for (var prop in obj) {
        props.push(prop);
      }
      return props;
    }()).
    filter(function (propertyName) {
      return propertyName.substr(0,2) === 'on';
    })).
    forEach(function (eventName) {
      patchProperty(obj, eventName);
    });
};

function patchEventTargetMethods(obj) {
  var addDelegate = obj.addEventListener;
  obj.addEventListener = function (eventName, handler) {
    var fn;
    //Ignore special listeners of IE11 & Edge dev tools, see https://github.com/angular/zone.js/issues/150
    if (handler.toString() !== "[object FunctionWrapper]") {
      if (handler.handleEvent) {
        // Have to pass in 'handler' reference as an argument here, otherwise it gets clobbered in
        // IE9 by the arguments[1] assignment at end of this function.
        fn = (function(handler) {
          return function() {
            handler.handleEvent.apply(handler, arguments);
          };
        })(handler);
      } else {
        fn = handler;
      }

      handler._fn = fn;
      handler._bound = handler._bound || {};
      arguments[1] = handler._bound[eventName] = zone.bind(fn);
    }
    return addDelegate.apply(this, arguments);
  };

  var removeDelegate = obj.removeEventListener;
  obj.removeEventListener = function (eventName, handler) {
    if(handler._bound && handler._bound[eventName]) {
      var _bound = handler._bound;
      
      arguments[1] = _bound[eventName];
      delete _bound[eventName];
    }
    var result = removeDelegate.apply(this, arguments);
    global.zone.dequeueTask(handler._fn);
    return result;
  };
};

// wrap some native API on `window`
function patchClass(className) {
  var OriginalClass = global[className];
  if (!OriginalClass) return;

  global[className] = function () {
    var a = bindArguments(arguments);
    switch (a.length) {
      case 0: this._o = new OriginalClass(); break;
      case 1: this._o = new OriginalClass(a[0]); break;
      case 2: this._o = new OriginalClass(a[0], a[1]); break;
      case 3: this._o = new OriginalClass(a[0], a[1], a[2]); break;
      case 4: this._o = new OriginalClass(a[0], a[1], a[2], a[3]); break;
      default: throw new Error('what are you even doing?');
    }
  };

  var instance = new OriginalClass();

  var prop;
  for (prop in instance) {
    (function (prop) {
      if (typeof instance[prop] === 'function') {
        global[className].prototype[prop] = function () {
          return this._o[prop].apply(this._o, arguments);
        };
      } else {
        Object.defineProperty(global[className].prototype, prop, {
          set: function (fn) {
            if (typeof fn === 'function') {
              this._o[prop] = global.zone.bind(fn);
            } else {
              this._o[prop] = fn;
            }
          },
          get: function () {
            return this._o[prop];
          }
        });
      }
    }(prop));
  }

  for (prop in OriginalClass) {
    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
      global[className][prop] = OriginalClass[prop];
    }
  }
};

module.exports = {
  bindArguments: bindArguments,
  bindArgumentsOnce: bindArgumentsOnce,
  patchPrototype: patchPrototype,
  patchProperty: patchProperty,
  patchProperties: patchProperties,
  patchEventTargetMethods: patchEventTargetMethods,
  patchClass: patchClass,
  isWebWorker: isWebWorker
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],15:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.3.0
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFullfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,{},typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

if (!global.Zone) {
  throw new Error('zone.js should be installed before loading the long stack trace zone');
}

global.Zone.longStackTraceZone = require('../zones/long-stack-trace.js');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../zones/long-stack-trace.js":2}],2:[function(require,module,exports){
(function (global){
/*
 * Wrapped stacktrace
 *
 * We need this because in some implementations, constructing a trace is slow
 * and so we want to defer accessing the trace for as long as possible
 */

'use strict';

function _Stacktrace(e) {
  this._e = e;
};

_Stacktrace.prototype.get = function () {
  if (global.zone.stackFramesFilter && this._e.stack) {
    return this._e.stack
      .split('\n')
      .filter(global.zone.stackFramesFilter)
      .join('\n');
  }

  return this._e.stack;
}

function _getStacktraceWithUncaughtError () {
  return new _Stacktrace(new Error());
}

function _getStacktraceWithCaughtError () {
  try {
    throw new Error();
  } catch (e) {
    return new _Stacktrace(e);
  }
}

// Some implementations of exception handling don't create a stack trace if the exception
// isn't thrown, however it's faster not to actually throw the exception.
var stack = _getStacktraceWithUncaughtError();

var _getStacktrace = stack && stack._e.stack
  ? _getStacktraceWithUncaughtError
  : _getStacktraceWithCaughtError;

module.exports = {
  getLongStacktrace: function (exception) {
    var traces = [];
    var currentZone = this;
    if (exception) {
      if (currentZone.stackFramesFilter && exception.stack) {
        traces.push(exception.stack.split('\n')
              .filter(currentZone.stackFramesFilter)
              .join('\n'));
      } else {
        traces.push(exception.stack);
      }
    }
    var now = Date.now();

    while (currentZone && currentZone.constructedAtException) {
      traces.push(
          '--- ' + (Date(currentZone.constructedAtTime)).toString() +
          ' - ' + (now - currentZone.constructedAtTime) + 'ms ago',
          currentZone.constructedAtException.get());
      currentZone = currentZone.parent;
    }

    return traces.join('\n');
  },

  stackFramesFilter: function (line) {
    return /zone(-microtask)?(\.min)?\.js/.test(line);
  },

  onError: function (exception) {
    var reporter = this.reporter || console.log.bind(console);
    reporter(exception.toString());
    reporter(this.getLongStacktrace(exception));
  },

  '$fork': function (parentFork) {
    return function() {
      var newZone = parentFork.apply(this, arguments);
      newZone.constructedAtException = _getStacktrace();
      newZone.constructedAtTime = Date.now();
      return newZone;
    }
  }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);

/**
 @license
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


 */

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

See the License for the specific language governing permissions and
limitations under the License.
***************************************************************************** */
"use strict";
var Reflect;
(function (Reflect) {
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    var __Metadata__ = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param targetKey (Optional) The property key to decorate.
      * @param targetDescriptor (Optional) The property descriptor for the target key
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     C = Reflect.decorate(decoratorsArray, C);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, C, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, C.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(C, "staticMethod",
      *         Reflect.decorate(decoratorsArray, C, "staticMethod",
      *             Object.getOwnPropertyDescriptor(C, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(C.prototype, "method",
      *         Reflect.decorate(decoratorsArray, C.prototype, "method",
      *             Object.getOwnPropertyDescriptor(C.prototype, "method")));
      *
      */
    function decorate(decorators, target, targetKey, targetDescriptor) {
        if (!IsUndefined(targetDescriptor)) {
            if (!IsArray(decorators)) {
                throw new TypeError();
            }
            else if (!IsObject(target)) {
                throw new TypeError();
            }
            else if (IsUndefined(targetKey)) {
                throw new TypeError();
            }
            else if (!IsObject(targetDescriptor)) {
                throw new TypeError();
            }
            targetKey = ToPropertyKey(targetKey);
            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
        }
        else if (!IsUndefined(targetKey)) {
            if (!IsArray(decorators)) {
                throw new TypeError();
            }
            else if (!IsObject(target)) {
                throw new TypeError();
            }
            targetKey = ToPropertyKey(targetKey);
            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
        }
        else {
            if (!IsArray(decorators)) {
                throw new TypeError();
            }
            else if (!IsConstructor(target)) {
                throw new TypeError();
            }
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class C {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, targetKey) {
            if (!IsUndefined(targetKey)) {
                if (!IsObject(target)) {
                    throw new TypeError();
                }
                targetKey = ToPropertyKey(targetKey);
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
            }
            else {
                if (!IsConstructor(target)) {
                    throw new TypeError();
                }
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, undefined);
            }
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param targetKey (Optional) The property key for the target.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, C);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, C, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, C, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryHasMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryGetMetadata(metadataKey, target, targetKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(C);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(C.prototype, "method");
      *
      */
    function getMetadataKeys(target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryMetadataKeys(target, targetKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(C);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(C.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryOwnMetadataKeys(target, targetKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#deletemetadata-metadatakey-p-
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
        if (IsUndefined(metadataMap)) {
            return false;
        }
        if (!metadataMap.delete(metadataKey)) {
            return false;
        }
        if (metadataMap.size > 0) {
            return true;
        }
        var targetMetadata = __Metadata__.get(target);
        targetMetadata.delete(targetKey);
        if (targetMetadata.size > 0) {
            return true;
        }
        __Metadata__.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated)) {
                if (!IsConstructor(decorated)) {
                    throw new TypeError();
                }
                target = decorated;
            }
        }
        return target;
    }
    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated)) {
                if (!IsObject(decorated)) {
                    throw new TypeError();
                }
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            decorator(target, propertyKey);
        }
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#getorcreatemetadatamap--o-p-create-
    function GetOrCreateMetadataMap(target, targetKey, create) {
        var targetMetadata = __Metadata__.get(target);
        if (!targetMetadata) {
            if (!create) {
                return undefined;
            }
            targetMetadata = new _Map();
            __Metadata__.set(target, targetMetadata);
        }
        var keyMetadata = targetMetadata.get(targetKey);
        if (!keyMetadata) {
            if (!create) {
                return undefined;
            }
            keyMetadata = new _Map();
            targetMetadata.set(targetKey, keyMetadata);
        }
        return keyMetadata;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) {
            return true;
        }
        var parent = GetPrototypeOf(O);
        if (parent !== null) {
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        }
        return false;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (metadataMap === undefined) {
            return false;
        }
        return Boolean(metadataMap.has(MetadataKey));
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetmetadata--metadatakey-o-p-
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) {
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        var parent = GetPrototypeOf(O);
        if (parent !== null) {
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        }
        return undefined;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (metadataMap === undefined) {
            return undefined;
        }
        return metadataMap.get(MetadataKey);
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarymetadatakeys--o-p-
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = GetPrototypeOf(O);
        if (parent === null) {
            return ownKeys;
        }
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0) {
            return ownKeys;
        }
        if (ownKeys.length <= 0) {
            return parentKeys;
        }
        var set = new _Set();
        var keys = [];
        for (var _i = 0; _i < ownKeys.length; _i++) {
            var key = ownKeys[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0; _a < parentKeys.length; _a++) {
            var key = parentKeys[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryownmetadatakeys--o-p-
    function OrdinaryOwnMetadataKeys(target, targetKey) {
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
        var keys = [];
        if (metadataMap) {
            metadataMap.forEach(function (_, key) { return keys.push(key); });
        }
        return keys;
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
    function IsArray(x) {
        return Array.isArray(x);
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
    function IsConstructor(x) {
        return typeof x === "function";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
    function ToPropertyKey(value) {
        if (IsSymbol(value)) {
            return value;
        }
        return String(value);
    }
    function GetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype) {
            return proto;
        }
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard. 
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype) {
            return proto;
        }
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype) {
            return proto;
        }
        // if the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function") {
            return proto;
        }
        // if we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O) {
            return proto;
        }
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        function Map() {
            this._keys = [];
            this._values = [];
            this._cache = cacheSentinel;
        }
        Map.prototype = {
            get size() {
                return this._keys.length;
            },
            has: function (key) {
                if (key === this._cache) {
                    return true;
                }
                if (this._find(key) >= 0) {
                    this._cache = key;
                    return true;
                }
                return false;
            },
            get: function (key) {
                var index = this._find(key);
                if (index >= 0) {
                    this._cache = key;
                    return this._values[index];
                }
                return undefined;
            },
            set: function (key, value) {
                this.delete(key);
                this._keys.push(key);
                this._values.push(value);
                this._cache = key;
                return this;
            },
            delete: function (key) {
                var index = this._find(key);
                if (index >= 0) {
                    this._keys.splice(index, 1);
                    this._values.splice(index, 1);
                    this._cache = cacheSentinel;
                    return true;
                }
                return false;
            },
            clear: function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cache = cacheSentinel;
            },
            forEach: function (callback, thisArg) {
                var size = this.size;
                for (var i = 0; i < size; ++i) {
                    var key = this._keys[i];
                    var value = this._values[i];
                    this._cache = key;
                    callback.call(this, value, key, this);
                }
            },
            _find: function (key) {
                var keys = this._keys;
                var size = keys.length;
                for (var i = 0; i < size; ++i) {
                    if (keys[i] === key) {
                        return i;
                    }
                }
                return -1;
            }
        };
        return Map;
    }
    // naive Set shim
    function CreateSetPolyfill() {
        var cacheSentinel = {};
        function Set() {
            this._map = new _Map();
        }
        Set.prototype = {
            get size() {
                return this._map.length;
            },
            has: function (value) {
                return this._map.has(value);
            },
            add: function (value) {
                this._map.set(value, value);
                return this;
            },
            delete: function (value) {
                return this._map.delete(value);
            },
            clear: function () {
                this._map.clear();
            },
            forEach: function (callback, thisArg) {
                this._map.forEach(callback, thisArg);
            }
        };
        return Set;
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var isNode = typeof global !== "undefined" &&
            typeof module === "object" &&
            typeof module.exports === "object" &&
            typeof require === "function";
        var nodeCrypto = isNode && require("crypto");
        var hasOwn = Object.prototype.hasOwnProperty;
        var keys = {};
        var rootKey = CreateUniqueKey();
        function WeakMap() {
            this._key = CreateUniqueKey();
        }
        WeakMap.prototype = {
            has: function (target) {
                var table = GetOrCreateWeakMapTable(target, false);
                if (table) {
                    return this._key in table;
                }
                return false;
            },
            get: function (target) {
                var table = GetOrCreateWeakMapTable(target, false);
                if (table) {
                    return table[this._key];
                }
                return undefined;
            },
            set: function (target, value) {
                var table = GetOrCreateWeakMapTable(target, true);
                table[this._key] = value;
                return this;
            },
            delete: function (target) {
                var table = GetOrCreateWeakMapTable(target, false);
                if (table && this._key in table) {
                    return delete table[this._key];
                }
                return false;
            },
            clear: function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            }
        };
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i) {
                buffer[i] = Math.random() * 255 | 0;
            }
        }
        function GenRandomBytes(size) {
            if (nodeCrypto) {
                var data = nodeCrypto.randomBytes(size);
                return data;
            }
            else if (typeof Uint8Array === "function") {
                var data = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                    crypto.getRandomValues(data);
                }
                else if (typeof msCrypto !== "undefined") {
                    msCrypto.getRandomValues(data);
                }
                else {
                    FillRandomBytes(data, size);
                }
                return data;
            }
            else {
                var data = new Array(size);
                FillRandomBytes(data, size);
                return data;
            }
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122  4.4
            data[6] = data[6] & 0x4f | 0x40;
            data[8] = data[8] & 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8) {
                    result += "-";
                }
                if (byte < 16) {
                    result += "0";
                }
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
        function CreateUniqueKey() {
            var key;
            do {
                key = "@@WeakMap@@" + CreateUUID();
            } while (hasOwn.call(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create) {
                    return undefined;
                }
                Object.defineProperty(target, rootKey, { value: Object.create(null) });
            }
            return target[rootKey];
        }
        return WeakMap;
    }
    // hook global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    __global.Reflect[p] = Reflect[p];
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof window !== "undefined" ? window :
        typeof WorkerGlobalScope !== "undefined" ? self :
            typeof global !== "undefined" ? global :
                Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURLDisabled=Reflect.js.map
/**
 @license

                                 Apache License
                           Version 2.0, January 2011
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

"format register";
/**
 @license
Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.
Microsoft Open Technologies would like to thank its contributors, a list
of whom are at http://rx.codeplex.com/wikipage?title=Contributors.

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License. You may
obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions
and limitations under the License.

 */
System.register("rx", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  ;
  (function(undefined) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    var Rx = {
      internals: {},
      config: {Promise: root.Promise},
      helpers: {}
    };
    var noop = Rx.helpers.noop = function() {},
        notDefined = Rx.helpers.notDefined = function(x) {
          return typeof x === 'undefined';
        },
        isScheduler = Rx.helpers.isScheduler = function(x) {
          return x instanceof Rx.Scheduler;
        },
        identity = Rx.helpers.identity = function(x) {
          return x;
        },
        pluck = Rx.helpers.pluck = function(property) {
          return function(x) {
            return x[property];
          };
        },
        just = Rx.helpers.just = function(value) {
          return function() {
            return value;
          };
        },
        defaultNow = Rx.helpers.defaultNow = Date.now,
        defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
          return isEqual(x, y);
        },
        defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
          return x > y ? 1 : (x < y ? -1 : 0);
        },
        defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
          return x.toString();
        },
        defaultError = Rx.helpers.defaultError = function(err) {
          throw err;
        },
        isPromise = Rx.helpers.isPromise = function(p) {
          return !!p && typeof p.then === 'function';
        },
        asArray = Rx.helpers.asArray = function() {
          return Array.prototype.slice.call(arguments);
        },
        not = Rx.helpers.not = function(a) {
          return !a;
        },
        isFunction = Rx.helpers.isFunction = (function() {
          var isFn = function(value) {
            return typeof value == 'function' || false;
          };
          if (isFn(/x/)) {
            isFn = function(value) {
              return typeof value == 'function' && toString.call(value) == '[object Function]';
            };
          }
          return isFn;
        }());
    function cloneArray(arr) {
      for (var a = [],
          i = 0,
          len = arr.length; i < len; i++) {
        a.push(arr[i]);
      }
      return a;
    }
    Rx.config.longStackSupport = false;
    var hasStacks = false;
    try {
      throw new Error();
    } catch (e) {
      hasStacks = !!e.stack;
    }
    var rStartingLine = captureLine(),
        rFileName;
    var STACK_JUMP_SEPARATOR = "From previous event:";
    function makeStackTraceLong(error, observable) {
      if (hasStacks && observable.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
        var stacks = [];
        for (var o = observable; !!o; o = o.source) {
          if (o.stack) {
            stacks.unshift(o.stack);
          }
        }
        stacks.unshift(error.stack);
        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
      }
    }
    function filterStackString(stackString) {
      var lines = stackString.split("\n"),
          desiredLines = [];
      for (var i = 0,
          len = lines.length; i < len; i++) {
        var line = lines[i];
        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
          desiredLines.push(line);
        }
      }
      return desiredLines.join("\n");
    }
    function isInternalFrame(stackLine) {
      var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
      if (!fileNameAndLineNumber) {
        return false;
      }
      var fileName = fileNameAndLineNumber[0],
          lineNumber = fileNameAndLineNumber[1];
      return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
    }
    function isNodeFrame(stackLine) {
      return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
    }
    function captureLine() {
      if (!hasStacks) {
        return ;
      }
      try {
        throw new Error();
      } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
          return ;
        }
        rFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
      }
    }
    function getFileNameAndLineNumber(stackLine) {
      var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
      if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
      }
      var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
      if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
      }
      var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
      if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
      }
    }
    var EmptyError = Rx.EmptyError = function() {
      this.message = 'Sequence contains no elements.';
      Error.call(this);
    };
    EmptyError.prototype = Error.prototype;
    var ObjectDisposedError = Rx.ObjectDisposedError = function() {
      this.message = 'Object has been disposed';
      Error.call(this);
    };
    ObjectDisposedError.prototype = Error.prototype;
    var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
      this.message = 'Argument out of range';
      Error.call(this);
    };
    ArgumentOutOfRangeError.prototype = Error.prototype;
    var NotSupportedError = Rx.NotSupportedError = function(message) {
      this.message = message || 'This operation is not supported';
      Error.call(this);
    };
    NotSupportedError.prototype = Error.prototype;
    var NotImplementedError = Rx.NotImplementedError = function(message) {
      this.message = message || 'This operation is not implemented';
      Error.call(this);
    };
    NotImplementedError.prototype = Error.prototype;
    var notImplemented = Rx.helpers.notImplemented = function() {
      throw new NotImplementedError();
    };
    var notSupported = Rx.helpers.notSupported = function() {
      throw new NotSupportedError();
    };
    var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
      done: true,
      value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
      return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function(o) {
      return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
      if (typeof thisArg === 'undefined') {
        return func;
      }
      switch (argCount) {
        case 0:
          return function() {
            return func.call(thisArg);
          };
        case 1:
          return function(arg) {
            return func.call(thisArg, arg);
          };
        case 2:
          return function(value, index) {
            return func.call(thisArg, value, index);
          };
        case 3:
          return function(value, index, collection) {
            return func.call(thisArg, value, index, collection);
          };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    };
    var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
        dontEnumsLength = dontEnums.length;
    var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        boolClass = '[object Boolean]',
        dateClass = '[object Date]',
        errorClass = '[object Error]',
        funcClass = '[object Function]',
        numberClass = '[object Number]',
        objectClass = '[object Object]',
        regexpClass = '[object RegExp]',
        stringClass = '[object String]';
    var toString = Object.prototype.toString,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        supportsArgsClass = toString.call(arguments) == argsClass,
        supportNodeClass,
        errorProto = Error.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype,
        propertyIsEnumerable = objectProto.propertyIsEnumerable;
    try {
      supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
    } catch (e) {
      supportNodeClass = true;
    }
    var nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
      'constructor': true,
      'toLocaleString': true,
      'toString': true,
      'valueOf': true
    };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
      'constructor': true,
      'toString': true,
      'valueOf': true
    };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
      'constructor': true,
      'toString': true
    };
    nonEnumProps[objectClass] = {'constructor': true};
    var support = {};
    (function() {
      var ctor = function() {
        this.x = 1;
      },
          props = [];
      ctor.prototype = {
        'valueOf': 1,
        'y': 1
      };
      for (var key in new ctor) {
        props.push(key);
      }
      for (key in arguments) {}
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
      support.nonEnumArgs = key != 0;
      support.nonEnumShadows = !/valueOf/.test(props);
    }(1));
    var isObject = Rx.internals.isObject = function(value) {
      var type = typeof value;
      return value && (type == 'function' || type == 'object') || false;
    };
    function keysIn(object) {
      var result = [];
      if (!isObject(object)) {
        return result;
      }
      if (support.nonEnumArgs && object.length && isArguments(object)) {
        object = slice.call(object);
      }
      var skipProto = support.enumPrototypes && typeof object == 'function',
          skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
      for (var key in object) {
        if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
          result.push(key);
        }
      }
      if (support.nonEnumShadows && object !== objectProto) {
        var ctor = object.constructor,
            index = -1,
            length = dontEnumsLength;
        if (object === (ctor && ctor.prototype)) {
          var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
              nonEnum = nonEnumProps[className];
        }
        while (++index < length) {
          key = dontEnums[index];
          if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
            result.push(key);
          }
        }
      }
      return result;
    }
    function internalFor(object, callback, keysFunc) {
      var index = -1,
          props = keysFunc(object),
          length = props.length;
      while (++index < length) {
        var key = props[index];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }
    function internalForIn(object, callback) {
      return internalFor(object, callback, keysIn);
    }
    function isNode(value) {
      return typeof value.toString != 'function' && typeof(value + '') == 'string';
    }
    var isArguments = function(value) {
      return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
    };
    if (!supportsArgsClass) {
      isArguments = function(value) {
        return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
      };
    }
    var isEqual = Rx.internals.isEqual = function(x, y) {
      return deepEquals(x, y, [], []);
    };
    function deepEquals(a, b, stackA, stackB) {
      if (a === b) {
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;
      if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
        return false;
      }
      var className = toString.call(a),
          otherClass = toString.call(b);
      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          return +a == +b;
        case numberClass:
          return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
        case regexpClass:
        case stringClass:
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
          return false;
        }
        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
        if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      var initedStack = !stackA;
      stackA || (stackA = []);
      stackB || (stackB = []);
      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      var result = true;
      stackA.push(a);
      stackB.push(b);
      if (isArr) {
        length = a.length;
        size = b.length;
        result = size == length;
        if (result) {
          while (size--) {
            var index = length,
                value = b[size];
            if (!(result = deepEquals(a[size], value, stackA, stackB))) {
              break;
            }
          }
        }
      } else {
        internalForIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            size++;
            return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
          }
        });
        if (result) {
          internalForIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();
      return result;
    }
    var hasProp = {}.hasOwnProperty,
        slice = Array.prototype.slice;
    var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
      function __() {
        this.constructor = child;
      }
      __.prototype = parent.prototype;
      child.prototype = new __();
    };
    var addProperties = Rx.internals.addProperties = function(obj) {
      for (var sources = [],
          i = 1,
          len = arguments.length; i < len; i++) {
        sources.push(arguments[i]);
      }
      for (var idx = 0,
          ln = sources.length; idx < ln; idx++) {
        var source = sources[idx];
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    };
    var addRef = Rx.internals.addRef = function(xs, r) {
      return new AnonymousObservable(function(observer) {
        return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
      });
    };
    function arrayInitialize(count, factory) {
      var a = new Array(count);
      for (var i = 0; i < count; i++) {
        a[i] = factory();
      }
      return a;
    }
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function IndexedItem(id, value) {
      this.id = id;
      this.value = value;
    }
    IndexedItem.prototype.compareTo = function(other) {
      var c = this.value.compareTo(other.value);
      c === 0 && (c = this.id - other.id);
      return c;
    };
    var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
      this.items = new Array(capacity);
      this.length = 0;
    };
    var priorityProto = PriorityQueue.prototype;
    priorityProto.isHigherPriority = function(left, right) {
      return this.items[left].compareTo(this.items[right]) < 0;
    };
    priorityProto.percolate = function(index) {
      if (index >= this.length || index < 0) {
        return ;
      }
      var parent = index - 1 >> 1;
      if (parent < 0 || parent === index) {
        return ;
      }
      if (this.isHigherPriority(index, parent)) {
        var temp = this.items[index];
        this.items[index] = this.items[parent];
        this.items[parent] = temp;
        this.percolate(parent);
      }
    };
    priorityProto.heapify = function(index) {
      +index || (index = 0);
      if (index >= this.length || index < 0) {
        return ;
      }
      var left = 2 * index + 1,
          right = 2 * index + 2,
          first = index;
      if (left < this.length && this.isHigherPriority(left, first)) {
        first = left;
      }
      if (right < this.length && this.isHigherPriority(right, first)) {
        first = right;
      }
      if (first !== index) {
        var temp = this.items[index];
        this.items[index] = this.items[first];
        this.items[first] = temp;
        this.heapify(first);
      }
    };
    priorityProto.peek = function() {
      return this.items[0].value;
    };
    priorityProto.removeAt = function(index) {
      this.items[index] = this.items[--this.length];
      this.items[this.length] = undefined;
      this.heapify();
    };
    priorityProto.dequeue = function() {
      var result = this.peek();
      this.removeAt(0);
      return result;
    };
    priorityProto.enqueue = function(item) {
      var index = this.length++;
      this.items[index] = new IndexedItem(PriorityQueue.count++, item);
      this.percolate(index);
    };
    priorityProto.remove = function(item) {
      for (var i = 0; i < this.length; i++) {
        if (this.items[i].value === item) {
          this.removeAt(i);
          return true;
        }
      }
      return false;
    };
    PriorityQueue.count = 0;
    var CompositeDisposable = Rx.CompositeDisposable = function() {
      var args = [],
          i,
          len;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
        len = args.length;
      } else {
        len = arguments.length;
        args = new Array(len);
        for (i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      for (i = 0; i < len; i++) {
        if (!isDisposable(args[i])) {
          throw new TypeError('Not a disposable');
        }
      }
      this.disposables = args;
      this.isDisposed = false;
      this.length = args.length;
    };
    var CompositeDisposablePrototype = CompositeDisposable.prototype;
    CompositeDisposablePrototype.add = function(item) {
      if (this.isDisposed) {
        item.dispose();
      } else {
        this.disposables.push(item);
        this.length++;
      }
    };
    CompositeDisposablePrototype.remove = function(item) {
      var shouldDispose = false;
      if (!this.isDisposed) {
        var idx = this.disposables.indexOf(item);
        if (idx !== -1) {
          shouldDispose = true;
          this.disposables.splice(idx, 1);
          this.length--;
          item.dispose();
        }
      }
      return shouldDispose;
    };
    CompositeDisposablePrototype.dispose = function() {
      if (!this.isDisposed) {
        this.isDisposed = true;
        var len = this.disposables.length,
            currentDisposables = new Array(len);
        for (var i = 0; i < len; i++) {
          currentDisposables[i] = this.disposables[i];
        }
        this.disposables = [];
        this.length = 0;
        for (i = 0; i < len; i++) {
          currentDisposables[i].dispose();
        }
      }
    };
    var Disposable = Rx.Disposable = function(action) {
      this.isDisposed = false;
      this.action = action || noop;
    };
    Disposable.prototype.dispose = function() {
      if (!this.isDisposed) {
        this.action();
        this.isDisposed = true;
      }
    };
    var disposableCreate = Disposable.create = function(action) {
      return new Disposable(action);
    };
    var disposableEmpty = Disposable.empty = {dispose: noop};
    var isDisposable = Disposable.isDisposable = function(d) {
      return d && isFunction(d.dispose);
    };
    var checkDisposed = Disposable.checkDisposed = function(disposable) {
      if (disposable.isDisposed) {
        throw new ObjectDisposedError();
      }
    };
    var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = (function() {
      function BooleanDisposable() {
        this.isDisposed = false;
        this.current = null;
      }
      var booleanDisposablePrototype = BooleanDisposable.prototype;
      booleanDisposablePrototype.getDisposable = function() {
        return this.current;
      };
      booleanDisposablePrototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      booleanDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      return BooleanDisposable;
    }());
    var SerialDisposable = Rx.SerialDisposable = SingleAssignmentDisposable;
    var RefCountDisposable = Rx.RefCountDisposable = (function() {
      function InnerDisposable(disposable) {
        this.disposable = disposable;
        this.disposable.count++;
        this.isInnerDisposed = false;
      }
      InnerDisposable.prototype.dispose = function() {
        if (!this.disposable.isDisposed && !this.isInnerDisposed) {
          this.isInnerDisposed = true;
          this.disposable.count--;
          if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
            this.disposable.isDisposed = true;
            this.disposable.underlyingDisposable.dispose();
          }
        }
      };
      function RefCountDisposable(disposable) {
        this.underlyingDisposable = disposable;
        this.isDisposed = false;
        this.isPrimaryDisposed = false;
        this.count = 0;
      }
      RefCountDisposable.prototype.dispose = function() {
        if (!this.isDisposed && !this.isPrimaryDisposed) {
          this.isPrimaryDisposed = true;
          if (this.count === 0) {
            this.isDisposed = true;
            this.underlyingDisposable.dispose();
          }
        }
      };
      RefCountDisposable.prototype.getDisposable = function() {
        return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
      };
      return RefCountDisposable;
    })();
    function ScheduledDisposable(scheduler, disposable) {
      this.scheduler = scheduler;
      this.disposable = disposable;
      this.isDisposed = false;
    }
    function scheduleItem(s, self) {
      if (!self.isDisposed) {
        self.isDisposed = true;
        self.disposable.dispose();
      }
    }
    ScheduledDisposable.prototype.dispose = function() {
      this.scheduler.scheduleWithState(this, scheduleItem);
    };
    var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
      this.scheduler = scheduler;
      this.state = state;
      this.action = action;
      this.dueTime = dueTime;
      this.comparer = comparer || defaultSubComparer;
      this.disposable = new SingleAssignmentDisposable();
    };
    ScheduledItem.prototype.invoke = function() {
      this.disposable.setDisposable(this.invokeCore());
    };
    ScheduledItem.prototype.compareTo = function(other) {
      return this.comparer(this.dueTime, other.dueTime);
    };
    ScheduledItem.prototype.isCancelled = function() {
      return this.disposable.isDisposed;
    };
    ScheduledItem.prototype.invokeCore = function() {
      return this.action(this.scheduler, this.state);
    };
    var Scheduler = Rx.Scheduler = (function() {
      function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
        this.now = now;
        this._schedule = schedule;
        this._scheduleRelative = scheduleRelative;
        this._scheduleAbsolute = scheduleAbsolute;
      }
      function invokeAction(scheduler, action) {
        action();
        return disposableEmpty;
      }
      var schedulerProto = Scheduler.prototype;
      schedulerProto.schedule = function(action) {
        return this._schedule(action, invokeAction);
      };
      schedulerProto.scheduleWithState = function(state, action) {
        return this._schedule(state, action);
      };
      schedulerProto.scheduleWithRelative = function(dueTime, action) {
        return this._scheduleRelative(action, dueTime, invokeAction);
      };
      schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
        return this._scheduleRelative(state, dueTime, action);
      };
      schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
        return this._scheduleAbsolute(action, dueTime, invokeAction);
      };
      schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
        return this._scheduleAbsolute(state, dueTime, action);
      };
      Scheduler.now = defaultNow;
      Scheduler.normalize = function(timeSpan) {
        timeSpan < 0 && (timeSpan = 0);
        return timeSpan;
      };
      return Scheduler;
    }());
    var normalizeTime = Scheduler.normalize;
    (function(schedulerProto) {
      function invokeRecImmediate(scheduler, pair) {
        var state = pair[0],
            action = pair[1],
            group = new CompositeDisposable();
        function recursiveAction(state1) {
          action(state1, function(state2) {
            var isAdded = false,
                isDone = false,
                d = scheduler.scheduleWithState(state2, function(scheduler1, state3) {
                  if (isAdded) {
                    group.remove(d);
                  } else {
                    isDone = true;
                  }
                  recursiveAction(state3);
                  return disposableEmpty;
                });
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
          });
        }
        recursiveAction(state);
        return group;
      }
      function invokeRecDate(scheduler, pair, method) {
        var state = pair[0],
            action = pair[1],
            group = new CompositeDisposable();
        function recursiveAction(state1) {
          action(state1, function(state2, dueTime1) {
            var isAdded = false,
                isDone = false,
                d = scheduler[method](state2, dueTime1, function(scheduler1, state3) {
                  if (isAdded) {
                    group.remove(d);
                  } else {
                    isDone = true;
                  }
                  recursiveAction(state3);
                  return disposableEmpty;
                });
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
          });
        }
        ;
        recursiveAction(state);
        return group;
      }
      function scheduleInnerRecursive(action, self) {
        action(function(dt) {
          self(action, dt);
        });
      }
      schedulerProto.scheduleRecursive = function(action) {
        return this.scheduleRecursiveWithState(action, function(_action, self) {
          _action(function() {
            self(_action);
          });
        });
      };
      schedulerProto.scheduleRecursiveWithState = function(state, action) {
        return this.scheduleWithState([state, action], invokeRecImmediate);
      };
      schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
        return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
      };
      schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
        return this._scheduleRelative([state, action], dueTime, function(s, p) {
          return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
        });
      };
      schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
        return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
      };
      schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
        return this._scheduleAbsolute([state, action], dueTime, function(s, p) {
          return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
        });
      };
    }(Scheduler.prototype));
    (function(schedulerProto) {
      Scheduler.prototype.schedulePeriodic = function(period, action) {
        return this.schedulePeriodicWithState(null, period, action);
      };
      Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
        if (typeof root.setInterval === 'undefined') {
          throw new NotSupportedError();
        }
        period = normalizeTime(period);
        var s = state,
            id = root.setInterval(function() {
              s = action(s);
            }, period);
        return disposableCreate(function() {
          root.clearInterval(id);
        });
      };
    }(Scheduler.prototype));
    (function(schedulerProto) {
      schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
        return new CatchScheduler(this, handler);
      };
    }(Scheduler.prototype));
    var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
      function tick(command, recurse) {
        recurse(0, this._period);
        try {
          this._state = this._action(this._state);
        } catch (e) {
          this._cancel.dispose();
          throw e;
        }
      }
      function SchedulePeriodicRecursive(scheduler, state, period, action) {
        this._scheduler = scheduler;
        this._state = state;
        this._period = period;
        this._action = action;
      }
      SchedulePeriodicRecursive.prototype.start = function() {
        var d = new SingleAssignmentDisposable();
        this._cancel = d;
        d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
        return d;
      };
      return SchedulePeriodicRecursive;
    }());
    var immediateScheduler = Scheduler.immediate = (function() {
      function scheduleNow(state, action) {
        return action(this, state);
      }
      return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
    }());
    var currentThreadScheduler = Scheduler.currentThread = (function() {
      var queue;
      function runTrampoline() {
        while (queue.length > 0) {
          var item = queue.dequeue();
          !item.isCancelled() && item.invoke();
        }
      }
      function scheduleNow(state, action) {
        var si = new ScheduledItem(this, state, action, this.now());
        if (!queue) {
          queue = new PriorityQueue(4);
          queue.enqueue(si);
          var result = tryCatch(runTrampoline)();
          queue = null;
          if (result === errorObj) {
            return thrower(result.e);
          }
        } else {
          queue.enqueue(si);
        }
        return si.disposable;
      }
      var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      currentScheduler.scheduleRequired = function() {
        return !queue;
      };
      return currentScheduler;
    }());
    var scheduleMethod,
        clearMethod;
    var localTimer = (function() {
      var localSetTimeout,
          localClearTimeout = noop;
      if (!!root.WScript) {
        localSetTimeout = function(fn, time) {
          root.WScript.Sleep(time);
          fn();
        };
      } else if (!!root.setTimeout) {
        localSetTimeout = root.setTimeout;
        localClearTimeout = root.clearTimeout;
      } else {
        throw new NotSupportedError();
      }
      return {
        setTimeout: localSetTimeout,
        clearTimeout: localClearTimeout
      };
    }());
    var localSetTimeout = localTimer.setTimeout,
        localClearTimeout = localTimer.clearTimeout;
    (function() {
      var nextHandle = 1,
          tasksByHandle = {},
          currentlyRunning = false;
      clearMethod = function(handle) {
        delete tasksByHandle[handle];
      };
      function runTask(handle) {
        if (currentlyRunning) {
          localSetTimeout(function() {
            runTask(handle);
          }, 0);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunning = true;
            var result = tryCatch(task)();
            clearMethod(handle);
            currentlyRunning = false;
            if (result === errorObj) {
              return thrower(result.e);
            }
          }
        }
      }
      var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
      var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
      function postMessageSupported() {
        if (!root.postMessage || root.importScripts) {
          return false;
        }
        var isAsync = false,
            oldHandler = root.onmessage;
        root.onmessage = function() {
          isAsync = true;
        };
        root.postMessage('', '*');
        root.onmessage = oldHandler;
        return isAsync;
      }
      if (isFunction(setImmediate)) {
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          setImmediate(function() {
            runTask(id);
          });
          return id;
        };
      } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          process.nextTick(function() {
            runTask(id);
          });
          return id;
        };
      } else if (postMessageSupported()) {
        var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
        function onGlobalPostMessage(event) {
          if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
            runTask(event.data.substring(MSG_PREFIX.length));
          }
        }
        if (root.addEventListener) {
          root.addEventListener('message', onGlobalPostMessage, false);
        } else {
          root.attachEvent('onmessage', onGlobalPostMessage, false);
        }
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          root.postMessage(MSG_PREFIX + currentId, '*');
          return id;
        };
      } else if (!!root.MessageChannel) {
        var channel = new root.MessageChannel();
        channel.port1.onmessage = function(e) {
          runTask(e.data);
        };
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          channel.port2.postMessage(id);
          return id;
        };
      } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
        scheduleMethod = function(action) {
          var scriptElement = root.document.createElement('script');
          var id = nextHandle++;
          tasksByHandle[id] = action;
          scriptElement.onreadystatechange = function() {
            runTask(id);
            scriptElement.onreadystatechange = null;
            scriptElement.parentNode.removeChild(scriptElement);
            scriptElement = null;
          };
          root.document.documentElement.appendChild(scriptElement);
          return id;
        };
      } else {
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          localSetTimeout(function() {
            runTask(id);
          }, 0);
          return id;
        };
      }
    }());
    var timeoutScheduler = Scheduler.timeout = Scheduler.default = (function() {
      function scheduleNow(state, action) {
        var scheduler = this,
            disposable = new SingleAssignmentDisposable();
        var id = scheduleMethod(function() {
          if (!disposable.isDisposed) {
            disposable.setDisposable(action(scheduler, state));
          }
        });
        return new CompositeDisposable(disposable, disposableCreate(function() {
          clearMethod(id);
        }));
      }
      function scheduleRelative(state, dueTime, action) {
        var scheduler = this,
            dt = Scheduler.normalize(dueTime);
        if (dt === 0) {
          return scheduler.scheduleWithState(state, action);
        }
        var disposable = new SingleAssignmentDisposable();
        var id = localSetTimeout(function() {
          if (!disposable.isDisposed) {
            disposable.setDisposable(action(scheduler, state));
          }
        }, dt);
        return new CompositeDisposable(disposable, disposableCreate(function() {
          localClearTimeout(id);
        }));
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
      }
      return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
    })();
    var CatchScheduler = (function(__super__) {
      function scheduleNow(state, action) {
        return this._scheduler.scheduleWithState(state, this._wrap(action));
      }
      function scheduleRelative(state, dueTime, action) {
        return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
      }
      inherits(CatchScheduler, __super__);
      function CatchScheduler(scheduler, handler) {
        this._scheduler = scheduler;
        this._handler = handler;
        this._recursiveOriginal = null;
        this._recursiveWrapper = null;
        __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
      }
      CatchScheduler.prototype._clone = function(scheduler) {
        return new CatchScheduler(scheduler, this._handler);
      };
      CatchScheduler.prototype._wrap = function(action) {
        var parent = this;
        return function(self, state) {
          try {
            return action(parent._getRecursiveWrapper(self), state);
          } catch (e) {
            if (!parent._handler(e)) {
              throw e;
            }
            return disposableEmpty;
          }
        };
      };
      CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
        if (this._recursiveOriginal !== scheduler) {
          this._recursiveOriginal = scheduler;
          var wrapper = this._clone(scheduler);
          wrapper._recursiveOriginal = scheduler;
          wrapper._recursiveWrapper = wrapper;
          this._recursiveWrapper = wrapper;
        }
        return this._recursiveWrapper;
      };
      CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
        var self = this,
            failed = false,
            d = new SingleAssignmentDisposable();
        d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
          if (failed) {
            return null;
          }
          try {
            return action(state1);
          } catch (e) {
            failed = true;
            if (!self._handler(e)) {
              throw e;
            }
            d.dispose();
            return null;
          }
        }));
        return d;
      };
      return CatchScheduler;
    }(Scheduler));
    var Notification = Rx.Notification = (function() {
      function Notification(kind, value, exception, accept, acceptObservable, toString) {
        this.kind = kind;
        this.value = value;
        this.exception = exception;
        this._accept = accept;
        this._acceptObservable = acceptObservable;
        this.toString = toString;
      }
      Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
        return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
      };
      Notification.prototype.toObservable = function(scheduler) {
        var self = this;
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new AnonymousObservable(function(observer) {
          return scheduler.scheduleWithState(self, function(_, notification) {
            notification._acceptObservable(observer);
            notification.kind === 'N' && observer.onCompleted();
          });
        });
      };
      return Notification;
    })();
    var notificationCreateOnNext = Notification.createOnNext = (function() {
      function _accept(onNext) {
        return onNext(this.value);
      }
      function _acceptObservable(observer) {
        return observer.onNext(this.value);
      }
      function toString() {
        return 'OnNext(' + this.value + ')';
      }
      return function(value) {
        return new Notification('N', value, null, _accept, _acceptObservable, toString);
      };
    }());
    var notificationCreateOnError = Notification.createOnError = (function() {
      function _accept(onNext, onError) {
        return onError(this.exception);
      }
      function _acceptObservable(observer) {
        return observer.onError(this.exception);
      }
      function toString() {
        return 'OnError(' + this.exception + ')';
      }
      return function(e) {
        return new Notification('E', null, e, _accept, _acceptObservable, toString);
      };
    }());
    var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
      function _accept(onNext, onError, onCompleted) {
        return onCompleted();
      }
      function _acceptObservable(observer) {
        return observer.onCompleted();
      }
      function toString() {
        return 'OnCompleted()';
      }
      return function() {
        return new Notification('C', null, null, _accept, _acceptObservable, toString);
      };
    }());
    var Enumerator = Rx.internals.Enumerator = function(next) {
      this._next = next;
    };
    Enumerator.prototype.next = function() {
      return this._next();
    };
    Enumerator.prototype[$iterator$] = function() {
      return this;
    };
    var Enumerable = Rx.internals.Enumerable = function(iterator) {
      this._iterator = iterator;
    };
    Enumerable.prototype[$iterator$] = function() {
      return this._iterator();
    };
    Enumerable.prototype.concat = function() {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var e = sources[$iterator$]();
        var isDisposed,
            subscription = new SerialDisposable();
        var cancelable = immediateScheduler.scheduleRecursive(function(self) {
          if (isDisposed) {
            return ;
          }
          try {
            var currentItem = e.next();
          } catch (ex) {
            return o.onError(ex);
          }
          if (currentItem.done) {
            return o.onCompleted();
          }
          var currentValue = currentItem.value;
          isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
          var d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(currentValue.subscribe(function(x) {
            o.onNext(x);
          }, function(err) {
            o.onError(err);
          }, self));
        });
        return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
          isDisposed = true;
        }));
      });
    };
    Enumerable.prototype.catchError = function() {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var e = sources[$iterator$]();
        var isDisposed,
            subscription = new SerialDisposable();
        var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
          if (isDisposed) {
            return ;
          }
          try {
            var currentItem = e.next();
          } catch (ex) {
            return observer.onError(ex);
          }
          if (currentItem.done) {
            if (lastException !== null) {
              o.onError(lastException);
            } else {
              o.onCompleted();
            }
            return ;
          }
          var currentValue = currentItem.value;
          isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
          var d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(currentValue.subscribe(function(x) {
            o.onNext(x);
          }, self, function() {
            o.onCompleted();
          }));
        });
        return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
          isDisposed = true;
        }));
      });
    };
    Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var exceptions = new Subject(),
            notifier = new Subject(),
            handled = notificationHandler(exceptions),
            notificationDisposable = handled.subscribe(notifier);
        var e = sources[$iterator$]();
        var isDisposed,
            lastException,
            subscription = new SerialDisposable();
        var cancelable = immediateScheduler.scheduleRecursive(function(self) {
          if (isDisposed) {
            return ;
          }
          try {
            var currentItem = e.next();
          } catch (ex) {
            return o.onError(ex);
          }
          if (currentItem.done) {
            if (lastException) {
              o.onError(lastException);
            } else {
              o.onCompleted();
            }
            return ;
          }
          var currentValue = currentItem.value;
          isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
          var outer = new SingleAssignmentDisposable();
          var inner = new SingleAssignmentDisposable();
          subscription.setDisposable(new CompositeDisposable(inner, outer));
          outer.setDisposable(currentValue.subscribe(function(x) {
            o.onNext(x);
          }, function(exn) {
            inner.setDisposable(notifier.subscribe(self, function(ex) {
              o.onError(ex);
            }, function() {
              o.onCompleted();
            }));
            exceptions.onNext(exn);
          }, function() {
            o.onCompleted();
          }));
        });
        return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
          isDisposed = true;
        }));
      });
    };
    var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
      if (repeatCount == null) {
        repeatCount = -1;
      }
      return new Enumerable(function() {
        var left = repeatCount;
        return new Enumerator(function() {
          if (left === 0) {
            return doneEnumerator;
          }
          if (left > 0) {
            left--;
          }
          return {
            done: false,
            value: value
          };
        });
      });
    };
    var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
      if (selector) {
        var selectorFn = bindCallback(selector, thisArg, 3);
      }
      return new Enumerable(function() {
        var index = -1;
        return new Enumerator(function() {
          return ++index < source.length ? {
            done: false,
            value: !selector ? source[index] : selectorFn(source[index], index, source)
          } : doneEnumerator;
        });
      });
    };
    var Observer = Rx.Observer = function() {};
    Observer.prototype.toNotifier = function() {
      var observer = this;
      return function(n) {
        return n.accept(observer);
      };
    };
    Observer.prototype.asObserver = function() {
      return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
    };
    Observer.prototype.checked = function() {
      return new CheckedObserver(this);
    };
    var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
      onNext || (onNext = noop);
      onError || (onError = defaultError);
      onCompleted || (onCompleted = noop);
      return new AnonymousObserver(onNext, onError, onCompleted);
    };
    Observer.fromNotifier = function(handler, thisArg) {
      return new AnonymousObserver(function(x) {
        return handler.call(thisArg, notificationCreateOnNext(x));
      }, function(e) {
        return handler.call(thisArg, notificationCreateOnError(e));
      }, function() {
        return handler.call(thisArg, notificationCreateOnCompleted());
      });
    };
    Observer.prototype.notifyOn = function(scheduler) {
      return new ObserveOnObserver(scheduler, this);
    };
    Observer.prototype.makeSafe = function(disposable) {
      return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
    };
    var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
      inherits(AbstractObserver, __super__);
      function AbstractObserver() {
        this.isStopped = false;
        __super__.call(this);
      }
      AbstractObserver.prototype.next = notImplemented;
      AbstractObserver.prototype.error = notImplemented;
      AbstractObserver.prototype.completed = notImplemented;
      AbstractObserver.prototype.onNext = function(value) {
        if (!this.isStopped) {
          this.next(value);
        }
      };
      AbstractObserver.prototype.onError = function(error) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.error(error);
        }
      };
      AbstractObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.completed();
        }
      };
      AbstractObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      AbstractObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.error(e);
          return true;
        }
        return false;
      };
      return AbstractObserver;
    }(Observer));
    var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
      inherits(AnonymousObserver, __super__);
      function AnonymousObserver(onNext, onError, onCompleted) {
        __super__.call(this);
        this._onNext = onNext;
        this._onError = onError;
        this._onCompleted = onCompleted;
      }
      AnonymousObserver.prototype.next = function(value) {
        this._onNext(value);
      };
      AnonymousObserver.prototype.error = function(error) {
        this._onError(error);
      };
      AnonymousObserver.prototype.completed = function() {
        this._onCompleted();
      };
      return AnonymousObserver;
    }(AbstractObserver));
    var CheckedObserver = (function(__super__) {
      inherits(CheckedObserver, __super__);
      function CheckedObserver(observer) {
        __super__.call(this);
        this._observer = observer;
        this._state = 0;
      }
      var CheckedObserverPrototype = CheckedObserver.prototype;
      CheckedObserverPrototype.onNext = function(value) {
        this.checkAccess();
        var res = tryCatch(this._observer.onNext).call(this._observer, value);
        this._state = 0;
        res === errorObj && thrower(res.e);
      };
      CheckedObserverPrototype.onError = function(err) {
        this.checkAccess();
        var res = tryCatch(this._observer.onError).call(this._observer, err);
        this._state = 2;
        res === errorObj && thrower(res.e);
      };
      CheckedObserverPrototype.onCompleted = function() {
        this.checkAccess();
        var res = tryCatch(this._observer.onCompleted).call(this._observer);
        this._state = 2;
        res === errorObj && thrower(res.e);
      };
      CheckedObserverPrototype.checkAccess = function() {
        if (this._state === 1) {
          throw new Error('Re-entrancy detected');
        }
        if (this._state === 2) {
          throw new Error('Observer completed');
        }
        if (this._state === 0) {
          this._state = 1;
        }
      };
      return CheckedObserver;
    }(Observer));
    var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
      inherits(ScheduledObserver, __super__);
      function ScheduledObserver(scheduler, observer) {
        __super__.call(this);
        this.scheduler = scheduler;
        this.observer = observer;
        this.isAcquired = false;
        this.hasFaulted = false;
        this.queue = [];
        this.disposable = new SerialDisposable();
      }
      ScheduledObserver.prototype.next = function(value) {
        var self = this;
        this.queue.push(function() {
          self.observer.onNext(value);
        });
      };
      ScheduledObserver.prototype.error = function(e) {
        var self = this;
        this.queue.push(function() {
          self.observer.onError(e);
        });
      };
      ScheduledObserver.prototype.completed = function() {
        var self = this;
        this.queue.push(function() {
          self.observer.onCompleted();
        });
      };
      ScheduledObserver.prototype.ensureActive = function() {
        var isOwner = false,
            parent = this;
        if (!this.hasFaulted && this.queue.length > 0) {
          isOwner = !this.isAcquired;
          this.isAcquired = true;
        }
        if (isOwner) {
          this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(self) {
            var work;
            if (parent.queue.length > 0) {
              work = parent.queue.shift();
            } else {
              parent.isAcquired = false;
              return ;
            }
            try {
              work();
            } catch (ex) {
              parent.queue = [];
              parent.hasFaulted = true;
              throw ex;
            }
            self();
          }));
        }
      };
      ScheduledObserver.prototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        this.disposable.dispose();
      };
      return ScheduledObserver;
    }(AbstractObserver));
    var ObserveOnObserver = (function(__super__) {
      inherits(ObserveOnObserver, __super__);
      function ObserveOnObserver(scheduler, observer, cancel) {
        __super__.call(this, scheduler, observer);
        this._cancel = cancel;
      }
      ObserveOnObserver.prototype.next = function(value) {
        __super__.prototype.next.call(this, value);
        this.ensureActive();
      };
      ObserveOnObserver.prototype.error = function(e) {
        __super__.prototype.error.call(this, e);
        this.ensureActive();
      };
      ObserveOnObserver.prototype.completed = function() {
        __super__.prototype.completed.call(this);
        this.ensureActive();
      };
      ObserveOnObserver.prototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        this._cancel && this._cancel.dispose();
        this._cancel = null;
      };
      return ObserveOnObserver;
    })(ScheduledObserver);
    var observableProto;
    var Observable = Rx.Observable = (function() {
      function Observable(subscribe) {
        if (Rx.config.longStackSupport && hasStacks) {
          try {
            throw new Error();
          } catch (e) {
            this.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          }
          var self = this;
          this._subscribe = function(observer) {
            var oldOnError = observer.onError.bind(observer);
            observer.onError = function(err) {
              makeStackTraceLong(err, self);
              oldOnError(err);
            };
            return subscribe.call(self, observer);
          };
        } else {
          this._subscribe = subscribe;
        }
      }
      observableProto = Observable.prototype;
      observableProto.subscribe = observableProto.forEach = function(observerOrOnNext, onError, onCompleted) {
        return this._subscribe(typeof observerOrOnNext === 'object' ? observerOrOnNext : observerCreate(observerOrOnNext, onError, onCompleted));
      };
      observableProto.subscribeOnNext = function(onNext, thisArg) {
        return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext));
      };
      observableProto.subscribeOnError = function(onError, thisArg) {
        return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError));
      };
      observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
        return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted));
      };
      return Observable;
    })();
    var ObservableBase = Rx.ObservableBase = (function(__super__) {
      inherits(ObservableBase, __super__);
      function fixSubscriber(subscriber) {
        return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
      }
      function setDisposable(s, state) {
        var ado = state[0],
            self = state[1];
        var sub = tryCatch(self.subscribeCore).call(self, ado);
        if (sub === errorObj) {
          if (!ado.fail(errorObj.e)) {
            return thrower(errorObj.e);
          }
        }
        ado.setDisposable(fixSubscriber(sub));
      }
      function subscribe(observer) {
        var ado = new AutoDetachObserver(observer),
            state = [ado, this];
        if (currentThreadScheduler.scheduleRequired()) {
          currentThreadScheduler.scheduleWithState(state, setDisposable);
        } else {
          setDisposable(null, state);
        }
        return ado;
      }
      function ObservableBase() {
        __super__.call(this, subscribe);
      }
      ObservableBase.prototype.subscribeCore = notImplemented;
      return ObservableBase;
    }(Observable));
    observableProto.observeOn = function(scheduler) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        return source.subscribe(new ObserveOnObserver(scheduler, observer));
      }, source);
    };
    observableProto.subscribeOn = function(scheduler) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var m = new SingleAssignmentDisposable(),
            d = new SerialDisposable();
        d.setDisposable(m);
        m.setDisposable(scheduler.schedule(function() {
          d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
        }));
        return d;
      }, source);
    };
    var observableFromPromise = Observable.fromPromise = function(promise) {
      return observableDefer(function() {
        var subject = new Rx.AsyncSubject();
        promise.then(function(value) {
          subject.onNext(value);
          subject.onCompleted();
        }, subject.onError.bind(subject));
        return subject;
      });
    };
    observableProto.toPromise = function(promiseCtor) {
      promiseCtor || (promiseCtor = Rx.config.Promise);
      if (!promiseCtor) {
        throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
      }
      var source = this;
      return new promiseCtor(function(resolve, reject) {
        var value,
            hasValue = false;
        source.subscribe(function(v) {
          value = v;
          hasValue = true;
        }, reject, function() {
          hasValue && resolve(value);
        });
      });
    };
    var ToArrayObservable = (function(__super__) {
      inherits(ToArrayObservable, __super__);
      function ToArrayObservable(source) {
        this.source = source;
        __super__.call(this);
      }
      ToArrayObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new ToArrayObserver(observer));
      };
      return ToArrayObservable;
    }(ObservableBase));
    function ToArrayObserver(observer) {
      this.observer = observer;
      this.a = [];
      this.isStopped = false;
    }
    ToArrayObserver.prototype.onNext = function(x) {
      if (!this.isStopped) {
        this.a.push(x);
      }
    };
    ToArrayObserver.prototype.onError = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
      }
    };
    ToArrayObserver.prototype.onCompleted = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onNext(this.a);
        this.observer.onCompleted();
      }
    };
    ToArrayObserver.prototype.dispose = function() {
      this.isStopped = true;
    };
    ToArrayObserver.prototype.fail = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }
      return false;
    };
    observableProto.toArray = function() {
      return new ToArrayObservable(this);
    };
    Observable.create = Observable.createWithDisposable = function(subscribe, parent) {
      return new AnonymousObservable(subscribe, parent);
    };
    var observableDefer = Observable.defer = function(observableFactory) {
      return new AnonymousObservable(function(observer) {
        var result;
        try {
          result = observableFactory();
        } catch (e) {
          return observableThrow(e).subscribe(observer);
        }
        isPromise(result) && (result = observableFromPromise(result));
        return result.subscribe(observer);
      });
    };
    var observableEmpty = Observable.empty = function(scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithState(null, function() {
          observer.onCompleted();
        });
      });
    };
    var FromObservable = (function(__super__) {
      inherits(FromObservable, __super__);
      function FromObservable(iterable, mapper, scheduler) {
        this.iterable = iterable;
        this.mapper = mapper;
        this.scheduler = scheduler;
        __super__.call(this);
      }
      FromObservable.prototype.subscribeCore = function(observer) {
        var sink = new FromSink(observer, this);
        return sink.run();
      };
      return FromObservable;
    }(ObservableBase));
    var FromSink = (function() {
      function FromSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromSink.prototype.run = function() {
        var list = Object(this.parent.iterable),
            it = getIterable(list),
            observer = this.observer,
            mapper = this.parent.mapper;
        function loopRecursive(i, recurse) {
          try {
            var next = it.next();
          } catch (e) {
            return observer.onError(e);
          }
          if (next.done) {
            return observer.onCompleted();
          }
          var result = next.value;
          if (mapper) {
            try {
              result = mapper(result, i);
            } catch (e) {
              return observer.onError(e);
            }
          }
          observer.onNext(result);
          recurse(i + 1);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      return FromSink;
    }());
    var maxSafeInteger = Math.pow(2, 53) - 1;
    function StringIterable(str) {
      this._s = s;
    }
    StringIterable.prototype[$iterator$] = function() {
      return new StringIterator(this._s);
    };
    function StringIterator(str) {
      this._s = s;
      this._l = s.length;
      this._i = 0;
    }
    StringIterator.prototype[$iterator$] = function() {
      return this;
    };
    StringIterator.prototype.next = function() {
      return this._i < this._l ? {
        done: false,
        value: this._s.charAt(this._i++)
      } : doneEnumerator;
    };
    function ArrayIterable(a) {
      this._a = a;
    }
    ArrayIterable.prototype[$iterator$] = function() {
      return new ArrayIterator(this._a);
    };
    function ArrayIterator(a) {
      this._a = a;
      this._l = toLength(a);
      this._i = 0;
    }
    ArrayIterator.prototype[$iterator$] = function() {
      return this;
    };
    ArrayIterator.prototype.next = function() {
      return this._i < this._l ? {
        done: false,
        value: this._a[this._i++]
      } : doneEnumerator;
    };
    function numberIsFinite(value) {
      return typeof value === 'number' && root.isFinite(value);
    }
    function isNan(n) {
      return n !== n;
    }
    function getIterable(o) {
      var i = o[$iterator$],
          it;
      if (!i && typeof o === 'string') {
        it = new StringIterable(o);
        return it[$iterator$]();
      }
      if (!i && o.length !== undefined) {
        it = new ArrayIterable(o);
        return it[$iterator$]();
      }
      if (!i) {
        throw new TypeError('Object is not iterable');
      }
      return o[$iterator$]();
    }
    function sign(value) {
      var number = +value;
      if (number === 0) {
        return number;
      }
      if (isNaN(number)) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }
    function toLength(o) {
      var len = +o.length;
      if (isNaN(len)) {
        return 0;
      }
      if (len === 0 || !numberIsFinite(len)) {
        return len;
      }
      len = sign(len) * Math.floor(Math.abs(len));
      if (len <= 0) {
        return 0;
      }
      if (len > maxSafeInteger) {
        return maxSafeInteger;
      }
      return len;
    }
    var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
      if (iterable == null) {
        throw new Error('iterable cannot be null.');
      }
      if (mapFn && !isFunction(mapFn)) {
        throw new Error('mapFn when provided must be a function');
      }
      if (mapFn) {
        var mapper = bindCallback(mapFn, thisArg, 2);
      }
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new FromObservable(iterable, mapper, scheduler);
    };
    var FromArrayObservable = (function(__super__) {
      inherits(FromArrayObservable, __super__);
      function FromArrayObservable(args, scheduler) {
        this.args = args;
        this.scheduler = scheduler;
        __super__.call(this);
      }
      FromArrayObservable.prototype.subscribeCore = function(observer) {
        var sink = new FromArraySink(observer, this);
        return sink.run();
      };
      return FromArrayObservable;
    }(ObservableBase));
    function FromArraySink(observer, parent) {
      this.observer = observer;
      this.parent = parent;
    }
    FromArraySink.prototype.run = function() {
      var observer = this.observer,
          args = this.parent.args,
          len = args.length;
      function loopRecursive(i, recurse) {
        if (i < len) {
          observer.onNext(args[i]);
          recurse(i + 1);
        } else {
          observer.onCompleted();
        }
      }
      return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
    };
    var observableFromArray = Observable.fromArray = function(array, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new FromArrayObservable(array, scheduler);
    };
    Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new AnonymousObservable(function(o) {
        var first = true;
        return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
          var hasResult,
              result;
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            hasResult && (result = resultSelector(state));
          } catch (e) {
            return o.onError(e);
          }
          if (hasResult) {
            o.onNext(result);
            self(state);
          } else {
            o.onCompleted();
          }
        });
      });
    };
    var observableNever = Observable.never = function() {
      return new AnonymousObservable(function() {
        return disposableEmpty;
      });
    };
    function observableOf(scheduler, array) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new FromArrayObservable(array, scheduler);
    }
    Observable.of = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return new FromArrayObservable(args, currentThreadScheduler);
    };
    Observable.ofWithScheduler = function(scheduler) {
      var len = arguments.length,
          args = new Array(len - 1);
      for (var i = 1; i < len; i++) {
        args[i - 1] = arguments[i];
      }
      return new FromArrayObservable(args, scheduler);
    };
    Observable.pairs = function(obj, scheduler) {
      scheduler || (scheduler = Rx.Scheduler.currentThread);
      return new AnonymousObservable(function(observer) {
        var keys = Object.keys(obj),
            len = keys.length;
        return scheduler.scheduleRecursiveWithState(0, function(idx, self) {
          if (idx < len) {
            var key = keys[idx];
            observer.onNext([key, obj[key]]);
            self(idx + 1);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    var RangeObservable = (function(__super__) {
      inherits(RangeObservable, __super__);
      function RangeObservable(start, count, scheduler) {
        this.start = start;
        this.count = count;
        this.scheduler = scheduler;
        __super__.call(this);
      }
      RangeObservable.prototype.subscribeCore = function(observer) {
        var sink = new RangeSink(observer, this);
        return sink.run();
      };
      return RangeObservable;
    }(ObservableBase));
    var RangeSink = (function() {
      function RangeSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RangeSink.prototype.run = function() {
        var start = this.parent.start,
            count = this.parent.count,
            observer = this.observer;
        function loopRecursive(i, recurse) {
          if (i < count) {
            observer.onNext(start + i);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      return RangeSink;
    }());
    Observable.range = function(start, count, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new RangeObservable(start, count, scheduler);
    };
    Observable.repeat = function(value, repeatCount, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return observableReturn(value, scheduler).repeat(repeatCount == null ? -1 : repeatCount);
    };
    var observableReturn = Observable['return'] = Observable.just = Observable.returnValue = function(value, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function(o) {
        return scheduler.scheduleWithState(value, function(_, v) {
          o.onNext(v);
          o.onCompleted();
        });
      });
    };
    var observableThrow = Observable['throw'] = Observable.throwError = function(error, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function(observer) {
        return scheduler.schedule(function() {
          observer.onError(error);
        });
      });
    };
    Observable.throwException = function() {
      return Observable.throwError.apply(null, arguments);
    };
    Observable.using = function(resourceFactory, observableFactory) {
      return new AnonymousObservable(function(observer) {
        var disposable = disposableEmpty,
            resource,
            source;
        try {
          resource = resourceFactory();
          resource && (disposable = resource);
          source = observableFactory(resource);
        } catch (exception) {
          return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
        }
        return new CompositeDisposable(source.subscribe(observer), disposable);
      });
    };
    observableProto.amb = function(rightSource) {
      var leftSource = this;
      return new AnonymousObservable(function(observer) {
        var choice,
            leftChoice = 'L',
            rightChoice = 'R',
            leftSubscription = new SingleAssignmentDisposable(),
            rightSubscription = new SingleAssignmentDisposable();
        isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
        function choiceL() {
          if (!choice) {
            choice = leftChoice;
            rightSubscription.dispose();
          }
        }
        function choiceR() {
          if (!choice) {
            choice = rightChoice;
            leftSubscription.dispose();
          }
        }
        leftSubscription.setDisposable(leftSource.subscribe(function(left) {
          choiceL();
          if (choice === leftChoice) {
            observer.onNext(left);
          }
        }, function(err) {
          choiceL();
          if (choice === leftChoice) {
            observer.onError(err);
          }
        }, function() {
          choiceL();
          if (choice === leftChoice) {
            observer.onCompleted();
          }
        }));
        rightSubscription.setDisposable(rightSource.subscribe(function(right) {
          choiceR();
          if (choice === rightChoice) {
            observer.onNext(right);
          }
        }, function(err) {
          choiceR();
          if (choice === rightChoice) {
            observer.onError(err);
          }
        }, function() {
          choiceR();
          if (choice === rightChoice) {
            observer.onCompleted();
          }
        }));
        return new CompositeDisposable(leftSubscription, rightSubscription);
      });
    };
    Observable.amb = function() {
      var acc = observableNever(),
          items = [];
      if (Array.isArray(arguments[0])) {
        items = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          items.push(arguments[i]);
        }
      }
      function func(previous, current) {
        return previous.amb(current);
      }
      for (var i = 0,
          len = items.length; i < len; i++) {
        acc = func(acc, items[i]);
      }
      return acc;
    };
    function observableCatchHandler(source, handler) {
      return new AnonymousObservable(function(o) {
        var d1 = new SingleAssignmentDisposable(),
            subscription = new SerialDisposable();
        subscription.setDisposable(d1);
        d1.setDisposable(source.subscribe(function(x) {
          o.onNext(x);
        }, function(e) {
          try {
            var result = handler(e);
          } catch (ex) {
            return o.onError(ex);
          }
          isPromise(result) && (result = observableFromPromise(result));
          var d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(result.subscribe(o));
        }, function(x) {
          o.onCompleted(x);
        }));
        return subscription;
      }, source);
    }
    observableProto['catch'] = observableProto.catchError = observableProto.catchException = function(handlerOrSecond) {
      return typeof handlerOrSecond === 'function' ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
    };
    var observableCatch = Observable.catchError = Observable['catch'] = Observable.catchException = function() {
      var items = [];
      if (Array.isArray(arguments[0])) {
        items = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          items.push(arguments[i]);
        }
      }
      return enumerableOf(items).catchError();
    };
    observableProto.combineLatest = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      if (Array.isArray(args[0])) {
        args[0].unshift(this);
      } else {
        args.unshift(this);
      }
      return combineLatest.apply(this, args);
    };
    var combineLatest = Observable.combineLatest = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var resultSelector = args.pop();
      Array.isArray(args[0]) && (args = args[0]);
      return new AnonymousObservable(function(o) {
        var n = args.length,
            falseFactory = function() {
              return false;
            },
            hasValue = arrayInitialize(n, falseFactory),
            hasValueAll = false,
            isDone = arrayInitialize(n, falseFactory),
            values = new Array(n);
        function next(i) {
          hasValue[i] = true;
          if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
            try {
              var res = resultSelector.apply(null, values);
            } catch (e) {
              return o.onError(e);
            }
            o.onNext(res);
          } else if (isDone.filter(function(x, j) {
            return j !== i;
          }).every(identity)) {
            o.onCompleted();
          }
        }
        function done(i) {
          isDone[i] = true;
          isDone.every(identity) && o.onCompleted();
        }
        var subscriptions = new Array(n);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            var source = args[i],
                sad = new SingleAssignmentDisposable();
            isPromise(source) && (source = observableFromPromise(source));
            sad.setDisposable(source.subscribe(function(x) {
              values[i] = x;
              next(i);
            }, function(e) {
              o.onError(e);
            }, function() {
              done(i);
            }));
            subscriptions[i] = sad;
          }(idx));
        }
        return new CompositeDisposable(subscriptions);
      }, this);
    };
    observableProto.concat = function() {
      for (var args = [],
          i = 0,
          len = arguments.length; i < len; i++) {
        args.push(arguments[i]);
      }
      args.unshift(this);
      return observableConcat.apply(null, args);
    };
    var observableConcat = Observable.concat = function() {
      var args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(arguments.length);
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return enumerableOf(args).concat();
    };
    observableProto.concatAll = observableProto.concatObservable = function() {
      return this.merge(1);
    };
    var MergeObservable = (function(__super__) {
      inherits(MergeObservable, __super__);
      function MergeObservable(source, maxConcurrent) {
        this.source = source;
        this.maxConcurrent = maxConcurrent;
        __super__.call(this);
      }
      MergeObservable.prototype.subscribeCore = function(observer) {
        var g = new CompositeDisposable();
        g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
        return g;
      };
      return MergeObservable;
    }(ObservableBase));
    var MergeObserver = (function() {
      function MergeObserver(o, max, g) {
        this.o = o;
        this.max = max;
        this.g = g;
        this.done = false;
        this.q = [];
        this.activeCount = 0;
        this.isStopped = false;
      }
      MergeObserver.prototype.handleSubscribe = function(xs) {
        var sad = new SingleAssignmentDisposable();
        this.g.add(sad);
        isPromise(xs) && (xs = observableFromPromise(xs));
        sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
      };
      MergeObserver.prototype.onNext = function(innerSource) {
        if (this.isStopped) {
          return ;
        }
        if (this.activeCount < this.max) {
          this.activeCount++;
          this.handleSubscribe(innerSource);
        } else {
          this.q.push(innerSource);
        }
      };
      MergeObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      MergeObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.done = true;
          this.activeCount === 0 && this.o.onCompleted();
        }
      };
      MergeObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      MergeObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      function InnerObserver(parent, sad) {
        this.parent = parent;
        this.sad = sad;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (!this.isStopped) {
          this.parent.o.onNext(x);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          var parent = this.parent;
          parent.g.remove(this.sad);
          if (parent.q.length > 0) {
            parent.handleSubscribe(parent.q.shift());
          } else {
            parent.activeCount--;
            parent.done && parent.activeCount === 0 && parent.o.onCompleted();
          }
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
          return true;
        }
        return false;
      };
      return MergeObserver;
    }());
    observableProto.merge = function(maxConcurrentOrOther) {
      return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
    };
    var observableMerge = Observable.merge = function() {
      var scheduler,
          sources = [],
          i,
          len = arguments.length;
      if (!arguments[0]) {
        scheduler = immediateScheduler;
        for (i = 1; i < len; i++) {
          sources.push(arguments[i]);
        }
      } else if (isScheduler(arguments[0])) {
        scheduler = arguments[0];
        for (i = 1; i < len; i++) {
          sources.push(arguments[i]);
        }
      } else {
        scheduler = immediateScheduler;
        for (i = 0; i < len; i++) {
          sources.push(arguments[i]);
        }
      }
      if (Array.isArray(sources[0])) {
        sources = sources[0];
      }
      return observableOf(scheduler, sources).mergeAll();
    };
    var CompositeError = Rx.CompositeError = function(errors) {
      this.name = "NotImplementedError";
      this.innerErrors = errors;
      this.message = 'This contains multiple errors. Check the innerErrors';
      Error.call(this);
    };
    CompositeError.prototype = Error.prototype;
    Observable.mergeDelayError = function() {
      var args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        var len = arguments.length;
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      var source = observableOf(null, args);
      return new AnonymousObservable(function(o) {
        var group = new CompositeDisposable(),
            m = new SingleAssignmentDisposable(),
            isStopped = false,
            errors = [];
        function setCompletion() {
          if (errors.length === 0) {
            o.onCompleted();
          } else if (errors.length === 1) {
            o.onError(errors[0]);
          } else {
            o.onError(new CompositeError(errors));
          }
        }
        group.add(m);
        m.setDisposable(source.subscribe(function(innerSource) {
          var innerSubscription = new SingleAssignmentDisposable();
          group.add(innerSubscription);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          innerSubscription.setDisposable(innerSource.subscribe(function(x) {
            o.onNext(x);
          }, function(e) {
            errors.push(e);
            group.remove(innerSubscription);
            isStopped && group.length === 1 && setCompletion();
          }, function() {
            group.remove(innerSubscription);
            isStopped && group.length === 1 && setCompletion();
          }));
        }, function(e) {
          errors.push(e);
          isStopped = true;
          group.length === 1 && setCompletion();
        }, function() {
          isStopped = true;
          group.length === 1 && setCompletion();
        }));
        return group;
      });
    };
    var MergeAllObservable = (function(__super__) {
      inherits(MergeAllObservable, __super__);
      function MergeAllObservable(source) {
        this.source = source;
        __super__.call(this);
      }
      MergeAllObservable.prototype.subscribeCore = function(observer) {
        var g = new CompositeDisposable(),
            m = new SingleAssignmentDisposable();
        g.add(m);
        m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
        return g;
      };
      return MergeAllObservable;
    }(ObservableBase));
    var MergeAllObserver = (function() {
      function MergeAllObserver(o, g) {
        this.o = o;
        this.g = g;
        this.isStopped = false;
        this.done = false;
      }
      MergeAllObserver.prototype.onNext = function(innerSource) {
        if (this.isStopped) {
          return ;
        }
        var sad = new SingleAssignmentDisposable();
        this.g.add(sad);
        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
        sad.setDisposable(innerSource.subscribe(new InnerObserver(this, this.g, sad)));
      };
      MergeAllObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      MergeAllObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.done = true;
          this.g.length === 1 && this.o.onCompleted();
        }
      };
      MergeAllObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      MergeAllObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      function InnerObserver(parent, g, sad) {
        this.parent = parent;
        this.g = g;
        this.sad = sad;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (!this.isStopped) {
          this.parent.o.onNext(x);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          var parent = this.parent;
          this.isStopped = true;
          parent.g.remove(this.sad);
          parent.done && parent.g.length === 1 && parent.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
          return true;
        }
        return false;
      };
      return MergeAllObserver;
    }());
    observableProto.mergeAll = observableProto.mergeObservable = function() {
      return new MergeAllObservable(this);
    };
    observableProto.onErrorResumeNext = function(second) {
      if (!second) {
        throw new Error('Second observable is required');
      }
      return onErrorResumeNext([this, second]);
    };
    var onErrorResumeNext = Observable.onErrorResumeNext = function() {
      var sources = [];
      if (Array.isArray(arguments[0])) {
        sources = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
      }
      return new AnonymousObservable(function(observer) {
        var pos = 0,
            subscription = new SerialDisposable(),
            cancelable = immediateScheduler.scheduleRecursive(function(self) {
              var current,
                  d;
              if (pos < sources.length) {
                current = sources[pos++];
                isPromise(current) && (current = observableFromPromise(current));
                d = new SingleAssignmentDisposable();
                subscription.setDisposable(d);
                d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
              } else {
                observer.onCompleted();
              }
            });
        return new CompositeDisposable(subscription, cancelable);
      });
    };
    observableProto.skipUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var isOpen = false;
        var disposables = new CompositeDisposable(source.subscribe(function(left) {
          isOpen && o.onNext(left);
        }, function(e) {
          o.onError(e);
        }, function() {
          isOpen && o.onCompleted();
        }));
        isPromise(other) && (other = observableFromPromise(other));
        var rightSubscription = new SingleAssignmentDisposable();
        disposables.add(rightSubscription);
        rightSubscription.setDisposable(other.subscribe(function() {
          isOpen = true;
          rightSubscription.dispose();
        }, function(e) {
          o.onError(e);
        }, function() {
          rightSubscription.dispose();
        }));
        return disposables;
      }, source);
    };
    observableProto['switch'] = observableProto.switchLatest = function() {
      var sources = this;
      return new AnonymousObservable(function(observer) {
        var hasLatest = false,
            innerSubscription = new SerialDisposable(),
            isStopped = false,
            latest = 0,
            subscription = sources.subscribe(function(innerSource) {
              var d = new SingleAssignmentDisposable(),
                  id = ++latest;
              hasLatest = true;
              innerSubscription.setDisposable(d);
              isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
              d.setDisposable(innerSource.subscribe(function(x) {
                latest === id && observer.onNext(x);
              }, function(e) {
                latest === id && observer.onError(e);
              }, function() {
                if (latest === id) {
                  hasLatest = false;
                  isStopped && observer.onCompleted();
                }
              }));
            }, function(e) {
              observer.onError(e);
            }, function() {
              isStopped = true;
              !hasLatest && observer.onCompleted();
            });
        return new CompositeDisposable(subscription, innerSubscription);
      }, sources);
    };
    observableProto.takeUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(o) {
        isPromise(other) && (other = observableFromPromise(other));
        return new CompositeDisposable(source.subscribe(o), other.subscribe(function() {
          o.onCompleted();
        }, function(e) {
          o.onError(e);
        }, noop));
      }, source);
    };
    observableProto.withLatestFrom = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var resultSelector = args.pop(),
          source = this;
      if (typeof source === 'undefined') {
        throw new Error('Source observable not found for withLatestFrom().');
      }
      if (typeof resultSelector !== 'function') {
        throw new Error('withLatestFrom() expects a resultSelector function.');
      }
      if (Array.isArray(args[0])) {
        args = args[0];
      }
      return new AnonymousObservable(function(observer) {
        var falseFactory = function() {
          return false;
        },
            n = args.length,
            hasValue = arrayInitialize(n, falseFactory),
            hasValueAll = false,
            values = new Array(n);
        var subscriptions = new Array(n + 1);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            var other = args[i],
                sad = new SingleAssignmentDisposable();
            isPromise(other) && (other = observableFromPromise(other));
            sad.setDisposable(other.subscribe(function(x) {
              values[i] = x;
              hasValue[i] = true;
              hasValueAll = hasValue.every(identity);
            }, observer.onError.bind(observer), function() {}));
            subscriptions[i] = sad;
          }(idx));
        }
        var sad = new SingleAssignmentDisposable();
        sad.setDisposable(source.subscribe(function(x) {
          var res;
          var allValues = [x].concat(values);
          if (!hasValueAll)
            return ;
          try {
            res = resultSelector.apply(null, allValues);
          } catch (ex) {
            observer.onError(ex);
            return ;
          }
          observer.onNext(res);
        }, observer.onError.bind(observer), function() {
          observer.onCompleted();
        }));
        subscriptions[n] = sad;
        return new CompositeDisposable(subscriptions);
      }, this);
    };
    function zipArray(second, resultSelector) {
      var first = this;
      return new AnonymousObservable(function(observer) {
        var index = 0,
            len = second.length;
        return first.subscribe(function(left) {
          if (index < len) {
            var right = second[index++],
                result;
            try {
              result = resultSelector(left, right);
            } catch (e) {
              return observer.onError(e);
            }
            observer.onNext(result);
          } else {
            observer.onCompleted();
          }
        }, function(e) {
          observer.onError(e);
        }, function() {
          observer.onCompleted();
        });
      }, first);
    }
    function falseFactory() {
      return false;
    }
    function emptyArrayFactory() {
      return [];
    }
    observableProto.zip = function() {
      if (Array.isArray(arguments[0])) {
        return zipArray.apply(this, arguments);
      }
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var parent = this,
          resultSelector = args.pop();
      args.unshift(parent);
      return new AnonymousObservable(function(observer) {
        var n = args.length,
            queues = arrayInitialize(n, emptyArrayFactory),
            isDone = arrayInitialize(n, falseFactory);
        function next(i) {
          var res,
              queuedValues;
          if (queues.every(function(x) {
            return x.length > 0;
          })) {
            try {
              queuedValues = queues.map(function(x) {
                return x.shift();
              });
              res = resultSelector.apply(parent, queuedValues);
            } catch (ex) {
              observer.onError(ex);
              return ;
            }
            observer.onNext(res);
          } else if (isDone.filter(function(x, j) {
            return j !== i;
          }).every(identity)) {
            observer.onCompleted();
          }
        }
        ;
        function done(i) {
          isDone[i] = true;
          if (isDone.every(function(x) {
            return x;
          })) {
            observer.onCompleted();
          }
        }
        var subscriptions = new Array(n);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            var source = args[i],
                sad = new SingleAssignmentDisposable();
            isPromise(source) && (source = observableFromPromise(source));
            sad.setDisposable(source.subscribe(function(x) {
              queues[i].push(x);
              next(i);
            }, function(e) {
              observer.onError(e);
            }, function() {
              done(i);
            }));
            subscriptions[i] = sad;
          })(idx);
        }
        return new CompositeDisposable(subscriptions);
      }, parent);
    };
    Observable.zip = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var first = args.shift();
      return first.zip.apply(first, args);
    };
    Observable.zipArray = function() {
      var sources;
      if (Array.isArray(arguments[0])) {
        sources = arguments[0];
      } else {
        var len = arguments.length;
        sources = new Array(len);
        for (var i = 0; i < len; i++) {
          sources[i] = arguments[i];
        }
      }
      return new AnonymousObservable(function(observer) {
        var n = sources.length,
            queues = arrayInitialize(n, function() {
              return [];
            }),
            isDone = arrayInitialize(n, function() {
              return false;
            });
        function next(i) {
          if (queues.every(function(x) {
            return x.length > 0;
          })) {
            var res = queues.map(function(x) {
              return x.shift();
            });
            observer.onNext(res);
          } else if (isDone.filter(function(x, j) {
            return j !== i;
          }).every(identity)) {
            observer.onCompleted();
            return ;
          }
        }
        ;
        function done(i) {
          isDone[i] = true;
          if (isDone.every(identity)) {
            observer.onCompleted();
            return ;
          }
        }
        var subscriptions = new Array(n);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            subscriptions[i] = new SingleAssignmentDisposable();
            subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
              queues[i].push(x);
              next(i);
            }, function(e) {
              observer.onError(e);
            }, function() {
              done(i);
            }));
          })(idx);
        }
        return new CompositeDisposable(subscriptions);
      });
    };
    observableProto.asObservable = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(o);
      }, this);
    };
    observableProto.bufferWithCount = function(count, skip) {
      if (typeof skip !== 'number') {
        skip = count;
      }
      return this.windowWithCount(count, skip).selectMany(function(x) {
        return x.toArray();
      }).where(function(x) {
        return x.length > 0;
      });
    };
    observableProto.dematerialize = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(function(x) {
          return x.accept(o);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, this);
    };
    observableProto.distinctUntilChanged = function(keySelector, comparer) {
      var source = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var hasCurrentKey = false,
            currentKey;
        return source.subscribe(function(value) {
          var key = value;
          if (keySelector) {
            try {
              key = keySelector(value);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          if (hasCurrentKey) {
            try {
              var comparerEquals = comparer(currentKey, key);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          if (!hasCurrentKey || !comparerEquals) {
            hasCurrentKey = true;
            currentKey = key;
            o.onNext(value);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, this);
    };
    observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var tapObserver = !observerOrOnNext || isFunction(observerOrOnNext) ? observerCreate(observerOrOnNext || noop, onError || noop, onCompleted || noop) : observerOrOnNext;
        return source.subscribe(function(x) {
          try {
            tapObserver.onNext(x);
          } catch (e) {
            observer.onError(e);
          }
          observer.onNext(x);
        }, function(err) {
          try {
            tapObserver.onError(err);
          } catch (e) {
            observer.onError(e);
          }
          observer.onError(err);
        }, function() {
          try {
            tapObserver.onCompleted();
          } catch (e) {
            observer.onError(e);
          }
          observer.onCompleted();
        });
      }, this);
    };
    observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
      return this.tap(typeof thisArg !== 'undefined' ? function(x) {
        onNext.call(thisArg, x);
      } : onNext);
    };
    observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
      return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
        onError.call(thisArg, e);
      } : onError);
    };
    observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
      return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
        onCompleted.call(thisArg);
      } : onCompleted);
    };
    observableProto['finally'] = observableProto.ensure = function(action) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var subscription;
        try {
          subscription = source.subscribe(observer);
        } catch (e) {
          action();
          throw e;
        }
        return disposableCreate(function() {
          try {
            subscription.dispose();
          } catch (e) {
            throw e;
          } finally {
            action();
          }
        });
      }, this);
    };
    observableProto.finallyAction = function(action) {
      return this.ensure(action);
    };
    observableProto.ignoreElements = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(noop, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.materialize = function() {
      var source = this;
      return new AnonymousObservable(function(observer) {
        return source.subscribe(function(value) {
          observer.onNext(notificationCreateOnNext(value));
        }, function(e) {
          observer.onNext(notificationCreateOnError(e));
          observer.onCompleted();
        }, function() {
          observer.onNext(notificationCreateOnCompleted());
          observer.onCompleted();
        });
      }, source);
    };
    observableProto.repeat = function(repeatCount) {
      return enumerableRepeat(this, repeatCount).concat();
    };
    observableProto.retry = function(retryCount) {
      return enumerableRepeat(this, retryCount).catchError();
    };
    observableProto.retryWhen = function(notifier) {
      return enumerableRepeat(this).catchErrorWhen(notifier);
    };
    observableProto.scan = function() {
      var hasSeed = false,
          seed,
          accumulator,
          source = this;
      if (arguments.length === 2) {
        hasSeed = true;
        seed = arguments[0];
        accumulator = arguments[1];
      } else {
        accumulator = arguments[0];
      }
      return new AnonymousObservable(function(o) {
        var hasAccumulation,
            accumulation,
            hasValue;
        return source.subscribe(function(x) {
          !hasValue && (hasValue = true);
          try {
            if (hasAccumulation) {
              accumulation = accumulator(accumulation, x);
            } else {
              accumulation = hasSeed ? accumulator(seed, x) : x;
              hasAccumulation = true;
            }
          } catch (e) {
            o.onError(e);
            return ;
          }
          o.onNext(accumulation);
        }, function(e) {
          o.onError(e);
        }, function() {
          !hasValue && hasSeed && o.onNext(seed);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.skipLast = function(count) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          q.push(x);
          q.length > count && o.onNext(q.shift());
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.startWith = function() {
      var values,
          scheduler,
          start = 0;
      if (!!arguments.length && isScheduler(arguments[0])) {
        scheduler = arguments[0];
        start = 1;
      } else {
        scheduler = immediateScheduler;
      }
      for (var args = [],
          i = start,
          len = arguments.length; i < len; i++) {
        args.push(arguments[i]);
      }
      return enumerableOf([observableFromArray(args, scheduler), this]).concat();
    };
    observableProto.takeLast = function(count) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          q.push(x);
          q.length > count && q.shift();
        }, function(e) {
          o.onError(e);
        }, function() {
          while (q.length > 0) {
            o.onNext(q.shift());
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastBuffer = function(count) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          q.push(x);
          q.length > count && q.shift();
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(q);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.windowWithCount = function(count, skip) {
      var source = this;
      +count || (count = 0);
      Math.abs(count) === Infinity && (count = 0);
      if (count <= 0) {
        throw new ArgumentOutOfRangeError();
      }
      skip == null && (skip = count);
      +skip || (skip = 0);
      Math.abs(skip) === Infinity && (skip = 0);
      if (skip <= 0) {
        throw new ArgumentOutOfRangeError();
      }
      return new AnonymousObservable(function(observer) {
        var m = new SingleAssignmentDisposable(),
            refCountDisposable = new RefCountDisposable(m),
            n = 0,
            q = [];
        function createWindow() {
          var s = new Subject();
          q.push(s);
          observer.onNext(addRef(s, refCountDisposable));
        }
        createWindow();
        m.setDisposable(source.subscribe(function(x) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onNext(x);
          }
          var c = n - count + 1;
          c >= 0 && c % skip === 0 && q.shift().onCompleted();
          ++n % skip === 0 && createWindow();
        }, function(e) {
          while (q.length > 0) {
            q.shift().onError(e);
          }
          observer.onError(e);
        }, function() {
          while (q.length > 0) {
            q.shift().onCompleted();
          }
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    function concatMap(source, selector, thisArg) {
      var selectorFunc = bindCallback(selector, thisArg, 3);
      return source.map(function(x, i) {
        var result = selectorFunc(x, i, source);
        isPromise(result) && (result = observableFromPromise(result));
        (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
        return result;
      }).concatAll();
    }
    observableProto.selectConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
      if (isFunction(selector) && isFunction(resultSelector)) {
        return this.concatMap(function(x, i) {
          var selectorResult = selector(x, i);
          isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
          (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
          return selectorResult.map(function(y, i2) {
            return resultSelector(x, y, i, i2);
          });
        });
      }
      return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function() {
        return selector;
      });
    };
    observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
      var source = this,
          onNextFunc = bindCallback(onNext, thisArg, 2),
          onErrorFunc = bindCallback(onError, thisArg, 1),
          onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
      return new AnonymousObservable(function(observer) {
        var index = 0;
        return source.subscribe(function(x) {
          var result;
          try {
            result = onNextFunc(x, index++);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
        }, function(err) {
          var result;
          try {
            result = onErrorFunc(err);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        }, function() {
          var result;
          try {
            result = onCompletedFunc();
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        });
      }, this).concatAll();
    };
    observableProto.defaultIfEmpty = function(defaultValue) {
      var source = this;
      defaultValue === undefined && (defaultValue = null);
      return new AnonymousObservable(function(observer) {
        var found = false;
        return source.subscribe(function(x) {
          found = true;
          observer.onNext(x);
        }, function(e) {
          observer.onError(e);
        }, function() {
          !found && observer.onNext(defaultValue);
          observer.onCompleted();
        });
      }, source);
    };
    function arrayIndexOfComparer(array, item, comparer) {
      for (var i = 0,
          len = array.length; i < len; i++) {
        if (comparer(array[i], item)) {
          return i;
        }
      }
      return -1;
    }
    function HashSet(comparer) {
      this.comparer = comparer;
      this.set = [];
    }
    HashSet.prototype.push = function(value) {
      var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
      retValue && this.set.push(value);
      return retValue;
    };
    observableProto.distinct = function(keySelector, comparer) {
      var source = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var hashSet = new HashSet(comparer);
        return source.subscribe(function(x) {
          var key = x;
          if (keySelector) {
            try {
              key = keySelector(x);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          hashSet.push(key) && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, this);
    };
    var MapObservable = (function(__super__) {
      inherits(MapObservable, __super__);
      function MapObservable(source, selector, thisArg) {
        this.source = source;
        this.selector = bindCallback(selector, thisArg, 3);
        __super__.call(this);
      }
      MapObservable.prototype.internalMap = function(selector, thisArg) {
        var self = this;
        return new MapObservable(this.source, function(x, i, o) {
          return selector.call(this, self.selector(x, i, o), i, o);
        }, thisArg);
      };
      MapObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new MapObserver(observer, this.selector, this));
      };
      return MapObservable;
    }(ObservableBase));
    function MapObserver(observer, selector, source) {
      this.observer = observer;
      this.selector = selector;
      this.source = source;
      this.i = 0;
      this.isStopped = false;
    }
    MapObserver.prototype.onNext = function(x) {
      if (this.isStopped) {
        return ;
      }
      var result = tryCatch(this.selector).call(this, x, this.i++, this.source);
      if (result === errorObj) {
        return this.observer.onError(result.e);
      }
      this.observer.onNext(result);
    };
    MapObserver.prototype.onError = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
      }
    };
    MapObserver.prototype.onCompleted = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onCompleted();
      }
    };
    MapObserver.prototype.dispose = function() {
      this.isStopped = true;
    };
    MapObserver.prototype.fail = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }
      return false;
    };
    observableProto.map = observableProto.select = function(selector, thisArg) {
      var selectorFn = typeof selector === 'function' ? selector : function() {
        return selector;
      };
      return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
    };
    observableProto.pluck = function() {
      var args = arguments,
          len = arguments.length;
      if (len === 0) {
        throw new Error('List of properties cannot be empty.');
      }
      return this.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < len; i++) {
          var p = currentProp[args[i]];
          if (typeof p !== 'undefined') {
            currentProp = p;
          } else {
            return undefined;
          }
        }
        return currentProp;
      });
    };
    observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var index = 0;
        return source.subscribe(function(x) {
          var result;
          try {
            result = onNext.call(thisArg, x, index++);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
        }, function(err) {
          var result;
          try {
            result = onError.call(thisArg, err);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        }, function() {
          var result;
          try {
            result = onCompleted.call(thisArg);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        });
      }, source).mergeAll();
    };
    function flatMap(source, selector, thisArg) {
      var selectorFunc = bindCallback(selector, thisArg, 3);
      return source.map(function(x, i) {
        var result = selectorFunc(x, i, source);
        isPromise(result) && (result = observableFromPromise(result));
        (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
        return result;
      }).mergeAll();
    }
    observableProto.selectMany = observableProto.flatMap = function(selector, resultSelector, thisArg) {
      if (isFunction(selector) && isFunction(resultSelector)) {
        return this.flatMap(function(x, i) {
          var selectorResult = selector(x, i);
          isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
          (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
          return selectorResult.map(function(y, i2) {
            return resultSelector(x, y, i, i2);
          });
        }, thisArg);
      }
      return isFunction(selector) ? flatMap(this, selector, thisArg) : flatMap(this, function() {
        return selector;
      });
    };
    observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function(selector, thisArg) {
      return this.select(selector, thisArg).switchLatest();
    };
    observableProto.skip = function(count) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var remaining = count;
        return source.subscribe(function(x) {
          if (remaining <= 0) {
            o.onNext(x);
          } else {
            remaining--;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.skipWhile = function(predicate, thisArg) {
      var source = this,
          callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0,
            running = false;
        return source.subscribe(function(x) {
          if (!running) {
            try {
              running = !callback(x, i++, source);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          running && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.take = function(count, scheduler) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (count === 0) {
        return observableEmpty(scheduler);
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var remaining = count;
        return source.subscribe(function(x) {
          if (remaining-- > 0) {
            o.onNext(x);
            remaining === 0 && o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeWhile = function(predicate, thisArg) {
      var source = this,
          callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0,
            running = true;
        return source.subscribe(function(x) {
          if (running) {
            try {
              running = callback(x, i++, source);
            } catch (e) {
              o.onError(e);
              return ;
            }
            if (running) {
              o.onNext(x);
            } else {
              o.onCompleted();
            }
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    var FilterObservable = (function(__super__) {
      inherits(FilterObservable, __super__);
      function FilterObservable(source, predicate, thisArg) {
        this.source = source;
        this.predicate = bindCallback(predicate, thisArg, 3);
        __super__.call(this);
      }
      FilterObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new FilterObserver(observer, this.predicate, this));
      };
      FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
        var self = this;
        return new FilterObservable(this.source, function(x, i, o) {
          return self.predicate(x, i, o) && predicate.call(this, x, i, o);
        }, thisArg);
      };
      return FilterObservable;
    }(ObservableBase));
    function FilterObserver(observer, predicate, source) {
      this.observer = observer;
      this.predicate = predicate;
      this.source = source;
      this.i = 0;
      this.isStopped = false;
    }
    FilterObserver.prototype.onNext = function(x) {
      if (this.isStopped) {
        return ;
      }
      var shouldYield = tryCatch(this.predicate).call(this, x, this.i++, this.source);
      if (shouldYield === errorObj) {
        return this.observer.onError(shouldYield.e);
      }
      shouldYield && this.observer.onNext(x);
    };
    FilterObserver.prototype.onError = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
      }
    };
    FilterObserver.prototype.onCompleted = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onCompleted();
      }
    };
    FilterObserver.prototype.dispose = function() {
      this.isStopped = true;
    };
    FilterObserver.prototype.fail = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }
      return false;
    };
    observableProto.filter = observableProto.where = function(predicate, thisArg) {
      return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
    };
    observableProto.transduce = function(transducer) {
      var source = this;
      function transformForObserver(o) {
        return {
          '@@transducer/init': function() {
            return o;
          },
          '@@transducer/step': function(obs, input) {
            return obs.onNext(input);
          },
          '@@transducer/result': function(obs) {
            return obs.onCompleted();
          }
        };
      }
      return new AnonymousObservable(function(o) {
        var xform = transducer(transformForObserver(o));
        return source.subscribe(function(v) {
          try {
            xform['@@transducer/step'](o, v);
          } catch (e) {
            o.onError(e);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          xform['@@transducer/result'](o);
        });
      }, source);
    };
    var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
      inherits(AnonymousObservable, __super__);
      function fixSubscriber(subscriber) {
        return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
      }
      function setDisposable(s, state) {
        var ado = state[0],
            subscribe = state[1];
        var sub = tryCatch(subscribe)(ado);
        if (sub === errorObj) {
          if (!ado.fail(errorObj.e)) {
            return thrower(errorObj.e);
          }
        }
        ado.setDisposable(fixSubscriber(sub));
      }
      function AnonymousObservable(subscribe, parent) {
        this.source = parent;
        function s(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, subscribe];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        __super__.call(this, s);
      }
      return AnonymousObservable;
    }(Observable));
    var AutoDetachObserver = (function(__super__) {
      inherits(AutoDetachObserver, __super__);
      function AutoDetachObserver(observer) {
        __super__.call(this);
        this.observer = observer;
        this.m = new SingleAssignmentDisposable();
      }
      var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
      AutoDetachObserverPrototype.next = function(value) {
        var result = tryCatch(this.observer.onNext).call(this.observer, value);
        if (result === errorObj) {
          this.dispose();
          thrower(result.e);
        }
      };
      AutoDetachObserverPrototype.error = function(err) {
        var result = tryCatch(this.observer.onError).call(this.observer, err);
        this.dispose();
        result === errorObj && thrower(result.e);
      };
      AutoDetachObserverPrototype.completed = function() {
        var result = tryCatch(this.observer.onCompleted).call(this.observer);
        this.dispose();
        result === errorObj && thrower(result.e);
      };
      AutoDetachObserverPrototype.setDisposable = function(value) {
        this.m.setDisposable(value);
      };
      AutoDetachObserverPrototype.getDisposable = function() {
        return this.m.getDisposable();
      };
      AutoDetachObserverPrototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        this.m.dispose();
      };
      return AutoDetachObserver;
    }(AbstractObserver));
    var InnerSubscription = function(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function() {
      if (!this.subject.isDisposed && this.observer !== null) {
        var idx = this.subject.observers.indexOf(this.observer);
        this.subject.observers.splice(idx, 1);
        this.observer = null;
      }
    };
    var Subject = Rx.Subject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
          return disposableEmpty;
        }
        observer.onCompleted();
        return disposableEmpty;
      }
      inherits(Subject, __super__);
      function Subject() {
        __super__.call(this, subscribe);
        this.isDisposed = false, this.isStopped = false, this.observers = [];
        this.hasError = false;
      }
      addProperties(Subject.prototype, Observer.prototype, {
        hasObservers: function() {
          return this.observers.length > 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onCompleted();
            }
            this.observers.length = 0;
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            this.error = error;
            this.hasError = true;
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onError(error);
            }
            this.observers.length = 0;
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (!this.isStopped) {
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onNext(value);
            }
          }
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
        }
      });
      Subject.create = function(observer, observable) {
        return new AnonymousSubject(observer, observable);
      };
      return Subject;
    }(Observable));
    var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
        } else if (this.hasValue) {
          observer.onNext(this.value);
          observer.onCompleted();
        } else {
          observer.onCompleted();
        }
        return disposableEmpty;
      }
      inherits(AsyncSubject, __super__);
      function AsyncSubject() {
        __super__.call(this, subscribe);
        this.isDisposed = false;
        this.isStopped = false;
        this.hasValue = false;
        this.observers = [];
        this.hasError = false;
      }
      addProperties(AsyncSubject.prototype, Observer, {
        hasObservers: function() {
          checkDisposed(this);
          return this.observers.length > 0;
        },
        onCompleted: function() {
          var i,
              len;
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            var os = cloneArray(this.observers),
                len = os.length;
            if (this.hasValue) {
              for (i = 0; i < len; i++) {
                var o = os[i];
                o.onNext(this.value);
                o.onCompleted();
              }
            } else {
              for (i = 0; i < len; i++) {
                os[i].onCompleted();
              }
            }
            this.observers.length = 0;
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            this.hasError = true;
            this.error = error;
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onError(error);
            }
            this.observers.length = 0;
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.value = value;
          this.hasValue = true;
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
          this.exception = null;
          this.value = null;
        }
      });
      return AsyncSubject;
    }(Observable));
    var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
      inherits(AnonymousSubject, __super__);
      function subscribe(observer) {
        return this.observable.subscribe(observer);
      }
      function AnonymousSubject(observer, observable) {
        this.observer = observer;
        this.observable = observable;
        __super__.call(this, subscribe);
      }
      addProperties(AnonymousSubject.prototype, Observer.prototype, {
        onCompleted: function() {
          this.observer.onCompleted();
        },
        onError: function(error) {
          this.observer.onError(error);
        },
        onNext: function(value) {
          this.observer.onNext(value);
        }
      });
      return AnonymousSubject;
    }(Observable));
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      root.Rx = Rx;
      define(function() {
        return Rx;
      });
    } else if (freeExports && freeModule) {
      if (moduleExports) {
        (freeModule.exports = Rx).Rx = Rx;
      } else {
        freeExports.Rx = Rx;
      }
    } else {
      root.Rx = Rx;
    }
    var rEndingLine = captureLine();
  }.call(this));
  global.define = __define;
  return module.exports;
});

System.register("angular2/src/facade/lang", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/lang";
  var _global,
      Type,
      BaseException,
      Math,
      Date,
      assertionsEnabled_,
      StringWrapper,
      StringJoiner,
      NumberParseError,
      NumberWrapper,
      RegExp,
      RegExpWrapper,
      RegExpMatcherWrapper,
      FunctionWrapper,
      Json,
      DateWrapper;
  function getTypeNameForDebugging(type) {
    return type['name'];
  }
  function makeTypeError(message) {
    return new TypeError(message);
  }
  function assertionsEnabled() {
    return assertionsEnabled_;
  }
  function ENUM_INDEX(value) {
    return value;
  }
  function CONST_EXPR(expr) {
    return expr;
  }
  function CONST() {
    return (function(target) {
      return target;
    });
  }
  function ABSTRACT() {
    return (function(t) {
      return t;
    });
  }
  function IMPLEMENTS(_) {
    return (function(t) {
      return t;
    });
  }
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isType(obj) {
    return isFunction(obj);
  }
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  function isPromise(obj) {
    return obj instanceof _global.Promise;
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  function isDate(obj) {
    return obj instanceof Date && !isNaN(obj.valueOf());
  }
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  function serializeEnum(val) {
    return val;
  }
  function deserializeEnum(val, values) {
    return val;
  }
  function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
  }
  function getMapKey(value) {
    return value;
  }
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function print(obj) {
    if (obj instanceof BaseException) {
      console.log(obj.stack);
    } else {
      console.log(obj);
    }
  }
  $__export("getTypeNameForDebugging", getTypeNameForDebugging);
  $__export("makeTypeError", makeTypeError);
  $__export("assertionsEnabled", assertionsEnabled);
  $__export("ENUM_INDEX", ENUM_INDEX);
  $__export("CONST_EXPR", CONST_EXPR);
  $__export("CONST", CONST);
  $__export("ABSTRACT", ABSTRACT);
  $__export("IMPLEMENTS", IMPLEMENTS);
  $__export("isPresent", isPresent);
  $__export("isBlank", isBlank);
  $__export("isString", isString);
  $__export("isFunction", isFunction);
  $__export("isType", isType);
  $__export("isStringMap", isStringMap);
  $__export("isPromise", isPromise);
  $__export("isArray", isArray);
  $__export("isNumber", isNumber);
  $__export("isDate", isDate);
  $__export("stringify", stringify);
  $__export("serializeEnum", serializeEnum);
  $__export("deserializeEnum", deserializeEnum);
  $__export("looseIdentical", looseIdentical);
  $__export("getMapKey", getMapKey);
  $__export("normalizeBlank", normalizeBlank);
  $__export("normalizeBool", normalizeBool);
  $__export("isJsObject", isJsObject);
  $__export("print", print);
  return {
    setters: [],
    execute: function() {
      _global = (typeof window === 'undefined' ? global : window);
      $__export("global", _global);
      Type = Function;
      $__export("Type", Type);
      BaseException = (function($__super) {
        function BaseException(message, _originalException, _originalStack, _context) {
          $traceurRuntime.superConstructor(BaseException).call(this, message);
          this.message = message;
          this._originalException = _originalException;
          this._originalStack = _originalStack;
          this._context = _context;
          this.stack = (new Error(message)).stack;
        }
        return ($traceurRuntime.createClass)(BaseException, {
          get originalException() {
            return this._originalException;
          },
          get originalStack() {
            return this._originalStack;
          },
          get context() {
            return this._context;
          },
          toString: function() {
            return this.message;
          }
        }, {}, $__super);
      }(Error));
      $__export("BaseException", BaseException);
      Math = _global.Math;
      $__export("Math", Math);
      Date = _global.Date;
      $__export("Date", Date);
      assertionsEnabled_ = typeof _global['assert'] !== 'undefined';
      _global.assert = function assert(condition) {
        if (assertionsEnabled_) {
          _global['assert'].call(condition);
        }
      };
      StringWrapper = (function() {
        function StringWrapper() {}
        return ($traceurRuntime.createClass)(StringWrapper, {}, {
          fromCharCode: function(code) {
            return String.fromCharCode(code);
          },
          charCodeAt: function(s, index) {
            return s.charCodeAt(index);
          },
          split: function(s, regExp) {
            return s.split(regExp);
          },
          equals: function(s, s2) {
            return s === s2;
          },
          replace: function(s, from, replace) {
            return s.replace(from, replace);
          },
          replaceAll: function(s, from, replace) {
            return s.replace(from, replace);
          },
          toUpperCase: function(s) {
            return s.toUpperCase();
          },
          toLowerCase: function(s) {
            return s.toLowerCase();
          },
          startsWith: function(s, start) {
            return s.startsWith(start);
          },
          substring: function(s, start) {
            var end = arguments[2] !== (void 0) ? arguments[2] : null;
            return s.substring(start, end === null ? undefined : end);
          },
          replaceAllMapped: function(s, from, cb) {
            return s.replace(from, function() {
              for (var matches = [],
                  $__1 = 0; $__1 < arguments.length; $__1++)
                matches[$__1] = arguments[$__1];
              matches.splice(-2, 2);
              return cb(matches);
            });
          },
          contains: function(s, substr) {
            return s.indexOf(substr) != -1;
          },
          compare: function(a, b) {
            if (a < b) {
              return -1;
            } else if (a > b) {
              return 1;
            } else {
              return 0;
            }
          }
        });
      }());
      $__export("StringWrapper", StringWrapper);
      StringJoiner = (function() {
        function StringJoiner() {
          var parts = arguments[0] !== (void 0) ? arguments[0] : [];
          this.parts = parts;
        }
        return ($traceurRuntime.createClass)(StringJoiner, {
          add: function(part) {
            this.parts.push(part);
          },
          toString: function() {
            return this.parts.join("");
          }
        }, {});
      }());
      $__export("StringJoiner", StringJoiner);
      NumberParseError = (function($__super) {
        function NumberParseError(message) {
          $traceurRuntime.superConstructor(NumberParseError).call(this);
          this.message = message;
        }
        return ($traceurRuntime.createClass)(NumberParseError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("NumberParseError", NumberParseError);
      NumberWrapper = (function() {
        function NumberWrapper() {}
        return ($traceurRuntime.createClass)(NumberWrapper, {}, {
          toFixed: function(n, fractionDigits) {
            return n.toFixed(fractionDigits);
          },
          equal: function(a, b) {
            return a === b;
          },
          parseIntAutoRadix: function(text) {
            var result = parseInt(text);
            if (isNaN(result)) {
              throw new NumberParseError("Invalid integer literal when parsing " + text);
            }
            return result;
          },
          parseInt: function(text, radix) {
            if (radix == 10) {
              if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
              }
            } else if (radix == 16) {
              if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
              }
            } else {
              var result = parseInt(text, radix);
              if (!isNaN(result)) {
                return result;
              }
            }
            throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " + radix);
          },
          parseFloat: function(text) {
            return parseFloat(text);
          },
          get NaN() {
            return NaN;
          },
          isNaN: function(value) {
            return isNaN(value);
          },
          isInteger: function(value) {
            return Number.isInteger(value);
          }
        });
      }());
      $__export("NumberWrapper", NumberWrapper);
      RegExp = _global.RegExp;
      $__export("RegExp", RegExp);
      RegExpWrapper = (function() {
        function RegExpWrapper() {}
        return ($traceurRuntime.createClass)(RegExpWrapper, {}, {
          create: function(regExpStr) {
            var flags = arguments[1] !== (void 0) ? arguments[1] : '';
            flags = flags.replace(/g/g, '');
            return new _global.RegExp(regExpStr, flags + 'g');
          },
          firstMatch: function(regExp, input) {
            regExp.lastIndex = 0;
            return regExp.exec(input);
          },
          test: function(regExp, input) {
            regExp.lastIndex = 0;
            return regExp.test(input);
          },
          matcher: function(regExp, input) {
            regExp.lastIndex = 0;
            return {
              re: regExp,
              input: input
            };
          }
        });
      }());
      $__export("RegExpWrapper", RegExpWrapper);
      RegExpMatcherWrapper = (function() {
        function RegExpMatcherWrapper() {}
        return ($traceurRuntime.createClass)(RegExpMatcherWrapper, {}, {next: function(matcher) {
            return matcher.re.exec(matcher.input);
          }});
      }());
      $__export("RegExpMatcherWrapper", RegExpMatcherWrapper);
      FunctionWrapper = (function() {
        function FunctionWrapper() {}
        return ($traceurRuntime.createClass)(FunctionWrapper, {}, {apply: function(fn, posArgs) {
            return fn.apply(null, posArgs);
          }});
      }());
      $__export("FunctionWrapper", FunctionWrapper);
      Json = (function() {
        function Json() {}
        return ($traceurRuntime.createClass)(Json, {}, {
          parse: function(s) {
            return _global.JSON.parse(s);
          },
          stringify: function(data) {
            return _global.JSON.stringify(data, null, 2);
          }
        });
      }());
      $__export("Json", Json);
      DateWrapper = (function() {
        function DateWrapper() {}
        return ($traceurRuntime.createClass)(DateWrapper, {}, {
          create: function(year) {
            var month = arguments[1] !== (void 0) ? arguments[1] : 1;
            var day = arguments[2] !== (void 0) ? arguments[2] : 1;
            var hour = arguments[3] !== (void 0) ? arguments[3] : 0;
            var minutes = arguments[4] !== (void 0) ? arguments[4] : 0;
            var seconds = arguments[5] !== (void 0) ? arguments[5] : 0;
            var milliseconds = arguments[6] !== (void 0) ? arguments[6] : 0;
            return new Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
          },
          fromMillis: function(ms) {
            return new Date(ms);
          },
          toMillis: function(date) {
            return date.getTime();
          },
          now: function() {
            return new Date();
          },
          toJson: function(date) {
            return date.toJSON();
          }
        });
      }());
      $__export("DateWrapper", DateWrapper);
    }
  };
});

System.register("angular2/src/di/metadata", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/metadata";
  var __decorate,
      __metadata,
      CONST,
      stringify,
      InjectMetadata,
      OptionalMetadata,
      DependencyMetadata,
      InjectableMetadata,
      SelfMetadata,
      SkipSelfMetadata,
      HostMetadata;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      stringify = $__m.stringify;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      InjectMetadata = (($traceurRuntime.createClass)(function(token) {
        this.token = token;
      }, {toString: function() {
          return ("@Inject(" + stringify(this.token) + ")");
        }}, {}));
      $__export("InjectMetadata", InjectMetadata);
      $__export("InjectMetadata", InjectMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], InjectMetadata));
      OptionalMetadata = (($traceurRuntime.createClass)(function() {}, {toString: function() {
          return "@Optional()";
        }}, {}));
      $__export("OptionalMetadata", OptionalMetadata);
      $__export("OptionalMetadata", OptionalMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], OptionalMetadata));
      DependencyMetadata = (($traceurRuntime.createClass)(function() {}, {get token() {
          return null;
        }}, {}));
      $__export("DependencyMetadata", DependencyMetadata);
      $__export("DependencyMetadata", DependencyMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], DependencyMetadata));
      InjectableMetadata = (($traceurRuntime.createClass)(function() {}, {}, {}));
      $__export("InjectableMetadata", InjectableMetadata);
      $__export("InjectableMetadata", InjectableMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], InjectableMetadata));
      SelfMetadata = (($traceurRuntime.createClass)(function() {}, {toString: function() {
          return "@Self()";
        }}, {}));
      $__export("SelfMetadata", SelfMetadata);
      $__export("SelfMetadata", SelfMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], SelfMetadata));
      SkipSelfMetadata = (($traceurRuntime.createClass)(function() {}, {toString: function() {
          return "@SkipSelf()";
        }}, {}));
      $__export("SkipSelfMetadata", SkipSelfMetadata);
      $__export("SkipSelfMetadata", SkipSelfMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], SkipSelfMetadata));
      HostMetadata = (($traceurRuntime.createClass)(function() {}, {toString: function() {
          return "@Host()";
        }}, {}));
      $__export("HostMetadata", HostMetadata);
      $__export("HostMetadata", HostMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], HostMetadata));
    }
  };
});

System.register("angular2/src/util/decorators", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/util/decorators";
  var global,
      isFunction,
      stringify,
      Reflect;
  function extractAnnotation(annotation) {
    if (isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
      annotation = annotation.annotation;
    }
    return annotation;
  }
  function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function || fnOrArray === Number || fnOrArray === Array) {
      throw new Error(("Can not use native " + stringify(fnOrArray) + " as constructor"));
    }
    if (isFunction(fnOrArray)) {
      return fnOrArray;
    } else if (fnOrArray instanceof Array) {
      var annotations = fnOrArray;
      var fn = fnOrArray[fnOrArray.length - 1];
      if (!isFunction(fn)) {
        throw new Error(("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'"));
      }
      var annoLength = annotations.length - 1;
      if (annoLength != fn.length) {
        throw new Error(("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn)));
      }
      var paramsAnnotations = [];
      for (var i = 0,
          ii = annotations.length - 1; i < ii; i++) {
        var paramAnnotations = [];
        paramsAnnotations.push(paramAnnotations);
        var annotation = annotations[i];
        if (annotation instanceof Array) {
          for (var j = 0; j < annotation.length; j++) {
            paramAnnotations.push(extractAnnotation(annotation[j]));
          }
        } else if (isFunction(annotation)) {
          paramAnnotations.push(extractAnnotation(annotation));
        } else {
          paramAnnotations.push(annotation);
        }
      }
      Reflect.defineMetadata('parameters', paramsAnnotations, fn);
      return fn;
    } else {
      throw new Error(("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'"));
    }
  }
  function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
      if (isFunction(clsDef.extends)) {
        constructor.prototype = proto = Object.create(clsDef.extends.prototype);
      } else {
        throw new Error(("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends)));
      }
    }
    for (var key in clsDef) {
      if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
        proto[key] = applyParams(clsDef[key], key);
      }
    }
    if (this && this.annotations instanceof Array) {
      Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    return constructor;
  }
  function makeDecorator(annotationCls) {
    var chainFn = arguments[1] !== (void 0) ? arguments[1] : null;
    function DecoratorFactory(objOrType) {
      var annotationInstance = new annotationCls(objOrType);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        var chainAnnotation = isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
        chainAnnotation.push(annotationInstance);
        var TypeDecorator = function TypeDecorator(cls) {
          var annotations = Reflect.getOwnMetadata('annotations', cls);
          annotations = annotations || [];
          annotations.push(annotationInstance);
          Reflect.defineMetadata('annotations', annotations, cls);
          return cls;
        };
        TypeDecorator.annotations = chainAnnotation;
        TypeDecorator.Class = Class;
        if (chainFn)
          chainFn(TypeDecorator);
        return TypeDecorator;
      }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return DecoratorFactory;
  }
  function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
      for (var args = [],
          $__0 = 0; $__0 < arguments.length; $__0++)
        args[$__0] = arguments[$__0];
      var annotationInstance = Object.create(annotationCls.prototype);
      annotationCls.apply(annotationInstance, args);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
      }
      function ParamDecorator(cls, unusedKey, index) {
        var parameters = Reflect.getMetadata('parameters', cls);
        parameters = parameters || [];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        parameters[index] = parameters[index] || [];
        var annotationsForParam = parameters[index];
        annotationsForParam.push(annotationInstance);
        Reflect.defineMetadata('parameters', parameters, cls);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return ParamDecoratorFactory;
  }
  $__export("Class", Class);
  $__export("makeDecorator", makeDecorator);
  $__export("makeParamDecorator", makeParamDecorator);
  return {
    setters: [function($__m) {
      global = $__m.global;
      isFunction = $__m.isFunction;
      stringify = $__m.stringify;
    }],
    execute: function() {
      Reflect = global.Reflect;
      if (!(Reflect && Reflect.getMetadata)) {
        throw 'reflect-metadata shim is required when using class decorators';
      }
    }
  };
});

System.register("angular2/src/di/forward_ref", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/forward_ref";
  var stringify,
      isFunction;
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return stringify(this());
    };
    return forwardRefFn;
  }
  function resolveForwardRef(type) {
    if (isFunction(type) && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
      return type();
    } else {
      return type;
    }
  }
  $__export("forwardRef", forwardRef);
  $__export("resolveForwardRef", resolveForwardRef);
  return {
    setters: [function($__m) {
      stringify = $__m.stringify;
      isFunction = $__m.isFunction;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/facade/collection", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/collection";
  var isJsObject,
      global,
      isPresent,
      isBlank,
      isArray,
      List,
      Map,
      Set,
      StringMap,
      createMapFromPairs,
      createMapFromMap,
      _clearValues,
      _arrayFromMap,
      MapWrapper,
      StringMapWrapper,
      ListWrapper,
      createSetFromList,
      SetWrapper;
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return isArray(obj) || (!(obj instanceof Map) && Symbol.iterator in obj);
  }
  function iterateListLike(obj, fn) {
    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[Symbol.iterator]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  $__export("isListLikeIterable", isListLikeIterable);
  $__export("iterateListLike", iterateListLike);
  return {
    setters: [function($__m) {
      isJsObject = $__m.isJsObject;
      global = $__m.global;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      isArray = $__m.isArray;
    }],
    execute: function() {
      List = global.Array;
      $__export("List", List);
      Map = global.Map;
      $__export("Map", Map);
      Set = global.Set;
      $__export("Set", Set);
      StringMap = global.Object;
      $__export("StringMap", StringMap);
      createMapFromPairs = (function() {
        try {
          if (new Map([[1, 2]]).size === 1) {
            return function createMapFromPairs(pairs) {
              return new Map(pairs);
            };
          }
        } catch (e) {}
        return function createMapAndPopulateFromPairs(pairs) {
          var map = new Map();
          for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            map.set(pair[0], pair[1]);
          }
          return map;
        };
      })();
      createMapFromMap = (function() {
        try {
          if (new Map(new Map())) {
            return function createMapFromMap(m) {
              return new Map(m);
            };
          }
        } catch (e) {}
        return function createMapAndPopulateFromMap(m) {
          var map = new Map();
          m.forEach((function(v, k) {
            map.set(k, v);
          }));
          return map;
        };
      })();
      _clearValues = (function() {
        if ((new Map()).keys().next) {
          return function _clearValues(m) {
            var keyIterator = m.keys();
            var k;
            while (!((k = keyIterator.next()).done)) {
              m.set(k.value, null);
            }
          };
        } else {
          return function _clearValuesWithForeEach(m) {
            m.forEach((function(v, k) {
              m.set(k, null);
            }));
          };
        }
      })();
      _arrayFromMap = (function() {
        try {
          if ((new Map()).values().next) {
            return function createArrayFromMap(m, getValues) {
              return getValues ? Array.from(m.values()) : Array.from(m.keys());
            };
          }
        } catch (e) {}
        return function createArrayFromMapWithForeach(m, getValues) {
          var res = ListWrapper.createFixedSize(m.size),
              i = 0;
          m.forEach((function(v, k) {
            ListWrapper.set(res, i, getValues ? v : k);
            i++;
          }));
          return res;
        };
      })();
      MapWrapper = (function() {
        function MapWrapper() {}
        return ($traceurRuntime.createClass)(MapWrapper, {}, {
          clone: function(m) {
            return createMapFromMap(m);
          },
          createFromStringMap: function(stringMap) {
            var result = new Map();
            for (var prop in stringMap) {
              result.set(prop, stringMap[prop]);
            }
            return result;
          },
          toStringMap: function(m) {
            var r = {};
            m.forEach((function(v, k) {
              return r[k] = v;
            }));
            return r;
          },
          createFromPairs: function(pairs) {
            return createMapFromPairs(pairs);
          },
          forEach: function(m, fn) {
            m.forEach(fn);
          },
          get: function(map, key) {
            return map.get(key);
          },
          size: function(m) {
            return m.size;
          },
          delete: function(m, k) {
            m.delete(k);
          },
          clearValues: function(m) {
            _clearValues(m);
          },
          iterable: function(m) {
            return m;
          },
          keys: function(m) {
            return _arrayFromMap(m, false);
          },
          values: function(m) {
            return _arrayFromMap(m, true);
          }
        });
      }());
      $__export("MapWrapper", MapWrapper);
      StringMapWrapper = (function() {
        function StringMapWrapper() {}
        return ($traceurRuntime.createClass)(StringMapWrapper, {}, {
          create: function() {
            return {};
          },
          contains: function(map, key) {
            return map.hasOwnProperty(key);
          },
          get: function(map, key) {
            return map.hasOwnProperty(key) ? map[key] : undefined;
          },
          set: function(map, key, value) {
            map[key] = value;
          },
          keys: function(map) {
            return Object.keys(map);
          },
          isEmpty: function(map) {
            for (var prop in map) {
              return false;
            }
            return true;
          },
          delete: function(map, key) {
            delete map[key];
          },
          forEach: function(map, callback) {
            for (var prop in map) {
              if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
              }
            }
          },
          merge: function(m1, m2) {
            var m = {};
            for (var attr in m1) {
              if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
              }
            }
            for (var attr in m2) {
              if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
              }
            }
            return m;
          },
          equals: function(m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
              return false;
            }
            var key;
            for (var i = 0; i < k1.length; i++) {
              key = k1[i];
              if (m1[key] !== m2[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }());
      $__export("StringMapWrapper", StringMapWrapper);
      ListWrapper = (function() {
        function ListWrapper() {}
        return ($traceurRuntime.createClass)(ListWrapper, {}, {
          createFixedSize: function(size) {
            return new List(size);
          },
          createGrowableSize: function(size) {
            return new List(size);
          },
          get: function(m, k) {
            return m[k];
          },
          set: function(m, k, v) {
            m[k] = v;
          },
          clone: function(array) {
            return array.slice(0);
          },
          map: function(array, fn) {
            return array.map(fn);
          },
          forEach: function(array, fn) {
            for (var i = 0; i < array.length; i++) {
              fn(array[i]);
            }
          },
          forEachWithIndex: function(array, fn) {
            for (var i = 0; i < array.length; i++) {
              fn(array[i], i);
            }
          },
          first: function(array) {
            if (!array)
              return null;
            return array[0];
          },
          last: function(array) {
            if (!array || array.length == 0)
              return null;
            return array[array.length - 1];
          },
          find: function(list, pred) {
            for (var i = 0; i < list.length; ++i) {
              if (pred(list[i]))
                return list[i];
            }
            return null;
          },
          indexOf: function(array, value) {
            var startIndex = arguments[2] !== (void 0) ? arguments[2] : 0;
            return array.indexOf(value, startIndex);
          },
          reduce: function(list, fn, init) {
            return list.reduce(fn, init);
          },
          filter: function(array, pred) {
            return array.filter(pred);
          },
          any: function(list, pred) {
            for (var i = 0; i < list.length; ++i) {
              if (pred(list[i]))
                return true;
            }
            return false;
          },
          contains: function(list, el) {
            return list.indexOf(el) !== -1;
          },
          reversed: function(array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
          },
          concat: function(a, b) {
            return a.concat(b);
          },
          insert: function(list, index, value) {
            list.splice(index, 0, value);
          },
          removeAt: function(list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
          },
          removeAll: function(list, items) {
            for (var i = 0; i < items.length; ++i) {
              var index = list.indexOf(items[i]);
              list.splice(index, 1);
            }
          },
          removeLast: function(list) {
            return list.pop();
          },
          remove: function(list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
              list.splice(index, 1);
              return true;
            }
            return false;
          },
          clear: function(list) {
            list.splice(0, list.length);
          },
          join: function(list, s) {
            return list.join(s);
          },
          isEmpty: function(list) {
            return list.length == 0;
          },
          fill: function(list, value) {
            var start = arguments[2] !== (void 0) ? arguments[2] : 0;
            var end = arguments[3] !== (void 0) ? arguments[3] : null;
            list.fill(value, start, end === null ? list.length : end);
          },
          equals: function(a, b) {
            if (a.length != b.length)
              return false;
            for (var i = 0; i < a.length; ++i) {
              if (a[i] !== b[i])
                return false;
            }
            return true;
          },
          slice: function(l) {
            var from = arguments[1] !== (void 0) ? arguments[1] : 0;
            var to = arguments[2] !== (void 0) ? arguments[2] : null;
            return l.slice(from, to === null ? undefined : to);
          },
          splice: function(l, from, length) {
            return l.splice(from, length);
          },
          sort: function(l, compareFn) {
            if (isPresent(compareFn)) {
              l.sort(compareFn);
            } else {
              l.sort();
            }
          },
          toString: function(l) {
            return l.toString();
          },
          toJSON: function(l) {
            return JSON.stringify(l);
          },
          maximum: function(list, predicate) {
            if (list.length == 0) {
              return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
              var candidate = list[index];
              if (isBlank(candidate)) {
                continue;
              }
              var candidateValue = predicate(candidate);
              if (candidateValue > maxValue) {
                solution = candidate;
                maxValue = candidateValue;
              }
            }
            return solution;
          }
        });
      }());
      $__export("ListWrapper", ListWrapper);
      createSetFromList = (function() {
        var test = new Set([1, 2, 3]);
        if (test.size === 3) {
          return function createSetFromList(lst) {
            return new Set(lst);
          };
        } else {
          return function createSetAndPopulateFromList(lst) {
            var res = new Set(lst);
            if (res.size !== lst.length) {
              for (var i = 0; i < lst.length; i++) {
                res.add(lst[i]);
              }
            }
            return res;
          };
        }
      })();
      SetWrapper = (function() {
        function SetWrapper() {}
        return ($traceurRuntime.createClass)(SetWrapper, {}, {
          createFromList: function(lst) {
            return createSetFromList(lst);
          },
          has: function(s, key) {
            return s.has(key);
          },
          delete: function(m, k) {
            m.delete(k);
          }
        });
      }());
      $__export("SetWrapper", SetWrapper);
    }
  };
});

System.register("angular2/src/reflection/reflector", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflector";
  var isPresent,
      BaseException,
      ListWrapper,
      Map,
      MapWrapper,
      Set,
      SetWrapper,
      StringMapWrapper,
      ReflectionInfo,
      Reflector;
  function _mergeMaps(target, config) {
    StringMapWrapper.forEach(config, (function(v, k) {
      return target.set(k, v);
    }));
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      Set = $__m.Set;
      SetWrapper = $__m.SetWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      ReflectionInfo = (function() {
        function ReflectionInfo(annotations, parameters, factory, interfaces) {
          this._annotations = annotations;
          this._parameters = parameters;
          this._factory = factory;
          this._interfaces = interfaces;
        }
        return ($traceurRuntime.createClass)(ReflectionInfo, {}, {});
      }());
      $__export("ReflectionInfo", ReflectionInfo);
      Reflector = (function() {
        function Reflector(reflectionCapabilities) {
          this._injectableInfo = new Map();
          this._getters = new Map();
          this._setters = new Map();
          this._methods = new Map();
          this._usedKeys = null;
          this.reflectionCapabilities = reflectionCapabilities;
        }
        return ($traceurRuntime.createClass)(Reflector, {
          isReflectionEnabled: function() {
            return this.reflectionCapabilities.isReflectionEnabled();
          },
          trackUsage: function() {
            this._usedKeys = new Set();
          },
          listUnusedKeys: function() {
            var $__0 = this;
            if (this._usedKeys == null) {
              throw new BaseException('Usage tracking is disabled');
            }
            var allTypes = MapWrapper.keys(this._injectableInfo);
            return ListWrapper.filter(allTypes, (function(key) {
              return !SetWrapper.has($__0._usedKeys, key);
            }));
          },
          registerFunction: function(func, funcInfo) {
            this._injectableInfo.set(func, funcInfo);
          },
          registerType: function(type, typeInfo) {
            this._injectableInfo.set(type, typeInfo);
          },
          registerGetters: function(getters) {
            _mergeMaps(this._getters, getters);
          },
          registerSetters: function(setters) {
            _mergeMaps(this._setters, setters);
          },
          registerMethods: function(methods) {
            _mergeMaps(this._methods, methods);
          },
          factory: function(type) {
            if (this._containsReflectionInfo(type)) {
              var res = this._getReflectionInfo(type)._factory;
              return isPresent(res) ? res : null;
            } else {
              return this.reflectionCapabilities.factory(type);
            }
          },
          parameters: function(typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
              var res = this._getReflectionInfo(typeOrFunc)._parameters;
              return isPresent(res) ? res : [];
            } else {
              return this.reflectionCapabilities.parameters(typeOrFunc);
            }
          },
          annotations: function(typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
              var res = this._getReflectionInfo(typeOrFunc)._annotations;
              return isPresent(res) ? res : [];
            } else {
              return this.reflectionCapabilities.annotations(typeOrFunc);
            }
          },
          interfaces: function(type) {
            if (this._injectableInfo.has(type)) {
              var res = this._getReflectionInfo(type)._interfaces;
              return isPresent(res) ? res : [];
            } else {
              return this.reflectionCapabilities.interfaces(type);
            }
          },
          getter: function(name) {
            if (this._getters.has(name)) {
              return this._getters.get(name);
            } else {
              return this.reflectionCapabilities.getter(name);
            }
          },
          setter: function(name) {
            if (this._setters.has(name)) {
              return this._setters.get(name);
            } else {
              return this.reflectionCapabilities.setter(name);
            }
          },
          method: function(name) {
            if (this._methods.has(name)) {
              return this._methods.get(name);
            } else {
              return this.reflectionCapabilities.method(name);
            }
          },
          _getReflectionInfo: function(typeOrFunc) {
            if (isPresent(this._usedKeys)) {
              this._usedKeys.add(typeOrFunc);
            }
            return this._injectableInfo.get(typeOrFunc);
          },
          _containsReflectionInfo: function(typeOrFunc) {
            return this._injectableInfo.has(typeOrFunc);
          }
        }, {});
      }());
      $__export("Reflector", Reflector);
    }
  };
});

System.register("angular2/src/reflection/reflection_capabilities", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflection_capabilities";
  var isPresent,
      isFunction,
      global,
      stringify,
      BaseException,
      ListWrapper,
      ReflectionCapabilities;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isFunction = $__m.isFunction;
      global = $__m.global;
      stringify = $__m.stringify;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      ReflectionCapabilities = (function() {
        function ReflectionCapabilities(reflect) {
          this._reflect = isPresent(reflect) ? reflect : global.Reflect;
        }
        return ($traceurRuntime.createClass)(ReflectionCapabilities, {
          isReflectionEnabled: function() {
            return true;
          },
          factory: function(t) {
            switch (t.length) {
              case 0:
                return (function() {
                  return new t();
                });
              case 1:
                return (function(a1) {
                  return new t(a1);
                });
              case 2:
                return (function(a1, a2) {
                  return new t(a1, a2);
                });
              case 3:
                return (function(a1, a2, a3) {
                  return new t(a1, a2, a3);
                });
              case 4:
                return (function(a1, a2, a3, a4) {
                  return new t(a1, a2, a3, a4);
                });
              case 5:
                return (function(a1, a2, a3, a4, a5) {
                  return new t(a1, a2, a3, a4, a5);
                });
              case 6:
                return (function(a1, a2, a3, a4, a5, a6) {
                  return new t(a1, a2, a3, a4, a5, a6);
                });
              case 7:
                return (function(a1, a2, a3, a4, a5, a6, a7) {
                  return new t(a1, a2, a3, a4, a5, a6, a7);
                });
              case 8:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8);
                });
              case 9:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
                });
              case 10:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                });
              case 11:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                });
              case 12:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                });
              case 13:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
                });
              case 14:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
                });
              case 15:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
                });
              case 16:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                });
              case 17:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
                });
              case 18:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
                });
              case 19:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                });
              case 20:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                });
            }
            ;
            throw new Error(("Cannot create a factory for '" + stringify(t) + "' because its constructor has more than 20 arguments"));
          },
          _zipTypesAndAnnotaions: function(paramTypes, paramAnnotations) {
            var result;
            if (typeof paramTypes === 'undefined') {
              result = ListWrapper.createFixedSize(paramAnnotations.length);
            } else {
              result = ListWrapper.createFixedSize(paramTypes.length);
            }
            for (var i = 0; i < result.length; i++) {
              if (typeof paramTypes === 'undefined') {
                result[i] = [];
              } else if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
              } else {
                result[i] = [];
              }
              if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
              }
            }
            return result;
          },
          parameters: function(typeOfFunc) {
            if (isPresent(typeOfFunc.parameters)) {
              return typeOfFunc.parameters;
            }
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
              var paramAnnotations = this._reflect.getMetadata('parameters', typeOfFunc);
              var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOfFunc);
              if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
              }
            }
            return ListWrapper.createFixedSize(typeOfFunc.length);
          },
          annotations: function(typeOfFunc) {
            if (isPresent(typeOfFunc.annotations)) {
              var annotations = typeOfFunc.annotations;
              if (isFunction(annotations) && annotations.annotations) {
                annotations = annotations.annotations;
              }
              return annotations;
            }
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
              var annotations = this._reflect.getMetadata('annotations', typeOfFunc);
              if (isPresent(annotations))
                return annotations;
            }
            return [];
          },
          interfaces: function(type) {
            throw new BaseException("JavaScript does not support interfaces");
          },
          getter: function(name) {
            return new Function('o', 'return o.' + name + ';');
          },
          setter: function(name) {
            return new Function('o', 'v', 'return o.' + name + ' = v;');
          },
          method: function(name) {
            var functionBody = ("if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);");
            return new Function('o', 'args', functionBody);
          }
        }, {});
      }());
      $__export("ReflectionCapabilities", ReflectionCapabilities);
    }
  };
});

System.register("angular2/src/di/type_literal", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/type_literal";
  var TypeLiteral;
  return {
    setters: [],
    execute: function() {
      TypeLiteral = (function() {
        function TypeLiteral() {}
        return ($traceurRuntime.createClass)(TypeLiteral, {get type() {
            throw new Error("Type literals are only supported in Dart");
          }}, {});
      }());
      $__export("TypeLiteral", TypeLiteral);
    }
  };
});

System.register("angular2/src/di/exceptions", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/exceptions";
  var ListWrapper,
      stringify,
      BaseException,
      isBlank,
      AbstractBindingError,
      NoBindingError,
      CyclicDependencyError,
      InstantiationError,
      InvalidBindingError,
      NoAnnotationError,
      OutOfBoundsError;
  function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
      if (ListWrapper.contains(res, keys[i])) {
        res.push(keys[i]);
        return res;
      } else {
        res.push(keys[i]);
      }
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
      var tokenStrs = ListWrapper.map(reversed, (function(k) {
        return stringify(k.token);
      }));
      return " (" + tokenStrs.join(' -> ') + ")";
    } else {
      return "";
    }
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      AbstractBindingError = (function($__super) {
        function AbstractBindingError(injector, key, constructResolvingMessage, originalException, originalStack) {
          $traceurRuntime.superConstructor(AbstractBindingError).call(this, "DI Exception", originalException, originalStack, null);
          this.keys = [key];
          this.injectors = [injector];
          this.constructResolvingMessage = constructResolvingMessage;
          this.message = this.constructResolvingMessage(this.keys);
        }
        return ($traceurRuntime.createClass)(AbstractBindingError, {
          addKey: function(injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
            this.message = this.constructResolvingMessage(this.keys);
          },
          get context() {
            return this.injectors[this.injectors.length - 1].debugContext();
          },
          toString: function() {
            return this.message;
          }
        }, {}, $__super);
      }(BaseException));
      $__export("AbstractBindingError", AbstractBindingError);
      NoBindingError = (function($__super) {
        function NoBindingError(injector, key) {
          $traceurRuntime.superConstructor(NoBindingError).call(this, injector, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("No provider for " + first + "!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(NoBindingError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("NoBindingError", NoBindingError);
      CyclicDependencyError = (function($__super) {
        function CyclicDependencyError(injector, key) {
          $traceurRuntime.superConstructor(CyclicDependencyError).call(this, injector, key, function(keys) {
            return ("Cannot instantiate cyclic dependency!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(CyclicDependencyError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("CyclicDependencyError", CyclicDependencyError);
      InstantiationError = (function($__super) {
        function InstantiationError(injector, originalException, originalStack, key) {
          $traceurRuntime.superConstructor(InstantiationError).call(this, injector, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("Error during instantiation of " + first + "!" + constructResolvingPath(keys) + ".");
          }, originalException, originalStack);
          this.causeKey = key;
        }
        return ($traceurRuntime.createClass)(InstantiationError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("InstantiationError", InstantiationError);
      InvalidBindingError = (function($__super) {
        function InvalidBindingError(binding) {
          $traceurRuntime.superConstructor(InvalidBindingError).call(this);
          this.message = "Invalid binding - only instances of Binding and Type are allowed, got: " + binding.toString();
        }
        return ($traceurRuntime.createClass)(InvalidBindingError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("InvalidBindingError", InvalidBindingError);
      NoAnnotationError = (function($__super) {
        function NoAnnotationError(typeOrFunc, params) {
          $traceurRuntime.superConstructor(NoAnnotationError).call(this);
          var signature = [];
          for (var i = 0,
              ii = params.length; i < ii; i++) {
            var parameter = params[i];
            if (isBlank(parameter) || parameter.length == 0) {
              signature.push('?');
            } else {
              signature.push(ListWrapper.map(parameter, stringify).join(' '));
            }
          }
          this.message = "Cannot resolve all parameters for " + stringify(typeOrFunc) + "(" + signature.join(', ') + "). " + 'Make sure they all have valid type or annotations.';
        }
        return ($traceurRuntime.createClass)(NoAnnotationError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("NoAnnotationError", NoAnnotationError);
      OutOfBoundsError = (function($__super) {
        function OutOfBoundsError(index) {
          $traceurRuntime.superConstructor(OutOfBoundsError).call(this);
          this.message = ("Index " + index + " is out-of-bounds.");
        }
        return ($traceurRuntime.createClass)(OutOfBoundsError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("OutOfBoundsError", OutOfBoundsError);
    }
  };
});

System.register("angular2/src/di/opaque_token", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/opaque_token";
  var __decorate,
      __metadata,
      CONST,
      OpaqueToken;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      OpaqueToken = (($traceurRuntime.createClass)(function(desc) {
        this._desc = 'Token(' + desc + ')';
      }, {toString: function() {
          return this._desc;
        }}, {}));
      $__export("OpaqueToken", OpaqueToken);
      $__export("OpaqueToken", OpaqueToken = __decorate([CONST(), __metadata('design:paramtypes', [String])], OpaqueToken));
    }
  };
});

System.register("angular2/src/change_detection/constants", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/constants";
  var StringWrapper,
      isBlank,
      CHECK_ONCE,
      CHECKED,
      CHECK_ALWAYS,
      DETACHED,
      ON_PUSH,
      DEFAULT,
      ON_PUSH_OBSERVE;
  function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return isBlank(changeDetectionStrategy) || StringWrapper.equals(changeDetectionStrategy, DEFAULT);
  }
  $__export("isDefaultChangeDetectionStrategy", isDefaultChangeDetectionStrategy);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      CHECK_ONCE = "CHECK_ONCE";
      $__export("CHECK_ONCE", CHECK_ONCE);
      CHECKED = "CHECKED";
      $__export("CHECKED", CHECKED);
      CHECK_ALWAYS = "ALWAYS_CHECK";
      $__export("CHECK_ALWAYS", CHECK_ALWAYS);
      DETACHED = "DETACHED";
      $__export("DETACHED", DETACHED);
      ON_PUSH = "ON_PUSH";
      $__export("ON_PUSH", ON_PUSH);
      DEFAULT = "DEFAULT";
      $__export("DEFAULT", DEFAULT);
      ON_PUSH_OBSERVE = "ON_PUSH_OBSERVE";
      $__export("ON_PUSH_OBSERVE", ON_PUSH_OBSERVE);
    }
  };
});

System.register("angular2/src/change_detection/pipe_lifecycle_reflector", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipe_lifecycle_reflector";
  function implementsOnDestroy(pipe) {
    return pipe.constructor.prototype.onDestroy;
  }
  $__export("implementsOnDestroy", implementsOnDestroy);
  return {
    setters: [],
    execute: function() {
    }
  };
});

System.register("angular2/src/change_detection/binding_record", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/binding_record";
  var isPresent,
      isBlank,
      DIRECTIVE_LIFECYCLE,
      BINDING,
      DIRECTIVE,
      ELEMENT_PROPERTY,
      ELEMENT_ATTRIBUTE,
      ELEMENT_CLASS,
      ELEMENT_STYLE,
      TEXT_NODE,
      EVENT,
      HOST_EVENT,
      BindingTarget,
      BindingRecord;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      DIRECTIVE_LIFECYCLE = "directiveLifecycle";
      BINDING = "native";
      DIRECTIVE = "directive";
      ELEMENT_PROPERTY = "elementProperty";
      ELEMENT_ATTRIBUTE = "elementAttribute";
      ELEMENT_CLASS = "elementClass";
      ELEMENT_STYLE = "elementStyle";
      TEXT_NODE = "textNode";
      EVENT = "event";
      HOST_EVENT = "hostEvent";
      BindingTarget = (function() {
        function BindingTarget(mode, elementIndex, name, unit, debug) {
          this.mode = mode;
          this.elementIndex = elementIndex;
          this.name = name;
          this.unit = unit;
          this.debug = debug;
        }
        return ($traceurRuntime.createClass)(BindingTarget, {
          isDirective: function() {
            return this.mode === DIRECTIVE;
          },
          isElementProperty: function() {
            return this.mode === ELEMENT_PROPERTY;
          },
          isElementAttribute: function() {
            return this.mode === ELEMENT_ATTRIBUTE;
          },
          isElementClass: function() {
            return this.mode === ELEMENT_CLASS;
          },
          isElementStyle: function() {
            return this.mode === ELEMENT_STYLE;
          },
          isTextNode: function() {
            return this.mode === TEXT_NODE;
          }
        }, {});
      }());
      $__export("BindingTarget", BindingTarget);
      BindingRecord = (function() {
        function BindingRecord(mode, target, implicitReceiver, ast, setter, lifecycleEvent, directiveRecord) {
          this.mode = mode;
          this.target = target;
          this.implicitReceiver = implicitReceiver;
          this.ast = ast;
          this.setter = setter;
          this.lifecycleEvent = lifecycleEvent;
          this.directiveRecord = directiveRecord;
        }
        return ($traceurRuntime.createClass)(BindingRecord, {
          isDirectiveLifecycle: function() {
            return this.mode === DIRECTIVE_LIFECYCLE;
          },
          callOnChange: function() {
            return isPresent(this.directiveRecord) && this.directiveRecord.callOnChange;
          },
          isDefaultChangeDetection: function() {
            return isBlank(this.directiveRecord) || this.directiveRecord.isDefaultChangeDetection();
          }
        }, {
          createDirectiveOnCheck: function(directiveRecord) {
            return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "onCheck", directiveRecord);
          },
          createDirectiveOnInit: function(directiveRecord) {
            return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "onInit", directiveRecord);
          },
          createDirectiveOnChange: function(directiveRecord) {
            return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "onChange", directiveRecord);
          },
          createForDirective: function(ast, propertyName, setter, directiveRecord) {
            var elementIndex = directiveRecord.directiveIndex.elementIndex;
            var t = new BindingTarget(DIRECTIVE, elementIndex, propertyName, null, ast.toString());
            return new BindingRecord(DIRECTIVE, t, 0, ast, setter, null, directiveRecord);
          },
          createForElementProperty: function(ast, elementIndex, propertyName) {
            var t = new BindingTarget(ELEMENT_PROPERTY, elementIndex, propertyName, null, ast.toString());
            return new BindingRecord(BINDING, t, 0, ast, null, null, null);
          },
          createForElementAttribute: function(ast, elementIndex, attributeName) {
            var t = new BindingTarget(ELEMENT_ATTRIBUTE, elementIndex, attributeName, null, ast.toString());
            return new BindingRecord(BINDING, t, 0, ast, null, null, null);
          },
          createForElementClass: function(ast, elementIndex, className) {
            var t = new BindingTarget(ELEMENT_CLASS, elementIndex, className, null, ast.toString());
            return new BindingRecord(BINDING, t, 0, ast, null, null, null);
          },
          createForElementStyle: function(ast, elementIndex, styleName, unit) {
            var t = new BindingTarget(ELEMENT_STYLE, elementIndex, styleName, unit, ast.toString());
            return new BindingRecord(BINDING, t, 0, ast, null, null, null);
          },
          createForHostProperty: function(directiveIndex, ast, propertyName) {
            var t = new BindingTarget(ELEMENT_PROPERTY, directiveIndex.elementIndex, propertyName, null, ast.toString());
            return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
          },
          createForHostAttribute: function(directiveIndex, ast, attributeName) {
            var t = new BindingTarget(ELEMENT_ATTRIBUTE, directiveIndex.elementIndex, attributeName, null, ast.toString());
            return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
          },
          createForHostClass: function(directiveIndex, ast, className) {
            var t = new BindingTarget(ELEMENT_CLASS, directiveIndex.elementIndex, className, null, ast.toString());
            return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
          },
          createForHostStyle: function(directiveIndex, ast, styleName, unit) {
            var t = new BindingTarget(ELEMENT_STYLE, directiveIndex.elementIndex, styleName, unit, ast.toString());
            return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
          },
          createForTextNode: function(ast, elementIndex) {
            var t = new BindingTarget(TEXT_NODE, elementIndex, null, null, ast.toString());
            return new BindingRecord(BINDING, t, 0, ast, null, null, null);
          },
          createForEvent: function(ast, eventName, elementIndex) {
            var t = new BindingTarget(EVENT, elementIndex, eventName, null, ast.toString());
            return new BindingRecord(EVENT, t, 0, ast, null, null, null);
          },
          createForHostEvent: function(ast, eventName, directiveRecord) {
            var directiveIndex = directiveRecord.directiveIndex;
            var t = new BindingTarget(HOST_EVENT, directiveIndex.elementIndex, eventName, null, ast.toString());
            return new BindingRecord(HOST_EVENT, t, directiveIndex, ast, null, null, directiveRecord);
          }
        });
      }());
      $__export("BindingRecord", BindingRecord);
    }
  };
});

System.register("angular2/src/change_detection/directive_record", ["angular2/src/facade/lang", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/directive_record";
  var normalizeBool,
      isDefaultChangeDetectionStrategy,
      DirectiveIndex,
      DirectiveRecord;
  return {
    setters: [function($__m) {
      normalizeBool = $__m.normalizeBool;
    }, function($__m) {
      isDefaultChangeDetectionStrategy = $__m.isDefaultChangeDetectionStrategy;
    }],
    execute: function() {
      DirectiveIndex = (function() {
        function DirectiveIndex(elementIndex, directiveIndex) {
          this.elementIndex = elementIndex;
          this.directiveIndex = directiveIndex;
        }
        return ($traceurRuntime.createClass)(DirectiveIndex, {get name() {
            return (this.elementIndex + "_" + this.directiveIndex);
          }}, {});
      }());
      $__export("DirectiveIndex", DirectiveIndex);
      DirectiveRecord = (function() {
        function DirectiveRecord() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              directiveIndex = $__1.directiveIndex,
              callOnAllChangesDone = $__1.callOnAllChangesDone,
              callOnChange = $__1.callOnChange,
              callOnCheck = $__1.callOnCheck,
              callOnInit = $__1.callOnInit,
              changeDetection = $__1.changeDetection;
          this.directiveIndex = directiveIndex;
          this.callOnAllChangesDone = normalizeBool(callOnAllChangesDone);
          this.callOnChange = normalizeBool(callOnChange);
          this.callOnCheck = normalizeBool(callOnCheck);
          this.callOnInit = normalizeBool(callOnInit);
          this.changeDetection = changeDetection;
        }
        return ($traceurRuntime.createClass)(DirectiveRecord, {isDefaultChangeDetection: function() {
            return isDefaultChangeDetectionStrategy(this.changeDetection);
          }}, {});
      }());
      $__export("DirectiveRecord", DirectiveRecord);
    }
  };
});

System.register("angular2/src/change_detection/change_detector_ref", ["angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detector_ref";
  var DETACHED,
      CHECK_ALWAYS,
      ChangeDetectorRef;
  return {
    setters: [function($__m) {
      DETACHED = $__m.DETACHED;
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
    }],
    execute: function() {
      ChangeDetectorRef = (function() {
        function ChangeDetectorRef(_cd) {
          this._cd = _cd;
        }
        return ($traceurRuntime.createClass)(ChangeDetectorRef, {
          requestCheck: function() {
            this._cd.markPathToRootAsCheckOnce();
          },
          detach: function() {
            this._cd.mode = DETACHED;
          },
          reattach: function() {
            this._cd.mode = CHECK_ALWAYS;
            this.requestCheck();
          }
        }, {});
      }());
      $__export("ChangeDetectorRef", ChangeDetectorRef);
    }
  };
});

System.register("angular2/src/change_detection/exceptions", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/exceptions";
  var BaseException,
      ExpressionChangedAfterItHasBeenCheckedException,
      ChangeDetectionError,
      DehydratedException;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ExpressionChangedAfterItHasBeenCheckedException = (function($__super) {
        function ExpressionChangedAfterItHasBeenCheckedException(exp, oldValue, currValue, context) {
          $traceurRuntime.superConstructor(ExpressionChangedAfterItHasBeenCheckedException).call(this, ("Expression '" + exp + "' has changed after it was checked. ") + ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
        }
        return ($traceurRuntime.createClass)(ExpressionChangedAfterItHasBeenCheckedException, {}, {}, $__super);
      }(BaseException));
      $__export("ExpressionChangedAfterItHasBeenCheckedException", ExpressionChangedAfterItHasBeenCheckedException);
      ChangeDetectionError = (function($__super) {
        function ChangeDetectionError(exp, originalException, originalStack, context) {
          $traceurRuntime.superConstructor(ChangeDetectionError).call(this, (originalException + " in [" + exp + "]"), originalException, originalStack, context);
          this.location = exp;
        }
        return ($traceurRuntime.createClass)(ChangeDetectionError, {}, {}, $__super);
      }(BaseException));
      $__export("ChangeDetectionError", ChangeDetectionError);
      DehydratedException = (function($__super) {
        function DehydratedException() {
          $traceurRuntime.superConstructor(DehydratedException).call(this, 'Attempt to detect changes on a dehydrated detector.');
        }
        return ($traceurRuntime.createClass)(DehydratedException, {}, {}, $__super);
      }(BaseException));
      $__export("DehydratedException", DehydratedException);
    }
  };
});

System.register("angular2/src/profile/wtf_impl", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/profile/wtf_impl";
  var global,
      trace,
      events;
  function detectWTF() {
    var wtf = global['wtf'];
    if (wtf) {
      trace = wtf['trace'];
      if (trace) {
        events = trace['events'];
        return true;
      }
    }
    return false;
  }
  function createScope(signature) {
    var flags = arguments[1] !== (void 0) ? arguments[1] : null;
    return events.createScope(signature, flags);
  }
  function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
  }
  function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
  }
  function endTimeRange(range) {
    trace.endTimeRange(range);
  }
  $__export("detectWTF", detectWTF);
  $__export("createScope", createScope);
  $__export("leave", leave);
  $__export("startTimeRange", startTimeRange);
  $__export("endTimeRange", endTimeRange);
  return {
    setters: [function($__m) {
      global = $__m.global;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/change_detection/observable_facade", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/observable_facade";
  function isObservable(value) {
    return false;
  }
  $__export("isObservable", isObservable);
  return {
    setters: [],
    execute: function() {
    }
  };
});

System.register("angular2/src/change_detection/codegen_name_util", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/codegen_name_util";
  var RegExpWrapper,
      StringWrapper,
      ListWrapper,
      MapWrapper,
      Map,
      _ALREADY_CHECKED_ACCESSOR,
      _CONTEXT_ACCESSOR,
      _PROP_BINDING_INDEX,
      _DIRECTIVES_ACCESSOR,
      _DISPATCHER_ACCESSOR,
      _LOCALS_ACCESSOR,
      _MODE_ACCESSOR,
      _PIPES_ACCESSOR,
      _PROTOS_ACCESSOR,
      CONTEXT_INDEX,
      _FIELD_PREFIX,
      _whiteSpaceRegExp,
      CodegenNameUtil;
  function sanitizeName(s) {
    return StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
  }
  $__export("sanitizeName", sanitizeName);
  return {
    setters: [function($__m) {
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
    }],
    execute: function() {
      _ALREADY_CHECKED_ACCESSOR = "alreadyChecked";
      _CONTEXT_ACCESSOR = "context";
      _PROP_BINDING_INDEX = "propertyBindingIndex";
      _DIRECTIVES_ACCESSOR = "directiveIndices";
      _DISPATCHER_ACCESSOR = "dispatcher";
      _LOCALS_ACCESSOR = "locals";
      _MODE_ACCESSOR = "mode";
      _PIPES_ACCESSOR = "pipes";
      _PROTOS_ACCESSOR = "protos";
      CONTEXT_INDEX = 0;
      $__export("CONTEXT_INDEX", CONTEXT_INDEX);
      _FIELD_PREFIX = 'this.';
      _whiteSpaceRegExp = RegExpWrapper.create("\\W", "g");
      CodegenNameUtil = (function() {
        function CodegenNameUtil(records, eventBindings, directiveRecords, utilName) {
          this.records = records;
          this.eventBindings = eventBindings;
          this.directiveRecords = directiveRecords;
          this.utilName = utilName;
          this._sanitizedNames = ListWrapper.createFixedSize(this.records.length + 1);
          this._sanitizedNames[CONTEXT_INDEX] = _CONTEXT_ACCESSOR;
          for (var i = 0,
              iLen = this.records.length; i < iLen; ++i) {
            this._sanitizedNames[i + 1] = sanitizeName(("" + this.records[i].name + i));
          }
          this._sanitizedEventNames = new Map();
          for (var ebIndex = 0; ebIndex < eventBindings.length; ++ebIndex) {
            var eb = eventBindings[ebIndex];
            var names = [_CONTEXT_ACCESSOR];
            for (var i = 0,
                iLen = eb.records.length; i < iLen; ++i) {
              names.push(sanitizeName(("" + eb.records[i].name + i + "_" + ebIndex)));
            }
            this._sanitizedEventNames.set(eb, names);
          }
        }
        return ($traceurRuntime.createClass)(CodegenNameUtil, {
          _addFieldPrefix: function(name) {
            return ("" + _FIELD_PREFIX + name);
          },
          getDispatcherName: function() {
            return this._addFieldPrefix(_DISPATCHER_ACCESSOR);
          },
          getPipesAccessorName: function() {
            return this._addFieldPrefix(_PIPES_ACCESSOR);
          },
          getProtosName: function() {
            return this._addFieldPrefix(_PROTOS_ACCESSOR);
          },
          getDirectivesAccessorName: function() {
            return this._addFieldPrefix(_DIRECTIVES_ACCESSOR);
          },
          getLocalsAccessorName: function() {
            return this._addFieldPrefix(_LOCALS_ACCESSOR);
          },
          getAlreadyCheckedName: function() {
            return this._addFieldPrefix(_ALREADY_CHECKED_ACCESSOR);
          },
          getModeName: function() {
            return this._addFieldPrefix(_MODE_ACCESSOR);
          },
          getPropertyBindingIndex: function() {
            return this._addFieldPrefix(_PROP_BINDING_INDEX);
          },
          getLocalName: function(idx) {
            return ("l_" + this._sanitizedNames[idx]);
          },
          getEventLocalName: function(eb, idx) {
            return ("l_" + MapWrapper.get(this._sanitizedEventNames, eb)[idx]);
          },
          getChangeName: function(idx) {
            return ("c_" + this._sanitizedNames[idx]);
          },
          genInitLocals: function() {
            var declarations = [];
            var assignments = [];
            for (var i = 0,
                iLen = this.getFieldCount(); i < iLen; ++i) {
              if (i == CONTEXT_INDEX) {
                declarations.push((this.getLocalName(i) + " = " + this.getFieldName(i)));
              } else {
                var rec = this.records[i - 1];
                if (rec.argumentToPureFunction) {
                  var changeName = this.getChangeName(i);
                  declarations.push((this.getLocalName(i) + "," + changeName));
                  assignments.push(changeName);
                } else {
                  declarations.push(("" + this.getLocalName(i)));
                }
              }
            }
            var assignmentsCode = ListWrapper.isEmpty(assignments) ? '' : (ListWrapper.join(assignments, '=') + " = false;");
            return ("var " + ListWrapper.join(declarations, ',') + ";" + assignmentsCode);
          },
          genInitEventLocals: function() {
            var $__0 = this;
            var res = [(this.getLocalName(CONTEXT_INDEX) + " = " + this.getFieldName(CONTEXT_INDEX))];
            MapWrapper.forEach(this._sanitizedEventNames, (function(names, eb) {
              for (var i = 0; i < names.length; ++i) {
                if (i !== CONTEXT_INDEX) {
                  res.push(("" + $__0.getEventLocalName(eb, i)));
                }
              }
            }));
            return res.length > 1 ? ("var " + res.join(',') + ";") : '';
          },
          getPreventDefaultAccesor: function() {
            return "preventDefault";
          },
          getFieldCount: function() {
            return this._sanitizedNames.length;
          },
          getFieldName: function(idx) {
            return this._addFieldPrefix(this._sanitizedNames[idx]);
          },
          getAllFieldNames: function() {
            var fieldList = [];
            for (var k = 0,
                kLen = this.getFieldCount(); k < kLen; ++k) {
              if (k === 0 || this.records[k - 1].shouldBeChecked()) {
                fieldList.push(this.getFieldName(k));
              }
            }
            for (var i = 0,
                iLen = this.records.length; i < iLen; ++i) {
              var rec = this.records[i];
              if (rec.isPipeRecord()) {
                fieldList.push(this.getPipeName(rec.selfIndex));
              }
            }
            for (var j = 0,
                jLen = this.directiveRecords.length; j < jLen; ++j) {
              var dRec = this.directiveRecords[j];
              fieldList.push(this.getDirectiveName(dRec.directiveIndex));
              if (!dRec.isDefaultChangeDetection()) {
                fieldList.push(this.getDetectorName(dRec.directiveIndex));
              }
            }
            return fieldList;
          },
          genDehydrateFields: function() {
            var fields = this.getAllFieldNames();
            ListWrapper.removeAt(fields, CONTEXT_INDEX);
            if (ListWrapper.isEmpty(fields))
              return '';
            fields.push((this.utilName + ".uninitialized;"));
            return ListWrapper.join(fields, ' = ');
          },
          genPipeOnDestroy: function() {
            var $__0 = this;
            return ListWrapper.join(ListWrapper.map(ListWrapper.filter(this.records, (function(r) {
              return r.isPipeRecord();
            })), (function(r) {
              return ($__0.utilName + ".callPipeOnDestroy(" + $__0.getPipeName(r.selfIndex) + ");");
            })), '\n');
          },
          getPipeName: function(idx) {
            return this._addFieldPrefix((this._sanitizedNames[idx] + "_pipe"));
          },
          getDirectiveName: function(d) {
            return this._addFieldPrefix(("directive_" + d.name));
          },
          getDetectorName: function(d) {
            return this._addFieldPrefix(("detector_" + d.name));
          }
        }, {});
      }());
      $__export("CodegenNameUtil", CodegenNameUtil);
    }
  };
});

System.register("angular2/src/change_detection/codegen_facade", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/codegen_facade";
  function codify(obj) {
    return JSON.stringify(obj);
  }
  function rawString(str) {
    return ("'" + str + "'");
  }
  function combineGeneratedStrings(vals) {
    return vals.join(' + ');
  }
  $__export("codify", codify);
  $__export("rawString", rawString);
  $__export("combineGeneratedStrings", combineGeneratedStrings);
  return {
    setters: [],
    execute: function() {
    }
  };
});

System.register("angular2/src/change_detection/proto_record", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/proto_record";
  var RecordType,
      ProtoRecord;
  return {
    setters: [],
    execute: function() {
      $__export("RecordType", RecordType);
      (function(RecordType) {
        RecordType[RecordType["SELF"] = 0] = "SELF";
        RecordType[RecordType["CONST"] = 1] = "CONST";
        RecordType[RecordType["PRIMITIVE_OP"] = 2] = "PRIMITIVE_OP";
        RecordType[RecordType["PROPERTY_READ"] = 3] = "PROPERTY_READ";
        RecordType[RecordType["PROPERTY_WRITE"] = 4] = "PROPERTY_WRITE";
        RecordType[RecordType["LOCAL"] = 5] = "LOCAL";
        RecordType[RecordType["INVOKE_METHOD"] = 6] = "INVOKE_METHOD";
        RecordType[RecordType["INVOKE_CLOSURE"] = 7] = "INVOKE_CLOSURE";
        RecordType[RecordType["KEYED_READ"] = 8] = "KEYED_READ";
        RecordType[RecordType["KEYED_WRITE"] = 9] = "KEYED_WRITE";
        RecordType[RecordType["PIPE"] = 10] = "PIPE";
        RecordType[RecordType["INTERPOLATE"] = 11] = "INTERPOLATE";
        RecordType[RecordType["SAFE_PROPERTY"] = 12] = "SAFE_PROPERTY";
        RecordType[RecordType["COLLECTION_LITERAL"] = 13] = "COLLECTION_LITERAL";
        RecordType[RecordType["SAFE_INVOKE_METHOD"] = 14] = "SAFE_INVOKE_METHOD";
        RecordType[RecordType["DIRECTIVE_LIFECYCLE"] = 15] = "DIRECTIVE_LIFECYCLE";
        RecordType[RecordType["CHAIN"] = 16] = "CHAIN";
      })(RecordType || ($__export("RecordType", RecordType = {})));
      ProtoRecord = (function() {
        function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, lastInBinding, lastInDirective, argumentToPureFunction, referencedBySelf, propertyBindingIndex) {
          this.mode = mode;
          this.name = name;
          this.funcOrValue = funcOrValue;
          this.args = args;
          this.fixedArgs = fixedArgs;
          this.contextIndex = contextIndex;
          this.directiveIndex = directiveIndex;
          this.selfIndex = selfIndex;
          this.bindingRecord = bindingRecord;
          this.lastInBinding = lastInBinding;
          this.lastInDirective = lastInDirective;
          this.argumentToPureFunction = argumentToPureFunction;
          this.referencedBySelf = referencedBySelf;
          this.propertyBindingIndex = propertyBindingIndex;
        }
        return ($traceurRuntime.createClass)(ProtoRecord, {
          isPureFunction: function() {
            return this.mode === RecordType.INTERPOLATE || this.mode === RecordType.COLLECTION_LITERAL;
          },
          isUsedByOtherRecord: function() {
            return !this.lastInBinding || this.referencedBySelf;
          },
          shouldBeChecked: function() {
            return this.argumentToPureFunction || this.lastInBinding || this.isPureFunction();
          },
          isPipeRecord: function() {
            return this.mode === RecordType.PIPE;
          },
          isLifeCycleRecord: function() {
            return this.mode === RecordType.DIRECTIVE_LIFECYCLE;
          }
        }, {});
      }());
      $__export("ProtoRecord", ProtoRecord);
    }
  };
});

System.register("angular2/src/change_detection/parser/ast", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/ast";
  var isPresent,
      ListWrapper,
      AST,
      EmptyExpr,
      ImplicitReceiver,
      Chain,
      Conditional,
      If,
      PropertyRead,
      PropertyWrite,
      SafePropertyRead,
      KeyedRead,
      KeyedWrite,
      BindingPipe,
      LiteralPrimitive,
      LiteralArray,
      LiteralMap,
      Interpolation,
      Binary,
      PrefixNot,
      MethodCall,
      SafeMethodCall,
      FunctionCall,
      ASTWithSource,
      TemplateBinding,
      RecursiveAstVisitor,
      AstTransformer;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      AST = (function() {
        function AST() {}
        return ($traceurRuntime.createClass)(AST, {
          visit: function(visitor) {
            return null;
          },
          toString: function() {
            return "AST";
          }
        }, {});
      }());
      $__export("AST", AST);
      EmptyExpr = (function($__super) {
        function EmptyExpr() {
          $traceurRuntime.superConstructor(EmptyExpr).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(EmptyExpr, {visit: function(visitor) {}}, {}, $__super);
      }(AST));
      $__export("EmptyExpr", EmptyExpr);
      ImplicitReceiver = (function($__super) {
        function ImplicitReceiver() {
          $traceurRuntime.superConstructor(ImplicitReceiver).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(ImplicitReceiver, {visit: function(visitor) {
            return visitor.visitImplicitReceiver(this);
          }}, {}, $__super);
      }(AST));
      $__export("ImplicitReceiver", ImplicitReceiver);
      Chain = (function($__super) {
        function Chain(expressions) {
          $traceurRuntime.superConstructor(Chain).call(this);
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(Chain, {visit: function(visitor) {
            return visitor.visitChain(this);
          }}, {}, $__super);
      }(AST));
      $__export("Chain", Chain);
      Conditional = (function($__super) {
        function Conditional(condition, trueExp, falseExp) {
          $traceurRuntime.superConstructor(Conditional).call(this);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
        }
        return ($traceurRuntime.createClass)(Conditional, {visit: function(visitor) {
            return visitor.visitConditional(this);
          }}, {}, $__super);
      }(AST));
      $__export("Conditional", Conditional);
      If = (function($__super) {
        function If(condition, trueExp, falseExp) {
          $traceurRuntime.superConstructor(If).call(this);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
        }
        return ($traceurRuntime.createClass)(If, {visit: function(visitor) {
            return visitor.visitIf(this);
          }}, {}, $__super);
      }(AST));
      $__export("If", If);
      PropertyRead = (function($__super) {
        function PropertyRead(receiver, name, getter) {
          $traceurRuntime.superConstructor(PropertyRead).call(this);
          this.receiver = receiver;
          this.name = name;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(PropertyRead, {visit: function(visitor) {
            return visitor.visitPropertyRead(this);
          }}, {}, $__super);
      }(AST));
      $__export("PropertyRead", PropertyRead);
      PropertyWrite = (function($__super) {
        function PropertyWrite(receiver, name, setter, value) {
          $traceurRuntime.superConstructor(PropertyWrite).call(this);
          this.receiver = receiver;
          this.name = name;
          this.setter = setter;
          this.value = value;
        }
        return ($traceurRuntime.createClass)(PropertyWrite, {visit: function(visitor) {
            return visitor.visitPropertyWrite(this);
          }}, {}, $__super);
      }(AST));
      $__export("PropertyWrite", PropertyWrite);
      SafePropertyRead = (function($__super) {
        function SafePropertyRead(receiver, name, getter) {
          $traceurRuntime.superConstructor(SafePropertyRead).call(this);
          this.receiver = receiver;
          this.name = name;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(SafePropertyRead, {visit: function(visitor) {
            return visitor.visitSafePropertyRead(this);
          }}, {}, $__super);
      }(AST));
      $__export("SafePropertyRead", SafePropertyRead);
      KeyedRead = (function($__super) {
        function KeyedRead(obj, key) {
          $traceurRuntime.superConstructor(KeyedRead).call(this);
          this.obj = obj;
          this.key = key;
        }
        return ($traceurRuntime.createClass)(KeyedRead, {visit: function(visitor) {
            return visitor.visitKeyedRead(this);
          }}, {}, $__super);
      }(AST));
      $__export("KeyedRead", KeyedRead);
      KeyedWrite = (function($__super) {
        function KeyedWrite(obj, key, value) {
          $traceurRuntime.superConstructor(KeyedWrite).call(this);
          this.obj = obj;
          this.key = key;
          this.value = value;
        }
        return ($traceurRuntime.createClass)(KeyedWrite, {visit: function(visitor) {
            return visitor.visitKeyedWrite(this);
          }}, {}, $__super);
      }(AST));
      $__export("KeyedWrite", KeyedWrite);
      BindingPipe = (function($__super) {
        function BindingPipe(exp, name, args) {
          $traceurRuntime.superConstructor(BindingPipe).call(this);
          this.exp = exp;
          this.name = name;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(BindingPipe, {visit: function(visitor) {
            return visitor.visitPipe(this);
          }}, {}, $__super);
      }(AST));
      $__export("BindingPipe", BindingPipe);
      LiteralPrimitive = (function($__super) {
        function LiteralPrimitive(value) {
          $traceurRuntime.superConstructor(LiteralPrimitive).call(this);
          this.value = value;
        }
        return ($traceurRuntime.createClass)(LiteralPrimitive, {visit: function(visitor) {
            return visitor.visitLiteralPrimitive(this);
          }}, {}, $__super);
      }(AST));
      $__export("LiteralPrimitive", LiteralPrimitive);
      LiteralArray = (function($__super) {
        function LiteralArray(expressions) {
          $traceurRuntime.superConstructor(LiteralArray).call(this);
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(LiteralArray, {visit: function(visitor) {
            return visitor.visitLiteralArray(this);
          }}, {}, $__super);
      }(AST));
      $__export("LiteralArray", LiteralArray);
      LiteralMap = (function($__super) {
        function LiteralMap(keys, values) {
          $traceurRuntime.superConstructor(LiteralMap).call(this);
          this.keys = keys;
          this.values = values;
        }
        return ($traceurRuntime.createClass)(LiteralMap, {visit: function(visitor) {
            return visitor.visitLiteralMap(this);
          }}, {}, $__super);
      }(AST));
      $__export("LiteralMap", LiteralMap);
      Interpolation = (function($__super) {
        function Interpolation(strings, expressions) {
          $traceurRuntime.superConstructor(Interpolation).call(this);
          this.strings = strings;
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(Interpolation, {visit: function(visitor) {
            visitor.visitInterpolation(this);
          }}, {}, $__super);
      }(AST));
      $__export("Interpolation", Interpolation);
      Binary = (function($__super) {
        function Binary(operation, left, right) {
          $traceurRuntime.superConstructor(Binary).call(this);
          this.operation = operation;
          this.left = left;
          this.right = right;
        }
        return ($traceurRuntime.createClass)(Binary, {visit: function(visitor) {
            return visitor.visitBinary(this);
          }}, {}, $__super);
      }(AST));
      $__export("Binary", Binary);
      PrefixNot = (function($__super) {
        function PrefixNot(expression) {
          $traceurRuntime.superConstructor(PrefixNot).call(this);
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(PrefixNot, {visit: function(visitor) {
            return visitor.visitPrefixNot(this);
          }}, {}, $__super);
      }(AST));
      $__export("PrefixNot", PrefixNot);
      MethodCall = (function($__super) {
        function MethodCall(receiver, name, fn, args) {
          $traceurRuntime.superConstructor(MethodCall).call(this);
          this.receiver = receiver;
          this.name = name;
          this.fn = fn;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(MethodCall, {visit: function(visitor) {
            return visitor.visitMethodCall(this);
          }}, {}, $__super);
      }(AST));
      $__export("MethodCall", MethodCall);
      SafeMethodCall = (function($__super) {
        function SafeMethodCall(receiver, name, fn, args) {
          $traceurRuntime.superConstructor(SafeMethodCall).call(this);
          this.receiver = receiver;
          this.name = name;
          this.fn = fn;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(SafeMethodCall, {visit: function(visitor) {
            return visitor.visitSafeMethodCall(this);
          }}, {}, $__super);
      }(AST));
      $__export("SafeMethodCall", SafeMethodCall);
      FunctionCall = (function($__super) {
        function FunctionCall(target, args) {
          $traceurRuntime.superConstructor(FunctionCall).call(this);
          this.target = target;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(FunctionCall, {visit: function(visitor) {
            return visitor.visitFunctionCall(this);
          }}, {}, $__super);
      }(AST));
      $__export("FunctionCall", FunctionCall);
      ASTWithSource = (function($__super) {
        function ASTWithSource(ast, source, location) {
          $traceurRuntime.superConstructor(ASTWithSource).call(this);
          this.ast = ast;
          this.source = source;
          this.location = location;
        }
        return ($traceurRuntime.createClass)(ASTWithSource, {
          visit: function(visitor) {
            return this.ast.visit(visitor);
          },
          toString: function() {
            return (this.source + " in " + this.location);
          }
        }, {}, $__super);
      }(AST));
      $__export("ASTWithSource", ASTWithSource);
      TemplateBinding = (function() {
        function TemplateBinding(key, keyIsVar, name, expression) {
          this.key = key;
          this.keyIsVar = keyIsVar;
          this.name = name;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(TemplateBinding, {}, {});
      }());
      $__export("TemplateBinding", TemplateBinding);
      RecursiveAstVisitor = (function() {
        function RecursiveAstVisitor() {}
        return ($traceurRuntime.createClass)(RecursiveAstVisitor, {
          visitBinary: function(ast) {
            ast.left.visit(this);
            ast.right.visit(this);
            return null;
          },
          visitChain: function(ast) {
            return this.visitAll(ast.expressions);
          },
          visitConditional: function(ast) {
            ast.condition.visit(this);
            ast.trueExp.visit(this);
            ast.falseExp.visit(this);
            return null;
          },
          visitIf: function(ast) {
            ast.condition.visit(this);
            ast.trueExp.visit(this);
            ast.falseExp.visit(this);
            return null;
          },
          visitPipe: function(ast) {
            ast.exp.visit(this);
            this.visitAll(ast.args);
            return null;
          },
          visitFunctionCall: function(ast) {
            ast.target.visit(this);
            this.visitAll(ast.args);
            return null;
          },
          visitImplicitReceiver: function(ast) {
            return null;
          },
          visitInterpolation: function(ast) {
            return this.visitAll(ast.expressions);
          },
          visitKeyedRead: function(ast) {
            ast.obj.visit(this);
            ast.key.visit(this);
            return null;
          },
          visitKeyedWrite: function(ast) {
            ast.obj.visit(this);
            ast.key.visit(this);
            ast.value.visit(this);
            return null;
          },
          visitLiteralArray: function(ast) {
            return this.visitAll(ast.expressions);
          },
          visitLiteralMap: function(ast) {
            return this.visitAll(ast.values);
          },
          visitLiteralPrimitive: function(ast) {
            return null;
          },
          visitMethodCall: function(ast) {
            ast.receiver.visit(this);
            return this.visitAll(ast.args);
          },
          visitPrefixNot: function(ast) {
            ast.expression.visit(this);
            return null;
          },
          visitPropertyRead: function(ast) {
            ast.receiver.visit(this);
            return null;
          },
          visitPropertyWrite: function(ast) {
            ast.receiver.visit(this);
            ast.value.visit(this);
            return null;
          },
          visitSafePropertyRead: function(ast) {
            ast.receiver.visit(this);
            return null;
          },
          visitSafeMethodCall: function(ast) {
            ast.receiver.visit(this);
            return this.visitAll(ast.args);
          },
          visitAll: function(asts) {
            var $__0 = this;
            ListWrapper.forEach(asts, (function(ast) {
              ast.visit($__0);
            }));
            return null;
          }
        }, {});
      }());
      $__export("RecursiveAstVisitor", RecursiveAstVisitor);
      AstTransformer = (function() {
        function AstTransformer() {}
        return ($traceurRuntime.createClass)(AstTransformer, {
          visitImplicitReceiver: function(ast) {
            return ast;
          },
          visitInterpolation: function(ast) {
            return new Interpolation(ast.strings, this.visitAll(ast.expressions));
          },
          visitLiteralPrimitive: function(ast) {
            return new LiteralPrimitive(ast.value);
          },
          visitPropertyRead: function(ast) {
            return new PropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
          },
          visitPropertyWrite: function(ast) {
            return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.setter, ast.value);
          },
          visitSafePropertyRead: function(ast) {
            return new SafePropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
          },
          visitMethodCall: function(ast) {
            return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
          },
          visitSafeMethodCall: function(ast) {
            return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
          },
          visitFunctionCall: function(ast) {
            return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
          },
          visitLiteralArray: function(ast) {
            return new LiteralArray(this.visitAll(ast.expressions));
          },
          visitLiteralMap: function(ast) {
            return new LiteralMap(ast.keys, this.visitAll(ast.values));
          },
          visitBinary: function(ast) {
            return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
          },
          visitPrefixNot: function(ast) {
            return new PrefixNot(ast.expression.visit(this));
          },
          visitConditional: function(ast) {
            return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
          },
          visitPipe: function(ast) {
            return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
          },
          visitKeyedRead: function(ast) {
            return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
          },
          visitKeyedWrite: function(ast) {
            return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
          },
          visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          visitChain: function(ast) {
            return new Chain(this.visitAll(ast.expressions));
          },
          visitIf: function(ast) {
            var falseExp = isPresent(ast.falseExp) ? ast.falseExp.visit(this) : null;
            return new If(ast.condition.visit(this), ast.trueExp.visit(this), falseExp);
          }
        }, {});
      }());
      $__export("AstTransformer", AstTransformer);
    }
  };
});

System.register("angular2/src/change_detection/dynamic_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/abstract_change_detector", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/constants", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/dynamic_change_detector";
  var isPresent,
      isBlank,
      BaseException,
      FunctionWrapper,
      StringWrapper,
      ListWrapper,
      AbstractChangeDetector,
      ChangeDetectionUtil,
      ON_PUSH_OBSERVE,
      RecordType,
      DynamicChangeDetector;
  function isSame(a, b) {
    if (a === b)
      return true;
    if (a instanceof String && b instanceof String && a == b)
      return true;
    if ((a !== a) && (b !== b))
      return true;
    return false;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      FunctionWrapper = $__m.FunctionWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      AbstractChangeDetector = $__m.AbstractChangeDetector;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      ON_PUSH_OBSERVE = $__m.ON_PUSH_OBSERVE;
    }, function($__m) {
      RecordType = $__m.RecordType;
    }],
    execute: function() {
      DynamicChangeDetector = (function($__super) {
        function DynamicChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy, records, eventBindings, directiveRecords, genConfig) {
          $traceurRuntime.superConstructor(DynamicChangeDetector).call(this, id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy);
          this.records = records;
          this.eventBindings = eventBindings;
          this.directiveRecords = directiveRecords;
          this.genConfig = genConfig;
          this.directives = null;
          var len = records.length + 1;
          this.values = ListWrapper.createFixedSize(len);
          this.localPipes = ListWrapper.createFixedSize(len);
          this.prevContexts = ListWrapper.createFixedSize(len);
          this.changes = ListWrapper.createFixedSize(len);
          this.dehydrateDirectives(false);
        }
        return ($traceurRuntime.createClass)(DynamicChangeDetector, {
          handleEventInternal: function(eventName, elIndex, locals) {
            var $__0 = this;
            var preventDefault = false;
            this._matchingEventBindings(eventName, elIndex).forEach((function(rec) {
              var res = $__0._processEventBinding(rec, locals);
              if (res === false) {
                preventDefault = true;
              }
            }));
            return preventDefault;
          },
          _processEventBinding: function(eb, locals) {
            var values = ListWrapper.createFixedSize(eb.records.length);
            values[0] = this.values[0];
            for (var i = 0; i < eb.records.length; ++i) {
              var proto = eb.records[i];
              var res = this._calculateCurrValue(proto, values, locals);
              if (proto.lastInBinding) {
                this._markPathAsCheckOnce(proto);
                return res;
              } else {
                this._writeSelf(proto, res, values);
              }
            }
            throw new BaseException("Cannot be reached");
          },
          _markPathAsCheckOnce: function(proto) {
            if (!proto.bindingRecord.isDefaultChangeDetection()) {
              var dir = proto.bindingRecord.directiveRecord;
              this._getDetectorFor(dir.directiveIndex).markPathToRootAsCheckOnce();
            }
          },
          _matchingEventBindings: function(eventName, elIndex) {
            return ListWrapper.filter(this.eventBindings, (function(eb) {
              return eb.eventName == eventName && eb.elIndex === elIndex;
            }));
          },
          hydrateDirectives: function(directives) {
            this.values[0] = this.context;
            this.directives = directives;
            if (StringWrapper.equals(this.strategy, ON_PUSH_OBSERVE)) {
              for (var i = 0; i < this.directiveIndices.length; ++i) {
                var index = this.directiveIndices[i];
                $traceurRuntime.superGet(this, DynamicChangeDetector.prototype, "observeDirective").call(this, directives.getDirectiveFor(index), i);
              }
            }
          },
          dehydrateDirectives: function(destroyPipes) {
            if (destroyPipes) {
              this._destroyPipes();
            }
            this.values[0] = null;
            this.directives = null;
            ListWrapper.fill(this.values, ChangeDetectionUtil.uninitialized, 1);
            ListWrapper.fill(this.changes, false);
            ListWrapper.fill(this.localPipes, null);
            ListWrapper.fill(this.prevContexts, ChangeDetectionUtil.uninitialized);
          },
          _destroyPipes: function() {
            for (var i = 0; i < this.localPipes.length; ++i) {
              if (isPresent(this.localPipes[i])) {
                ChangeDetectionUtil.callPipeOnDestroy(this.localPipes[i]);
              }
            }
          },
          checkNoChanges: function() {
            this.runDetectChanges(true);
          },
          detectChangesInRecordsInternal: function(throwOnChange) {
            var protos = this.records;
            var changes = null;
            var isChanged = false;
            for (var i = 0; i < protos.length; ++i) {
              var proto = protos[i];
              var bindingRecord = proto.bindingRecord;
              var directiveRecord = bindingRecord.directiveRecord;
              if (this._firstInBinding(proto)) {
                this.propertyBindingIndex = proto.propertyBindingIndex;
              }
              if (proto.isLifeCycleRecord()) {
                if (proto.name === "onCheck" && !throwOnChange) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onCheck();
                } else if (proto.name === "onInit" && !throwOnChange && !this.alreadyChecked) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onInit();
                } else if (proto.name === "onChange" && isPresent(changes) && !throwOnChange) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onChange(changes);
                }
              } else {
                var change = this._check(proto, throwOnChange, this.values, this.locals);
                if (isPresent(change)) {
                  this._updateDirectiveOrElement(change, bindingRecord);
                  isChanged = true;
                  changes = this._addChange(bindingRecord, change, changes);
                }
              }
              if (proto.lastInDirective) {
                changes = null;
                if (isChanged && !bindingRecord.isDefaultChangeDetection()) {
                  this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
                }
                isChanged = false;
              }
            }
            this.alreadyChecked = true;
          },
          _firstInBinding: function(r) {
            var prev = ChangeDetectionUtil.protoByIndex(this.records, r.selfIndex - 1);
            return isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
          },
          callOnAllChangesDone: function() {
            $traceurRuntime.superGet(this, DynamicChangeDetector.prototype, "callOnAllChangesDone").call(this);
            var dirs = this.directiveRecords;
            for (var i = dirs.length - 1; i >= 0; --i) {
              var dir = dirs[i];
              if (dir.callOnAllChangesDone) {
                this._getDirectiveFor(dir.directiveIndex).onAllChangesDone();
              }
            }
          },
          _updateDirectiveOrElement: function(change, bindingRecord) {
            if (isBlank(bindingRecord.directiveRecord)) {
              $traceurRuntime.superGet(this, DynamicChangeDetector.prototype, "notifyDispatcher").call(this, change.currentValue);
            } else {
              var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
              bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
            }
            if (this.genConfig.logBindingUpdate) {
              $traceurRuntime.superGet(this, DynamicChangeDetector.prototype, "logBindingUpdate").call(this, change.currentValue);
            }
          },
          _addChange: function(bindingRecord, change, changes) {
            if (bindingRecord.callOnChange()) {
              return $traceurRuntime.superGet(this, DynamicChangeDetector.prototype, "addChange").call(this, changes, change.previousValue, change.currentValue);
            } else {
              return changes;
            }
          },
          _getDirectiveFor: function(directiveIndex) {
            return this.directives.getDirectiveFor(directiveIndex);
          },
          _getDetectorFor: function(directiveIndex) {
            return this.directives.getDetectorFor(directiveIndex);
          },
          _check: function(proto, throwOnChange, values, locals) {
            if (proto.isPipeRecord()) {
              return this._pipeCheck(proto, throwOnChange, values);
            } else {
              return this._referenceCheck(proto, throwOnChange, values, locals);
            }
          },
          _referenceCheck: function(proto, throwOnChange, values, locals) {
            if (this._pureFuncAndArgsDidNotChange(proto)) {
              this._setChanged(proto, false);
              return null;
            }
            var currValue = this._calculateCurrValue(proto, values, locals);
            if (StringWrapper.equals(this.strategy, ON_PUSH_OBSERVE)) {
              $traceurRuntime.superGet(this, DynamicChangeDetector.prototype, "observeValue").call(this, currValue, proto.selfIndex);
            }
            if (proto.shouldBeChecked()) {
              var prevValue = this._readSelf(proto, values);
              if (!isSame(prevValue, currValue)) {
                if (proto.lastInBinding) {
                  var change = ChangeDetectionUtil.simpleChange(prevValue, currValue);
                  if (throwOnChange)
                    this.throwOnChangeError(prevValue, currValue);
                  this._writeSelf(proto, currValue, values);
                  this._setChanged(proto, true);
                  return change;
                } else {
                  this._writeSelf(proto, currValue, values);
                  this._setChanged(proto, true);
                  return null;
                }
              } else {
                this._setChanged(proto, false);
                return null;
              }
            } else {
              this._writeSelf(proto, currValue, values);
              this._setChanged(proto, true);
              return null;
            }
          },
          _calculateCurrValue: function(proto, values, locals) {
            switch (proto.mode) {
              case RecordType.SELF:
                return this._readContext(proto, values);
              case RecordType.CONST:
                return proto.funcOrValue;
              case RecordType.PROPERTY_READ:
                var context = this._readContext(proto, values);
                return proto.funcOrValue(context);
              case RecordType.SAFE_PROPERTY:
                var context = this._readContext(proto, values);
                return isBlank(context) ? null : proto.funcOrValue(context);
              case RecordType.PROPERTY_WRITE:
                var context = this._readContext(proto, values);
                var value = this._readArgs(proto, values)[0];
                proto.funcOrValue(context, value);
                return value;
              case RecordType.KEYED_WRITE:
                var context = this._readContext(proto, values);
                var key = this._readArgs(proto, values)[0];
                var value = this._readArgs(proto, values)[1];
                context[key] = value;
                return value;
              case RecordType.LOCAL:
                return locals.get(proto.name);
              case RecordType.INVOKE_METHOD:
                var context = this._readContext(proto, values);
                var args = this._readArgs(proto, values);
                return proto.funcOrValue(context, args);
              case RecordType.SAFE_INVOKE_METHOD:
                var context = this._readContext(proto, values);
                if (isBlank(context)) {
                  return null;
                }
                var args = this._readArgs(proto, values);
                return proto.funcOrValue(context, args);
              case RecordType.KEYED_READ:
                var arg = this._readArgs(proto, values)[0];
                return this._readContext(proto, values)[arg];
              case RecordType.CHAIN:
                var args = this._readArgs(proto, values);
                return args[args.length - 1];
              case RecordType.INVOKE_CLOSURE:
                return FunctionWrapper.apply(this._readContext(proto, values), this._readArgs(proto, values));
              case RecordType.INTERPOLATE:
              case RecordType.PRIMITIVE_OP:
              case RecordType.COLLECTION_LITERAL:
                return FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto, values));
              default:
                throw new BaseException(("Unknown operation " + proto.mode));
            }
          },
          _pipeCheck: function(proto, throwOnChange, values) {
            var context = this._readContext(proto, values);
            var args = this._readArgs(proto, values);
            var pipe = this._pipeFor(proto, context);
            var currValue = pipe.transform(context, args);
            if (proto.shouldBeChecked()) {
              var prevValue = this._readSelf(proto, values);
              if (!isSame(prevValue, currValue)) {
                currValue = ChangeDetectionUtil.unwrapValue(currValue);
                if (proto.lastInBinding) {
                  var change = ChangeDetectionUtil.simpleChange(prevValue, currValue);
                  if (throwOnChange)
                    this.throwOnChangeError(prevValue, currValue);
                  this._writeSelf(proto, currValue, values);
                  this._setChanged(proto, true);
                  return change;
                } else {
                  this._writeSelf(proto, currValue, values);
                  this._setChanged(proto, true);
                  return null;
                }
              } else {
                this._setChanged(proto, false);
                return null;
              }
            } else {
              this._writeSelf(proto, currValue, values);
              this._setChanged(proto, true);
              return null;
            }
          },
          _pipeFor: function(proto, context) {
            var storedPipe = this._readPipe(proto);
            if (isPresent(storedPipe))
              return storedPipe;
            var pipe = this.pipes.get(proto.name);
            this._writePipe(proto, pipe);
            return pipe;
          },
          _readContext: function(proto, values) {
            if (proto.contextIndex == -1) {
              return this._getDirectiveFor(proto.directiveIndex);
            } else {
              return values[proto.contextIndex];
            }
            return values[proto.contextIndex];
          },
          _readSelf: function(proto, values) {
            return values[proto.selfIndex];
          },
          _writeSelf: function(proto, value, values) {
            values[proto.selfIndex] = value;
          },
          _readPipe: function(proto) {
            return this.localPipes[proto.selfIndex];
          },
          _writePipe: function(proto, value) {
            this.localPipes[proto.selfIndex] = value;
          },
          _setChanged: function(proto, value) {
            if (proto.argumentToPureFunction)
              this.changes[proto.selfIndex] = value;
          },
          _pureFuncAndArgsDidNotChange: function(proto) {
            return proto.isPureFunction() && !this._argsChanged(proto);
          },
          _argsChanged: function(proto) {
            var args = proto.args;
            for (var i = 0; i < args.length; ++i) {
              if (this.changes[args[i]]) {
                return true;
              }
            }
            return false;
          },
          _readArgs: function(proto, values) {
            var res = ListWrapper.createFixedSize(proto.args.length);
            var args = proto.args;
            for (var i = 0; i < args.length; ++i) {
              res[i] = values[args[i]];
            }
            return res;
          }
        }, {}, $__super);
      }(AbstractChangeDetector));
      $__export("DynamicChangeDetector", DynamicChangeDetector);
    }
  };
});

System.register("angular2/src/change_detection/event_binding", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/event_binding";
  var EventBinding;
  return {
    setters: [],
    execute: function() {
      EventBinding = (function() {
        function EventBinding(eventName, elIndex, dirIndex, records) {
          this.eventName = eventName;
          this.elIndex = elIndex;
          this.dirIndex = dirIndex;
          this.records = records;
        }
        return ($traceurRuntime.createClass)(EventBinding, {}, {});
      }());
      $__export("EventBinding", EventBinding);
    }
  };
});

System.register("angular2/src/change_detection/coalesce", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/coalesce";
  var isPresent,
      isBlank,
      looseIdentical,
      ListWrapper,
      Map,
      RecordType,
      ProtoRecord;
  function coalesce(records) {
    var res = [];
    var indexMap = new Map();
    for (var i = 0; i < records.length; ++i) {
      var r = records[i];
      var record = _replaceIndices(r, res.length + 1, indexMap);
      var matchingRecord = _findMatching(record, res);
      if (isPresent(matchingRecord) && record.lastInBinding) {
        res.push(_selfRecord(record, matchingRecord.selfIndex, res.length + 1));
        indexMap.set(r.selfIndex, matchingRecord.selfIndex);
        matchingRecord.referencedBySelf = true;
      } else if (isPresent(matchingRecord) && !record.lastInBinding) {
        if (record.argumentToPureFunction) {
          matchingRecord.argumentToPureFunction = true;
        }
        indexMap.set(r.selfIndex, matchingRecord.selfIndex);
      } else {
        res.push(record);
        indexMap.set(r.selfIndex, record.selfIndex);
      }
    }
    return res;
  }
  function _selfRecord(r, contextIndex, selfIndex) {
    return new ProtoRecord(RecordType.SELF, "self", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, false, false, r.propertyBindingIndex);
  }
  function _findMatching(r, rs) {
    return ListWrapper.find(rs, (function(rr) {
      return rr.mode !== RecordType.DIRECTIVE_LIFECYCLE && _sameDirIndex(rr, r) && rr.mode === r.mode && looseIdentical(rr.funcOrValue, r.funcOrValue) && rr.contextIndex === r.contextIndex && looseIdentical(rr.name, r.name) && ListWrapper.equals(rr.args, r.args);
    }));
  }
  function _sameDirIndex(a, b) {
    var di1 = isBlank(a.directiveIndex) ? null : a.directiveIndex.directiveIndex;
    var ei1 = isBlank(a.directiveIndex) ? null : a.directiveIndex.elementIndex;
    var di2 = isBlank(b.directiveIndex) ? null : b.directiveIndex.directiveIndex;
    var ei2 = isBlank(b.directiveIndex) ? null : b.directiveIndex.elementIndex;
    return di1 === di2 && ei1 === ei2;
  }
  function _replaceIndices(r, selfIndex, indexMap) {
    var args = ListWrapper.map(r.args, (function(a) {
      return _map(indexMap, a);
    }));
    var contextIndex = _map(indexMap, r.contextIndex);
    return new ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, r.argumentToPureFunction, r.referencedBySelf, r.propertyBindingIndex);
  }
  function _map(indexMap, value) {
    var r = indexMap.get(value);
    return isPresent(r) ? r : value;
  }
  $__export("coalesce", coalesce);
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      looseIdentical = $__m.looseIdentical;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
    }, function($__m) {
      RecordType = $__m.RecordType;
      ProtoRecord = $__m.ProtoRecord;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/change_detection/pregen_proto_change_detector", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pregen_proto_change_detector";
  var BaseException,
      PregenProtoChangeDetector;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      $__export("PregenProtoChangeDetectorFactory", Function);
      PregenProtoChangeDetector = (function() {
        function PregenProtoChangeDetector() {}
        return ($traceurRuntime.createClass)(PregenProtoChangeDetector, {instantiate: function(dispatcher) {
            throw new BaseException('Pregen change detection not supported in Js');
          }}, {isSupported: function() {
            return false;
          }});
      }());
      $__export("PregenProtoChangeDetector", PregenProtoChangeDetector);
    }
  };
});

System.register("angular2/src/change_detection/differs/iterable_differs", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/differs/iterable_differs";
  var __decorate,
      __metadata,
      isBlank,
      isPresent,
      BaseException,
      CONST,
      ListWrapper,
      Binding,
      SkipSelfMetadata,
      OptionalMetadata,
      Injectable,
      IterableDiffers;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Binding = $__m.Binding;
      SkipSelfMetadata = $__m.SkipSelfMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      IterableDiffers = (($traceurRuntime.createClass)(function(factories) {
        this.factories = factories;
      }, {find: function(iterable) {
          var factory = ListWrapper.find(this.factories, (function(f) {
            return f.supports(iterable);
          }));
          if (isPresent(factory)) {
            return factory;
          } else {
            throw new BaseException(("Cannot find a differ supporting object '" + iterable + "'"));
          }
        }}, {
        create: function(factories, parent) {
          if (isPresent(parent)) {
            var copied = ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new IterableDiffers(factories);
          } else {
            return new IterableDiffers(factories);
          }
        },
        extend: function(factories) {
          return new Binding(IterableDiffers, {
            toFactory: (function(parent) {
              if (isBlank(parent)) {
                throw new BaseException('Cannot extend IterableDiffers without a parent injector');
              }
              return IterableDiffers.create(factories, parent);
            }),
            deps: [[IterableDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]
          });
        }
      }));
      $__export("IterableDiffers", IterableDiffers);
      $__export("IterableDiffers", IterableDiffers = __decorate([Injectable(), CONST(), __metadata('design:paramtypes', [Array])], IterableDiffers));
    }
  };
});

System.register("angular2/src/change_detection/differs/default_iterable_differ", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/differs/default_iterable_differ";
  var __decorate,
      __metadata,
      CONST,
      BaseException,
      isListLikeIterable,
      iterateListLike,
      MapWrapper,
      isBlank,
      isPresent,
      stringify,
      getMapKey,
      looseIdentical,
      isArray,
      DefaultIterableDifferFactory,
      DefaultIterableDiffer,
      CollectionChangeRecord,
      _DuplicateItemRecordList,
      _DuplicateMap;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      stringify = $__m.stringify;
      getMapKey = $__m.getMapKey;
      looseIdentical = $__m.looseIdentical;
      isArray = $__m.isArray;
    }, function($__m) {
      isListLikeIterable = $__m.isListLikeIterable;
      iterateListLike = $__m.iterateListLike;
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      DefaultIterableDifferFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return isListLikeIterable(obj);
        },
        create: function(cdRef) {
          return new DefaultIterableDiffer();
        }
      }, {}));
      $__export("DefaultIterableDifferFactory", DefaultIterableDifferFactory);
      $__export("DefaultIterableDifferFactory", DefaultIterableDifferFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], DefaultIterableDifferFactory));
      DefaultIterableDiffer = (function() {
        function DefaultIterableDiffer() {
          this._collection = null;
          this._length = null;
          this._linkedRecords = null;
          this._unlinkedRecords = null;
          this._previousItHead = null;
          this._itHead = null;
          this._itTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._movesHead = null;
          this._movesTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
        }
        return ($traceurRuntime.createClass)(DefaultIterableDiffer, {
          get collection() {
            return this._collection;
          },
          get length() {
            return this._length;
          },
          forEachItem: function(fn) {
            var record;
            for (record = this._itHead; record !== null; record = record._next) {
              fn(record);
            }
          },
          forEachPreviousItem: function(fn) {
            var record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              fn(record);
            }
          },
          forEachAddedItem: function(fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
            }
          },
          forEachMovedItem: function(fn) {
            var record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
              fn(record);
            }
          },
          forEachRemovedItem: function(fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
            }
          },
          diff: function(collection) {
            if (isBlank(collection))
              collection = [];
            if (!isListLikeIterable(collection)) {
              throw new BaseException(("Error trying to diff '" + collection + "'"));
            }
            if (this.check(collection)) {
              return this;
            } else {
              return null;
            }
          },
          onDestroy: function() {},
          check: function(collection) {
            var $__0 = this;
            this._reset();
            var record = this._itHead;
            var mayBeDirty = false;
            var index;
            var item;
            if (isArray(collection)) {
              var list = collection;
              this._length = collection.length;
              for (index = 0; index < this._length; index++) {
                item = list[index];
                if (record === null || !looseIdentical(record.item, item)) {
                  record = this._mismatch(record, item, index);
                  mayBeDirty = true;
                } else if (mayBeDirty) {
                  record = this._verifyReinsertion(record, item, index);
                }
                record = record._next;
              }
            } else {
              index = 0;
              iterateListLike(collection, (function(item) {
                if (record === null || !looseIdentical(record.item, item)) {
                  record = $__0._mismatch(record, item, index);
                  mayBeDirty = true;
                } else if (mayBeDirty) {
                  record = $__0._verifyReinsertion(record, item, index);
                }
                record = record._next;
                index++;
              }));
              this._length = index;
            }
            this._truncate(record);
            this._collection = collection;
            return this.isDirty;
          },
          get isDirty() {
            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
          },
          _reset: function() {
            if (this.isDirty) {
              var record;
              var nextRecord;
              for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
              }
              for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
              }
              this._additionsHead = this._additionsTail = null;
              for (record = this._movesHead; record !== null; record = nextRecord) {
                record.previousIndex = record.currentIndex;
                nextRecord = record._nextMoved;
              }
              this._movesHead = this._movesTail = null;
              this._removalsHead = this._removalsTail = null;
            }
          },
          _mismatch: function(record, item, index) {
            var previousRecord;
            if (record === null) {
              previousRecord = this._itTail;
            } else {
              previousRecord = record._prev;
              this._remove(record);
            }
            record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
            if (record !== null) {
              this._moveAfter(record, previousRecord, index);
            } else {
              record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
              if (record !== null) {
                this._reinsertAfter(record, previousRecord, index);
              } else {
                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
              }
            }
            return record;
          },
          _verifyReinsertion: function(record, item, index) {
            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
            if (reinsertRecord !== null) {
              record = this._reinsertAfter(reinsertRecord, record._prev, index);
            } else if (record.currentIndex != index) {
              record.currentIndex = index;
              this._addToMoves(record, index);
            }
            return record;
          },
          _truncate: function(record) {
            while (record !== null) {
              var nextRecord = record._next;
              this._addToRemovals(this._unlink(record));
              record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
              this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
              this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
              this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
              this._removalsTail._nextRemoved = null;
            }
          },
          _reinsertAfter: function(record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.remove(record);
            }
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
              this._removalsHead = next;
            } else {
              prev._nextRemoved = next;
            }
            if (next === null) {
              this._removalsTail = prev;
            } else {
              next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
          },
          _moveAfter: function(record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
          },
          _addAfter: function(record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
              this._additionsTail = this._additionsHead = record;
            } else {
              this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
          },
          _insertAfter: function(record, prevRecord, index) {
            var next = prevRecord === null ? this._itHead : prevRecord._next;
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
              this._itTail = record;
            } else {
              next._prev = record;
            }
            if (prevRecord === null) {
              this._itHead = record;
            } else {
              prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
              this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
          },
          _remove: function(record) {
            return this._addToRemovals(this._unlink(record));
          },
          _unlink: function(record) {
            if (this._linkedRecords !== null) {
              this._linkedRecords.remove(record);
            }
            var prev = record._prev;
            var next = record._next;
            if (prev === null) {
              this._itHead = next;
            } else {
              prev._next = next;
            }
            if (next === null) {
              this._itTail = prev;
            } else {
              next._prev = prev;
            }
            return record;
          },
          _addToMoves: function(record, toIndex) {
            if (record.previousIndex === toIndex) {
              return record;
            }
            if (this._movesTail === null) {
              this._movesTail = this._movesHead = record;
            } else {
              this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
          },
          _addToRemovals: function(record) {
            if (this._unlinkedRecords === null) {
              this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
              this._removalsTail = this._removalsHead = record;
              record._prevRemoved = null;
            } else {
              record._prevRemoved = this._removalsTail;
              this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
          },
          toString: function() {
            var record;
            var list = [];
            for (record = this._itHead; record !== null; record = record._next) {
              list.push(record);
            }
            var previous = [];
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              previous.push(record);
            }
            var additions = [];
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              additions.push(record);
            }
            var moves = [];
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
              moves.push(record);
            }
            var removals = [];
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              removals.push(record);
            }
            return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
          }
        }, {});
      }());
      $__export("DefaultIterableDiffer", DefaultIterableDiffer);
      CollectionChangeRecord = (function() {
        function CollectionChangeRecord(item) {
          this.item = item;
          this.currentIndex = null;
          this.previousIndex = null;
          this._nextPrevious = null;
          this._prev = null;
          this._next = null;
          this._prevDup = null;
          this._nextDup = null;
          this._prevRemoved = null;
          this._nextRemoved = null;
          this._nextAdded = null;
          this._nextMoved = null;
        }
        return ($traceurRuntime.createClass)(CollectionChangeRecord, {toString: function() {
            return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + '[' + stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
          }}, {});
      }());
      $__export("CollectionChangeRecord", CollectionChangeRecord);
      _DuplicateItemRecordList = (function() {
        function _DuplicateItemRecordList() {
          this._head = null;
          this._tail = null;
        }
        return ($traceurRuntime.createClass)(_DuplicateItemRecordList, {
          add: function(record) {
            if (this._head === null) {
              this._head = this._tail = record;
              record._nextDup = null;
              record._prevDup = null;
            } else {
              this._tail._nextDup = record;
              record._prevDup = this._tail;
              record._nextDup = null;
              this._tail = record;
            }
          },
          get: function(item, afterIndex) {
            var record;
            for (record = this._head; record !== null; record = record._nextDup) {
              if ((afterIndex === null || afterIndex < record.currentIndex) && looseIdentical(record.item, item)) {
                return record;
              }
            }
            return null;
          },
          remove: function(record) {
            var prev = record._prevDup;
            var next = record._nextDup;
            if (prev === null) {
              this._head = next;
            } else {
              prev._nextDup = next;
            }
            if (next === null) {
              this._tail = prev;
            } else {
              next._prevDup = prev;
            }
            return this._head === null;
          }
        }, {});
      }());
      _DuplicateMap = (function() {
        function _DuplicateMap() {
          this.map = new Map();
        }
        return ($traceurRuntime.createClass)(_DuplicateMap, {
          put: function(record) {
            var key = getMapKey(record.item);
            var duplicates = this.map.get(key);
            if (!isPresent(duplicates)) {
              duplicates = new _DuplicateItemRecordList();
              this.map.set(key, duplicates);
            }
            duplicates.add(record);
          },
          get: function(value) {
            var afterIndex = arguments[1] !== (void 0) ? arguments[1] : null;
            var key = getMapKey(value);
            var recordList = this.map.get(key);
            return isBlank(recordList) ? null : recordList.get(value, afterIndex);
          },
          remove: function(record) {
            var key = getMapKey(record.item);
            var recordList = this.map.get(key);
            if (recordList.remove(record)) {
              MapWrapper.delete(this.map, key);
            }
            return record;
          },
          get isEmpty() {
            return MapWrapper.size(this.map) === 0;
          },
          clear: function() {
            this.map.clear();
          },
          toString: function() {
            return '_DuplicateMap(' + stringify(this.map) + ')';
          }
        }, {});
      }());
    }
  };
});

System.register("angular2/src/change_detection/differs/keyvalue_differs", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/differs/keyvalue_differs";
  var __decorate,
      __metadata,
      isBlank,
      isPresent,
      BaseException,
      CONST,
      ListWrapper,
      Binding,
      SkipSelfMetadata,
      OptionalMetadata,
      Injectable,
      KeyValueDiffers;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Binding = $__m.Binding;
      SkipSelfMetadata = $__m.SkipSelfMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      KeyValueDiffers = (($traceurRuntime.createClass)(function(factories) {
        this.factories = factories;
      }, {find: function(kv) {
          var factory = ListWrapper.find(this.factories, (function(f) {
            return f.supports(kv);
          }));
          if (isPresent(factory)) {
            return factory;
          } else {
            throw new BaseException(("Cannot find a differ supporting object '" + kv + "'"));
          }
        }}, {
        create: function(factories, parent) {
          if (isPresent(parent)) {
            var copied = ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new KeyValueDiffers(factories);
          } else {
            return new KeyValueDiffers(factories);
          }
        },
        extend: function(factories) {
          return new Binding(KeyValueDiffers, {
            toFactory: (function(parent) {
              if (isBlank(parent)) {
                throw new BaseException('Cannot extend KeyValueDiffers without a parent injector');
              }
              return KeyValueDiffers.create(factories, parent);
            }),
            deps: [[KeyValueDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]
          });
        }
      }));
      $__export("KeyValueDiffers", KeyValueDiffers);
      $__export("KeyValueDiffers", KeyValueDiffers = __decorate([Injectable(), CONST(), __metadata('design:paramtypes', [Array])], KeyValueDiffers));
    }
  };
});

System.register("angular2/src/change_detection/differs/default_keyvalue_differ", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/differs/default_keyvalue_differ";
  var __decorate,
      __metadata,
      MapWrapper,
      StringMapWrapper,
      stringify,
      looseIdentical,
      isJsObject,
      CONST,
      isBlank,
      BaseException,
      DefaultKeyValueDifferFactory,
      DefaultKeyValueDiffer,
      KVChangeRecord;
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      looseIdentical = $__m.looseIdentical;
      isJsObject = $__m.isJsObject;
      CONST = $__m.CONST;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      DefaultKeyValueDifferFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return obj instanceof Map || isJsObject(obj);
        },
        create: function(cdRef) {
          return new DefaultKeyValueDiffer();
        }
      }, {}));
      $__export("DefaultKeyValueDifferFactory", DefaultKeyValueDifferFactory);
      $__export("DefaultKeyValueDifferFactory", DefaultKeyValueDifferFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], DefaultKeyValueDifferFactory));
      DefaultKeyValueDiffer = (function() {
        function DefaultKeyValueDiffer() {
          this._records = new Map();
          this._mapHead = null;
          this._previousMapHead = null;
          this._changesHead = null;
          this._changesTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
        }
        return ($traceurRuntime.createClass)(DefaultKeyValueDiffer, {
          get isDirty() {
            return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
          },
          forEachItem: function(fn) {
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
              fn(record);
            }
          },
          forEachPreviousItem: function(fn) {
            var record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              fn(record);
            }
          },
          forEachChangedItem: function(fn) {
            var record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
              fn(record);
            }
          },
          forEachAddedItem: function(fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
            }
          },
          forEachRemovedItem: function(fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
            }
          },
          diff: function(map) {
            if (isBlank(map))
              map = MapWrapper.createFromPairs([]);
            if (!(map instanceof Map || isJsObject(map))) {
              throw new BaseException(("Error trying to diff '" + map + "'"));
            }
            if (this.check(map)) {
              return this;
            } else {
              return null;
            }
          },
          onDestroy: function() {},
          check: function(map) {
            var $__0 = this;
            this._reset();
            var records = this._records;
            var oldSeqRecord = this._mapHead;
            var lastOldSeqRecord = null;
            var lastNewSeqRecord = null;
            var seqChanged = false;
            this._forEach(map, (function(value, key) {
              var newSeqRecord;
              if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                newSeqRecord = oldSeqRecord;
                if (!looseIdentical(value, oldSeqRecord.currentValue)) {
                  oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                  oldSeqRecord.currentValue = value;
                  $__0._addToChanges(oldSeqRecord);
                }
              } else {
                seqChanged = true;
                if (oldSeqRecord !== null) {
                  oldSeqRecord._next = null;
                  $__0._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                  $__0._addToRemovals(oldSeqRecord);
                }
                if (records.has(key)) {
                  newSeqRecord = records.get(key);
                } else {
                  newSeqRecord = new KVChangeRecord(key);
                  records.set(key, newSeqRecord);
                  newSeqRecord.currentValue = value;
                  $__0._addToAdditions(newSeqRecord);
                }
              }
              if (seqChanged) {
                if ($__0._isInRemovals(newSeqRecord)) {
                  $__0._removeFromRemovals(newSeqRecord);
                }
                if (lastNewSeqRecord == null) {
                  $__0._mapHead = newSeqRecord;
                } else {
                  lastNewSeqRecord._next = newSeqRecord;
                }
              }
              lastOldSeqRecord = oldSeqRecord;
              lastNewSeqRecord = newSeqRecord;
              oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
            }));
            this._truncate(lastOldSeqRecord, oldSeqRecord);
            return this.isDirty;
          },
          _reset: function() {
            if (this.isDirty) {
              var record;
              for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
              }
              for (record = this._changesHead; record !== null; record = record._nextChanged) {
                record.previousValue = record.currentValue;
              }
              for (record = this._additionsHead; record != null; record = record._nextAdded) {
                record.previousValue = record.currentValue;
              }
              this._changesHead = this._changesTail = null;
              this._additionsHead = this._additionsTail = null;
              this._removalsHead = this._removalsTail = null;
            }
          },
          _truncate: function(lastRecord, record) {
            while (record !== null) {
              if (lastRecord === null) {
                this._mapHead = null;
              } else {
                lastRecord._next = null;
              }
              var nextRecord = record._next;
              this._addToRemovals(record);
              lastRecord = record;
              record = nextRecord;
            }
            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
              rec.previousValue = rec.currentValue;
              rec.currentValue = null;
              MapWrapper.delete(this._records, rec.key);
            }
          },
          _isInRemovals: function(record) {
            return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
          },
          _addToRemovals: function(record) {
            if (this._removalsHead === null) {
              this._removalsHead = this._removalsTail = record;
            } else {
              this._removalsTail._nextRemoved = record;
              record._prevRemoved = this._removalsTail;
              this._removalsTail = record;
            }
          },
          _removeFromSeq: function(prev, record) {
            var next = record._next;
            if (prev === null) {
              this._mapHead = next;
            } else {
              prev._next = next;
            }
          },
          _removeFromRemovals: function(record) {
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
              this._removalsHead = next;
            } else {
              prev._nextRemoved = next;
            }
            if (next === null) {
              this._removalsTail = prev;
            } else {
              next._prevRemoved = prev;
            }
            record._prevRemoved = record._nextRemoved = null;
          },
          _addToAdditions: function(record) {
            if (this._additionsHead === null) {
              this._additionsHead = this._additionsTail = record;
            } else {
              this._additionsTail._nextAdded = record;
              this._additionsTail = record;
            }
          },
          _addToChanges: function(record) {
            if (this._changesHead === null) {
              this._changesHead = this._changesTail = record;
            } else {
              this._changesTail._nextChanged = record;
              this._changesTail = record;
            }
          },
          toString: function() {
            var items = [];
            var previous = [];
            var changes = [];
            var additions = [];
            var removals = [];
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
              items.push(stringify(record));
            }
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              previous.push(stringify(record));
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
              changes.push(stringify(record));
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              additions.push(stringify(record));
            }
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              removals.push(stringify(record));
            }
            return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
          },
          _forEach: function(obj, fn) {
            if (obj instanceof Map) {
              MapWrapper.forEach(obj, fn);
            } else {
              StringMapWrapper.forEach(obj, fn);
            }
          }
        }, {});
      }());
      $__export("DefaultKeyValueDiffer", DefaultKeyValueDiffer);
      KVChangeRecord = (function() {
        function KVChangeRecord(key) {
          this.key = key;
          this.previousValue = null;
          this.currentValue = null;
          this._nextPrevious = null;
          this._next = null;
          this._nextAdded = null;
          this._nextRemoved = null;
          this._prevRemoved = null;
          this._nextChanged = null;
        }
        return ($traceurRuntime.createClass)(KVChangeRecord, {toString: function() {
            return looseIdentical(this.previousValue, this.currentValue) ? stringify(this.key) : (stringify(this.key) + '[' + stringify(this.previousValue) + '->' + stringify(this.currentValue) + ']');
          }}, {});
      }());
      $__export("KVChangeRecord", KVChangeRecord);
    }
  };
});

System.register("angular2/src/change_detection/interfaces", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/interfaces";
  var __decorate,
      __metadata,
      CONST,
      ChangeDetection,
      DebugContext,
      ChangeDetectorGenConfig,
      ChangeDetectorDefinition;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ChangeDetection = (($traceurRuntime.createClass)(function() {}, {
        getProtoChangeDetector: function(id, definition) {
          return null;
        },
        get generateDetectors() {
          return null;
        },
        get genConfig() {
          return null;
        }
      }, {}));
      $__export("ChangeDetection", ChangeDetection);
      $__export("ChangeDetection", ChangeDetection = __decorate([CONST(), __metadata('design:paramtypes', [])], ChangeDetection));
      DebugContext = (function() {
        function DebugContext(element, componentElement, directive, context, locals, injector) {
          this.element = element;
          this.componentElement = componentElement;
          this.directive = directive;
          this.context = context;
          this.locals = locals;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(DebugContext, {}, {});
      }());
      $__export("DebugContext", DebugContext);
      ChangeDetectorGenConfig = (function() {
        function ChangeDetectorGenConfig(genCheckNoChanges, genDebugInfo, logBindingUpdate) {
          this.genCheckNoChanges = genCheckNoChanges;
          this.genDebugInfo = genDebugInfo;
          this.logBindingUpdate = logBindingUpdate;
        }
        return ($traceurRuntime.createClass)(ChangeDetectorGenConfig, {}, {});
      }());
      $__export("ChangeDetectorGenConfig", ChangeDetectorGenConfig);
      ChangeDetectorDefinition = (function() {
        function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, eventRecords, directiveRecords, genConfig) {
          this.id = id;
          this.strategy = strategy;
          this.variableNames = variableNames;
          this.bindingRecords = bindingRecords;
          this.eventRecords = eventRecords;
          this.directiveRecords = directiveRecords;
          this.genConfig = genConfig;
        }
        return ($traceurRuntime.createClass)(ChangeDetectorDefinition, {}, {});
      }());
      $__export("ChangeDetectorDefinition", ChangeDetectorDefinition);
    }
  };
});

System.register("angular2/src/change_detection/parser/lexer", ["angular2/src/di/decorators", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/lexer";
  var __decorate,
      __metadata,
      Injectable,
      SetWrapper,
      NumberWrapper,
      StringJoiner,
      StringWrapper,
      BaseException,
      isPresent,
      TokenType,
      Lexer,
      Token,
      EOF,
      $EOF,
      $TAB,
      $LF,
      $VTAB,
      $FF,
      $CR,
      $SPACE,
      $BANG,
      $DQ,
      $HASH,
      $$,
      $PERCENT,
      $AMPERSAND,
      $SQ,
      $LPAREN,
      $RPAREN,
      $STAR,
      $PLUS,
      $COMMA,
      $MINUS,
      $PERIOD,
      $SLASH,
      $COLON,
      $SEMICOLON,
      $LT,
      $EQ,
      $GT,
      $QUESTION,
      $0,
      $9,
      $A,
      $E,
      $Z,
      $LBRACKET,
      $BACKSLASH,
      $RBRACKET,
      $CARET,
      $_,
      $a,
      $e,
      $f,
      $n,
      $r,
      $t,
      $u,
      $v,
      $z,
      $LBRACE,
      $BAR,
      $RBRACE,
      $NBSP,
      ScannerError,
      _Scanner,
      OPERATORS,
      KEYWORDS;
  function newCharacterToken(index, code) {
    return new Token(index, TokenType.CHARACTER, code, StringWrapper.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
    return new Token(index, TokenType.IDENTIFIER, 0, text);
  }
  function newKeywordToken(index, text) {
    return new Token(index, TokenType.KEYWORD, 0, text);
  }
  function newOperatorToken(index, text) {
    return new Token(index, TokenType.OPERATOR, 0, text);
  }
  function newStringToken(index, text) {
    return new Token(index, TokenType.STRING, 0, text);
  }
  function newNumberToken(index, n) {
    return new Token(index, TokenType.NUMBER, n, "");
  }
  function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == $$);
  }
  function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) || (code == $_) || (code == $$);
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      SetWrapper = $__m.SetWrapper;
    }, function($__m) {
      NumberWrapper = $__m.NumberWrapper;
      StringJoiner = $__m.StringJoiner;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      $__export("TokenType", TokenType);
      (function(TokenType) {
        TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
        TokenType[TokenType["IDENTIFIER"] = 1] = "IDENTIFIER";
        TokenType[TokenType["KEYWORD"] = 2] = "KEYWORD";
        TokenType[TokenType["STRING"] = 3] = "STRING";
        TokenType[TokenType["OPERATOR"] = 4] = "OPERATOR";
        TokenType[TokenType["NUMBER"] = 5] = "NUMBER";
      })(TokenType || ($__export("TokenType", TokenType = {})));
      Lexer = (($traceurRuntime.createClass)(function() {}, {tokenize: function(text) {
          var scanner = new _Scanner(text);
          var tokens = [];
          var token = scanner.scanToken();
          while (token != null) {
            tokens.push(token);
            token = scanner.scanToken();
          }
          return tokens;
        }}, {}));
      $__export("Lexer", Lexer);
      $__export("Lexer", Lexer = __decorate([Injectable(), __metadata('design:paramtypes', [])], Lexer));
      Token = (function() {
        function Token(index, type, numValue, strValue) {
          this.index = index;
          this.type = type;
          this.numValue = numValue;
          this.strValue = strValue;
        }
        return ($traceurRuntime.createClass)(Token, {
          isCharacter: function(code) {
            return (this.type == TokenType.CHARACTER && this.numValue == code);
          },
          isNumber: function() {
            return (this.type == TokenType.NUMBER);
          },
          isString: function() {
            return (this.type == TokenType.STRING);
          },
          isOperator: function(operater) {
            return (this.type == TokenType.OPERATOR && this.strValue == operater);
          },
          isIdentifier: function() {
            return (this.type == TokenType.IDENTIFIER);
          },
          isKeyword: function() {
            return (this.type == TokenType.KEYWORD);
          },
          isKeywordVar: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "var");
          },
          isKeywordNull: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "null");
          },
          isKeywordUndefined: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "undefined");
          },
          isKeywordTrue: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "true");
          },
          isKeywordIf: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "if");
          },
          isKeywordElse: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "else");
          },
          isKeywordFalse: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "false");
          },
          toNumber: function() {
            return (this.type == TokenType.NUMBER) ? this.numValue : -1;
          },
          toString: function() {
            switch (this.type) {
              case TokenType.CHARACTER:
              case TokenType.STRING:
              case TokenType.IDENTIFIER:
              case TokenType.KEYWORD:
                return this.strValue;
              case TokenType.NUMBER:
                return this.numValue.toString();
              default:
                return null;
            }
          }
        }, {});
      }());
      $__export("Token", Token);
      EOF = new Token(-1, TokenType.CHARACTER, 0, "");
      $__export("EOF", EOF);
      $EOF = 0;
      $__export("$EOF", $EOF);
      $TAB = 9;
      $__export("$TAB", $TAB);
      $LF = 10;
      $__export("$LF", $LF);
      $VTAB = 11;
      $__export("$VTAB", $VTAB);
      $FF = 12;
      $__export("$FF", $FF);
      $CR = 13;
      $__export("$CR", $CR);
      $SPACE = 32;
      $__export("$SPACE", $SPACE);
      $BANG = 33;
      $__export("$BANG", $BANG);
      $DQ = 34;
      $__export("$DQ", $DQ);
      $HASH = 35;
      $__export("$HASH", $HASH);
      $$ = 36;
      $__export("$$", $$);
      $PERCENT = 37;
      $__export("$PERCENT", $PERCENT);
      $AMPERSAND = 38;
      $__export("$AMPERSAND", $AMPERSAND);
      $SQ = 39;
      $__export("$SQ", $SQ);
      $LPAREN = 40;
      $__export("$LPAREN", $LPAREN);
      $RPAREN = 41;
      $__export("$RPAREN", $RPAREN);
      $STAR = 42;
      $__export("$STAR", $STAR);
      $PLUS = 43;
      $__export("$PLUS", $PLUS);
      $COMMA = 44;
      $__export("$COMMA", $COMMA);
      $MINUS = 45;
      $__export("$MINUS", $MINUS);
      $PERIOD = 46;
      $__export("$PERIOD", $PERIOD);
      $SLASH = 47;
      $__export("$SLASH", $SLASH);
      $COLON = 58;
      $__export("$COLON", $COLON);
      $SEMICOLON = 59;
      $__export("$SEMICOLON", $SEMICOLON);
      $LT = 60;
      $__export("$LT", $LT);
      $EQ = 61;
      $__export("$EQ", $EQ);
      $GT = 62;
      $__export("$GT", $GT);
      $QUESTION = 63;
      $__export("$QUESTION", $QUESTION);
      $0 = 48;
      $9 = 57;
      $A = 65, $E = 69, $Z = 90;
      $LBRACKET = 91;
      $__export("$LBRACKET", $LBRACKET);
      $BACKSLASH = 92;
      $__export("$BACKSLASH", $BACKSLASH);
      $RBRACKET = 93;
      $__export("$RBRACKET", $RBRACKET);
      $CARET = 94;
      $_ = 95;
      $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
      $LBRACE = 123;
      $__export("$LBRACE", $LBRACE);
      $BAR = 124;
      $__export("$BAR", $BAR);
      $RBRACE = 125;
      $__export("$RBRACE", $RBRACE);
      $NBSP = 160;
      ScannerError = (function($__super) {
        function ScannerError(message) {
          $traceurRuntime.superConstructor(ScannerError).call(this);
          this.message = message;
        }
        return ($traceurRuntime.createClass)(ScannerError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("ScannerError", ScannerError);
      _Scanner = (function() {
        function _Scanner(input) {
          this.input = input;
          this.peek = 0;
          this.index = -1;
          this.length = input.length;
          this.advance();
        }
        return ($traceurRuntime.createClass)(_Scanner, {
          advance: function() {
            this.peek = ++this.index >= this.length ? $EOF : StringWrapper.charCodeAt(this.input, this.index);
          },
          scanToken: function() {
            var input = this.input,
                length = this.length,
                peek = this.peek,
                index = this.index;
            while (peek <= $SPACE) {
              if (++index >= length) {
                peek = $EOF;
                break;
              } else {
                peek = StringWrapper.charCodeAt(input, index);
              }
            }
            this.peek = peek;
            this.index = index;
            if (index >= length) {
              return null;
            }
            if (isIdentifierStart(peek))
              return this.scanIdentifier();
            if (isDigit(peek))
              return this.scanNumber(index);
            var start = index;
            switch (peek) {
              case $PERIOD:
                this.advance();
                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
              case $LPAREN:
              case $RPAREN:
              case $LBRACE:
              case $RBRACE:
              case $LBRACKET:
              case $RBRACKET:
              case $COMMA:
              case $COLON:
              case $SEMICOLON:
                return this.scanCharacter(start, peek);
              case $SQ:
              case $DQ:
                return this.scanString();
              case $HASH:
              case $PLUS:
              case $MINUS:
              case $STAR:
              case $SLASH:
              case $PERCENT:
              case $CARET:
                return this.scanOperator(start, StringWrapper.fromCharCode(peek));
              case $QUESTION:
                return this.scanComplexOperator(start, '?', $PERIOD, '.');
              case $LT:
              case $GT:
                return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=');
              case $BANG:
              case $EQ:
                return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=', $EQ, '=');
              case $AMPERSAND:
                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
              case $BAR:
                return this.scanComplexOperator(start, '|', $BAR, '|');
              case $NBSP:
                while (isWhitespace(this.peek))
                  this.advance();
                return this.scanToken();
            }
            this.error(("Unexpected character [" + StringWrapper.fromCharCode(peek) + "]"), 0);
            return null;
          },
          scanCharacter: function(start, code) {
            assert(this.peek == code);
            this.advance();
            return newCharacterToken(start, code);
          },
          scanOperator: function(start, str) {
            assert(this.peek == StringWrapper.charCodeAt(str, 0));
            assert(SetWrapper.has(OPERATORS, str));
            this.advance();
            return newOperatorToken(start, str);
          },
          scanComplexOperator: function(start, one, twoCode, two, threeCode, three) {
            assert(this.peek == StringWrapper.charCodeAt(one, 0));
            this.advance();
            var str = one;
            if (this.peek == twoCode) {
              this.advance();
              str += two;
            }
            if (isPresent(threeCode) && this.peek == threeCode) {
              this.advance();
              str += three;
            }
            assert(SetWrapper.has(OPERATORS, str));
            return newOperatorToken(start, str);
          },
          scanIdentifier: function() {
            assert(isIdentifierStart(this.peek));
            var start = this.index;
            this.advance();
            while (isIdentifierPart(this.peek))
              this.advance();
            var str = this.input.substring(start, this.index);
            if (SetWrapper.has(KEYWORDS, str)) {
              return newKeywordToken(start, str);
            } else {
              return newIdentifierToken(start, str);
            }
          },
          scanNumber: function(start) {
            assert(isDigit(this.peek));
            var simple = (this.index === start);
            this.advance();
            while (true) {
              if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
                simple = false;
              } else if (isExponentStart(this.peek)) {
                this.advance();
                if (isExponentSign(this.peek))
                  this.advance();
                if (!isDigit(this.peek))
                  this.error('Invalid exponent', -1);
                simple = false;
              } else {
                break;
              }
              this.advance();
            }
            var str = this.input.substring(start, this.index);
            var value = simple ? NumberWrapper.parseIntAutoRadix(str) : NumberWrapper.parseFloat(str);
            return newNumberToken(start, value);
          },
          scanString: function() {
            assert(this.peek == $SQ || this.peek == $DQ);
            var start = this.index;
            var quote = this.peek;
            this.advance();
            var buffer;
            var marker = this.index;
            var input = this.input;
            while (this.peek != quote) {
              if (this.peek == $BACKSLASH) {
                if (buffer == null)
                  buffer = new StringJoiner();
                buffer.add(input.substring(marker, this.index));
                this.advance();
                var unescapedCode = void 0;
                if (this.peek == $u) {
                  var hex = input.substring(this.index + 1, this.index + 5);
                  try {
                    unescapedCode = NumberWrapper.parseInt(hex, 16);
                  } catch (e) {
                    this.error(("Invalid unicode escape [\\u" + hex + "]"), 0);
                  }
                  for (var i = 0; i < 5; i++) {
                    this.advance();
                  }
                } else {
                  unescapedCode = unescape(this.peek);
                  this.advance();
                }
                buffer.add(StringWrapper.fromCharCode(unescapedCode));
                marker = this.index;
              } else if (this.peek == $EOF) {
                this.error('Unterminated quote', 0);
              } else {
                this.advance();
              }
            }
            var last = input.substring(marker, this.index);
            this.advance();
            var unescaped = last;
            if (buffer != null) {
              buffer.add(last);
              unescaped = buffer.toString();
            }
            return newStringToken(start, unescaped);
          },
          error: function(message, offset) {
            var position = this.index + offset;
            throw new ScannerError(("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]"));
          }
        }, {});
      }());
      OPERATORS = SetWrapper.createFromList(['+', '-', '*', '/', '%', '^', '=', '==', '!=', '===', '!==', '<', '>', '<=', '>=', '&&', '||', '&', '|', '!', '?', '#', '?.']);
      KEYWORDS = SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false', 'if', 'else']);
    }
  };
});

System.register("angular2/src/change_detection/parser/parser", ["angular2/src/di/decorators", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/lexer", "angular2/src/reflection/reflection", "angular2/src/change_detection/parser/ast"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/parser";
  var __decorate,
      __metadata,
      Injectable,
      isBlank,
      isPresent,
      BaseException,
      StringWrapper,
      ListWrapper,
      Lexer,
      EOF,
      $PERIOD,
      $COLON,
      $SEMICOLON,
      $LBRACKET,
      $RBRACKET,
      $COMMA,
      $LBRACE,
      $RBRACE,
      $LPAREN,
      $RPAREN,
      reflector,
      Reflector,
      EmptyExpr,
      ImplicitReceiver,
      PropertyRead,
      PropertyWrite,
      SafePropertyRead,
      LiteralPrimitive,
      Binary,
      PrefixNot,
      Conditional,
      If,
      BindingPipe,
      Chain,
      KeyedRead,
      KeyedWrite,
      LiteralArray,
      LiteralMap,
      Interpolation,
      MethodCall,
      SafeMethodCall,
      FunctionCall,
      TemplateBinding,
      ASTWithSource,
      _implicitReceiver,
      INTERPOLATION_REGEXP,
      ParseException,
      Parser,
      _ParseAST,
      SimpleExpressionChecker;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Lexer = $__m.Lexer;
      EOF = $__m.EOF;
      $PERIOD = $__m.$PERIOD;
      $COLON = $__m.$COLON;
      $SEMICOLON = $__m.$SEMICOLON;
      $LBRACKET = $__m.$LBRACKET;
      $RBRACKET = $__m.$RBRACKET;
      $COMMA = $__m.$COMMA;
      $LBRACE = $__m.$LBRACE;
      $RBRACE = $__m.$RBRACE;
      $LPAREN = $__m.$LPAREN;
      $RPAREN = $__m.$RPAREN;
    }, function($__m) {
      reflector = $__m.reflector;
      Reflector = $__m.Reflector;
    }, function($__m) {
      EmptyExpr = $__m.EmptyExpr;
      ImplicitReceiver = $__m.ImplicitReceiver;
      PropertyRead = $__m.PropertyRead;
      PropertyWrite = $__m.PropertyWrite;
      SafePropertyRead = $__m.SafePropertyRead;
      LiteralPrimitive = $__m.LiteralPrimitive;
      Binary = $__m.Binary;
      PrefixNot = $__m.PrefixNot;
      Conditional = $__m.Conditional;
      If = $__m.If;
      BindingPipe = $__m.BindingPipe;
      Chain = $__m.Chain;
      KeyedRead = $__m.KeyedRead;
      KeyedWrite = $__m.KeyedWrite;
      LiteralArray = $__m.LiteralArray;
      LiteralMap = $__m.LiteralMap;
      Interpolation = $__m.Interpolation;
      MethodCall = $__m.MethodCall;
      SafeMethodCall = $__m.SafeMethodCall;
      FunctionCall = $__m.FunctionCall;
      TemplateBinding = $__m.TemplateBinding;
      ASTWithSource = $__m.ASTWithSource;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      _implicitReceiver = new ImplicitReceiver();
      INTERPOLATION_REGEXP = /\{\{(.*?)\}\}/g;
      ParseException = (function($__super) {
        function ParseException(message, input, errLocation, ctxLocation) {
          $traceurRuntime.superConstructor(ParseException).call(this, ("Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation), null, null, ctxLocation);
        }
        return ($traceurRuntime.createClass)(ParseException, {}, {}, $__super);
      }(BaseException));
      Parser = (($traceurRuntime.createClass)(function(_lexer) {
        var providedReflector = arguments[1] !== (void 0) ? arguments[1] : null;
        this._lexer = _lexer;
        this._reflector = isPresent(providedReflector) ? providedReflector : reflector;
      }, {
        parseAction: function(input, location) {
          this._checkNoInterpolation(input, location);
          var tokens = this._lexer.tokenize(input);
          var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
          return new ASTWithSource(ast, input, location);
        },
        parseBinding: function(input, location) {
          this._checkNoInterpolation(input, location);
          var tokens = this._lexer.tokenize(input);
          var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
          return new ASTWithSource(ast, input, location);
        },
        parseSimpleBinding: function(input, location) {
          this._checkNoInterpolation(input, location);
          var tokens = this._lexer.tokenize(input);
          var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseSimpleBinding();
          return new ASTWithSource(ast, input, location);
        },
        parseTemplateBindings: function(input, location) {
          var tokens = this._lexer.tokenize(input);
          return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
        },
        parseInterpolation: function(input, location) {
          var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
          if (parts.length <= 1) {
            return null;
          }
          var strings = [];
          var expressions = [];
          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i % 2 === 0) {
              strings.push(part);
            } else if (part.trim().length > 0) {
              var tokens = this._lexer.tokenize(part);
              var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
              expressions.push(ast);
            } else {
              throw new ParseException('Blank expressions are not allowed in interpolated strings', input, ("at column " + this._findInterpolationErrorColumn(parts, i) + " in"), location);
            }
          }
          return new ASTWithSource(new Interpolation(strings, expressions), input, location);
        },
        wrapLiteralPrimitive: function(input, location) {
          return new ASTWithSource(new LiteralPrimitive(input), input, location);
        },
        _checkNoInterpolation: function(input, location) {
          var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
          if (parts.length > 1) {
            throw new ParseException('Got interpolation ({{}}) where expression was expected', input, ("at column " + this._findInterpolationErrorColumn(parts, 1) + " in"), location);
          }
        },
        _findInterpolationErrorColumn: function(parts, partInErrIdx) {
          var errLocation = '';
          for (var j = 0; j < partInErrIdx; j++) {
            errLocation += j % 2 === 0 ? parts[j] : ("{{" + parts[j] + "}}");
          }
          return errLocation.length;
        }
      }, {}));
      $__export("Parser", Parser);
      $__export("Parser", Parser = __decorate([Injectable(), __metadata('design:paramtypes', [Lexer, Reflector])], Parser));
      _ParseAST = (function() {
        function _ParseAST(input, location, tokens, reflector, parseAction) {
          this.input = input;
          this.location = location;
          this.tokens = tokens;
          this.reflector = reflector;
          this.parseAction = parseAction;
          this.index = 0;
        }
        return ($traceurRuntime.createClass)(_ParseAST, {
          peek: function(offset) {
            var i = this.index + offset;
            return i < this.tokens.length ? this.tokens[i] : EOF;
          },
          get next() {
            return this.peek(0);
          },
          get inputIndex() {
            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
          },
          advance: function() {
            this.index++;
          },
          optionalCharacter: function(code) {
            if (this.next.isCharacter(code)) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          optionalKeywordVar: function() {
            if (this.peekKeywordVar()) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          peekKeywordVar: function() {
            return this.next.isKeywordVar() || this.next.isOperator('#');
          },
          expectCharacter: function(code) {
            if (this.optionalCharacter(code))
              return ;
            this.error(("Missing expected " + StringWrapper.fromCharCode(code)));
          },
          optionalOperator: function(op) {
            if (this.next.isOperator(op)) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          expectOperator: function(operator) {
            if (this.optionalOperator(operator))
              return ;
            this.error(("Missing expected operator " + operator));
          },
          expectIdentifierOrKeyword: function() {
            var n = this.next;
            if (!n.isIdentifier() && !n.isKeyword()) {
              this.error(("Unexpected token " + n + ", expected identifier or keyword"));
            }
            this.advance();
            return n.toString();
          },
          expectIdentifierOrKeywordOrString: function() {
            var n = this.next;
            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
              this.error(("Unexpected token " + n + ", expected identifier, keyword, or string"));
            }
            this.advance();
            return n.toString();
          },
          parseChain: function() {
            var exprs = [];
            while (this.index < this.tokens.length) {
              var expr = this.parsePipe();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                if (!this.parseAction) {
                  this.error("Binding expression cannot contain chained expression");
                }
                while (this.optionalCharacter($SEMICOLON)) {}
              } else if (this.index < this.tokens.length) {
                this.error(("Unexpected token '" + this.next + "'"));
              }
            }
            if (exprs.length == 0)
              return new EmptyExpr();
            if (exprs.length == 1)
              return exprs[0];
            return new Chain(exprs);
          },
          parseSimpleBinding: function() {
            var ast = this.parseChain();
            if (!SimpleExpressionChecker.check(ast)) {
              this.error("Simple binding expression can only contain field access and constants'");
            }
            return ast;
          },
          parsePipe: function() {
            var result = this.parseExpression();
            if (this.optionalOperator("|")) {
              if (this.parseAction) {
                this.error("Cannot have a pipe in an action expression");
              }
              do {
                var name = this.expectIdentifierOrKeyword();
                var args = [];
                while (this.optionalCharacter($COLON)) {
                  args.push(this.parsePipe());
                }
                result = new BindingPipe(result, name, args);
              } while (this.optionalOperator("|"));
            }
            return result;
          },
          parseExpression: function() {
            return this.parseConditional();
          },
          parseConditional: function() {
            var start = this.inputIndex;
            var result = this.parseLogicalOr();
            if (this.optionalOperator('?')) {
              var yes = this.parsePipe();
              if (!this.optionalCharacter($COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error(("Conditional expression " + expression + " requires all 3 expressions"));
              }
              var no = this.parsePipe();
              return new Conditional(result, yes, no);
            } else {
              return result;
            }
          },
          parseLogicalOr: function() {
            var result = this.parseLogicalAnd();
            while (this.optionalOperator('||')) {
              result = new Binary('||', result, this.parseLogicalAnd());
            }
            return result;
          },
          parseLogicalAnd: function() {
            var result = this.parseEquality();
            while (this.optionalOperator('&&')) {
              result = new Binary('&&', result, this.parseEquality());
            }
            return result;
          },
          parseEquality: function() {
            var result = this.parseRelational();
            while (true) {
              if (this.optionalOperator('==')) {
                result = new Binary('==', result, this.parseRelational());
              } else if (this.optionalOperator('===')) {
                result = new Binary('===', result, this.parseRelational());
              } else if (this.optionalOperator('!=')) {
                result = new Binary('!=', result, this.parseRelational());
              } else if (this.optionalOperator('!==')) {
                result = new Binary('!==', result, this.parseRelational());
              } else {
                return result;
              }
            }
          },
          parseRelational: function() {
            var result = this.parseAdditive();
            while (true) {
              if (this.optionalOperator('<')) {
                result = new Binary('<', result, this.parseAdditive());
              } else if (this.optionalOperator('>')) {
                result = new Binary('>', result, this.parseAdditive());
              } else if (this.optionalOperator('<=')) {
                result = new Binary('<=', result, this.parseAdditive());
              } else if (this.optionalOperator('>=')) {
                result = new Binary('>=', result, this.parseAdditive());
              } else {
                return result;
              }
            }
          },
          parseAdditive: function() {
            var result = this.parseMultiplicative();
            while (true) {
              if (this.optionalOperator('+')) {
                result = new Binary('+', result, this.parseMultiplicative());
              } else if (this.optionalOperator('-')) {
                result = new Binary('-', result, this.parseMultiplicative());
              } else {
                return result;
              }
            }
          },
          parseMultiplicative: function() {
            var result = this.parsePrefix();
            while (true) {
              if (this.optionalOperator('*')) {
                result = new Binary('*', result, this.parsePrefix());
              } else if (this.optionalOperator('%')) {
                result = new Binary('%', result, this.parsePrefix());
              } else if (this.optionalOperator('/')) {
                result = new Binary('/', result, this.parsePrefix());
              } else {
                return result;
              }
            }
          },
          parsePrefix: function() {
            if (this.optionalOperator('+')) {
              return this.parsePrefix();
            } else if (this.optionalOperator('-')) {
              return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
            } else if (this.optionalOperator('!')) {
              return new PrefixNot(this.parsePrefix());
            } else {
              return this.parseCallChain();
            }
          },
          parseCallChain: function() {
            var result = this.parsePrimary();
            while (true) {
              if (this.optionalCharacter($PERIOD)) {
                result = this.parseAccessMemberOrMethodCall(result, false);
              } else if (this.optionalOperator('?.')) {
                result = this.parseAccessMemberOrMethodCall(result, true);
              } else if (this.optionalCharacter($LBRACKET)) {
                var key = this.parsePipe();
                this.expectCharacter($RBRACKET);
                if (this.optionalOperator("=")) {
                  var value = this.parseConditional();
                  result = new KeyedWrite(result, key, value);
                } else {
                  result = new KeyedRead(result, key);
                }
              } else if (this.optionalCharacter($LPAREN)) {
                var args = this.parseCallArguments();
                this.expectCharacter($RPAREN);
                result = new FunctionCall(result, args);
              } else {
                return result;
              }
            }
          },
          parsePrimary: function() {
            if (this.optionalCharacter($LPAREN)) {
              var result = this.parsePipe();
              this.expectCharacter($RPAREN);
              return result;
            } else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
              this.advance();
              return new LiteralPrimitive(null);
            } else if (this.next.isKeywordTrue()) {
              this.advance();
              return new LiteralPrimitive(true);
            } else if (this.next.isKeywordFalse()) {
              this.advance();
              return new LiteralPrimitive(false);
            } else if (this.parseAction && this.next.isKeywordIf()) {
              this.advance();
              this.expectCharacter($LPAREN);
              var condition = this.parseExpression();
              this.expectCharacter($RPAREN);
              var ifExp = this.parseExpressionOrBlock();
              var elseExp;
              if (this.next.isKeywordElse()) {
                this.advance();
                elseExp = this.parseExpressionOrBlock();
              }
              return new If(condition, ifExp, elseExp);
            } else if (this.optionalCharacter($LBRACKET)) {
              var elements = this.parseExpressionList($RBRACKET);
              this.expectCharacter($RBRACKET);
              return new LiteralArray(elements);
            } else if (this.next.isCharacter($LBRACE)) {
              return this.parseLiteralMap();
            } else if (this.next.isIdentifier()) {
              return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
            } else if (this.next.isNumber()) {
              var value = this.next.toNumber();
              this.advance();
              return new LiteralPrimitive(value);
            } else if (this.next.isString()) {
              var literalValue = this.next.toString();
              this.advance();
              return new LiteralPrimitive(literalValue);
            } else if (this.index >= this.tokens.length) {
              this.error(("Unexpected end of expression: " + this.input));
            } else {
              this.error(("Unexpected token " + this.next));
            }
            throw new BaseException("Fell through all cases in parsePrimary");
          },
          parseExpressionList: function(terminator) {
            var result = [];
            if (!this.next.isCharacter(terminator)) {
              do {
                result.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
            }
            return result;
          },
          parseLiteralMap: function() {
            var keys = [];
            var values = [];
            this.expectCharacter($LBRACE);
            if (!this.optionalCharacter($RBRACE)) {
              do {
                var key = this.expectIdentifierOrKeywordOrString();
                keys.push(key);
                this.expectCharacter($COLON);
                values.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
              this.expectCharacter($RBRACE);
            }
            return new LiteralMap(keys, values);
          },
          parseAccessMemberOrMethodCall: function(receiver) {
            var isSafe = arguments[1] !== (void 0) ? arguments[1] : false;
            var id = this.expectIdentifierOrKeyword();
            if (this.optionalCharacter($LPAREN)) {
              var args = this.parseCallArguments();
              this.expectCharacter($RPAREN);
              var fn = this.reflector.method(id);
              return isSafe ? new SafeMethodCall(receiver, id, fn, args) : new MethodCall(receiver, id, fn, args);
            } else {
              if (isSafe) {
                if (this.optionalOperator("=")) {
                  this.error("The '?.' operator cannot be used in the assignment");
                } else {
                  return new SafePropertyRead(receiver, id, this.reflector.getter(id));
                }
              } else {
                if (this.optionalOperator("=")) {
                  if (!this.parseAction) {
                    this.error("Bindings cannot contain assignments");
                  }
                  var value = this.parseConditional();
                  return new PropertyWrite(receiver, id, this.reflector.setter(id), value);
                } else {
                  return new PropertyRead(receiver, id, this.reflector.getter(id));
                }
              }
            }
            return null;
          },
          parseCallArguments: function() {
            if (this.next.isCharacter($RPAREN))
              return [];
            var positionals = [];
            do {
              positionals.push(this.parsePipe());
            } while (this.optionalCharacter($COMMA));
            return positionals;
          },
          parseExpressionOrBlock: function() {
            if (this.optionalCharacter($LBRACE)) {
              var block = this.parseBlockContent();
              this.expectCharacter($RBRACE);
              return block;
            }
            return this.parseExpression();
          },
          parseBlockContent: function() {
            if (!this.parseAction) {
              this.error("Binding expression cannot contain chained expression");
            }
            var exprs = [];
            while (this.index < this.tokens.length && !this.next.isCharacter($RBRACE)) {
              var expr = this.parseExpression();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                while (this.optionalCharacter($SEMICOLON)) {}
              }
            }
            if (exprs.length == 0)
              return new EmptyExpr();
            if (exprs.length == 1)
              return exprs[0];
            return new Chain(exprs);
          },
          expectTemplateBindingKey: function() {
            var result = '';
            var operatorFound = false;
            do {
              result += this.expectIdentifierOrKeywordOrString();
              operatorFound = this.optionalOperator('-');
              if (operatorFound) {
                result += '-';
              }
            } while (operatorFound);
            return result.toString();
          },
          parseTemplateBindings: function() {
            var bindings = [];
            var prefix = null;
            while (this.index < this.tokens.length) {
              var keyIsVar = this.optionalKeywordVar();
              var key = this.expectTemplateBindingKey();
              if (!keyIsVar) {
                if (prefix == null) {
                  prefix = key;
                } else {
                  key = prefix + '-' + key;
                }
              }
              this.optionalCharacter($COLON);
              var name = null;
              var expression = null;
              if (keyIsVar) {
                if (this.optionalOperator("=")) {
                  name = this.expectTemplateBindingKey();
                } else {
                  name = '\$implicit';
                }
              } else if (this.next !== EOF && !this.peekKeywordVar()) {
                var start = this.inputIndex;
                var ast = this.parsePipe();
                var source = this.input.substring(start, this.inputIndex);
                expression = new ASTWithSource(ast, source, this.location);
              }
              bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
              if (!this.optionalCharacter($SEMICOLON)) {
                this.optionalCharacter($COMMA);
              }
            }
            return bindings;
          },
          error: function(message) {
            var index = arguments[1] !== (void 0) ? arguments[1] : null;
            if (isBlank(index))
              index = this.index;
            var location = (index < this.tokens.length) ? ("at column " + (this.tokens[index].index + 1) + " in") : "at the end of the expression";
            throw new ParseException(message, this.input, location, this.location);
          }
        }, {});
      }());
      $__export("_ParseAST", _ParseAST);
      SimpleExpressionChecker = (function() {
        function SimpleExpressionChecker() {
          this.simple = true;
        }
        return ($traceurRuntime.createClass)(SimpleExpressionChecker, {
          visitImplicitReceiver: function(ast) {},
          visitInterpolation: function(ast) {
            this.simple = false;
          },
          visitLiteralPrimitive: function(ast) {},
          visitPropertyRead: function(ast) {},
          visitPropertyWrite: function(ast) {
            this.simple = false;
          },
          visitSafePropertyRead: function(ast) {
            this.simple = false;
          },
          visitMethodCall: function(ast) {
            this.simple = false;
          },
          visitSafeMethodCall: function(ast) {
            this.simple = false;
          },
          visitFunctionCall: function(ast) {
            this.simple = false;
          },
          visitLiteralArray: function(ast) {
            this.visitAll(ast.expressions);
          },
          visitLiteralMap: function(ast) {
            this.visitAll(ast.values);
          },
          visitBinary: function(ast) {
            this.simple = false;
          },
          visitPrefixNot: function(ast) {
            this.simple = false;
          },
          visitConditional: function(ast) {
            this.simple = false;
          },
          visitPipe: function(ast) {
            this.simple = false;
          },
          visitKeyedRead: function(ast) {
            this.simple = false;
          },
          visitKeyedWrite: function(ast) {
            this.simple = false;
          },
          visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          visitChain: function(ast) {
            this.simple = false;
          },
          visitIf: function(ast) {
            this.simple = false;
          }
        }, {check: function(ast) {
            var s = new SimpleExpressionChecker();
            ast.visit(s);
            return s.simple;
          }});
      }());
    }
  };
});

System.register("angular2/src/change_detection/parser/locals", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/locals";
  var isPresent,
      BaseException,
      MapWrapper,
      Locals;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      Locals = (function() {
        function Locals(parent, current) {
          this.parent = parent;
          this.current = current;
        }
        return ($traceurRuntime.createClass)(Locals, {
          contains: function(name) {
            if (this.current.has(name)) {
              return true;
            }
            if (isPresent(this.parent)) {
              return this.parent.contains(name);
            }
            return false;
          },
          get: function(name) {
            if (this.current.has(name)) {
              return this.current.get(name);
            }
            if (isPresent(this.parent)) {
              return this.parent.get(name);
            }
            throw new BaseException(("Cannot find '" + name + "'"));
          },
          set: function(name, value) {
            if (this.current.has(name)) {
              this.current.set(name, value);
            } else {
              throw new BaseException(("Setting of new keys post-construction is not supported. Key: " + name + "."));
            }
          },
          clearValues: function() {
            MapWrapper.clearValues(this.current);
          }
        }, {});
      }());
      $__export("Locals", Locals);
    }
  };
});

System.register("angular2/src/render/api", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/api";
  var isPresent,
      isBlank,
      RegExpWrapper,
      Map,
      MapWrapper,
      EventBinding,
      PropertyBindingType,
      ElementPropertyBinding,
      RenderElementBinder,
      DirectiveBinder,
      ViewType,
      ProtoViewDto,
      RenderDirectiveMetadata,
      RenderProtoViewRef,
      RenderFragmentRef,
      RenderViewRef,
      ViewEncapsulation,
      ViewDefinition,
      RenderProtoViewMergeMapping,
      RenderCompiler,
      RenderViewWithFragments,
      Renderer;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      EventBinding = (function() {
        function EventBinding(fullName, source) {
          this.fullName = fullName;
          this.source = source;
        }
        return ($traceurRuntime.createClass)(EventBinding, {}, {});
      }());
      $__export("EventBinding", EventBinding);
      $__export("PropertyBindingType", PropertyBindingType);
      (function(PropertyBindingType) {
        PropertyBindingType[PropertyBindingType["PROPERTY"] = 0] = "PROPERTY";
        PropertyBindingType[PropertyBindingType["ATTRIBUTE"] = 1] = "ATTRIBUTE";
        PropertyBindingType[PropertyBindingType["CLASS"] = 2] = "CLASS";
        PropertyBindingType[PropertyBindingType["STYLE"] = 3] = "STYLE";
      })(PropertyBindingType || ($__export("PropertyBindingType", PropertyBindingType = {})));
      ElementPropertyBinding = (function() {
        function ElementPropertyBinding(type, astWithSource, property) {
          var unit = arguments[3] !== (void 0) ? arguments[3] : null;
          this.type = type;
          this.astWithSource = astWithSource;
          this.property = property;
          this.unit = unit;
        }
        return ($traceurRuntime.createClass)(ElementPropertyBinding, {}, {});
      }());
      $__export("ElementPropertyBinding", ElementPropertyBinding);
      RenderElementBinder = (function() {
        function RenderElementBinder() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              index = $__1.index,
              parentIndex = $__1.parentIndex,
              distanceToParent = $__1.distanceToParent,
              directives = $__1.directives,
              nestedProtoView = $__1.nestedProtoView,
              propertyBindings = $__1.propertyBindings,
              variableBindings = $__1.variableBindings,
              eventBindings = $__1.eventBindings,
              readAttributes = $__1.readAttributes;
          this.index = index;
          this.parentIndex = parentIndex;
          this.distanceToParent = distanceToParent;
          this.directives = directives;
          this.nestedProtoView = nestedProtoView;
          this.propertyBindings = propertyBindings;
          this.variableBindings = variableBindings;
          this.eventBindings = eventBindings;
          this.readAttributes = readAttributes;
        }
        return ($traceurRuntime.createClass)(RenderElementBinder, {}, {});
      }());
      $__export("RenderElementBinder", RenderElementBinder);
      DirectiveBinder = (function() {
        function DirectiveBinder($__1) {
          var $__2 = $__1,
              directiveIndex = $__2.directiveIndex,
              propertyBindings = $__2.propertyBindings,
              eventBindings = $__2.eventBindings,
              hostPropertyBindings = $__2.hostPropertyBindings;
          this.directiveIndex = directiveIndex;
          this.propertyBindings = propertyBindings;
          this.eventBindings = eventBindings;
          this.hostPropertyBindings = hostPropertyBindings;
        }
        return ($traceurRuntime.createClass)(DirectiveBinder, {}, {});
      }());
      $__export("DirectiveBinder", DirectiveBinder);
      $__export("ViewType", ViewType);
      (function(ViewType) {
        ViewType[ViewType["HOST"] = 0] = "HOST";
        ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
        ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
      })(ViewType || ($__export("ViewType", ViewType = {})));
      ProtoViewDto = (function() {
        function ProtoViewDto($__1) {
          var $__2 = $__1,
              render = $__2.render,
              elementBinders = $__2.elementBinders,
              variableBindings = $__2.variableBindings,
              type = $__2.type,
              textBindings = $__2.textBindings,
              transitiveNgContentCount = $__2.transitiveNgContentCount;
          this.render = render;
          this.elementBinders = elementBinders;
          this.variableBindings = variableBindings;
          this.type = type;
          this.textBindings = textBindings;
          this.transitiveNgContentCount = transitiveNgContentCount;
        }
        return ($traceurRuntime.createClass)(ProtoViewDto, {}, {});
      }());
      $__export("ProtoViewDto", ProtoViewDto);
      RenderDirectiveMetadata = (function() {
        function RenderDirectiveMetadata($__1) {
          var $__2 = $__1,
              id = $__2.id,
              selector = $__2.selector,
              compileChildren = $__2.compileChildren,
              events = $__2.events,
              hostListeners = $__2.hostListeners,
              hostProperties = $__2.hostProperties,
              hostAttributes = $__2.hostAttributes,
              hostActions = $__2.hostActions,
              properties = $__2.properties,
              readAttributes = $__2.readAttributes,
              type = $__2.type,
              callOnDestroy = $__2.callOnDestroy,
              callOnChange = $__2.callOnChange,
              callOnCheck = $__2.callOnCheck,
              callOnInit = $__2.callOnInit,
              callOnAllChangesDone = $__2.callOnAllChangesDone,
              changeDetection = $__2.changeDetection,
              exportAs = $__2.exportAs;
          this.id = id;
          this.selector = selector;
          this.compileChildren = isPresent(compileChildren) ? compileChildren : true;
          this.events = events;
          this.hostListeners = hostListeners;
          this.hostAttributes = hostAttributes;
          this.hostProperties = hostProperties;
          this.hostActions = hostActions;
          this.properties = properties;
          this.readAttributes = readAttributes;
          this.type = type;
          this.callOnDestroy = callOnDestroy;
          this.callOnChange = callOnChange;
          this.callOnCheck = callOnCheck;
          this.callOnInit = callOnInit;
          this.callOnAllChangesDone = callOnAllChangesDone;
          this.changeDetection = changeDetection;
          this.exportAs = exportAs;
        }
        return ($traceurRuntime.createClass)(RenderDirectiveMetadata, {}, {
          get DIRECTIVE_TYPE() {
            return 0;
          },
          get COMPONENT_TYPE() {
            return 1;
          },
          create: function($__1) {
            var $__2 = $__1,
                id = $__2.id,
                selector = $__2.selector,
                compileChildren = $__2.compileChildren,
                events = $__2.events,
                host = $__2.host,
                properties = $__2.properties,
                readAttributes = $__2.readAttributes,
                type = $__2.type,
                callOnDestroy = $__2.callOnDestroy,
                callOnChange = $__2.callOnChange,
                callOnCheck = $__2.callOnCheck,
                callOnInit = $__2.callOnInit,
                callOnAllChangesDone = $__2.callOnAllChangesDone,
                changeDetection = $__2.changeDetection,
                exportAs = $__2.exportAs;
            var hostListeners = new Map();
            var hostProperties = new Map();
            var hostAttributes = new Map();
            var hostActions = new Map();
            if (isPresent(host)) {
              MapWrapper.forEach(host, (function(value, key) {
                var matches = RegExpWrapper.firstMatch(RenderDirectiveMetadata._hostRegExp, key);
                if (isBlank(matches)) {
                  hostAttributes.set(key, value);
                } else if (isPresent(matches[1])) {
                  hostProperties.set(matches[1], value);
                } else if (isPresent(matches[2])) {
                  hostListeners.set(matches[2], value);
                } else if (isPresent(matches[3])) {
                  hostActions.set(matches[3], value);
                }
              }));
            }
            return new RenderDirectiveMetadata({
              id: id,
              selector: selector,
              compileChildren: compileChildren,
              events: events,
              hostListeners: hostListeners,
              hostProperties: hostProperties,
              hostAttributes: hostAttributes,
              hostActions: hostActions,
              properties: properties,
              readAttributes: readAttributes,
              type: type,
              callOnDestroy: callOnDestroy,
              callOnChange: callOnChange,
              callOnCheck: callOnCheck,
              callOnInit: callOnInit,
              callOnAllChangesDone: callOnAllChangesDone,
              changeDetection: changeDetection,
              exportAs: exportAs
            });
          }
        });
      }());
      $__export("RenderDirectiveMetadata", RenderDirectiveMetadata);
      RenderDirectiveMetadata._hostRegExp = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\))|(?:@(.+)))$/g;
      RenderProtoViewRef = (function() {
        function RenderProtoViewRef() {}
        return ($traceurRuntime.createClass)(RenderProtoViewRef, {}, {});
      }());
      $__export("RenderProtoViewRef", RenderProtoViewRef);
      RenderFragmentRef = (function() {
        function RenderFragmentRef() {}
        return ($traceurRuntime.createClass)(RenderFragmentRef, {}, {});
      }());
      $__export("RenderFragmentRef", RenderFragmentRef);
      RenderViewRef = (function() {
        function RenderViewRef() {}
        return ($traceurRuntime.createClass)(RenderViewRef, {}, {});
      }());
      $__export("RenderViewRef", RenderViewRef);
      $__export("ViewEncapsulation", ViewEncapsulation);
      (function(ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["EMULATED"] = 0] = "EMULATED";
        ViewEncapsulation[ViewEncapsulation["NATIVE"] = 1] = "NATIVE";
        ViewEncapsulation[ViewEncapsulation["NONE"] = 2] = "NONE";
      })(ViewEncapsulation || ($__export("ViewEncapsulation", ViewEncapsulation = {})));
      ViewDefinition = (function() {
        function ViewDefinition() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              componentId = $__1.componentId,
              templateAbsUrl = $__1.templateAbsUrl,
              template = $__1.template,
              styleAbsUrls = $__1.styleAbsUrls,
              styles = $__1.styles,
              directives = $__1.directives,
              encapsulation = $__1.encapsulation;
          this.componentId = componentId;
          this.templateAbsUrl = templateAbsUrl;
          this.template = template;
          this.styleAbsUrls = styleAbsUrls;
          this.styles = styles;
          this.directives = directives;
          this.encapsulation = isPresent(encapsulation) ? encapsulation : ViewEncapsulation.EMULATED;
        }
        return ($traceurRuntime.createClass)(ViewDefinition, {}, {});
      }());
      $__export("ViewDefinition", ViewDefinition);
      RenderProtoViewMergeMapping = (function() {
        function RenderProtoViewMergeMapping(mergedProtoViewRef, fragmentCount, mappedElementIndices, mappedElementCount, mappedTextIndices, hostElementIndicesByViewIndex, nestedViewCountByViewIndex) {
          this.mergedProtoViewRef = mergedProtoViewRef;
          this.fragmentCount = fragmentCount;
          this.mappedElementIndices = mappedElementIndices;
          this.mappedElementCount = mappedElementCount;
          this.mappedTextIndices = mappedTextIndices;
          this.hostElementIndicesByViewIndex = hostElementIndicesByViewIndex;
          this.nestedViewCountByViewIndex = nestedViewCountByViewIndex;
        }
        return ($traceurRuntime.createClass)(RenderProtoViewMergeMapping, {}, {});
      }());
      $__export("RenderProtoViewMergeMapping", RenderProtoViewMergeMapping);
      RenderCompiler = (function() {
        function RenderCompiler() {}
        return ($traceurRuntime.createClass)(RenderCompiler, {
          compileHost: function(directiveMetadata) {
            return null;
          },
          compile: function(view) {
            return null;
          },
          mergeProtoViewsRecursively: function(protoViewRefs) {
            return null;
          }
        }, {});
      }());
      $__export("RenderCompiler", RenderCompiler);
      RenderViewWithFragments = (function() {
        function RenderViewWithFragments(viewRef, fragmentRefs) {
          this.viewRef = viewRef;
          this.fragmentRefs = fragmentRefs;
        }
        return ($traceurRuntime.createClass)(RenderViewWithFragments, {}, {});
      }());
      $__export("RenderViewWithFragments", RenderViewWithFragments);
      Renderer = (function() {
        function Renderer() {}
        return ($traceurRuntime.createClass)(Renderer, {
          createRootHostView: function(hostProtoViewRef, fragmentCount, hostElementSelector) {
            return null;
          },
          createView: function(protoViewRef, fragmentCount) {
            return null;
          },
          destroyView: function(viewRef) {},
          attachFragmentAfterFragment: function(previousFragmentRef, fragmentRef) {},
          attachFragmentAfterElement: function(elementRef, fragmentRef) {},
          detachFragment: function(fragmentRef) {},
          hydrateView: function(viewRef) {},
          dehydrateView: function(viewRef) {},
          getNativeElementSync: function(location) {
            return null;
          },
          setElementProperty: function(location, propertyName, propertyValue) {},
          setElementAttribute: function(location, attributeName, attributeValue) {},
          setElementClass: function(location, className, isAdd) {},
          setElementStyle: function(location, styleName, styleValue) {},
          invokeElementMethod: function(location, methodName, args) {},
          setText: function(viewRef, textNodeIndex, text) {},
          setEventDispatcher: function(viewRef, dispatcher) {}
        }, {});
      }());
      $__export("Renderer", Renderer);
    }
  };
});

System.register("angular2/src/core/application_tokens", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application_tokens";
  var OpaqueToken,
      CONST_EXPR,
      APP_COMPONENT_REF_PROMISE,
      APP_COMPONENT;
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      APP_COMPONENT_REF_PROMISE = CONST_EXPR(new OpaqueToken('Promise<ComponentRef>'));
      $__export("APP_COMPONENT_REF_PROMISE", APP_COMPONENT_REF_PROMISE);
      APP_COMPONENT = CONST_EXPR(new OpaqueToken('AppComponent'));
      $__export("APP_COMPONENT", APP_COMPONENT);
    }
  };
});

System.register("angular2/src/dom/dom_adapter", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/dom_adapter";
  var BaseException,
      isBlank,
      DOM,
      DomAdapter;
  function setRootDomAdapter(adapter) {
    if (isBlank(DOM)) {
      $__export("DOM", DOM = adapter);
    }
  }
  function _abstract() {
    return new BaseException('This method is abstract');
  }
  $__export("setRootDomAdapter", setRootDomAdapter);
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      $__export("DOM", DOM);
      DomAdapter = (function() {
        function DomAdapter() {}
        return ($traceurRuntime.createClass)(DomAdapter, {
          hasProperty: function(element, name) {
            throw _abstract();
          },
          setProperty: function(el, name, value) {
            throw _abstract();
          },
          getProperty: function(el, name) {
            throw _abstract();
          },
          invoke: function(el, methodName, args) {
            throw _abstract();
          },
          logError: function(error) {
            throw _abstract();
          },
          log: function(error) {
            throw _abstract();
          },
          logGroup: function(error) {
            throw _abstract();
          },
          logGroupEnd: function() {
            throw _abstract();
          },
          get attrToPropMap() {
            throw _abstract();
          },
          parse: function(templateHtml) {
            throw _abstract();
          },
          query: function(selector) {
            throw _abstract();
          },
          querySelector: function(el, selector) {
            throw _abstract();
          },
          querySelectorAll: function(el, selector) {
            throw _abstract();
          },
          on: function(el, evt, listener) {
            throw _abstract();
          },
          onAndCancel: function(el, evt, listener) {
            throw _abstract();
          },
          dispatchEvent: function(el, evt) {
            throw _abstract();
          },
          createMouseEvent: function(eventType) {
            throw _abstract();
          },
          createEvent: function(eventType) {
            throw _abstract();
          },
          preventDefault: function(evt) {
            throw _abstract();
          },
          isPrevented: function(evt) {
            throw _abstract();
          },
          getInnerHTML: function(el) {
            throw _abstract();
          },
          getOuterHTML: function(el) {
            throw _abstract();
          },
          nodeName: function(node) {
            throw _abstract();
          },
          nodeValue: function(node) {
            throw _abstract();
          },
          type: function(node) {
            throw _abstract();
          },
          content: function(node) {
            throw _abstract();
          },
          firstChild: function(el) {
            throw _abstract();
          },
          nextSibling: function(el) {
            throw _abstract();
          },
          parentElement: function(el) {
            throw _abstract();
          },
          childNodes: function(el) {
            throw _abstract();
          },
          childNodesAsList: function(el) {
            throw _abstract();
          },
          clearNodes: function(el) {
            throw _abstract();
          },
          appendChild: function(el, node) {
            throw _abstract();
          },
          removeChild: function(el, node) {
            throw _abstract();
          },
          replaceChild: function(el, newNode, oldNode) {
            throw _abstract();
          },
          remove: function(el) {
            throw _abstract();
          },
          insertBefore: function(el, node) {
            throw _abstract();
          },
          insertAllBefore: function(el, nodes) {
            throw _abstract();
          },
          insertAfter: function(el, node) {
            throw _abstract();
          },
          setInnerHTML: function(el, value) {
            throw _abstract();
          },
          getText: function(el) {
            throw _abstract();
          },
          setText: function(el, value) {
            throw _abstract();
          },
          getValue: function(el) {
            throw _abstract();
          },
          setValue: function(el, value) {
            throw _abstract();
          },
          getChecked: function(el) {
            throw _abstract();
          },
          setChecked: function(el, value) {
            throw _abstract();
          },
          createComment: function(text) {
            throw _abstract();
          },
          createTemplate: function(html) {
            throw _abstract();
          },
          createElement: function(tagName) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createTextNode: function(text) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createScriptTag: function(attrName, attrValue) {
            var doc = arguments[2] !== (void 0) ? arguments[2] : null;
            throw _abstract();
          },
          createStyleElement: function(css) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createShadowRoot: function(el) {
            throw _abstract();
          },
          getShadowRoot: function(el) {
            throw _abstract();
          },
          getHost: function(el) {
            throw _abstract();
          },
          getDistributedNodes: function(el) {
            throw _abstract();
          },
          clone: function(node) {
            throw _abstract();
          },
          getElementsByClassName: function(element, name) {
            throw _abstract();
          },
          getElementsByTagName: function(element, name) {
            throw _abstract();
          },
          classList: function(element) {
            throw _abstract();
          },
          addClass: function(element, classname) {
            throw _abstract();
          },
          removeClass: function(element, classname) {
            throw _abstract();
          },
          hasClass: function(element, classname) {
            throw _abstract();
          },
          setStyle: function(element, stylename, stylevalue) {
            throw _abstract();
          },
          removeStyle: function(element, stylename) {
            throw _abstract();
          },
          getStyle: function(element, stylename) {
            throw _abstract();
          },
          tagName: function(element) {
            throw _abstract();
          },
          attributeMap: function(element) {
            throw _abstract();
          },
          hasAttribute: function(element, attribute) {
            throw _abstract();
          },
          getAttribute: function(element, attribute) {
            throw _abstract();
          },
          setAttribute: function(element, name, value) {
            throw _abstract();
          },
          removeAttribute: function(element, attribute) {
            throw _abstract();
          },
          templateAwareRoot: function(el) {
            throw _abstract();
          },
          createHtmlDocument: function() {
            throw _abstract();
          },
          defaultDoc: function() {
            throw _abstract();
          },
          getBoundingClientRect: function(el) {
            throw _abstract();
          },
          getTitle: function() {
            throw _abstract();
          },
          setTitle: function(newTitle) {
            throw _abstract();
          },
          elementMatches: function(n, selector) {
            throw _abstract();
          },
          isTemplateElement: function(el) {
            throw _abstract();
          },
          isTextNode: function(node) {
            throw _abstract();
          },
          isCommentNode: function(node) {
            throw _abstract();
          },
          isElementNode: function(node) {
            throw _abstract();
          },
          hasShadowRoot: function(node) {
            throw _abstract();
          },
          isShadowRoot: function(node) {
            throw _abstract();
          },
          importIntoDoc: function(node) {
            throw _abstract();
          },
          adoptNode: function(node) {
            throw _abstract();
          },
          isPageRule: function(rule) {
            throw _abstract();
          },
          isStyleRule: function(rule) {
            throw _abstract();
          },
          isMediaRule: function(rule) {
            throw _abstract();
          },
          isKeyframesRule: function(rule) {
            throw _abstract();
          },
          getHref: function(element) {
            throw _abstract();
          },
          getEventKey: function(event) {
            throw _abstract();
          },
          resolveAndSetHref: function(element, baseUrl, href) {
            throw _abstract();
          },
          cssToRules: function(css) {
            throw _abstract();
          },
          supportsDOMEvents: function() {
            throw _abstract();
          },
          supportsNativeShadowDOM: function() {
            throw _abstract();
          },
          getGlobalEventTarget: function(target) {
            throw _abstract();
          },
          getHistory: function() {
            throw _abstract();
          },
          getLocation: function() {
            throw _abstract();
          },
          getBaseHref: function() {
            throw _abstract();
          },
          resetBaseElement: function() {
            throw _abstract();
          },
          getUserAgent: function() {
            throw _abstract();
          },
          setData: function(element, name, value) {
            throw _abstract();
          },
          getData: function(element, name) {
            throw _abstract();
          },
          setGlobalVar: function(name, value) {
            throw _abstract();
          }
        }, {});
      }());
      $__export("DomAdapter", DomAdapter);
    }
  };
});

System.register("angular2/src/dom/generic_browser_adapter", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/generic_browser_adapter";
  var ListWrapper,
      isPresent,
      isFunction,
      DomAdapter,
      GenericBrowserDomAdapter;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isFunction = $__m.isFunction;
    }, function($__m) {
      DomAdapter = $__m.DomAdapter;
    }],
    execute: function() {
      GenericBrowserDomAdapter = (function($__super) {
        function GenericBrowserDomAdapter() {
          $traceurRuntime.superConstructor(GenericBrowserDomAdapter).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(GenericBrowserDomAdapter, {
          getDistributedNodes: function(el) {
            return el.getDistributedNodes();
          },
          resolveAndSetHref: function(el, baseUrl, href) {
            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
          },
          cssToRules: function(css) {
            var style = this.createStyleElement(css);
            this.appendChild(this.defaultDoc().head, style);
            var rules = [];
            if (isPresent(style.sheet)) {
              try {
                var rawRules = style.sheet.cssRules;
                rules = ListWrapper.createFixedSize(rawRules.length);
                for (var i = 0; i < rawRules.length; i++) {
                  rules[i] = rawRules[i];
                }
              } catch (e) {}
            } else {}
            this.remove(style);
            return rules;
          },
          supportsDOMEvents: function() {
            return true;
          },
          supportsNativeShadowDOM: function() {
            return isFunction(this.defaultDoc().body.createShadowRoot);
          }
        }, {}, $__super);
      }(DomAdapter));
      $__export("GenericBrowserDomAdapter", GenericBrowserDomAdapter);
    }
  };
});

System.register("angular2/src/core/compiler/directive_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/metadata", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/directive_resolver";
  var __decorate,
      __metadata,
      resolveForwardRef,
      Injectable,
      isPresent,
      BaseException,
      stringify,
      DirectiveMetadata,
      reflector,
      DirectiveResolver;
  return {
    setters: [function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
    }, function($__m) {
      DirectiveMetadata = $__m.DirectiveMetadata;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      DirectiveResolver = (($traceurRuntime.createClass)(function() {}, {resolve: function(type) {
          var annotations = reflector.annotations(resolveForwardRef(type));
          if (isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              if (annotation instanceof DirectiveMetadata) {
                return annotation;
              }
            }
          }
          throw new BaseException(("No Directive annotation found on " + stringify(type)));
        }}, {}));
      $__export("DirectiveResolver", DirectiveResolver);
      $__export("DirectiveResolver", DirectiveResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], DirectiveResolver));
    }
  };
});

System.register("angular2/src/core/compiler/element_binder", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_binder";
  var isBlank,
      isPresent,
      BaseException,
      ElementBinder;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ElementBinder = (function() {
        function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective) {
          this.index = index;
          this.parent = parent;
          this.distanceToParent = distanceToParent;
          this.protoElementInjector = protoElementInjector;
          this.componentDirective = componentDirective;
          this.nestedProtoView = null;
          if (isBlank(index)) {
            throw new BaseException('null index not allowed.');
          }
        }
        return ($traceurRuntime.createClass)(ElementBinder, {
          hasStaticComponent: function() {
            return isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
          },
          hasEmbeddedProtoView: function() {
            return !isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
          }
        }, {});
      }());
      $__export("ElementBinder", ElementBinder);
    }
  };
});

System.register("angular2/src/core/compiler/view_ref", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_ref";
  var isPresent,
      ViewRef,
      ProtoViewRef;
  function internalView(viewRef) {
    return viewRef._view;
  }
  function internalProtoView(protoViewRef) {
    return isPresent(protoViewRef) ? protoViewRef._protoView : null;
  }
  $__export("internalView", internalView);
  $__export("internalProtoView", internalProtoView);
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      ViewRef = (function() {
        function ViewRef(_view) {
          this._view = _view;
        }
        return ($traceurRuntime.createClass)(ViewRef, {
          get render() {
            return this._view.render;
          },
          get renderFragment() {
            return this._view.renderFragment;
          },
          setLocal: function(contextName, value) {
            this._view.setLocal(contextName, value);
          }
        }, {});
      }());
      $__export("ViewRef", ViewRef);
      ProtoViewRef = (function() {
        function ProtoViewRef(_protoView) {
          this._protoView = _protoView;
        }
        return ($traceurRuntime.createClass)(ProtoViewRef, {}, {});
      }());
      $__export("ProtoViewRef", ProtoViewRef);
    }
  };
});

System.register("angular2/src/render/dom/util", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/util";
  var StringWrapper,
      isPresent,
      isBlank,
      DOM,
      ListWrapper,
      NG_BINDING_CLASS_SELECTOR,
      NG_BINDING_CLASS,
      EVENT_TARGET_SEPARATOR,
      NG_CONTENT_ELEMENT_NAME,
      NG_SHADOW_ROOT_ELEMENT_NAME,
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE,
      CAMEL_CASE_REGEXP,
      DASH_CASE_REGEXP,
      EventConfig,
      ClonedProtoView;
  function camelCaseToDashCase(input) {
    return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, (function(m) {
      return '-' + m[1].toLowerCase();
    }));
  }
  function dashCaseToCamelCase(input) {
    return StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, (function(m) {
      return m[1].toUpperCase();
    }));
  }
  function queryBoundElements(templateContent, isSingleElementChild) {
    var result;
    var dynamicElementList;
    var elementIdx = 0;
    if (isSingleElementChild) {
      var rootElement = DOM.firstChild(templateContent);
      var rootHasBinding = DOM.hasClass(rootElement, NG_BINDING_CLASS);
      dynamicElementList = DOM.getElementsByClassName(rootElement, NG_BINDING_CLASS);
      result = ListWrapper.createFixedSize(dynamicElementList.length + (rootHasBinding ? 1 : 0));
      if (rootHasBinding) {
        result[elementIdx++] = rootElement;
      }
    } else {
      dynamicElementList = DOM.querySelectorAll(templateContent, NG_BINDING_CLASS_SELECTOR);
      result = ListWrapper.createFixedSize(dynamicElementList.length);
    }
    for (var i = 0; i < dynamicElementList.length; i++) {
      result[elementIdx++] = dynamicElementList[i];
    }
    return result;
  }
  function cloneAndQueryProtoView(templateCloner, pv, importIntoDocument) {
    var templateContent = templateCloner.cloneContent(pv.cloneableTemplate, importIntoDocument);
    var boundElements = queryBoundElements(templateContent, pv.isSingleElementFragment);
    var boundTextNodes = queryBoundTextNodes(templateContent, pv.rootTextNodeIndices, boundElements, pv.elementBinders, pv.boundTextNodeCount);
    var fragments = queryFragments(templateContent, pv.fragmentsRootNodeCount);
    return new ClonedProtoView(pv, fragments, boundElements, boundTextNodes);
  }
  function queryFragments(templateContent, fragmentsRootNodeCount) {
    var fragments = ListWrapper.createGrowableSize(fragmentsRootNodeCount.length);
    var childNode = DOM.firstChild(templateContent);
    for (var fragmentIndex = 0; fragmentIndex < fragments.length; fragmentIndex++) {
      var fragment = ListWrapper.createFixedSize(fragmentsRootNodeCount[fragmentIndex]);
      fragments[fragmentIndex] = fragment;
      if (fragmentIndex >= 1) {
        childNode = DOM.nextSibling(childNode);
      }
      for (var i = 0; i < fragment.length; i++) {
        fragment[i] = childNode;
        childNode = DOM.nextSibling(childNode);
      }
    }
    return fragments;
  }
  function queryBoundTextNodes(templateContent, rootTextNodeIndices, boundElements, elementBinders, boundTextNodeCount) {
    var boundTextNodes = ListWrapper.createFixedSize(boundTextNodeCount);
    var textNodeIndex = 0;
    if (rootTextNodeIndices.length > 0) {
      var rootChildNodes = DOM.childNodes(templateContent);
      for (var i = 0; i < rootTextNodeIndices.length; i++) {
        boundTextNodes[textNodeIndex++] = rootChildNodes[rootTextNodeIndices[i]];
      }
    }
    for (var i = 0; i < elementBinders.length; i++) {
      var binder = elementBinders[i];
      var element = boundElements[i];
      if (binder.textNodeIndices.length > 0) {
        var childNodes = DOM.childNodes(element);
        for (var j = 0; j < binder.textNodeIndices.length; j++) {
          boundTextNodes[textNodeIndex++] = childNodes[binder.textNodeIndices[j]];
        }
      }
    }
    return boundTextNodes;
  }
  function isElementWithTag(node, elementName) {
    return DOM.isElementNode(node) && DOM.tagName(node).toLowerCase() == elementName.toLowerCase();
  }
  function queryBoundTextNodeIndices(parentNode, boundTextNodes, resultCallback) {
    var childNodes = DOM.childNodes(parentNode);
    for (var j = 0; j < childNodes.length; j++) {
      var node = childNodes[j];
      if (boundTextNodes.has(node)) {
        resultCallback(node, j, boundTextNodes.get(node));
      }
    }
  }
  function prependAll(parentNode, nodes) {
    var lastInsertedNode = null;
    nodes.forEach((function(node) {
      if (isBlank(lastInsertedNode)) {
        var firstChild = DOM.firstChild(parentNode);
        if (isPresent(firstChild)) {
          DOM.insertBefore(firstChild, node);
        } else {
          DOM.appendChild(parentNode, node);
        }
      } else {
        DOM.insertAfter(lastInsertedNode, node);
      }
      lastInsertedNode = node;
    }));
  }
  $__export("camelCaseToDashCase", camelCaseToDashCase);
  $__export("dashCaseToCamelCase", dashCaseToCamelCase);
  $__export("queryBoundElements", queryBoundElements);
  $__export("cloneAndQueryProtoView", cloneAndQueryProtoView);
  $__export("isElementWithTag", isElementWithTag);
  $__export("queryBoundTextNodeIndices", queryBoundTextNodeIndices);
  $__export("prependAll", prependAll);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      NG_BINDING_CLASS_SELECTOR = '.ng-binding';
      $__export("NG_BINDING_CLASS_SELECTOR", NG_BINDING_CLASS_SELECTOR);
      NG_BINDING_CLASS = 'ng-binding';
      $__export("NG_BINDING_CLASS", NG_BINDING_CLASS);
      EVENT_TARGET_SEPARATOR = ':';
      $__export("EVENT_TARGET_SEPARATOR", EVENT_TARGET_SEPARATOR);
      NG_CONTENT_ELEMENT_NAME = 'ng-content';
      $__export("NG_CONTENT_ELEMENT_NAME", NG_CONTENT_ELEMENT_NAME);
      NG_SHADOW_ROOT_ELEMENT_NAME = 'shadow-root';
      $__export("NG_SHADOW_ROOT_ELEMENT_NAME", NG_SHADOW_ROOT_ELEMENT_NAME);
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = 20;
      CAMEL_CASE_REGEXP = /([A-Z])/g;
      DASH_CASE_REGEXP = /-([a-z])/g;
      EventConfig = (function() {
        function EventConfig(fieldName, eventName, isLongForm) {
          this.fieldName = fieldName;
          this.eventName = eventName;
          this.isLongForm = isLongForm;
        }
        return ($traceurRuntime.createClass)(EventConfig, {getFullName: function() {
            return this.isLongForm ? ("" + this.fieldName + EVENT_TARGET_SEPARATOR + this.eventName) : this.eventName;
          }}, {parse: function(eventConfig) {
            var fieldName = eventConfig,
                eventName = eventConfig,
                isLongForm = false;
            var separatorIdx = eventConfig.indexOf(EVENT_TARGET_SEPARATOR);
            if (separatorIdx > -1) {
              fieldName = StringWrapper.substring(eventConfig, 0, separatorIdx).trim();
              eventName = StringWrapper.substring(eventConfig, separatorIdx + 1).trim();
              isLongForm = true;
            }
            return new EventConfig(fieldName, eventName, isLongForm);
          }});
      }());
      $__export("EventConfig", EventConfig);
      ClonedProtoView = (function() {
        function ClonedProtoView(original, fragments, boundElements, boundTextNodes) {
          this.original = original;
          this.fragments = fragments;
          this.boundElements = boundElements;
          this.boundTextNodes = boundTextNodes;
        }
        return ($traceurRuntime.createClass)(ClonedProtoView, {}, {});
      }());
      $__export("ClonedProtoView", ClonedProtoView);
    }
  };
});

System.register("angular2/src/core/compiler/element_ref", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_ref";
  var BaseException,
      ElementRef;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ElementRef = (function() {
        function ElementRef(parentView, boundElementIndex, renderBoundElementIndex, _renderer) {
          this._renderer = _renderer;
          this.parentView = parentView;
          this.boundElementIndex = boundElementIndex;
          this.renderBoundElementIndex = renderBoundElementIndex;
        }
        return ($traceurRuntime.createClass)(ElementRef, {
          get renderView() {
            return this.parentView.render;
          },
          set renderView(viewRef) {
            throw new BaseException('Abstract setter');
          },
          get nativeElement() {
            return this._renderer.getNativeElementSync(this);
          }
        }, {});
      }());
      $__export("ElementRef", ElementRef);
    }
  };
});

System.register("angular2/src/core/compiler/template_ref", ["angular2/src/core/compiler/view_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/template_ref";
  var internalView,
      TemplateRef;
  return {
    setters: [function($__m) {
      internalView = $__m.internalView;
    }],
    execute: function() {
      TemplateRef = (function() {
        function TemplateRef(elementRef) {
          this.elementRef = elementRef;
        }
        return ($traceurRuntime.createClass)(TemplateRef, {
          _getProtoView: function() {
            var parentView = internalView(this.elementRef.parentView);
            return parentView.proto.elementBinders[this.elementRef.boundElementIndex - parentView.elementOffset].nestedProtoView;
          },
          get protoViewRef() {
            return this._getProtoView().ref;
          },
          hasLocal: function(name) {
            return this._getProtoView().variableBindings.has(name);
          }
        }, {});
      }());
      $__export("TemplateRef", TemplateRef);
    }
  };
});

System.register("angular2/src/core/pipes/pipes", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/pipes/pipes";
  var isBlank,
      BaseException,
      ProtoPipes,
      Pipes;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ProtoPipes = (function() {
        function ProtoPipes(bindings) {
          var $__0 = this;
          this.config = {};
          bindings.forEach((function(b) {
            return $__0.config[b.name] = b;
          }));
        }
        return ($traceurRuntime.createClass)(ProtoPipes, {get: function(name) {
            var binding = this.config[name];
            if (isBlank(binding))
              throw new BaseException(("Cannot find pipe '" + name + "'."));
            return binding;
          }}, {});
      }());
      $__export("ProtoPipes", ProtoPipes);
      Pipes = (function() {
        function Pipes(proto, injector) {
          this.proto = proto;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(Pipes, {get: function(name) {
            var b = this.proto.get(name);
            return this.injector.instantiateResolved(b);
          }}, {});
      }());
      $__export("Pipes", Pipes);
    }
  };
});

System.register("angular2/src/core/compiler/view_pool", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_pool";
  var __decorate,
      __metadata,
      __param,
      Inject,
      Injectable,
      OpaqueToken,
      ListWrapper,
      Map,
      isPresent,
      isBlank,
      CONST_EXPR,
      APP_VIEW_POOL_CAPACITY,
      AppViewPool;
  return {
    setters: [function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
      OpaqueToken = $__m.OpaqueToken;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      APP_VIEW_POOL_CAPACITY = CONST_EXPR(new OpaqueToken('AppViewPool.viewPoolCapacity'));
      $__export("APP_VIEW_POOL_CAPACITY", APP_VIEW_POOL_CAPACITY);
      AppViewPool = (($traceurRuntime.createClass)(function(poolCapacityPerProtoView) {
        this._pooledViewsPerProtoView = new Map();
        this._poolCapacityPerProtoView = poolCapacityPerProtoView;
      }, {
        getView: function(protoView) {
          var pooledViews = this._pooledViewsPerProtoView.get(protoView);
          if (isPresent(pooledViews) && pooledViews.length > 0) {
            return ListWrapper.removeLast(pooledViews);
          }
          return null;
        },
        returnView: function(view) {
          var protoView = view.proto;
          var pooledViews = this._pooledViewsPerProtoView.get(protoView);
          if (isBlank(pooledViews)) {
            pooledViews = [];
            this._pooledViewsPerProtoView.set(protoView, pooledViews);
          }
          var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
          if (haveRemainingCapacity) {
            pooledViews.push(view);
          }
          return haveRemainingCapacity;
        }
      }, {}));
      $__export("AppViewPool", AppViewPool);
      $__export("AppViewPool", AppViewPool = __decorate([Injectable(), __param(0, Inject(APP_VIEW_POOL_CAPACITY)), __metadata('design:paramtypes', [Object])], AppViewPool));
    }
  };
});

System.register("angular2/src/core/compiler/view_listener", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_listener";
  var __decorate,
      __metadata,
      Injectable,
      AppViewListener;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppViewListener = (($traceurRuntime.createClass)(function() {}, {
        viewCreated: function(view) {},
        viewDestroyed: function(view) {}
      }, {}));
      $__export("AppViewListener", AppViewListener);
      $__export("AppViewListener", AppViewListener = __decorate([Injectable(), __metadata('design:paramtypes', [])], AppViewListener));
    }
  };
});

System.register("angular2/src/core/compiler/view_container_ref", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_container_ref";
  var ListWrapper,
      isPresent,
      internalView,
      ViewContainerRef;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      internalView = $__m.internalView;
    }],
    execute: function() {
      ViewContainerRef = (function() {
        function ViewContainerRef(viewManager, element) {
          this.viewManager = viewManager;
          this.element = element;
        }
        return ($traceurRuntime.createClass)(ViewContainerRef, {
          _getViews: function() {
            var vc = internalView(this.element.parentView).viewContainers[this.element.boundElementIndex];
            return isPresent(vc) ? vc.views : [];
          },
          clear: function() {
            for (var i = this.length - 1; i >= 0; i--) {
              this.remove(i);
            }
          },
          get: function(index) {
            return this._getViews()[index].ref;
          },
          get length() {
            return this._getViews().length;
          },
          createEmbeddedView: function(templateRef) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            if (atIndex == -1)
              atIndex = this.length;
            return this.viewManager.createEmbeddedViewInContainer(this.element, atIndex, templateRef);
          },
          createHostView: function() {
            var protoViewRef = arguments[0] !== (void 0) ? arguments[0] : null;
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            var dynamicallyCreatedBindings = arguments[2] !== (void 0) ? arguments[2] : null;
            if (atIndex == -1)
              atIndex = this.length;
            return this.viewManager.createHostViewInContainer(this.element, atIndex, protoViewRef, dynamicallyCreatedBindings);
          },
          insert: function(viewRef) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            if (atIndex == -1)
              atIndex = this.length;
            return this.viewManager.attachViewInContainer(this.element, atIndex, viewRef);
          },
          indexOf: function(viewRef) {
            return ListWrapper.indexOf(this._getViews(), internalView(viewRef));
          },
          remove: function() {
            var atIndex = arguments[0] !== (void 0) ? arguments[0] : -1;
            if (atIndex == -1)
              atIndex = this.length - 1;
            this.viewManager.destroyViewInContainer(this.element, atIndex);
          },
          detach: function() {
            var atIndex = arguments[0] !== (void 0) ? arguments[0] : -1;
            if (atIndex == -1)
              atIndex = this.length - 1;
            return this.viewManager.detachViewInContainer(this.element, atIndex);
          }
        }, {});
      }());
      $__export("ViewContainerRef", ViewContainerRef);
    }
  };
});

System.register("angular2/src/core/compiler/directive_lifecycle_reflector", ["angular2/src/facade/lang", "angular2/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/directive_lifecycle_reflector";
  var Type,
      isPresent,
      LifecycleEvent;
  function hasLifecycleHook(e, type, annotation) {
    if (isPresent(annotation.lifecycle)) {
      return annotation.lifecycle.indexOf(e) !== -1;
    } else {
      if (!(type instanceof Type))
        return false;
      var proto = type.prototype;
      switch (e) {
        case LifecycleEvent.onAllChangesDone:
          return !!proto.onAllChangesDone;
        case LifecycleEvent.onChange:
          return !!proto.onChange;
        case LifecycleEvent.onCheck:
          return !!proto.onCheck;
        case LifecycleEvent.onDestroy:
          return !!proto.onDestroy;
        case LifecycleEvent.onInit:
          return !!proto.onInit;
        default:
          return false;
      }
    }
  }
  $__export("hasLifecycleHook", hasLifecycleHook);
  return {
    setters: [function($__m) {
      Type = $__m.Type;
      isPresent = $__m.isPresent;
    }, function($__m) {
      LifecycleEvent = $__m.LifecycleEvent;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/core/compiler/query_list", ["angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/query_list";
  var ListWrapper,
      QueryList;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      QueryList = (function() {
        var $__1;
        function QueryList() {
          this._results = [];
          this._callbacks = [];
          this._dirty = false;
        }
        return ($traceurRuntime.createClass)(QueryList, ($__1 = {}, Object.defineProperty($__1, "reset", {
          value: function(newList) {
            this._results = newList;
            this._dirty = true;
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "add", {
          value: function(obj) {
            this._results.push(obj);
            this._dirty = true;
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "fireCallbacks", {
          value: function() {
            if (this._dirty) {
              ListWrapper.forEach(this._callbacks, (function(c) {
                return c();
              }));
              this._dirty = false;
            }
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "onChange", {
          value: function(callback) {
            this._callbacks.push(callback);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "removeCallback", {
          value: function(callback) {
            ListWrapper.remove(this._callbacks, callback);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "toString", {
          value: function() {
            return this._results.toString();
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "length", {
          get: function() {
            return this._results.length;
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "first", {
          get: function() {
            return ListWrapper.first(this._results);
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "last", {
          get: function() {
            return ListWrapper.last(this._results);
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "map", {
          value: function(fn) {
            return this._results.map(fn);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, Symbol.iterator, {
          value: function() {
            return this._results[Symbol.iterator]();
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), $__1), {});
      }());
      $__export("QueryList", QueryList);
    }
  };
});

System.register("angular2/src/core/pipes/pipe_binding", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/pipes/pipe_binding";
  var ResolvedBinding,
      Binding,
      PipeBinding;
  return {
    setters: [function($__m) {
      ResolvedBinding = $__m.ResolvedBinding;
      Binding = $__m.Binding;
    }],
    execute: function() {
      PipeBinding = (function($__super) {
        function PipeBinding(name, key, factory, dependencies) {
          $traceurRuntime.superConstructor(PipeBinding).call(this, key, factory, dependencies);
          this.name = name;
        }
        return ($traceurRuntime.createClass)(PipeBinding, {}, {createFromType: function(type, metadata) {
            var binding = new Binding(type, {toClass: type});
            var rb = binding.resolve();
            return new PipeBinding(metadata.name, rb.key, rb.factory, rb.dependencies);
          }}, $__super);
      }(ResolvedBinding));
      $__export("PipeBinding", PipeBinding);
    }
  };
});

System.register("angular2/src/core/compiler/view_resolver", ["angular2/di", "angular2/src/core/metadata/view", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_resolver";
  var __decorate,
      __metadata,
      Injectable,
      ViewMetadata,
      stringify,
      isBlank,
      BaseException,
      Map,
      reflector,
      ViewResolver;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ViewMetadata = $__m.ViewMetadata;
    }, function($__m) {
      stringify = $__m.stringify;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      Map = $__m.Map;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ViewResolver = (($traceurRuntime.createClass)(function() {
        this._cache = new Map();
      }, {
        resolve: function(component) {
          var view = this._cache.get(component);
          if (isBlank(view)) {
            view = this._resolve(component);
            this._cache.set(component, view);
          }
          return view;
        },
        _resolve: function(component) {
          var annotations = reflector.annotations(component);
          for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            if (annotation instanceof ViewMetadata) {
              return annotation;
            }
          }
          throw new BaseException(("No View annotation found on component " + stringify(component)));
        }
      }, {}));
      $__export("ViewResolver", ViewResolver);
      $__export("ViewResolver", ViewResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], ViewResolver));
    }
  };
});

System.register("angular2/src/core/compiler/pipe_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/core/metadata/directives", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/pipe_resolver";
  var __decorate,
      __metadata,
      resolveForwardRef,
      Injectable,
      isPresent,
      BaseException,
      stringify,
      PipeMetadata,
      reflector,
      PipeResolver;
  return {
    setters: [function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
    }, function($__m) {
      PipeMetadata = $__m.PipeMetadata;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      PipeResolver = (($traceurRuntime.createClass)(function() {}, {resolve: function(type) {
          var metas = reflector.annotations(resolveForwardRef(type));
          if (isPresent(metas)) {
            for (var i = 0; i < metas.length; i++) {
              var annotation = metas[i];
              if (annotation instanceof PipeMetadata) {
                return annotation;
              }
            }
          }
          throw new BaseException(("No Pipe decorator found on " + stringify(type)));
        }}, {}));
      $__export("PipeResolver", PipeResolver);
      $__export("PipeResolver", PipeResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], PipeResolver));
    }
  };
});

System.register("angular2/src/core/compiler/component_url_mapper", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/component_url_mapper";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      Map,
      ComponentUrlMapper,
      RuntimeComponentUrlMapper;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Map = $__m.Map;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ComponentUrlMapper = (($traceurRuntime.createClass)(function() {}, {getUrl: function(component) {
          return './';
        }}, {}));
      $__export("ComponentUrlMapper", ComponentUrlMapper);
      $__export("ComponentUrlMapper", ComponentUrlMapper = __decorate([Injectable(), __metadata('design:paramtypes', [])], ComponentUrlMapper));
      RuntimeComponentUrlMapper = (function($__super) {
        function RuntimeComponentUrlMapper() {
          $traceurRuntime.superConstructor(RuntimeComponentUrlMapper).call(this);
          this._componentUrls = new Map();
        }
        return ($traceurRuntime.createClass)(RuntimeComponentUrlMapper, {
          setComponentUrl: function(component, url) {
            this._componentUrls.set(component, url);
          },
          getUrl: function(component) {
            var url = this._componentUrls.get(component);
            if (isPresent(url))
              return url;
            return $traceurRuntime.superGet(this, RuntimeComponentUrlMapper.prototype, "getUrl").call(this, component);
          }
        }, {}, $__super);
      }(ComponentUrlMapper));
      $__export("RuntimeComponentUrlMapper", RuntimeComponentUrlMapper);
    }
  };
});

System.register("angular2/src/core/compiler/proto_view_factory", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/reflection/reflection", "angular2/src/change_detection/change_detection", "angular2/src/core/pipes/pipes", "angular2/src/render/api", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_injector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/proto_view_factory";
  var __decorate,
      __metadata,
      Injectable,
      ListWrapper,
      MapWrapper,
      isPresent,
      isBlank,
      BaseException,
      reflector,
      ChangeDetection,
      DirectiveIndex,
      BindingRecord,
      DirectiveRecord,
      DEFAULT,
      ChangeDetectorDefinition,
      ProtoPipes,
      RenderDirectiveMetadata,
      PropertyBindingType,
      ViewType,
      AppProtoView,
      ProtoElementInjector,
      BindingRecordsCreator,
      ProtoViewFactory,
      RenderProtoViewWithIndex,
      ParentProtoElementInjectorWithDistance;
  function getChangeDetectorDefinitions(hostComponentMetadata, rootRenderProtoView, allRenderDirectiveMetadata, genConfig) {
    var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
    var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex);
    return _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata, genConfig);
  }
  function _collectNestedProtoViews(renderProtoView) {
    var parentIndex = arguments[1] !== (void 0) ? arguments[1] : null;
    var boundElementIndex = arguments[2] !== (void 0) ? arguments[2] : null;
    var result = arguments[3] !== (void 0) ? arguments[3] : null;
    if (isBlank(result)) {
      result = [];
    }
    result.push(new RenderProtoViewWithIndex(renderProtoView, result.length, parentIndex, boundElementIndex));
    var currentIndex = result.length - 1;
    var childBoundElementIndex = 0;
    ListWrapper.forEach(renderProtoView.elementBinders, (function(elementBinder) {
      if (isPresent(elementBinder.nestedProtoView)) {
        _collectNestedProtoViews(elementBinder.nestedProtoView, currentIndex, childBoundElementIndex, result);
      }
      childBoundElementIndex++;
    }));
    return result;
  }
  function _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata, genConfig) {
    return ListWrapper.map(nestedPvsWithIndex, (function(pvWithIndex) {
      var elementBinders = pvWithIndex.renderProtoView.elementBinders;
      var bindingRecordsCreator = new BindingRecordsCreator();
      var propBindingRecords = bindingRecordsCreator.getPropertyBindingRecords(pvWithIndex.renderProtoView.textBindings, elementBinders, allRenderDirectiveMetadata);
      var eventBindingRecords = bindingRecordsCreator.getEventBindingRecords(elementBinders, allRenderDirectiveMetadata);
      var directiveRecords = bindingRecordsCreator.getDirectiveRecords(elementBinders, allRenderDirectiveMetadata);
      var strategyName = DEFAULT;
      if (pvWithIndex.renderProtoView.type === ViewType.COMPONENT) {
        strategyName = hostComponentMetadata.changeDetection;
      }
      var id = _protoViewId(hostComponentMetadata, pvWithIndex);
      var variableNames = nestedPvVariableNames[pvWithIndex.index];
      return new ChangeDetectorDefinition(id, strategyName, variableNames, propBindingRecords, eventBindingRecords, directiveRecords, genConfig);
    }));
  }
  function _getChangeDetectorDefinitionIds(hostComponentMetadata, nestedPvsWithIndex) {
    return nestedPvsWithIndex.map((function(pvWithIndex) {
      return _protoViewId(hostComponentMetadata, pvWithIndex);
    }));
  }
  function _protoViewId(hostComponentMetadata, pvWithIndex) {
    var typeString;
    if (pvWithIndex.renderProtoView.type === ViewType.COMPONENT) {
      typeString = 'comp';
    } else if (pvWithIndex.renderProtoView.type === ViewType.HOST) {
      typeString = 'host';
    } else {
      typeString = 'embedded';
    }
    return (hostComponentMetadata.id + "_" + typeString + "_" + pvWithIndex.index);
  }
  function _createAppProtoView(renderProtoView, protoChangeDetector, variableBindings, allDirectives, pipes) {
    var elementBinders = renderProtoView.elementBinders;
    var protoPipes = new ProtoPipes(pipes);
    var protoView = new AppProtoView(renderProtoView.type, renderProtoView.transitiveNgContentCount > 0, renderProtoView.render, protoChangeDetector, variableBindings, createVariableLocations(elementBinders), renderProtoView.textBindings.length, protoPipes);
    _createElementBinders(protoView, elementBinders, allDirectives);
    return protoView;
  }
  function _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex) {
    return ListWrapper.map(nestedPvsWithIndex, (function(pvWithIndex) {
      return _createVariableBindings(pvWithIndex.renderProtoView);
    }));
  }
  function _createVariableBindings(renderProtoView) {
    var variableBindings = new Map();
    MapWrapper.forEach(renderProtoView.variableBindings, (function(mappedName, varName) {
      variableBindings.set(varName, mappedName);
    }));
    return variableBindings;
  }
  function _collectNestedProtoViewsVariableNames(nestedPvsWithIndex) {
    var nestedPvVariableNames = ListWrapper.createFixedSize(nestedPvsWithIndex.length);
    ListWrapper.forEach(nestedPvsWithIndex, (function(pvWithIndex) {
      var parentVariableNames = isPresent(pvWithIndex.parentIndex) ? nestedPvVariableNames[pvWithIndex.parentIndex] : null;
      nestedPvVariableNames[pvWithIndex.index] = _createVariableNames(parentVariableNames, pvWithIndex.renderProtoView);
    }));
    return nestedPvVariableNames;
  }
  function _createVariableNames(parentVariableNames, renderProtoView) {
    var res = isBlank(parentVariableNames) ? [] : ListWrapper.clone(parentVariableNames);
    MapWrapper.forEach(renderProtoView.variableBindings, (function(mappedName, varName) {
      res.push(mappedName);
    }));
    ListWrapper.forEach(renderProtoView.elementBinders, (function(binder) {
      MapWrapper.forEach(binder.variableBindings, (function(mappedName, varName) {
        res.push(mappedName);
      }));
    }));
    return res;
  }
  function createVariableLocations(elementBinders) {
    var variableLocations = new Map();
    for (var i = 0; i < elementBinders.length; i++) {
      var binder = elementBinders[i];
      MapWrapper.forEach(binder.variableBindings, (function(mappedName, varName) {
        variableLocations.set(mappedName, i);
      }));
    }
    return variableLocations;
  }
  function _createElementBinders(protoView, elementBinders, allDirectiveBindings) {
    for (var i = 0; i < elementBinders.length; i++) {
      var renderElementBinder = elementBinders[i];
      var dirs = elementBinders[i].directives;
      var parentPeiWithDistance = _findParentProtoElementInjectorWithDistance(i, protoView.elementBinders, elementBinders);
      var directiveBindings = ListWrapper.map(dirs, (function(dir) {
        return allDirectiveBindings[dir.directiveIndex];
      }));
      var componentDirectiveBinding = null;
      if (directiveBindings.length > 0) {
        if (directiveBindings[0].metadata.type === RenderDirectiveMetadata.COMPONENT_TYPE) {
          componentDirectiveBinding = directiveBindings[0];
        }
      }
      var protoElementInjector = _createProtoElementInjector(i, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings);
      _createElementBinder(protoView, i, renderElementBinder, protoElementInjector, componentDirectiveBinding, directiveBindings);
    }
  }
  function _findParentProtoElementInjectorWithDistance(binderIndex, elementBinders, renderElementBinders) {
    var distance = 0;
    do {
      var renderElementBinder = renderElementBinders[binderIndex];
      binderIndex = renderElementBinder.parentIndex;
      if (binderIndex !== -1) {
        distance += renderElementBinder.distanceToParent;
        var elementBinder = elementBinders[binderIndex];
        if (isPresent(elementBinder.protoElementInjector)) {
          return new ParentProtoElementInjectorWithDistance(elementBinder.protoElementInjector, distance);
        }
      }
    } while (binderIndex !== -1);
    return new ParentProtoElementInjectorWithDistance(null, 0);
  }
  function _createProtoElementInjector(binderIndex, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings) {
    var protoElementInjector = null;
    var hasVariables = MapWrapper.size(renderElementBinder.variableBindings) > 0;
    if (directiveBindings.length > 0 || hasVariables || isPresent(renderElementBinder.nestedProtoView)) {
      var directiveVariableBindings = createDirectiveVariableBindings(renderElementBinder, directiveBindings);
      protoElementInjector = ProtoElementInjector.create(parentPeiWithDistance.protoElementInjector, binderIndex, directiveBindings, isPresent(componentDirectiveBinding), parentPeiWithDistance.distance, directiveVariableBindings);
      protoElementInjector.attributes = renderElementBinder.readAttributes;
    }
    return protoElementInjector;
  }
  function _createElementBinder(protoView, boundElementIndex, renderElementBinder, protoElementInjector, componentDirectiveBinding, directiveBindings) {
    var parent = null;
    if (renderElementBinder.parentIndex !== -1) {
      parent = protoView.elementBinders[renderElementBinder.parentIndex];
    }
    var elBinder = protoView.bindElement(parent, renderElementBinder.distanceToParent, protoElementInjector, componentDirectiveBinding);
    MapWrapper.forEach(renderElementBinder.variableBindings, (function(mappedName, varName) {
      protoView.protoLocals.set(mappedName, null);
    }));
    return elBinder;
  }
  function createDirectiveVariableBindings(renderElementBinder, directiveBindings) {
    var directiveVariableBindings = new Map();
    MapWrapper.forEach(renderElementBinder.variableBindings, (function(templateName, exportAs) {
      var dirIndex = _findDirectiveIndexByExportAs(renderElementBinder, directiveBindings, exportAs);
      directiveVariableBindings.set(templateName, dirIndex);
    }));
    return directiveVariableBindings;
  }
  function _findDirectiveIndexByExportAs(renderElementBinder, directiveBindings, exportAs) {
    var matchedDirectiveIndex = null;
    var matchedDirective;
    for (var i = 0; i < directiveBindings.length; ++i) {
      var directive = directiveBindings[i];
      if (_directiveExportAs(directive) == exportAs) {
        if (isPresent(matchedDirective)) {
          throw new BaseException(("More than one directive have exportAs = '" + exportAs + "'. Directives: [" + matchedDirective.displayName + ", " + directive.displayName + "]"));
        }
        matchedDirectiveIndex = i;
        matchedDirective = directive;
      }
    }
    if (isBlank(matchedDirective) && exportAs !== "$implicit") {
      throw new BaseException(("Cannot find directive with exportAs = '" + exportAs + "'"));
    }
    return matchedDirectiveIndex;
  }
  function _directiveExportAs(directive) {
    var directiveExportAs = directive.metadata.exportAs;
    if (isBlank(directiveExportAs) && directive.metadata.type === RenderDirectiveMetadata.COMPONENT_TYPE) {
      return "$implicit";
    } else {
      return directiveExportAs;
    }
  }
  $__export("getChangeDetectorDefinitions", getChangeDetectorDefinitions);
  $__export("createVariableLocations", createVariableLocations);
  $__export("createDirectiveVariableBindings", createDirectiveVariableBindings);
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      ChangeDetection = $__m.ChangeDetection;
      DirectiveIndex = $__m.DirectiveIndex;
      BindingRecord = $__m.BindingRecord;
      DirectiveRecord = $__m.DirectiveRecord;
      DEFAULT = $__m.DEFAULT;
      ChangeDetectorDefinition = $__m.ChangeDetectorDefinition;
    }, function($__m) {
      ProtoPipes = $__m.ProtoPipes;
    }, function($__m) {
      RenderDirectiveMetadata = $__m.RenderDirectiveMetadata;
      PropertyBindingType = $__m.PropertyBindingType;
      ViewType = $__m.ViewType;
    }, function($__m) {
      AppProtoView = $__m.AppProtoView;
    }, function($__m) {
      ProtoElementInjector = $__m.ProtoElementInjector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      BindingRecordsCreator = (function() {
        function BindingRecordsCreator() {
          this._directiveRecordsMap = new Map();
        }
        return ($traceurRuntime.createClass)(BindingRecordsCreator, {
          getEventBindingRecords: function(elementBinders, allDirectiveMetadatas) {
            var res = [];
            for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
              var renderElementBinder = elementBinders[boundElementIndex];
              this._createTemplateEventRecords(res, renderElementBinder, boundElementIndex);
              this._createHostEventRecords(res, renderElementBinder, allDirectiveMetadatas, boundElementIndex);
            }
            return res;
          },
          _createTemplateEventRecords: function(res, renderElementBinder, boundElementIndex) {
            renderElementBinder.eventBindings.forEach((function(eb) {
              res.push(BindingRecord.createForEvent(eb.source, eb.fullName, boundElementIndex));
            }));
          },
          _createHostEventRecords: function(res, renderElementBinder, allDirectiveMetadatas, boundElementIndex) {
            for (var i = 0; i < renderElementBinder.directives.length; ++i) {
              var dir = renderElementBinder.directives[i];
              var directiveMetadata = allDirectiveMetadatas[dir.directiveIndex];
              var dirRecord = this._getDirectiveRecord(boundElementIndex, i, directiveMetadata);
              dir.eventBindings.forEach((function(heb) {
                res.push(BindingRecord.createForHostEvent(heb.source, heb.fullName, dirRecord));
              }));
            }
          },
          getPropertyBindingRecords: function(textBindings, elementBinders, allDirectiveMetadatas) {
            var bindings = [];
            this._createTextNodeRecords(bindings, textBindings);
            for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
              var renderElementBinder = elementBinders[boundElementIndex];
              this._createElementPropertyRecords(bindings, boundElementIndex, renderElementBinder);
              this._createDirectiveRecords(bindings, boundElementIndex, renderElementBinder.directives, allDirectiveMetadatas);
            }
            return bindings;
          },
          getDirectiveRecords: function(elementBinders, allDirectiveMetadatas) {
            var directiveRecords = [];
            for (var elementIndex = 0; elementIndex < elementBinders.length; ++elementIndex) {
              var dirs = elementBinders[elementIndex].directives;
              for (var dirIndex = 0; dirIndex < dirs.length; ++dirIndex) {
                directiveRecords.push(this._getDirectiveRecord(elementIndex, dirIndex, allDirectiveMetadatas[dirs[dirIndex].directiveIndex]));
              }
            }
            return directiveRecords;
          },
          _createTextNodeRecords: function(bindings, textBindings) {
            for (var i = 0; i < textBindings.length; i++) {
              bindings.push(BindingRecord.createForTextNode(textBindings[i], i));
            }
          },
          _createElementPropertyRecords: function(bindings, boundElementIndex, renderElementBinder) {
            ListWrapper.forEach(renderElementBinder.propertyBindings, (function(binding) {
              if (binding.type === PropertyBindingType.PROPERTY) {
                bindings.push(BindingRecord.createForElementProperty(binding.astWithSource, boundElementIndex, binding.property));
              } else if (binding.type === PropertyBindingType.ATTRIBUTE) {
                bindings.push(BindingRecord.createForElementAttribute(binding.astWithSource, boundElementIndex, binding.property));
              } else if (binding.type === PropertyBindingType.CLASS) {
                bindings.push(BindingRecord.createForElementClass(binding.astWithSource, boundElementIndex, binding.property));
              } else if (binding.type === PropertyBindingType.STYLE) {
                bindings.push(BindingRecord.createForElementStyle(binding.astWithSource, boundElementIndex, binding.property, binding.unit));
              }
            }));
          },
          _createDirectiveRecords: function(bindings, boundElementIndex, directiveBinders, allDirectiveMetadatas) {
            for (var i = 0; i < directiveBinders.length; i++) {
              var directiveBinder = directiveBinders[i];
              var directiveMetadata = allDirectiveMetadatas[directiveBinder.directiveIndex];
              var directiveRecord = this._getDirectiveRecord(boundElementIndex, i, directiveMetadata);
              MapWrapper.forEach(directiveBinder.propertyBindings, (function(astWithSource, propertyName) {
                var setter = reflector.setter(propertyName);
                bindings.push(BindingRecord.createForDirective(astWithSource, propertyName, setter, directiveRecord));
              }));
              if (directiveRecord.callOnChange) {
                bindings.push(BindingRecord.createDirectiveOnChange(directiveRecord));
              }
              if (directiveRecord.callOnInit) {
                bindings.push(BindingRecord.createDirectiveOnInit(directiveRecord));
              }
              if (directiveRecord.callOnCheck) {
                bindings.push(BindingRecord.createDirectiveOnCheck(directiveRecord));
              }
            }
            for (var i = 0; i < directiveBinders.length; i++) {
              var directiveBinder = directiveBinders[i];
              ListWrapper.forEach(directiveBinder.hostPropertyBindings, (function(binding) {
                var dirIndex = new DirectiveIndex(boundElementIndex, i);
                if (binding.type === PropertyBindingType.PROPERTY) {
                  bindings.push(BindingRecord.createForHostProperty(dirIndex, binding.astWithSource, binding.property));
                } else if (binding.type === PropertyBindingType.ATTRIBUTE) {
                  bindings.push(BindingRecord.createForHostAttribute(dirIndex, binding.astWithSource, binding.property));
                } else if (binding.type === PropertyBindingType.CLASS) {
                  bindings.push(BindingRecord.createForHostClass(dirIndex, binding.astWithSource, binding.property));
                } else if (binding.type === PropertyBindingType.STYLE) {
                  bindings.push(BindingRecord.createForHostStyle(dirIndex, binding.astWithSource, binding.property, binding.unit));
                }
              }));
            }
          },
          _getDirectiveRecord: function(boundElementIndex, directiveIndex, directiveMetadata) {
            var id = boundElementIndex * 100 + directiveIndex;
            if (!this._directiveRecordsMap.has(id)) {
              this._directiveRecordsMap.set(id, new DirectiveRecord({
                directiveIndex: new DirectiveIndex(boundElementIndex, directiveIndex),
                callOnAllChangesDone: directiveMetadata.callOnAllChangesDone,
                callOnChange: directiveMetadata.callOnChange,
                callOnCheck: directiveMetadata.callOnCheck,
                callOnInit: directiveMetadata.callOnInit,
                changeDetection: directiveMetadata.changeDetection
              }));
            }
            return this._directiveRecordsMap.get(id);
          }
        }, {});
      }());
      $__export("BindingRecordsCreator", BindingRecordsCreator);
      ProtoViewFactory = (($traceurRuntime.createClass)(function(_changeDetection) {
        this._changeDetection = _changeDetection;
      }, {
        createAppProtoViews: function(hostComponentBinding, rootRenderProtoView, allDirectives, pipes) {
          var allRenderDirectiveMetadata = ListWrapper.map(allDirectives, (function(directiveBinding) {
            return directiveBinding.metadata;
          }));
          var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
          var nestedPvVariableBindings = _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex);
          var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex);
          var protoChangeDetectors = this._getProtoChangeDetectors(hostComponentBinding, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata);
          var appProtoViews = ListWrapper.createFixedSize(nestedPvsWithIndex.length);
          ListWrapper.forEach(nestedPvsWithIndex, (function(pvWithIndex) {
            var appProtoView = _createAppProtoView(pvWithIndex.renderProtoView, protoChangeDetectors[pvWithIndex.index], nestedPvVariableBindings[pvWithIndex.index], allDirectives, pipes);
            if (isPresent(pvWithIndex.parentIndex)) {
              var parentView = appProtoViews[pvWithIndex.parentIndex];
              parentView.elementBinders[pvWithIndex.boundElementIndex].nestedProtoView = appProtoView;
            }
            appProtoViews[pvWithIndex.index] = appProtoView;
          }));
          return appProtoViews;
        },
        _getProtoChangeDetectors: function(hostComponentBinding, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata) {
          var $__0 = this;
          if (this._changeDetection.generateDetectors) {
            var changeDetectorDefs = _getChangeDetectorDefinitions(hostComponentBinding.metadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata, this._changeDetection.genConfig);
            return changeDetectorDefs.map((function(changeDetectorDef) {
              return $__0._changeDetection.getProtoChangeDetector(changeDetectorDef.id, changeDetectorDef);
            }));
          } else {
            var changeDetectorIds = _getChangeDetectorDefinitionIds(hostComponentBinding.metadata, nestedPvsWithIndex);
            return changeDetectorIds.map((function(id) {
              return $__0._changeDetection.getProtoChangeDetector(id, null);
            }));
          }
        }
      }, {}));
      $__export("ProtoViewFactory", ProtoViewFactory);
      $__export("ProtoViewFactory", ProtoViewFactory = __decorate([Injectable(), __metadata('design:paramtypes', [ChangeDetection])], ProtoViewFactory));
      RenderProtoViewWithIndex = (function() {
        function RenderProtoViewWithIndex(renderProtoView, index, parentIndex, boundElementIndex) {
          this.renderProtoView = renderProtoView;
          this.index = index;
          this.parentIndex = parentIndex;
          this.boundElementIndex = boundElementIndex;
        }
        return ($traceurRuntime.createClass)(RenderProtoViewWithIndex, {}, {});
      }());
      ParentProtoElementInjectorWithDistance = (function() {
        function ParentProtoElementInjectorWithDistance(protoElementInjector, distance) {
          this.protoElementInjector = protoElementInjector;
          this.distance = distance;
        }
        return ($traceurRuntime.createClass)(ParentProtoElementInjectorWithDistance, {}, {});
      }());
    }
  };
});

System.register("angular2/src/services/url_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/url_resolver";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      isBlank,
      RegExpWrapper,
      ListWrapper,
      UrlResolver,
      _splitRe,
      _ComponentIndex;
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (isPresent(opt_scheme)) {
      out.push(opt_scheme + ':');
    }
    if (isPresent(opt_domain)) {
      out.push('//');
      if (isPresent(opt_userInfo)) {
        out.push(opt_userInfo + '@');
      }
      out.push(opt_domain);
      if (isPresent(opt_port)) {
        out.push(':' + opt_port);
      }
    }
    if (isPresent(opt_path)) {
      out.push(opt_path);
    }
    if (isPresent(opt_queryData)) {
      out.push('?' + opt_queryData);
    }
    if (isPresent(opt_fragment)) {
      out.push('#' + opt_fragment);
    }
    return out.join('');
  }
  function _split(uri) {
    return RegExpWrapper.firstMatch(_splitRe, uri);
  }
  function _removeDotSegments(path) {
    if (path == '/')
      return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length > 0) {
            ListWrapper.removeAt(out, out.length - 1);
          } else {
            up++;
          }
          break;
        default:
          out.push(segment);
      }
    }
    if (leadingSlash == '') {
      while (up-- > 0) {
        ListWrapper.insert(out, 0, '..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.PATH];
    path = isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.PATH] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.SCHEME], parts[_ComponentIndex.USER_INFO], parts[_ComponentIndex.DOMAIN], parts[_ComponentIndex.PORT], path, parts[_ComponentIndex.QUERY_DATA], parts[_ComponentIndex.FRAGMENT]);
  }
  function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (isPresent(parts[_ComponentIndex.SCHEME])) {
      return _joinAndCanonicalizePath(parts);
    } else {
      parts[_ComponentIndex.SCHEME] = baseParts[_ComponentIndex.SCHEME];
    }
    for (var i = _ComponentIndex.SCHEME; i <= _ComponentIndex.PORT; i++) {
      if (isBlank(parts[i])) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[_ComponentIndex.PATH][0] == '/') {
      return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.PATH];
    if (isBlank(path))
      path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.PATH];
    parts[_ComponentIndex.PATH] = path;
    return _joinAndCanonicalizePath(parts);
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      UrlResolver = (($traceurRuntime.createClass)(function() {}, {resolve: function(baseUrl, url) {
          return _resolveUrl(baseUrl, url);
        }}, {}));
      $__export("UrlResolver", UrlResolver);
      $__export("UrlResolver", UrlResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], UrlResolver));
      _splitRe = RegExpWrapper.create('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
      (function(_ComponentIndex) {
        _ComponentIndex[_ComponentIndex["SCHEME"] = 1] = "SCHEME";
        _ComponentIndex[_ComponentIndex["USER_INFO"] = 2] = "USER_INFO";
        _ComponentIndex[_ComponentIndex["DOMAIN"] = 3] = "DOMAIN";
        _ComponentIndex[_ComponentIndex["PORT"] = 4] = "PORT";
        _ComponentIndex[_ComponentIndex["PATH"] = 5] = "PATH";
        _ComponentIndex[_ComponentIndex["QUERY_DATA"] = 6] = "QUERY_DATA";
        _ComponentIndex[_ComponentIndex["FRAGMENT"] = 7] = "FRAGMENT";
      })(_ComponentIndex || (_ComponentIndex = {}));
    }
  };
});

System.register("angular2/src/services/app_root_url", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/app_root_url";
  var __decorate,
      __metadata,
      Injectable,
      AppRootUrl;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppRootUrl = (($traceurRuntime.createClass)(function(value) {
        this._value = value;
      }, {
        get value() {
          return this._value;
        },
        set value(value) {
          this._value = value;
        }
      }, {}));
      $__export("AppRootUrl", AppRootUrl);
      $__export("AppRootUrl", AppRootUrl = __decorate([Injectable(), __metadata('design:paramtypes', [String])], AppRootUrl));
    }
  };
});

System.register("angular2/src/pipes/invalid_pipe_argument_exception", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/invalid_pipe_argument_exception";
  var BaseException,
      InvalidPipeArgumentException;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      InvalidPipeArgumentException = (function($__super) {
        function InvalidPipeArgumentException(type, value) {
          $traceurRuntime.superConstructor(InvalidPipeArgumentException).call(this, ("Invalid argument '" + value + "' for pipe '" + type + "'"));
        }
        return ($traceurRuntime.createClass)(InvalidPipeArgumentException, {}, {}, $__super);
      }(BaseException));
      $__export("InvalidPipeArgumentException", InvalidPipeArgumentException);
    }
  };
});

System.register("angular2/src/pipes/lowercase_pipe", ["angular2/src/facade/lang", "angular2/di", "angular2/src/pipes/invalid_pipe_argument_exception", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/lowercase_pipe";
  var __decorate,
      __metadata,
      isString,
      StringWrapper,
      CONST,
      isBlank,
      Injectable,
      InvalidPipeArgumentException,
      Pipe,
      LowerCasePipe;
  return {
    setters: [function($__m) {
      isString = $__m.isString;
      StringWrapper = $__m.StringWrapper;
      CONST = $__m.CONST;
      isBlank = $__m.isBlank;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      InvalidPipeArgumentException = $__m.InvalidPipeArgumentException;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      LowerCasePipe = (($traceurRuntime.createClass)(function() {}, {transform: function(value) {
          var args = arguments[1] !== (void 0) ? arguments[1] : null;
          if (isBlank(value))
            return value;
          if (!isString(value)) {
            throw new InvalidPipeArgumentException(LowerCasePipe, value);
          }
          return StringWrapper.toLowerCase(value);
        }}, {}));
      $__export("LowerCasePipe", LowerCasePipe);
      $__export("LowerCasePipe", LowerCasePipe = __decorate([CONST(), Pipe({name: 'lowercase'}), Injectable(), __metadata('design:paramtypes', [])], LowerCasePipe));
    }
  };
});

System.register("angular2/src/pipes/async_pipe", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/di", "angular2/change_detection", "angular2/src/pipes/invalid_pipe_argument_exception", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/async_pipe";
  var __decorate,
      __metadata,
      isBlank,
      isPresent,
      isPromise,
      ObservableWrapper,
      Injectable,
      WrappedValue,
      InvalidPipeArgumentException,
      ChangeDetectorRef,
      Pipe,
      ObservableStrategy,
      PromiseStrategy,
      _promiseStrategy,
      _observableStrategy,
      AsyncPipe;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      isPromise = $__m.isPromise;
    }, function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      InvalidPipeArgumentException = $__m.InvalidPipeArgumentException;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ObservableStrategy = (function() {
        function ObservableStrategy() {}
        return ($traceurRuntime.createClass)(ObservableStrategy, {
          createSubscription: function(async, updateLatestValue) {
            return ObservableWrapper.subscribe(async, updateLatestValue, (function(e) {
              throw e;
            }));
          },
          dispose: function(subscription) {
            ObservableWrapper.dispose(subscription);
          },
          onDestroy: function(subscription) {
            ObservableWrapper.dispose(subscription);
          }
        }, {});
      }());
      PromiseStrategy = (function() {
        function PromiseStrategy() {}
        return ($traceurRuntime.createClass)(PromiseStrategy, {
          createSubscription: function(async, updateLatestValue) {
            return async.then(updateLatestValue);
          },
          dispose: function(subscription) {},
          onDestroy: function(subscription) {}
        }, {});
      }());
      _promiseStrategy = new PromiseStrategy();
      _observableStrategy = new ObservableStrategy();
      AsyncPipe = (($traceurRuntime.createClass)(function(_ref) {
        this._ref = _ref;
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
        this._strategy = null;
      }, {
        onDestroy: function() {
          if (isPresent(this._subscription)) {
            this._dispose();
          }
        },
        transform: function(obj, args) {
          if (isBlank(this._obj)) {
            if (isPresent(obj)) {
              this._subscribe(obj);
            }
            return null;
          }
          if (obj !== this._obj) {
            this._dispose();
            return this.transform(obj);
          }
          if (this._latestValue === this._latestReturnedValue) {
            return this._latestReturnedValue;
          } else {
            this._latestReturnedValue = this._latestValue;
            return WrappedValue.wrap(this._latestValue);
          }
        },
        _subscribe: function(obj) {
          var $__0 = this;
          this._obj = obj;
          this._strategy = this._selectStrategy(obj);
          this._subscription = this._strategy.createSubscription(obj, (function(value) {
            return $__0._updateLatestValue(obj, value);
          }));
        },
        _selectStrategy: function(obj) {
          if (isPromise(obj)) {
            return _promiseStrategy;
          } else if (ObservableWrapper.isObservable(obj)) {
            return _observableStrategy;
          } else {
            throw new InvalidPipeArgumentException(AsyncPipe, obj);
          }
        },
        _dispose: function() {
          this._strategy.dispose(this._subscription);
          this._latestValue = null;
          this._latestReturnedValue = null;
          this._subscription = null;
          this._obj = null;
        },
        _updateLatestValue: function(async, value) {
          if (async === this._obj) {
            this._latestValue = value;
            this._ref.requestCheck();
          }
        }
      }, {}));
      $__export("AsyncPipe", AsyncPipe);
      $__export("AsyncPipe", AsyncPipe = __decorate([Pipe({name: 'async'}), Injectable(), __metadata('design:paramtypes', [ChangeDetectorRef])], AsyncPipe));
    }
  };
});

System.register("angular2/src/pipes/json_pipe", ["angular2/src/facade/lang", "angular2/di", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/json_pipe";
  var __decorate,
      __metadata,
      Json,
      CONST,
      Injectable,
      Pipe,
      JsonPipe;
  return {
    setters: [function($__m) {
      Json = $__m.Json;
      CONST = $__m.CONST;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      JsonPipe = (($traceurRuntime.createClass)(function() {}, {transform: function(value) {
          var args = arguments[1] !== (void 0) ? arguments[1] : null;
          return Json.stringify(value);
        }}, {}));
      $__export("JsonPipe", JsonPipe);
      $__export("JsonPipe", JsonPipe = __decorate([CONST(), Pipe({name: 'json'}), Injectable(), __metadata('design:paramtypes', [])], JsonPipe));
    }
  };
});

System.register("angular2/src/facade/intl", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/intl";
  var NumberFormatStyle,
      NumberFormatter,
      dateFormatterCache,
      DateFormatter;
  function digitCondition(len) {
    return len == 2 ? '2-digit' : 'numeric';
  }
  function nameCondition(len) {
    return len < 4 ? 'short' : 'long';
  }
  function extractComponents(pattern) {
    var ret = {};
    var i = 0,
        j;
    while (i < pattern.length) {
      j = i;
      while (j < pattern.length && pattern[j] == pattern[i])
        j++;
      var len = j - i;
      switch (pattern[i]) {
        case 'G':
          ret.era = nameCondition(len);
          break;
        case 'y':
          ret.year = digitCondition(len);
          break;
        case 'M':
          if (len >= 3)
            ret.month = nameCondition(len);
          else
            ret.month = digitCondition(len);
          break;
        case 'd':
          ret.day = digitCondition(len);
          break;
        case 'E':
          ret.weekday = nameCondition(len);
          break;
        case 'j':
          ret.hour = digitCondition(len);
          break;
        case 'h':
          ret.hour = digitCondition(len);
          ret.hour12 = true;
          break;
        case 'H':
          ret.hour = digitCondition(len);
          ret.hour12 = false;
          break;
        case 'm':
          ret.minute = digitCondition(len);
          break;
        case 's':
          ret.second = digitCondition(len);
          break;
        case 'z':
          ret.timeZoneName = 'long';
          break;
        case 'Z':
          ret.timeZoneName = 'short';
          break;
      }
      i = j;
    }
    return ret;
  }
  return {
    setters: [],
    execute: function() {
      $__export("NumberFormatStyle", NumberFormatStyle);
      (function(NumberFormatStyle) {
        NumberFormatStyle[NumberFormatStyle["DECIMAL"] = 0] = "DECIMAL";
        NumberFormatStyle[NumberFormatStyle["PERCENT"] = 1] = "PERCENT";
        NumberFormatStyle[NumberFormatStyle["CURRENCY"] = 2] = "CURRENCY";
      })(NumberFormatStyle || ($__export("NumberFormatStyle", NumberFormatStyle = {})));
      NumberFormatter = (function() {
        function NumberFormatter() {}
        return ($traceurRuntime.createClass)(NumberFormatter, {}, {format: function(number, locale, style) {
            var $__2,
                $__3,
                $__4,
                $__5;
            var $__1 = arguments[3] !== (void 0) ? arguments[3] : {},
                minimumIntegerDigits = ($__2 = $__1.minimumIntegerDigits) === void 0 ? 1 : $__2,
                minimumFractionDigits = ($__3 = $__1.minimumFractionDigits) === void 0 ? 0 : $__3,
                maximumFractionDigits = ($__4 = $__1.maximumFractionDigits) === void 0 ? 3 : $__4,
                currency = $__1.currency,
                currencyAsSymbol = ($__5 = $__1.currencyAsSymbol) === void 0 ? false : $__5;
            var intlOptions = {
              minimumIntegerDigits: minimumIntegerDigits,
              minimumFractionDigits: minimumFractionDigits,
              maximumFractionDigits: maximumFractionDigits
            };
            intlOptions.style = NumberFormatStyle[style].toLowerCase();
            if (style == NumberFormatStyle.CURRENCY) {
              intlOptions.currency = currency;
              intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
            }
            return new Intl.NumberFormat(locale, intlOptions).format(number);
          }});
      }());
      $__export("NumberFormatter", NumberFormatter);
      dateFormatterCache = new Map();
      DateFormatter = (function() {
        function DateFormatter() {}
        return ($traceurRuntime.createClass)(DateFormatter, {}, {format: function(date, locale, pattern) {
            var key = locale + pattern;
            if (dateFormatterCache.has(key)) {
              return dateFormatterCache.get(key).format(date);
            }
            var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
            dateFormatterCache.set(key, formatter);
            return formatter.format(date);
          }});
      }());
      $__export("DateFormatter", DateFormatter);
    }
  };
});

System.register("angular2/src/pipes/number_pipe", ["angular2/src/facade/lang", "angular2/src/facade/intl", "angular2/di", "angular2/src/facade/collection", "angular2/src/pipes/invalid_pipe_argument_exception", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/number_pipe";
  var __decorate,
      __metadata,
      isNumber,
      isPresent,
      isBlank,
      NumberWrapper,
      RegExpWrapper,
      BaseException,
      CONST,
      NumberFormatter,
      NumberFormatStyle,
      Injectable,
      ListWrapper,
      InvalidPipeArgumentException,
      Pipe,
      defaultLocale,
      _re,
      NumberPipe,
      DecimalPipe,
      PercentPipe,
      CurrencyPipe;
  return {
    setters: [function($__m) {
      isNumber = $__m.isNumber;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      NumberWrapper = $__m.NumberWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      NumberFormatter = $__m.NumberFormatter;
      NumberFormatStyle = $__m.NumberFormatStyle;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      InvalidPipeArgumentException = $__m.InvalidPipeArgumentException;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      defaultLocale = 'en-US';
      _re = RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
      NumberPipe = (($traceurRuntime.createClass)(function() {}, {}, {_format: function(value, style, digits) {
          var currency = arguments[3] !== (void 0) ? arguments[3] : null;
          var currencyAsSymbol = arguments[4] !== (void 0) ? arguments[4] : false;
          if (isBlank(value))
            return null;
          if (!isNumber(value)) {
            throw new InvalidPipeArgumentException(NumberPipe, value);
          }
          var minInt = 1,
              minFraction = 0,
              maxFraction = 3;
          if (isPresent(digits)) {
            var parts = RegExpWrapper.firstMatch(_re, digits);
            if (isBlank(parts)) {
              throw new BaseException((digits + " is not a valid digit info for number pipes"));
            }
            if (isPresent(parts[1])) {
              minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (isPresent(parts[3])) {
              minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (isPresent(parts[5])) {
              maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
            }
          }
          return NumberFormatter.format(value, defaultLocale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyAsSymbol: currencyAsSymbol
          });
        }}));
      $__export("NumberPipe", NumberPipe);
      $__export("NumberPipe", NumberPipe = __decorate([CONST(), Injectable(), __metadata('design:paramtypes', [])], NumberPipe));
      DecimalPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {transform: function(value, args) {
            var digits = ListWrapper.first(args);
            return NumberPipe._format(value, NumberFormatStyle.DECIMAL, digits);
          }}, {}, $__super);
      }(NumberPipe));
      $__export("DecimalPipe", DecimalPipe);
      $__export("DecimalPipe", DecimalPipe = __decorate([CONST(), Pipe({name: 'number'}), Injectable(), __metadata('design:paramtypes', [])], DecimalPipe));
      PercentPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {transform: function(value, args) {
            var digits = ListWrapper.first(args);
            return NumberPipe._format(value, NumberFormatStyle.PERCENT, digits);
          }}, {}, $__super);
      }(NumberPipe));
      $__export("PercentPipe", PercentPipe);
      $__export("PercentPipe", PercentPipe = __decorate([CONST(), Pipe({name: 'percent'}), Injectable(), __metadata('design:paramtypes', [])], PercentPipe));
      CurrencyPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {transform: function(value, args) {
            var currencyCode = isPresent(args) && args.length > 0 ? args[0] : 'USD';
            var symbolDisplay = isPresent(args) && args.length > 1 ? args[1] : false;
            var digits = isPresent(args) && args.length > 2 ? args[2] : null;
            return NumberPipe._format(value, NumberFormatStyle.CURRENCY, digits, currencyCode, symbolDisplay);
          }}, {}, $__super);
      }(NumberPipe));
      $__export("CurrencyPipe", CurrencyPipe);
      $__export("CurrencyPipe", CurrencyPipe = __decorate([CONST(), Pipe({name: 'currency'}), Injectable(), __metadata('design:paramtypes', [])], CurrencyPipe));
    }
  };
});

System.register("angular2/src/facade/math", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/math";
  var global,
      Math,
      NaN;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      Math = global.Math;
      $__export("Math", Math);
      NaN = typeof NaN;
      $__export("NaN", NaN);
    }
  };
});

System.register("angular2/src/pipes/default_pipes", ["angular2/src/pipes/async_pipe", "angular2/src/pipes/uppercase_pipe", "angular2/src/pipes/lowercase_pipe", "angular2/src/pipes/json_pipe", "angular2/src/pipes/limit_to_pipe", "angular2/src/pipes/date_pipe", "angular2/src/pipes/number_pipe", "angular2/src/facade/lang", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/default_pipes";
  var AsyncPipe,
      UpperCasePipe,
      LowerCasePipe,
      JsonPipe,
      LimitToPipe,
      DatePipe,
      DecimalPipe,
      PercentPipe,
      CurrencyPipe,
      CONST_EXPR,
      Binding,
      OpaqueToken,
      DEFAULT_PIPES_LIST,
      DEFAULT_PIPES_TOKEN,
      DEFAULT_PIPES;
  return {
    setters: [function($__m) {
      AsyncPipe = $__m.AsyncPipe;
    }, function($__m) {
      UpperCasePipe = $__m.UpperCasePipe;
    }, function($__m) {
      LowerCasePipe = $__m.LowerCasePipe;
    }, function($__m) {
      JsonPipe = $__m.JsonPipe;
    }, function($__m) {
      LimitToPipe = $__m.LimitToPipe;
    }, function($__m) {
      DatePipe = $__m.DatePipe;
    }, function($__m) {
      DecimalPipe = $__m.DecimalPipe;
      PercentPipe = $__m.PercentPipe;
      CurrencyPipe = $__m.CurrencyPipe;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Binding = $__m.Binding;
      OpaqueToken = $__m.OpaqueToken;
    }],
    execute: function() {
      DEFAULT_PIPES_LIST = CONST_EXPR([AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, LimitToPipe, DecimalPipe, PercentPipe, CurrencyPipe, DatePipe]);
      DEFAULT_PIPES_TOKEN = CONST_EXPR(new OpaqueToken("Default Pipes"));
      $__export("DEFAULT_PIPES_TOKEN", DEFAULT_PIPES_TOKEN);
      DEFAULT_PIPES = CONST_EXPR(new Binding(DEFAULT_PIPES_TOKEN, {toValue: DEFAULT_PIPES_LIST}));
      $__export("DEFAULT_PIPES", DEFAULT_PIPES);
    }
  };
});

System.register("angular2/src/core/exception_handler", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/exception_handler";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      isBlank,
      BaseException,
      isListLikeIterable,
      _ArrayLogger,
      ExceptionHandler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      isListLikeIterable = $__m.isListLikeIterable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      _ArrayLogger = (function() {
        function _ArrayLogger() {
          this.res = [];
        }
        return ($traceurRuntime.createClass)(_ArrayLogger, {
          log: function(s) {
            this.res.push(s);
          },
          logGroup: function(s) {
            this.res.push(s);
          },
          logGroupEnd: function() {}
        }, {});
      }());
      ExceptionHandler = (($traceurRuntime.createClass)(function(logger) {
        var rethrowException = arguments[1] !== (void 0) ? arguments[1] : true;
        this.logger = logger;
        this.rethrowException = rethrowException;
      }, {
        call: function(exception) {
          var stackTrace = arguments[1] !== (void 0) ? arguments[1] : null;
          var reason = arguments[2] !== (void 0) ? arguments[2] : null;
          var originalException = this._findOriginalException(exception);
          var originalStack = this._findOriginalStack(exception);
          var context = this._findContext(exception);
          this.logger.logGroup(("EXCEPTION: " + exception));
          if (isPresent(stackTrace) && isBlank(originalStack)) {
            this.logger.log("STACKTRACE:");
            this.logger.log(this._longStackTrace(stackTrace));
          }
          if (isPresent(reason)) {
            this.logger.log(("REASON: " + reason));
          }
          if (isPresent(originalException)) {
            this.logger.log(("ORIGINAL EXCEPTION: " + originalException));
          }
          if (isPresent(originalStack)) {
            this.logger.log("ORIGINAL STACKTRACE:");
            this.logger.log(this._longStackTrace(originalStack));
          }
          if (isPresent(context)) {
            this.logger.log("ERROR CONTEXT:");
            this.logger.log(context);
          }
          this.logger.logGroupEnd();
          if (this.rethrowException)
            throw exception;
        },
        _longStackTrace: function(stackTrace) {
          return isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") : stackTrace.toString();
        },
        _findContext: function(exception) {
          try {
            if (!(exception instanceof BaseException))
              return null;
            return isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
          } catch (e) {
            return null;
          }
        },
        _findOriginalException: function(exception) {
          if (!(exception instanceof BaseException))
            return null;
          var e = exception.originalException;
          while (e instanceof BaseException && isPresent(e.originalException)) {
            e = e.originalException;
          }
          return e;
        },
        _findOriginalStack: function(exception) {
          if (!(exception instanceof BaseException))
            return null;
          var e = exception;
          var stack = exception.originalStack;
          while (e instanceof BaseException && isPresent(e.originalException)) {
            e = e.originalException;
            if (e instanceof BaseException && isPresent(e.originalException)) {
              stack = e.originalStack;
            }
          }
          return stack;
        }
      }, {exceptionToString: function(exception) {
          var stackTrace = arguments[1] !== (void 0) ? arguments[1] : null;
          var reason = arguments[2] !== (void 0) ? arguments[2] : null;
          var l = new _ArrayLogger();
          var e = new ExceptionHandler(l, false);
          e.call(exception, stackTrace, reason);
          return l.res.join("\n");
        }}));
      $__export("ExceptionHandler", ExceptionHandler);
      $__export("ExceptionHandler", ExceptionHandler = __decorate([Injectable(), __metadata('design:paramtypes', [Object, Boolean])], ExceptionHandler));
    }
  };
});

System.register("angular2/src/render/xhr", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/xhr";
  var XHR;
  return {
    setters: [],
    execute: function() {
      XHR = (function() {
        function XHR() {}
        return ($traceurRuntime.createClass)(XHR, {get: function(url) {
            return null;
          }}, {});
      }());
      $__export("XHR", XHR);
    }
  };
});

System.register("angular2/src/render/dom/compiler/style_url_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/services/url_resolver"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/style_url_resolver";
  var __decorate,
      __metadata,
      Injectable,
      RegExpWrapper,
      StringWrapper,
      UrlResolver,
      StyleUrlResolver,
      _cssUrlRe,
      _cssImportRe,
      _quoteRe,
      _dataUrlRe;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      StyleUrlResolver = (($traceurRuntime.createClass)(function(_resolver) {
        this._resolver = _resolver;
      }, {
        resolveUrls: function(cssText, baseUrl) {
          cssText = this._replaceUrls(cssText, _cssUrlRe, baseUrl);
          cssText = this._replaceUrls(cssText, _cssImportRe, baseUrl);
          return cssText;
        },
        _replaceUrls: function(cssText, re, baseUrl) {
          var $__0 = this;
          return StringWrapper.replaceAllMapped(cssText, re, (function(m) {
            var pre = m[1];
            var originalUrl = m[2];
            if (RegExpWrapper.test(_dataUrlRe, originalUrl)) {
              return m[0];
            }
            var url = StringWrapper.replaceAll(originalUrl, _quoteRe, '');
            var post = m[3];
            var resolvedUrl = $__0._resolver.resolve(baseUrl, url);
            return pre + "'" + resolvedUrl + "'" + post;
          }));
        }
      }, {}));
      $__export("StyleUrlResolver", StyleUrlResolver);
      $__export("StyleUrlResolver", StyleUrlResolver = __decorate([Injectable(), __metadata('design:paramtypes', [UrlResolver])], StyleUrlResolver));
      _cssUrlRe = /(url\()([^)]*)(\))/g;
      _cssImportRe = /(@import[\s]+(?!url\())['"]([^'"]*)['"](.*;)/g;
      _quoteRe = /['"]/g;
      _dataUrlRe = /^['"]?data:/g;
    }
  };
});

System.register("angular2/src/core/zone/ng_zone", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/profile/profile"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/zone/ng_zone";
  var ListWrapper,
      StringMapWrapper,
      normalizeBlank,
      isPresent,
      global,
      wtfLeave,
      wtfCreateScope,
      NgZone;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      normalizeBlank = $__m.normalizeBlank;
      isPresent = $__m.isPresent;
      global = $__m.global;
    }, function($__m) {
      wtfLeave = $__m.wtfLeave;
      wtfCreateScope = $__m.wtfCreateScope;
    }],
    execute: function() {
      NgZone = (function() {
        function NgZone($__3) {
          var enableLongStackTrace = $__3.enableLongStackTrace;
          this._zone_run_scope = wtfCreateScope("NgZone#run()");
          this._zone_microtask = wtfCreateScope("NgZone#microtask()");
          this._inVmTurnDone = false;
          this._pendingTimeouts = [];
          this._onTurnStart = null;
          this._onTurnDone = null;
          this._onEventDone = null;
          this._onErrorHandler = null;
          this._pendingMicrotasks = 0;
          this._hasExecutedCodeInInnerZone = false;
          this._nestedRun = 0;
          if (global.zone) {
            this._disabled = false;
            this._mountZone = global.zone;
            this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);
          } else {
            this._disabled = true;
            this._mountZone = null;
          }
        }
        return ($traceurRuntime.createClass)(NgZone, {
          overrideOnTurnStart: function(onTurnStartFn) {
            this._onTurnStart = normalizeBlank(onTurnStartFn);
          },
          overrideOnTurnDone: function(onTurnDoneFn) {
            this._onTurnDone = normalizeBlank(onTurnDoneFn);
          },
          overrideOnEventDone: function(onEventDoneFn, opt_waitForAsync) {
            var $__0 = this;
            var normalizedOnEventDone = normalizeBlank(onEventDoneFn);
            if (opt_waitForAsync) {
              this._onEventDone = (function() {
                if (!$__0._pendingTimeouts.length) {
                  normalizedOnEventDone();
                }
              });
            } else {
              this._onEventDone = normalizedOnEventDone;
            }
          },
          overrideOnErrorHandler: function(errorHandlingFn) {
            this._onErrorHandler = normalizeBlank(errorHandlingFn);
          },
          run: function(fn) {
            if (this._disabled) {
              return fn();
            } else {
              var s = this._zone_run_scope();
              try {
                return this._innerZone.run(fn);
              } finally {
                wtfLeave(s);
              }
            }
          },
          runOutsideAngular: function(fn) {
            if (this._disabled) {
              return fn();
            } else {
              return this._mountZone.run(fn);
            }
          },
          _createInnerZone: function(zone, enableLongStackTrace) {
            var _zone_microtask = this._zone_microtask;
            var ngZone = this;
            var errorHandling;
            if (enableLongStackTrace) {
              errorHandling = StringMapWrapper.merge(Zone.longStackTraceZone, {onError: function(e) {
                  ngZone._onError(this, e);
                }});
            } else {
              errorHandling = {onError: function(e) {
                  ngZone._onError(this, e);
                }};
            }
            return zone.fork(errorHandling).fork({
              '$run': function(parentRun) {
                return function() {
                  try {
                    ngZone._nestedRun++;
                    if (!ngZone._hasExecutedCodeInInnerZone) {
                      ngZone._hasExecutedCodeInInnerZone = true;
                      if (ngZone._onTurnStart) {
                        parentRun.call(ngZone._innerZone, ngZone._onTurnStart);
                      }
                    }
                    return parentRun.apply(this, arguments);
                  } finally {
                    ngZone._nestedRun--;
                    if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0 && !this._inVmTurnDone) {
                      if (ngZone._onTurnDone && ngZone._hasExecutedCodeInInnerZone) {
                        try {
                          this._inVmTurnDone = true;
                          parentRun.call(ngZone._innerZone, ngZone._onTurnDone);
                          if (ngZone._pendingMicrotasks === 0 && isPresent(ngZone._onEventDone)) {
                            ngZone.runOutsideAngular(ngZone._onEventDone);
                          }
                        } finally {
                          this._inVmTurnDone = false;
                          ngZone._hasExecutedCodeInInnerZone = false;
                        }
                      }
                    }
                  }
                };
              },
              '$scheduleMicrotask': function(parentScheduleMicrotask) {
                return function(fn) {
                  ngZone._pendingMicrotasks++;
                  var microtask = function() {
                    var s = _zone_microtask();
                    try {
                      fn();
                    } finally {
                      ngZone._pendingMicrotasks--;
                      wtfLeave(s);
                    }
                  };
                  parentScheduleMicrotask.call(this, microtask);
                };
              },
              '$setTimeout': function(parentSetTimeout) {
                return function(fn, delay) {
                  for (var args = [],
                      $__2 = 2; $__2 < arguments.length; $__2++)
                    args[$__2 - 2] = arguments[$__2];
                  var id;
                  var cb = function() {
                    fn();
                    ListWrapper.remove(ngZone._pendingTimeouts, id);
                  };
                  id = parentSetTimeout(cb, delay, args);
                  ngZone._pendingTimeouts.push(id);
                  return id;
                };
              },
              '$clearTimeout': function(parentClearTimeout) {
                return function(id) {
                  parentClearTimeout(id);
                  ListWrapper.remove(ngZone._pendingTimeouts, id);
                };
              },
              _innerZone: true
            });
          },
          _onError: function(zone, e) {
            if (isPresent(this._onErrorHandler)) {
              var trace = [normalizeBlank(e.stack)];
              while (zone && zone.constructedAtException) {
                trace.push(zone.constructedAtException.get());
                zone = zone.parent;
              }
              this._onErrorHandler(e, trace);
            } else {
              console.log('## _onError ##');
              console.log(e.stack);
              throw e;
            }
          }
        }, {});
      }());
      $__export("NgZone", NgZone);
    }
  };
});

System.register("angular2/src/core/life_cycle/life_cycle", ["angular2/di", "angular2/src/facade/lang", "angular2/src/profile/profile"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/life_cycle/life_cycle";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      BaseException,
      wtfLeave,
      wtfCreateScope,
      LifeCycle;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      wtfLeave = $__m.wtfLeave;
      wtfCreateScope = $__m.wtfCreateScope;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      LifeCycle = (($traceurRuntime.createClass)(function() {
        var changeDetector = arguments[0] !== (void 0) ? arguments[0] : null;
        var enforceNoNewChanges = arguments[1] !== (void 0) ? arguments[1] : false;
        this._runningTick = false;
        this._changeDetector = changeDetector;
        this._enforceNoNewChanges = enforceNoNewChanges;
      }, {
        registerWith: function(zone) {
          var changeDetector = arguments[1] !== (void 0) ? arguments[1] : null;
          var $__0 = this;
          if (isPresent(changeDetector)) {
            this._changeDetector = changeDetector;
          }
          zone.overrideOnTurnDone((function() {
            return $__0.tick();
          }));
        },
        tick: function() {
          if (this._runningTick) {
            throw new BaseException("LifeCycle.tick is called recursively");
          }
          var s = LifeCycle._scope_tick();
          try {
            this._runningTick = true;
            this._changeDetector.detectChanges();
            if (this._enforceNoNewChanges) {
              this._changeDetector.checkNoChanges();
            }
          } finally {
            this._runningTick = false;
            wtfLeave(s);
          }
        }
      }, {}));
      $__export("LifeCycle", LifeCycle);
      LifeCycle._scope_tick = wtfCreateScope('LifeCycle#tick()');
      $__export("LifeCycle", LifeCycle = __decorate([Injectable(), __metadata('design:paramtypes', [Object, Boolean])], LifeCycle));
    }
  };
});

System.register("angular2/src/render/xhr_impl", ["angular2/di", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/render/xhr"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/xhr_impl";
  var __decorate,
      __metadata,
      Injectable,
      PromiseWrapper,
      isPresent,
      XHR,
      XHRImpl;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      XHR = $__m.XHR;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      XHRImpl = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {get: function(url) {
            var completer = PromiseWrapper.completer();
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'text';
            xhr.onload = function() {
              var response = isPresent(xhr.response) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : 0;
              }
              if (200 <= status && status <= 300) {
                completer.resolve(response);
              } else {
                completer.reject(("Failed to load " + url), null);
              }
            };
            xhr.onerror = function() {
              completer.reject(("Failed to load " + url), null);
            };
            xhr.send();
            return completer.promise;
          }}, {}, $__super);
      }(XHR));
      $__export("XHRImpl", XHRImpl);
      $__export("XHRImpl", XHRImpl = __decorate([Injectable(), __metadata('design:paramtypes', [])], XHRImpl));
    }
  };
});

System.register("angular2/src/render/dom/events/event_manager", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/event_manager";
  var BaseException,
      StringWrapper,
      DOM,
      BUBBLE_SYMBOL,
      EventManager,
      EventManagerPlugin,
      DomEventsPlugin;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      BUBBLE_SYMBOL = '^';
      EventManager = (function() {
        function EventManager(_plugins, _zone) {
          this._plugins = _plugins;
          this._zone = _zone;
          for (var i = 0; i < _plugins.length; i++) {
            _plugins[i].manager = this;
          }
        }
        return ($traceurRuntime.createClass)(EventManager, {
          addEventListener: function(element, eventName, handler) {
            var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
            var plugin = this._findPluginFor(withoutBubbleSymbol);
            plugin.addEventListener(element, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
          },
          addGlobalEventListener: function(target, eventName, handler) {
            var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
            var plugin = this._findPluginFor(withoutBubbleSymbol);
            return plugin.addGlobalEventListener(target, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
          },
          getZone: function() {
            return this._zone;
          },
          _findPluginFor: function(eventName) {
            var plugins = this._plugins;
            for (var i = 0; i < plugins.length; i++) {
              var plugin = plugins[i];
              if (plugin.supports(eventName)) {
                return plugin;
              }
            }
            throw new BaseException(("No event manager plugin found for event " + eventName));
          },
          _removeBubbleSymbol: function(eventName) {
            return eventName[0] == BUBBLE_SYMBOL ? StringWrapper.substring(eventName, 1) : eventName;
          }
        }, {});
      }());
      $__export("EventManager", EventManager);
      EventManagerPlugin = (function() {
        function EventManagerPlugin() {}
        return ($traceurRuntime.createClass)(EventManagerPlugin, {
          supports: function(eventName) {
            return false;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            throw "not implemented";
          },
          addGlobalEventListener: function(element, eventName, handler, shouldSupportBubble) {
            throw "not implemented";
          }
        }, {});
      }());
      $__export("EventManagerPlugin", EventManagerPlugin);
      DomEventsPlugin = (function($__super) {
        function DomEventsPlugin() {
          $traceurRuntime.superConstructor(DomEventsPlugin).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(DomEventsPlugin, {
          supports: function(eventName) {
            return true;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
            this.manager._zone.runOutsideAngular((function() {
              DOM.on(element, eventName, outsideHandler);
            }));
          },
          addGlobalEventListener: function(target, eventName, handler, shouldSupportBubble) {
            var element = DOM.getGlobalEventTarget(target);
            var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
            return this.manager._zone.runOutsideAngular((function() {
              return DOM.onAndCancel(element, eventName, outsideHandler);
            }));
          },
          _getOutsideHandler: function(shouldSupportBubble, element, handler, zone) {
            return shouldSupportBubble ? DomEventsPlugin.bubbleCallback(element, handler, zone) : DomEventsPlugin.sameElementCallback(element, handler, zone);
          }
        }, {
          sameElementCallback: function(element, handler, zone) {
            return (function(event) {
              if (event.target === element) {
                zone.run((function() {
                  return handler(event);
                }));
              }
            });
          },
          bubbleCallback: function(element, handler, zone) {
            return (function(event) {
              return zone.run((function() {
                return handler(event);
              }));
            });
          }
        }, $__super);
      }(EventManagerPlugin));
      $__export("DomEventsPlugin", DomEventsPlugin);
    }
  };
});

System.register("angular2/src/render/dom/events/key_events", ["angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/events/event_manager"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/key_events";
  var DOM,
      isPresent,
      StringWrapper,
      StringMapWrapper,
      ListWrapper,
      EventManagerPlugin,
      modifierKeys,
      modifierKeyGetters,
      KeyEventsPlugin;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isPresent = $__m.isPresent;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      EventManagerPlugin = $__m.EventManagerPlugin;
    }],
    execute: function() {
      modifierKeys = ['alt', 'control', 'meta', 'shift'];
      modifierKeyGetters = {
        'alt': (function(event) {
          return event.altKey;
        }),
        'control': (function(event) {
          return event.ctrlKey;
        }),
        'meta': (function(event) {
          return event.metaKey;
        }),
        'shift': (function(event) {
          return event.shiftKey;
        })
      };
      KeyEventsPlugin = (function($__super) {
        function KeyEventsPlugin() {
          $traceurRuntime.superConstructor(KeyEventsPlugin).call(this);
        }
        return ($traceurRuntime.createClass)(KeyEventsPlugin, {
          supports: function(eventName) {
            return isPresent(KeyEventsPlugin.parseEventName(eventName));
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
            var outsideHandler = KeyEventsPlugin.eventCallback(element, shouldSupportBubble, StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
            this.manager.getZone().runOutsideAngular((function() {
              DOM.on(element, StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
            }));
          }
        }, {
          parseEventName: function(eventName) {
            var parts = eventName.toLowerCase().split('.');
            var domEventName = ListWrapper.removeAt(parts, 0);
            if ((parts.length === 0) || !(StringWrapper.equals(domEventName, 'keydown') || StringWrapper.equals(domEventName, 'keyup'))) {
              return null;
            }
            var key = KeyEventsPlugin._normalizeKey(ListWrapper.removeLast(parts));
            var fullKey = '';
            ListWrapper.forEach(modifierKeys, (function(modifierName) {
              if (ListWrapper.contains(parts, modifierName)) {
                ListWrapper.remove(parts, modifierName);
                fullKey += modifierName + '.';
              }
            }));
            fullKey += key;
            if (parts.length != 0 || key.length === 0) {
              return null;
            }
            var result = StringMapWrapper.create();
            StringMapWrapper.set(result, 'domEventName', domEventName);
            StringMapWrapper.set(result, 'fullKey', fullKey);
            return result;
          },
          getEventFullKey: function(event) {
            var fullKey = '';
            var key = DOM.getEventKey(event);
            key = key.toLowerCase();
            if (StringWrapper.equals(key, ' ')) {
              key = 'space';
            } else if (StringWrapper.equals(key, '.')) {
              key = 'dot';
            }
            ListWrapper.forEach(modifierKeys, (function(modifierName) {
              if (modifierName != key) {
                var modifierGetter = StringMapWrapper.get(modifierKeyGetters, modifierName);
                if (modifierGetter(event)) {
                  fullKey += modifierName + '.';
                }
              }
            }));
            fullKey += key;
            return fullKey;
          },
          eventCallback: function(element, shouldSupportBubble, fullKey, handler, zone) {
            return (function(event) {
              var correctElement = shouldSupportBubble || event.target === element;
              if (correctElement && StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
                zone.run((function() {
                  return handler(event);
                }));
              }
            });
          },
          _normalizeKey: function(keyName) {
            switch (keyName) {
              case 'esc':
                return 'escape';
              default:
                return keyName;
            }
          }
        }, $__super);
      }(EventManagerPlugin));
      $__export("KeyEventsPlugin", KeyEventsPlugin);
    }
  };
});

System.register("angular2/src/render/dom/events/hammer_common", ["angular2/src/render/dom/events/event_manager", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/hammer_common";
  var EventManagerPlugin,
      StringMapWrapper,
      _eventNames,
      HammerGesturesPluginCommon;
  return {
    setters: [function($__m) {
      EventManagerPlugin = $__m.EventManagerPlugin;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      _eventNames = {
        'pan': true,
        'panstart': true,
        'panmove': true,
        'panend': true,
        'pancancel': true,
        'panleft': true,
        'panright': true,
        'panup': true,
        'pandown': true,
        'pinch': true,
        'pinchstart': true,
        'pinchmove': true,
        'pinchend': true,
        'pinchcancel': true,
        'pinchin': true,
        'pinchout': true,
        'press': true,
        'pressup': true,
        'rotate': true,
        'rotatestart': true,
        'rotatemove': true,
        'rotateend': true,
        'rotatecancel': true,
        'swipe': true,
        'swipeleft': true,
        'swiperight': true,
        'swipeup': true,
        'swipedown': true,
        'tap': true
      };
      HammerGesturesPluginCommon = (function($__super) {
        function HammerGesturesPluginCommon() {
          $traceurRuntime.superConstructor(HammerGesturesPluginCommon).call(this);
        }
        return ($traceurRuntime.createClass)(HammerGesturesPluginCommon, {supports: function(eventName) {
            eventName = eventName.toLowerCase();
            return StringMapWrapper.contains(_eventNames, eventName);
          }}, {}, $__super);
      }(EventManagerPlugin));
      $__export("HammerGesturesPluginCommon", HammerGesturesPluginCommon);
    }
  };
});

System.register("angular2/src/services/anchor_based_app_root_url", ["angular2/src/services/app_root_url", "angular2/src/dom/dom_adapter", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/anchor_based_app_root_url";
  var __decorate,
      __metadata,
      AppRootUrl,
      DOM,
      Injectable,
      AnchorBasedAppRootUrl;
  return {
    setters: [function($__m) {
      AppRootUrl = $__m.AppRootUrl;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AnchorBasedAppRootUrl = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this, "");
          var rootUrl;
          var a = DOM.createElement('a');
          DOM.resolveAndSetHref(a, './', null);
          rootUrl = DOM.getHref(a);
          this.value = rootUrl;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(AppRootUrl));
      $__export("AnchorBasedAppRootUrl", AnchorBasedAppRootUrl);
      $__export("AnchorBasedAppRootUrl", AnchorBasedAppRootUrl = __decorate([Injectable(), __metadata('design:paramtypes', [])], AnchorBasedAppRootUrl));
    }
  };
});

System.register("angular2/src/core/compiler/dynamic_component_loader", ["angular2/di", "angular2/src/core/compiler/compiler", "angular2/src/core/compiler/view_manager"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/dynamic_component_loader";
  var __decorate,
      __metadata,
      Injectable,
      Compiler,
      AppViewManager,
      ComponentRef,
      DynamicComponentLoader;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Compiler = $__m.Compiler;
    }, function($__m) {
      AppViewManager = $__m.AppViewManager;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ComponentRef = (function() {
        function ComponentRef(location, instance, _dispose) {
          this._dispose = _dispose;
          this.location = location;
          this.instance = instance;
        }
        return ($traceurRuntime.createClass)(ComponentRef, {
          get hostView() {
            return this.location.parentView;
          },
          dispose: function() {
            this._dispose();
          }
        }, {});
      }());
      $__export("ComponentRef", ComponentRef);
      DynamicComponentLoader = (($traceurRuntime.createClass)(function(_compiler, _viewManager) {
        this._compiler = _compiler;
        this._viewManager = _viewManager;
      }, {
        loadAsRoot: function(typeOrBinding, overrideSelector, injector) {
          var $__0 = this;
          return this._compiler.compileInHost(typeOrBinding).then((function(hostProtoViewRef) {
            var hostViewRef = $__0._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
            var newLocation = $__0._viewManager.getHostElement(hostViewRef);
            var component = $__0._viewManager.getComponent(newLocation);
            var dispose = (function() {
              $__0._viewManager.destroyRootHostView(hostViewRef);
            });
            return new ComponentRef(newLocation, component, dispose);
          }));
        },
        loadIntoLocation: function(typeOrBinding, hostLocation, anchorName) {
          var bindings = arguments[3] !== (void 0) ? arguments[3] : null;
          return this.loadNextToLocation(typeOrBinding, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), bindings);
        },
        loadNextToLocation: function(typeOrBinding, location) {
          var bindings = arguments[2] !== (void 0) ? arguments[2] : null;
          var $__0 = this;
          return this._compiler.compileInHost(typeOrBinding).then((function(hostProtoViewRef) {
            var viewContainer = $__0._viewManager.getViewContainer(location);
            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, bindings);
            var newLocation = $__0._viewManager.getHostElement(hostViewRef);
            var component = $__0._viewManager.getComponent(newLocation);
            var dispose = (function() {
              var index = viewContainer.indexOf(hostViewRef);
              if (index !== -1) {
                viewContainer.remove(index);
              }
            });
            return new ComponentRef(newLocation, component, dispose);
          }));
        }
      }, {}));
      $__export("DynamicComponentLoader", DynamicComponentLoader);
      $__export("DynamicComponentLoader", DynamicComponentLoader = __decorate([Injectable(), __metadata('design:paramtypes', [Compiler, AppViewManager])], DynamicComponentLoader));
    }
  };
});

System.register("angular2/src/core/testability/get_testability", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/testability/get_testability";
  var global,
      PublicTestability,
      GetTestability;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      PublicTestability = (function() {
        function PublicTestability(testability) {
          this._testability = testability;
        }
        return ($traceurRuntime.createClass)(PublicTestability, {
          whenStable: function(callback) {
            this._testability.whenStable(callback);
          },
          findBindings: function(using, binding, exactMatch) {
            return this._testability.findBindings(using, binding, exactMatch);
          }
        }, {});
      }());
      GetTestability = (function() {
        function GetTestability() {}
        return ($traceurRuntime.createClass)(GetTestability, {}, {addToWindow: function(registry) {
            global.getAngularTestability = function(elem) {
              var findInAncestors = arguments[1] !== (void 0) ? arguments[1] : true;
              var testability = registry.findTestabilityInTree(elem, findInAncestors);
              if (testability == null) {
                throw new Error('Could not find testability for element.');
              }
              return new PublicTestability(testability);
            };
            global.getAllAngularTestabilities = function() {
              var testabilities = registry.getAllTestabilities();
              return testabilities.map((function(testability) {
                return new PublicTestability(testability);
              }));
            };
          }});
      }());
      $__export("GetTestability", GetTestability);
    }
  };
});

System.register("angular2/src/render/dom/dom_tokens", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/dom_tokens";
  var OpaqueToken,
      Binding,
      CONST_EXPR,
      StringWrapper,
      Math,
      DOCUMENT,
      APP_ID,
      APP_ID_RANDOM_BINDING,
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE;
  function _appIdRandomBindingFactory() {
    return ("" + randomChar() + randomChar() + randomChar());
  }
  function randomChar() {
    return StringWrapper.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
      Binding = $__m.Binding;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
      StringWrapper = $__m.StringWrapper;
      Math = $__m.Math;
    }],
    execute: function() {
      DOCUMENT = CONST_EXPR(new OpaqueToken('DocumentToken'));
      $__export("DOCUMENT", DOCUMENT);
      APP_ID = CONST_EXPR(new OpaqueToken('AppId'));
      $__export("APP_ID", APP_ID);
      APP_ID_RANDOM_BINDING = CONST_EXPR(new Binding(APP_ID, {
        toFactory: _appIdRandomBindingFactory,
        deps: []
      }));
      $__export("APP_ID_RANDOM_BINDING", APP_ID_RANDOM_BINDING);
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = CONST_EXPR(new OpaqueToken('MaxInMemoryElementsPerTemplate'));
      $__export("MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE", MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_element", ["angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_element";
  var MapWrapper,
      DOM,
      isBlank,
      isPresent,
      StringJoiner,
      assertionsEnabled,
      CompileElement;
  function getElementDescription(domElement) {
    var buf = new StringJoiner();
    var atts = DOM.attributeMap(domElement);
    buf.add("<");
    buf.add(DOM.tagName(domElement).toLowerCase());
    addDescriptionAttribute(buf, "id", atts.get("id"));
    addDescriptionAttribute(buf, "class", atts.get("class"));
    MapWrapper.forEach(atts, (function(attValue, attName) {
      if (attName !== "id" && attName !== "class") {
        addDescriptionAttribute(buf, attName, attValue);
      }
    }));
    buf.add(">");
    return buf.toString();
  }
  function addDescriptionAttribute(buffer, attName, attValue) {
    if (isPresent(attValue)) {
      if (attValue.length === 0) {
        buffer.add(' ' + attName);
      } else {
        buffer.add(' ' + attName + '="' + attValue + '"');
      }
    }
  }
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      StringJoiner = $__m.StringJoiner;
      assertionsEnabled = $__m.assertionsEnabled;
    }],
    execute: function() {
      CompileElement = (function() {
        function CompileElement(element) {
          var compilationUnit = arguments[1] !== (void 0) ? arguments[1] : '';
          this.element = element;
          this._attrs = null;
          this._classList = null;
          this.isViewRoot = false;
          this.inheritedProtoView = null;
          this.distanceToInheritedBinder = 0;
          this.inheritedElementBinder = null;
          this.compileChildren = true;
          var tplDesc = assertionsEnabled() ? getElementDescription(element) : null;
          if (compilationUnit !== '') {
            this.elementDescription = compilationUnit;
            if (isPresent(tplDesc))
              this.elementDescription += ": " + tplDesc;
          } else {
            this.elementDescription = tplDesc;
          }
        }
        return ($traceurRuntime.createClass)(CompileElement, {
          isBound: function() {
            return isPresent(this.inheritedElementBinder) && this.distanceToInheritedBinder === 0;
          },
          bindElement: function() {
            if (!this.isBound()) {
              var parentBinder = this.inheritedElementBinder;
              this.inheritedElementBinder = this.inheritedProtoView.bindElement(this.element, this.elementDescription);
              if (isPresent(parentBinder)) {
                this.inheritedElementBinder.setParent(parentBinder, this.distanceToInheritedBinder);
              }
              this.distanceToInheritedBinder = 0;
            }
            return this.inheritedElementBinder;
          },
          attrs: function() {
            if (isBlank(this._attrs)) {
              this._attrs = DOM.attributeMap(this.element);
            }
            return this._attrs;
          },
          classList: function() {
            if (isBlank(this._classList)) {
              this._classList = [];
              var elClassList = DOM.classList(this.element);
              for (var i = 0; i < elClassList.length; i++) {
                this._classList.push(elClassList[i]);
              }
            }
            return this._classList;
          }
        }, {});
      }());
      $__export("CompileElement", CompileElement);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_control", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_control";
  var isBlank,
      CompileControl;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      CompileControl = (function() {
        function CompileControl(_steps) {
          this._steps = _steps;
          this._currentStepIndex = 0;
          this._parent = null;
          this._results = null;
          this._additionalChildren = null;
        }
        return ($traceurRuntime.createClass)(CompileControl, {
          internalProcess: function(results, startStepIndex, parent, current) {
            this._results = results;
            var previousStepIndex = this._currentStepIndex;
            var previousParent = this._parent;
            this._ignoreCurrentElement = false;
            for (var i = startStepIndex; i < this._steps.length && !this._ignoreCurrentElement; i++) {
              var step = this._steps[i];
              this._parent = parent;
              this._currentStepIndex = i;
              step.processElement(parent, current, this);
              parent = this._parent;
            }
            if (!this._ignoreCurrentElement) {
              results.push(current);
            }
            this._currentStepIndex = previousStepIndex;
            this._parent = previousParent;
            var localAdditionalChildren = this._additionalChildren;
            this._additionalChildren = null;
            return localAdditionalChildren;
          },
          addParent: function(newElement) {
            this.internalProcess(this._results, this._currentStepIndex + 1, this._parent, newElement);
            this._parent = newElement;
          },
          addChild: function(element) {
            if (isBlank(this._additionalChildren)) {
              this._additionalChildren = [];
            }
            this._additionalChildren.push(element);
          },
          ignoreCurrentElement: function() {
            this._ignoreCurrentElement = true;
          }
        }, {});
      }());
      $__export("CompileControl", CompileControl);
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view", ["angular2/src/render/api", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view";
  var RenderProtoViewRef,
      DOM,
      DomProtoViewRef,
      DomProtoView;
  function resolveInternalDomProtoView(protoViewRef) {
    return protoViewRef._protoView;
  }
  $__export("resolveInternalDomProtoView", resolveInternalDomProtoView);
  return {
    setters: [function($__m) {
      RenderProtoViewRef = $__m.RenderProtoViewRef;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      DomProtoViewRef = (function($__super) {
        function DomProtoViewRef(_protoView) {
          $traceurRuntime.superConstructor(DomProtoViewRef).call(this);
          this._protoView = _protoView;
        }
        return ($traceurRuntime.createClass)(DomProtoViewRef, {}, {}, $__super);
      }(RenderProtoViewRef));
      $__export("DomProtoViewRef", DomProtoViewRef);
      DomProtoView = (function() {
        function DomProtoView(type, cloneableTemplate, encapsulation, elementBinders, hostAttributes, rootTextNodeIndices, boundTextNodeCount, fragmentsRootNodeCount, isSingleElementFragment) {
          this.type = type;
          this.cloneableTemplate = cloneableTemplate;
          this.encapsulation = encapsulation;
          this.elementBinders = elementBinders;
          this.hostAttributes = hostAttributes;
          this.rootTextNodeIndices = rootTextNodeIndices;
          this.boundTextNodeCount = boundTextNodeCount;
          this.fragmentsRootNodeCount = fragmentsRootNodeCount;
          this.isSingleElementFragment = isSingleElementFragment;
        }
        return ($traceurRuntime.createClass)(DomProtoView, {}, {create: function(templateCloner, type, rootElement, viewEncapsulation, fragmentsRootNodeCount, rootTextNodeIndices, elementBinders, hostAttributes) {
            var boundTextNodeCount = rootTextNodeIndices.length;
            for (var i = 0; i < elementBinders.length; i++) {
              boundTextNodeCount += elementBinders[i].textNodeIndices.length;
            }
            var isSingleElementFragment = fragmentsRootNodeCount.length === 1 && fragmentsRootNodeCount[0] === 1 && DOM.isElementNode(DOM.firstChild(DOM.content(rootElement)));
            return new DomProtoView(type, templateCloner.prepareForClone(rootElement), viewEncapsulation, elementBinders, hostAttributes, rootTextNodeIndices, boundTextNodeCount, fragmentsRootNodeCount, isSingleElementFragment);
          }});
      }());
      $__export("DomProtoView", DomProtoView);
    }
  };
});

System.register("angular2/src/render/dom/view/element_binder", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/element_binder";
  var isPresent,
      DomElementBinder,
      Event,
      HostAction;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      DomElementBinder = (function() {
        function DomElementBinder() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              textNodeIndices = $__1.textNodeIndices,
              hasNestedProtoView = $__1.hasNestedProtoView,
              eventLocals = $__1.eventLocals,
              localEvents = $__1.localEvents,
              globalEvents = $__1.globalEvents,
              hasNativeShadowRoot = $__1.hasNativeShadowRoot;
          this.textNodeIndices = textNodeIndices;
          this.hasNestedProtoView = hasNestedProtoView;
          this.eventLocals = eventLocals;
          this.localEvents = localEvents;
          this.globalEvents = globalEvents;
          this.hasNativeShadowRoot = isPresent(hasNativeShadowRoot) ? hasNativeShadowRoot : false;
        }
        return ($traceurRuntime.createClass)(DomElementBinder, {}, {});
      }());
      $__export("DomElementBinder", DomElementBinder);
      Event = (function() {
        function Event(name, target, fullName) {
          this.name = name;
          this.target = target;
          this.fullName = fullName;
        }
        return ($traceurRuntime.createClass)(Event, {}, {});
      }());
      $__export("Event", Event);
      HostAction = (function() {
        function HostAction(actionName, actionExpression, expression) {
          this.actionName = actionName;
          this.actionExpression = actionExpression;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(HostAction, {}, {});
      }());
      $__export("HostAction", HostAction);
    }
  };
});

System.register("angular2/src/render/dom/compiler/property_binding_parser", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/property_binding_parser";
  var isPresent,
      RegExpWrapper,
      StringWrapper,
      MapWrapper,
      dashCaseToCamelCase,
      BIND_NAME_REGEXP,
      PropertyBindingParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }],
    execute: function() {
      BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-|#)|(on-)|(onbubble-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
      PropertyBindingParser = (function() {
        function PropertyBindingParser(_parser) {
          this._parser = _parser;
        }
        return ($traceurRuntime.createClass)(PropertyBindingParser, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            var $__0 = this;
            var attrs = current.attrs();
            var newAttrs = new Map();
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              attrName = $__0._normalizeAttributeName(attrName);
              var bindParts = RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
              if (isPresent(bindParts)) {
                if (isPresent(bindParts[1])) {
                  $__0._bindProperty(bindParts[6], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[2])) {
                  var identifier = bindParts[6];
                  var value = attrValue == '' ? '\$implicit' : attrValue;
                  $__0._bindVariable(identifier, value, current, newAttrs);
                } else if (isPresent(bindParts[3])) {
                  $__0._bindEvent(bindParts[6], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[4])) {
                  $__0._bindEvent('^' + bindParts[6], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[5])) {
                  $__0._bindProperty(bindParts[6], attrValue, current, newAttrs);
                  $__0._bindAssignmentEvent(bindParts[6], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[7])) {
                  $__0._bindProperty(bindParts[7], attrValue, current, newAttrs);
                  $__0._bindAssignmentEvent(bindParts[7], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[8])) {
                  $__0._bindProperty(bindParts[8], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[9])) {
                  $__0._bindEvent(bindParts[9], attrValue, current, newAttrs);
                }
              } else {
                var expr = $__0._parser.parseInterpolation(attrValue, current.elementDescription);
                if (isPresent(expr)) {
                  $__0._bindPropertyAst(attrName, expr, current, newAttrs);
                }
              }
            }));
            MapWrapper.forEach(newAttrs, (function(attrValue, attrName) {
              attrs.set(attrName, attrValue);
            }));
          },
          _normalizeAttributeName: function(attrName) {
            return StringWrapper.startsWith(attrName, 'data-') ? StringWrapper.substring(attrName, 5) : attrName;
          },
          _bindVariable: function(identifier, value, current, newAttrs) {
            current.bindElement().bindVariable(dashCaseToCamelCase(identifier), value);
            newAttrs.set(identifier, value);
          },
          _bindProperty: function(name, expression, current, newAttrs) {
            this._bindPropertyAst(name, this._parser.parseBinding(expression, current.elementDescription), current, newAttrs);
          },
          _bindPropertyAst: function(name, ast, current, newAttrs) {
            var binder = current.bindElement();
            binder.bindProperty(dashCaseToCamelCase(name), ast);
            newAttrs.set(name, ast.source);
          },
          _bindAssignmentEvent: function(name, expression, current, newAttrs) {
            this._bindEvent(name, (expression + "=$event"), current, newAttrs);
          },
          _bindEvent: function(name, expression, current, newAttrs) {
            current.bindElement().bindEvent(dashCaseToCamelCase(name), this._parser.parseAction(expression, current.elementDescription));
          }
        }, {});
      }());
      $__export("PropertyBindingParser", PropertyBindingParser);
    }
  };
});

System.register("angular2/src/render/dom/compiler/text_interpolation_parser", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/text_interpolation_parser";
  var isPresent,
      DOM,
      TextInterpolationParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      TextInterpolationParser = (function() {
        function TextInterpolationParser(_parser) {
          this._parser = _parser;
        }
        return ($traceurRuntime.createClass)(TextInterpolationParser, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            if (!current.compileChildren) {
              return ;
            }
            var element = current.element;
            var childNodes = DOM.childNodes(DOM.templateAwareRoot(element));
            for (var i = 0; i < childNodes.length; i++) {
              var node = childNodes[i];
              if (DOM.isTextNode(node)) {
                var textNode = node;
                var text = DOM.nodeValue(textNode);
                var expr = this._parser.parseInterpolation(text, current.elementDescription);
                if (isPresent(expr)) {
                  DOM.setText(textNode, ' ');
                  if (current.element === current.inheritedProtoView.rootElement) {
                    current.inheritedProtoView.bindRootText(textNode, expr);
                  } else {
                    current.bindElement().bindText(textNode, expr);
                  }
                }
              }
            }
          }
        }, {});
      }());
      $__export("TextInterpolationParser", TextInterpolationParser);
    }
  };
});

System.register("angular2/src/render/dom/compiler/selector", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/selector";
  var Map,
      ListWrapper,
      isPresent,
      isBlank,
      RegExpWrapper,
      RegExpMatcherWrapper,
      StringWrapper,
      BaseException,
      _EMPTY_ATTR_VALUE,
      _SELECTOR_REGEXP,
      CssSelector,
      SelectorMatcher,
      SelectorListContext,
      SelectorContext;
  return {
    setters: [function($__m) {
      Map = $__m.Map;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
      RegExpMatcherWrapper = $__m.RegExpMatcherWrapper;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      _EMPTY_ATTR_VALUE = '';
      _SELECTOR_REGEXP = RegExpWrapper.create('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(\\))|' + '(\\s*,\\s*)');
      CssSelector = (function() {
        function CssSelector() {
          this.element = null;
          this.classNames = [];
          this.attrs = [];
          this.notSelectors = [];
        }
        return ($traceurRuntime.createClass)(CssSelector, {
          isElementSelector: function() {
            return isPresent(this.element) && ListWrapper.isEmpty(this.classNames) && ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
          },
          setElement: function() {
            var element = arguments[0] !== (void 0) ? arguments[0] : null;
            if (isPresent(element)) {
              element = element.toLowerCase();
            }
            this.element = element;
          },
          getMatchingElementTemplate: function() {
            var tagName = isPresent(this.element) ? this.element : 'div';
            var classAttr = this.classNames.length > 0 ? (" class=\"" + this.classNames.join(' ') + "\"") : '';
            var attrs = '';
            for (var i = 0; i < this.attrs.length; i += 2) {
              var attrName = this.attrs[i];
              var attrValue = this.attrs[i + 1] !== '' ? ("=\"" + this.attrs[i + 1] + "\"") : '';
              attrs += (" " + attrName + attrValue);
            }
            return ("<" + tagName + classAttr + attrs + "></" + tagName + ">");
          },
          addAttribute: function(name) {
            var value = arguments[1] !== (void 0) ? arguments[1] : _EMPTY_ATTR_VALUE;
            this.attrs.push(name.toLowerCase());
            if (isPresent(value)) {
              value = value.toLowerCase();
            } else {
              value = _EMPTY_ATTR_VALUE;
            }
            this.attrs.push(value);
          },
          addClassName: function(name) {
            this.classNames.push(name.toLowerCase());
          },
          toString: function() {
            var res = '';
            if (isPresent(this.element)) {
              res += this.element;
            }
            if (isPresent(this.classNames)) {
              for (var i = 0; i < this.classNames.length; i++) {
                res += '.' + this.classNames[i];
              }
            }
            if (isPresent(this.attrs)) {
              for (var i = 0; i < this.attrs.length; ) {
                var attrName = this.attrs[i++];
                var attrValue = this.attrs[i++];
                res += '[' + attrName;
                if (attrValue.length > 0) {
                  res += '=' + attrValue;
                }
                res += ']';
              }
            }
            ListWrapper.forEach(this.notSelectors, (function(notSelector) {
              res += ":not(" + notSelector.toString() + ")";
            }));
            return res;
          }
        }, {parse: function(selector) {
            var results = [];
            var _addResult = (function(res, cssSel) {
              if (cssSel.notSelectors.length > 0 && isBlank(cssSel.element) && ListWrapper.isEmpty(cssSel.classNames) && ListWrapper.isEmpty(cssSel.attrs)) {
                cssSel.element = "*";
              }
              res.push(cssSel);
            });
            var cssSelector = new CssSelector();
            var matcher = RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
            var match;
            var current = cssSelector;
            var inNot = false;
            while (isPresent(match = RegExpMatcherWrapper.next(matcher))) {
              if (isPresent(match[1])) {
                if (inNot) {
                  throw new BaseException('Nesting :not is not allowed in a selector');
                }
                inNot = true;
                current = new CssSelector();
                cssSelector.notSelectors.push(current);
              }
              if (isPresent(match[2])) {
                current.setElement(match[2]);
              }
              if (isPresent(match[3])) {
                current.addClassName(match[3]);
              }
              if (isPresent(match[4])) {
                current.addAttribute(match[4], match[5]);
              }
              if (isPresent(match[6])) {
                inNot = false;
                current = cssSelector;
              }
              if (isPresent(match[7])) {
                if (inNot) {
                  throw new BaseException('Multiple selectors in :not are not supported');
                }
                _addResult(results, cssSelector);
                cssSelector = current = new CssSelector();
              }
            }
            _addResult(results, cssSelector);
            return results;
          }});
      }());
      $__export("CssSelector", CssSelector);
      SelectorMatcher = (function() {
        function SelectorMatcher() {
          this._elementMap = new Map();
          this._elementPartialMap = new Map();
          this._classMap = new Map();
          this._classPartialMap = new Map();
          this._attrValueMap = new Map();
          this._attrValuePartialMap = new Map();
          this._listContexts = [];
        }
        return ($traceurRuntime.createClass)(SelectorMatcher, {
          addSelectables: function(cssSelectors, callbackCtxt) {
            var listContext = null;
            if (cssSelectors.length > 1) {
              listContext = new SelectorListContext(cssSelectors);
              this._listContexts.push(listContext);
            }
            for (var i = 0; i < cssSelectors.length; i++) {
              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
            }
          },
          _addSelectable: function(cssSelector, callbackCtxt, listContext) {
            var matcher = this;
            var element = cssSelector.element;
            var classNames = cssSelector.classNames;
            var attrs = cssSelector.attrs;
            var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
            if (isPresent(element)) {
              var isTerminal = attrs.length === 0 && classNames.length === 0;
              if (isTerminal) {
                this._addTerminal(matcher._elementMap, element, selectable);
              } else {
                matcher = this._addPartial(matcher._elementPartialMap, element);
              }
            }
            if (isPresent(classNames)) {
              for (var index = 0; index < classNames.length; index++) {
                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                var className = classNames[index];
                if (isTerminal) {
                  this._addTerminal(matcher._classMap, className, selectable);
                } else {
                  matcher = this._addPartial(matcher._classPartialMap, className);
                }
              }
            }
            if (isPresent(attrs)) {
              for (var index = 0; index < attrs.length; ) {
                var isTerminal = index === attrs.length - 2;
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                if (isTerminal) {
                  var terminalMap = matcher._attrValueMap;
                  var terminalValuesMap = terminalMap.get(attrName);
                  if (isBlank(terminalValuesMap)) {
                    terminalValuesMap = new Map();
                    terminalMap.set(attrName, terminalValuesMap);
                  }
                  this._addTerminal(terminalValuesMap, attrValue, selectable);
                } else {
                  var parttialMap = matcher._attrValuePartialMap;
                  var partialValuesMap = parttialMap.get(attrName);
                  if (isBlank(partialValuesMap)) {
                    partialValuesMap = new Map();
                    parttialMap.set(attrName, partialValuesMap);
                  }
                  matcher = this._addPartial(partialValuesMap, attrValue);
                }
              }
            }
          },
          _addTerminal: function(map, name, selectable) {
            var terminalList = map.get(name);
            if (isBlank(terminalList)) {
              terminalList = [];
              map.set(name, terminalList);
            }
            terminalList.push(selectable);
          },
          _addPartial: function(map, name) {
            var matcher = map.get(name);
            if (isBlank(matcher)) {
              matcher = new SelectorMatcher();
              map.set(name, matcher);
            }
            return matcher;
          },
          match: function(cssSelector, matchedCallback) {
            var result = false;
            var element = cssSelector.element;
            var classNames = cssSelector.classNames;
            var attrs = cssSelector.attrs;
            for (var i = 0; i < this._listContexts.length; i++) {
              this._listContexts[i].alreadyMatched = false;
            }
            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
            if (isPresent(classNames)) {
              for (var index = 0; index < classNames.length; index++) {
                var className = classNames[index];
                result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
              }
            }
            if (isPresent(attrs)) {
              for (var index = 0; index < attrs.length; ) {
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var terminalValuesMap = this._attrValueMap.get(attrName);
                if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                  result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
                }
                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) || result;
                var partialValuesMap = this._attrValuePartialMap.get(attrName);
                if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                  result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
                }
                result = this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
              }
            }
            return result;
          },
          _matchTerminal: function(map, name, cssSelector, matchedCallback) {
            if (isBlank(map) || isBlank(name)) {
              return false;
            }
            var selectables = map.get(name);
            var starSelectables = map.get("*");
            if (isPresent(starSelectables)) {
              selectables = ListWrapper.concat(selectables, starSelectables);
            }
            if (isBlank(selectables)) {
              return false;
            }
            var selectable;
            var result = false;
            for (var index = 0; index < selectables.length; index++) {
              selectable = selectables[index];
              result = selectable.finalize(cssSelector, matchedCallback) || result;
            }
            return result;
          },
          _matchPartial: function(map, name, cssSelector, matchedCallback) {
            if (isBlank(map) || isBlank(name)) {
              return false;
            }
            var nestedSelector = map.get(name);
            if (isBlank(nestedSelector)) {
              return false;
            }
            return nestedSelector.match(cssSelector, matchedCallback);
          }
        }, {createNotMatcher: function(notSelectors) {
            var notMatcher = new SelectorMatcher();
            notMatcher.addSelectables(notSelectors, null);
            return notMatcher;
          }});
      }());
      $__export("SelectorMatcher", SelectorMatcher);
      SelectorListContext = (function() {
        function SelectorListContext(selectors) {
          this.selectors = selectors;
          this.alreadyMatched = false;
        }
        return ($traceurRuntime.createClass)(SelectorListContext, {}, {});
      }());
      $__export("SelectorListContext", SelectorListContext);
      SelectorContext = (function() {
        function SelectorContext(selector, cbContext, listContext) {
          this.selector = selector;
          this.cbContext = cbContext;
          this.listContext = listContext;
          this.notSelectors = selector.notSelectors;
        }
        return ($traceurRuntime.createClass)(SelectorContext, {finalize: function(cssSelector, callback) {
            var result = true;
            if (this.notSelectors.length > 0 && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
              var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
              result = !notMatcher.match(cssSelector, null);
            }
            if (result && isPresent(callback) && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
              if (isPresent(this.listContext)) {
                this.listContext.alreadyMatched = true;
              }
              callback(this.selector, this.cbContext);
            }
            return result;
          }}, {});
      }());
      $__export("SelectorContext", SelectorContext);
    }
  };
});

System.register("angular2/src/render/dom/compiler/view_splitter", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/view_splitter";
  var isPresent,
      BaseException,
      StringWrapper,
      DOM,
      MapWrapper,
      CompileElement,
      dashCaseToCamelCase,
      ViewSplitter;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }],
    execute: function() {
      ViewSplitter = (function() {
        function ViewSplitter(_parser) {
          this._parser = _parser;
        }
        return ($traceurRuntime.createClass)(ViewSplitter, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            var attrs = current.attrs();
            var templateBindings = attrs.get('template');
            var hasTemplateBinding = isPresent(templateBindings);
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              if (StringWrapper.startsWith(attrName, '*')) {
                var key = StringWrapper.substring(attrName, 1);
                if (hasTemplateBinding) {
                  throw new BaseException("Only one template directive per element is allowed: " + (templateBindings + " and " + key + " cannot be used simultaneously ") + ("in " + current.elementDescription));
                } else {
                  templateBindings = (attrValue.length == 0) ? key : key + ' ' + attrValue;
                  hasTemplateBinding = true;
                }
              }
            }));
            if (isPresent(parent)) {
              if (DOM.isTemplateElement(current.element)) {
                if (!current.isViewRoot) {
                  var viewRoot = new CompileElement(DOM.createTemplate(''));
                  viewRoot.inheritedProtoView = current.bindElement().bindNestedProtoView(viewRoot.element);
                  viewRoot.elementDescription = current.elementDescription;
                  viewRoot.isViewRoot = true;
                  this._moveChildNodes(DOM.content(current.element), DOM.content(viewRoot.element));
                  control.addChild(viewRoot);
                }
              }
              if (hasTemplateBinding) {
                var anchor = new CompileElement(DOM.createTemplate(''));
                anchor.inheritedProtoView = current.inheritedProtoView;
                anchor.inheritedElementBinder = current.inheritedElementBinder;
                anchor.distanceToInheritedBinder = current.distanceToInheritedBinder;
                anchor.elementDescription = current.elementDescription;
                var viewRoot = new CompileElement(DOM.createTemplate(''));
                viewRoot.inheritedProtoView = anchor.bindElement().bindNestedProtoView(viewRoot.element);
                viewRoot.elementDescription = current.elementDescription;
                viewRoot.isViewRoot = true;
                current.inheritedProtoView = viewRoot.inheritedProtoView;
                current.inheritedElementBinder = null;
                current.distanceToInheritedBinder = 0;
                this._parseTemplateBindings(templateBindings, anchor);
                DOM.insertBefore(current.element, anchor.element);
                control.addParent(anchor);
                DOM.appendChild(DOM.content(viewRoot.element), current.element);
                control.addParent(viewRoot);
              }
            }
          },
          _moveChildNodes: function(source, target) {
            var next = DOM.firstChild(source);
            while (isPresent(next)) {
              DOM.appendChild(target, next);
              next = DOM.firstChild(source);
            }
          },
          _parseTemplateBindings: function(templateBindings, compileElement) {
            var bindings = this._parser.parseTemplateBindings(templateBindings, compileElement.elementDescription);
            for (var i = 0; i < bindings.length; i++) {
              var binding = bindings[i];
              if (binding.keyIsVar) {
                compileElement.bindElement().bindVariable(dashCaseToCamelCase(binding.key), binding.name);
                compileElement.attrs().set(binding.key, binding.name);
              } else if (isPresent(binding.expression)) {
                compileElement.bindElement().bindProperty(dashCaseToCamelCase(binding.key), binding.expression);
                compileElement.attrs().set(binding.key, binding.expression.source);
              } else {
                DOM.setAttribute(compileElement.element, binding.key, '');
              }
            }
          }
        }, {});
      }());
      $__export("ViewSplitter", ViewSplitter);
    }
  };
});

System.register("angular2/src/render/dom/compiler/shadow_css", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/shadow_css";
  var DOM,
      ListWrapper,
      StringWrapper,
      RegExpWrapper,
      RegExpMatcherWrapper,
      isPresent,
      isBlank,
      ShadowCss,
      _cssContentNextSelectorRe,
      _cssContentRuleRe,
      _cssContentUnscopedRuleRe,
      _polyfillHost,
      _polyfillHostContext,
      _parenSuffix,
      _cssColonHostRe,
      _cssColonHostContextRe,
      _polyfillHostNoCombinator,
      _shadowDOMSelectorsRe,
      _selectorReSuffix,
      _polyfillHostRe,
      _colonHostRe,
      _colonHostContextRe;
  function _cssToRules(cssText) {
    return DOM.cssToRules(cssText);
  }
  function _withCssRules(cssText, callback) {
    if (isBlank(callback))
      return ;
    var rules = _cssToRules(cssText);
    callback(rules);
  }
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      RegExpMatcherWrapper = $__m.RegExpMatcherWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      ShadowCss = (function() {
        function ShadowCss() {
          this.strictStyling = true;
        }
        return ($traceurRuntime.createClass)(ShadowCss, {
          shimStyle: function(style, selector) {
            var hostSelector = arguments[2] !== (void 0) ? arguments[2] : '';
            var cssText = DOM.getText(style);
            return this.shimCssText(cssText, selector, hostSelector);
          },
          shimCssText: function(cssText, selector) {
            var hostSelector = arguments[2] !== (void 0) ? arguments[2] : '';
            cssText = this._insertDirectives(cssText);
            return this._scopeCssText(cssText, selector, hostSelector);
          },
          _insertDirectives: function(cssText) {
            cssText = this._insertPolyfillDirectivesInCssText(cssText);
            return this._insertPolyfillRulesInCssText(cssText);
          },
          _insertPolyfillDirectivesInCssText: function(cssText) {
            return StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function(m) {
              return m[1] + '{';
            });
          },
          _insertPolyfillRulesInCssText: function(cssText) {
            return StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function(m) {
              var rule = m[0];
              rule = StringWrapper.replace(rule, m[1], '');
              rule = StringWrapper.replace(rule, m[2], '');
              return m[3] + rule;
            });
          },
          _scopeCssText: function(cssText, scopeSelector, hostSelector) {
            var $__0 = this;
            var unscoped = this._extractUnscopedRulesFromCssText(cssText);
            cssText = this._insertPolyfillHostInCssText(cssText);
            cssText = this._convertColonHost(cssText);
            cssText = this._convertColonHostContext(cssText);
            cssText = this._convertShadowDOMSelectors(cssText);
            if (isPresent(scopeSelector)) {
              _withCssRules(cssText, (function(rules) {
                cssText = $__0._scopeRules(rules, scopeSelector, hostSelector);
              }));
            }
            cssText = cssText + '\n' + unscoped;
            return cssText.trim();
          },
          _extractUnscopedRulesFromCssText: function(cssText) {
            var r = '',
                m;
            var matcher = RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
            while (isPresent(m = RegExpMatcherWrapper.next(matcher))) {
              var rule = m[0];
              rule = StringWrapper.replace(rule, m[2], '');
              rule = StringWrapper.replace(rule, m[1], m[3]);
              r += rule + '\n\n';
            }
            return r;
          },
          _convertColonHost: function(cssText) {
            return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
          },
          _convertColonHostContext: function(cssText) {
            return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
          },
          _convertColonRule: function(cssText, regExp, partReplacer) {
            return StringWrapper.replaceAllMapped(cssText, regExp, function(m) {
              if (isPresent(m[2])) {
                var parts = m[2].split(','),
                    r = [];
                for (var i = 0; i < parts.length; i++) {
                  var p = parts[i];
                  if (isBlank(p))
                    break;
                  p = p.trim();
                  r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
              } else {
                return _polyfillHostNoCombinator + m[3];
              }
            });
          },
          _colonHostContextPartReplacer: function(host, part, suffix) {
            if (StringWrapper.contains(part, _polyfillHost)) {
              return this._colonHostPartReplacer(host, part, suffix);
            } else {
              return host + part + suffix + ', ' + part + ' ' + host + suffix;
            }
          },
          _colonHostPartReplacer: function(host, part, suffix) {
            return host + StringWrapper.replace(part, _polyfillHost, '') + suffix;
          },
          _convertShadowDOMSelectors: function(cssText) {
            for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
              cssText = StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
            }
            return cssText;
          },
          _scopeRules: function(cssRules, scopeSelector, hostSelector) {
            var cssText = '';
            if (isPresent(cssRules)) {
              for (var i = 0; i < cssRules.length; i++) {
                var rule = cssRules[i];
                if (DOM.isStyleRule(rule) || DOM.isPageRule(rule)) {
                  cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) + ' {\n';
                  cssText += this._propertiesFromRule(rule) + '\n}\n\n';
                } else if (DOM.isMediaRule(rule)) {
                  cssText += '@media ' + rule.media.mediaText + ' {\n';
                  cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
                  cssText += '\n}\n\n';
                } else {
                  try {
                    if (isPresent(rule.cssText)) {
                      cssText += rule.cssText + '\n\n';
                    }
                  } catch (x) {
                    if (DOM.isKeyframesRule(rule) && isPresent(rule.cssRules)) {
                      cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
                    }
                  }
                }
              }
            }
            return cssText;
          },
          _ieSafeCssTextFromKeyFrameRule: function(rule) {
            var cssText = '@keyframes ' + rule.name + ' {';
            for (var i = 0; i < rule.cssRules.length; i++) {
              var r = rule.cssRules[i];
              cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
            }
            cssText += ' }';
            return cssText;
          },
          _scopeSelector: function(selector, scopeSelector, hostSelector, strict) {
            var r = [],
                parts = selector.split(',');
            for (var i = 0; i < parts.length; i++) {
              var p = parts[i];
              p = p.trim();
              if (this._selectorNeedsScoping(p, scopeSelector)) {
                p = strict && !StringWrapper.contains(p, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(p, scopeSelector) : this._applySelectorScope(p, scopeSelector, hostSelector);
              }
              r.push(p);
            }
            return r.join(', ');
          },
          _selectorNeedsScoping: function(selector, scopeSelector) {
            var re = this._makeScopeMatcher(scopeSelector);
            return !isPresent(RegExpWrapper.firstMatch(re, selector));
          },
          _makeScopeMatcher: function(scopeSelector) {
            var lre = /\[/g;
            var rre = /\]/g;
            scopeSelector = StringWrapper.replaceAll(scopeSelector, lre, '\\[');
            scopeSelector = StringWrapper.replaceAll(scopeSelector, rre, '\\]');
            return RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
          },
          _applySelectorScope: function(selector, scopeSelector, hostSelector) {
            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
          },
          _applySimpleSelectorScope: function(selector, scopeSelector, hostSelector) {
            if (isPresent(RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
              var replaceBy = this.strictStyling ? ("[" + hostSelector + "]") : scopeSelector;
              selector = StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
              return StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
            } else {
              return scopeSelector + ' ' + selector;
            }
          },
          _applyStrictSelectorScope: function(selector, scopeSelector) {
            var isRe = /\[is=([^\]]*)\]/g;
            scopeSelector = StringWrapper.replaceAllMapped(scopeSelector, isRe, (function(m) {
              return m[1];
            }));
            var splits = [' ', '>', '+', '~'],
                scoped = selector,
                attrName = '[' + scopeSelector + ']';
            for (var i = 0; i < splits.length; i++) {
              var sep = splits[i];
              var parts = scoped.split(sep);
              scoped = ListWrapper.map(parts, function(p) {
                var t = StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                if (t.length > 0 && !ListWrapper.contains(splits, t) && !StringWrapper.contains(t, attrName)) {
                  var re = /([^:]*)(:*)(.*)/g;
                  var m = RegExpWrapper.firstMatch(re, t);
                  if (isPresent(m)) {
                    p = m[1] + attrName + m[2] + m[3];
                  }
                }
                return p;
              }).join(sep);
            }
            return scoped;
          },
          _insertPolyfillHostInCssText: function(selector) {
            selector = StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
            selector = StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
            return selector;
          },
          _propertiesFromRule: function(rule) {
            var cssText = rule.style.cssText;
            var attrRe = /['"]+|attr/g;
            if (rule.style.content.length > 0 && !isPresent(RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
              var contentRe = /content:[^;]*;/g;
              cssText = StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
            }
            return cssText;
          }
        }, {});
      }());
      $__export("ShadowCss", ShadowCss);
      _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
      _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
      _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
      _polyfillHost = '-shadowcsshost';
      _polyfillHostContext = '-shadowcsscontext';
      _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
      _cssColonHostRe = RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
      _cssColonHostContextRe = RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
      _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
      _shadowDOMSelectorsRe = [/>>>/g, /::shadow/g, /::content/g, /\/deep\//g, /\/shadow-deep\//g, /\/shadow\//g];
      _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
      _polyfillHostRe = RegExpWrapper.create(_polyfillHost, 'im');
      _colonHostRe = /:host/gim;
      _colonHostContextRe = /:host-context/gim;
    }
  };
});

System.register("angular2/src/render/dom/schema/element_schema_registry", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/schema/element_schema_registry";
  var ElementSchemaRegistry;
  return {
    setters: [],
    execute: function() {
      ElementSchemaRegistry = (function() {
        function ElementSchemaRegistry() {}
        return ($traceurRuntime.createClass)(ElementSchemaRegistry, {
          hasProperty: function(elm, propName) {
            return true;
          },
          getMappedPropName: function(propName) {
            return propName;
          }
        }, {});
      }());
      $__export("ElementSchemaRegistry", ElementSchemaRegistry);
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view_merger", ["angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/element_binder", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view_merger";
  var DOM,
      isPresent,
      isBlank,
      isArray,
      ListWrapper,
      SetWrapper,
      MapWrapper,
      DomProtoView,
      DomProtoViewRef,
      resolveInternalDomProtoView,
      DomElementBinder,
      RenderProtoViewMergeMapping,
      ViewType,
      ViewEncapsulation,
      NG_BINDING_CLASS,
      NG_CONTENT_ELEMENT_NAME,
      cloneAndQueryProtoView,
      queryBoundElements,
      queryBoundTextNodeIndices,
      NG_SHADOW_ROOT_ELEMENT_NAME;
  function mergeProtoViewsRecursively(templateCloner, protoViewRefs) {
    var clonedProtoViews = [];
    var hostViewAndBinderIndices = [];
    cloneProtoViews(templateCloner, protoViewRefs, clonedProtoViews, hostViewAndBinderIndices);
    var mainProtoView = clonedProtoViews[0];
    mergeEmbeddedPvsIntoComponentOrRootPv(clonedProtoViews, hostViewAndBinderIndices);
    var fragments = [];
    var elementsWithNativeShadowRoot = new Set();
    mergeComponents(clonedProtoViews, hostViewAndBinderIndices, fragments, elementsWithNativeShadowRoot);
    markBoundTextNodeParentsAsBoundElements(clonedProtoViews);
    var fragmentsRootNodeCount = fragments.map((function(fragment) {
      return fragment.length;
    }));
    var rootElement = createRootElementFromFragments(fragments);
    var rootNode = DOM.content(rootElement);
    var mergedBoundElements = queryBoundElements(rootNode, false);
    var mergedBoundTextIndices = new Map();
    var boundTextNodeMap = indexBoundTextNodes(clonedProtoViews);
    var rootTextNodeIndices = calcRootTextNodeIndices(rootNode, boundTextNodeMap, mergedBoundTextIndices);
    var mergedElementBinders = calcElementBinders(clonedProtoViews, mergedBoundElements, elementsWithNativeShadowRoot, boundTextNodeMap, mergedBoundTextIndices);
    var mappedElementIndices = calcMappedElementIndices(clonedProtoViews, mergedBoundElements);
    var mappedTextIndices = calcMappedTextIndices(clonedProtoViews, mergedBoundTextIndices);
    var hostElementIndicesByViewIndex = calcHostElementIndicesByViewIndex(clonedProtoViews, hostViewAndBinderIndices);
    var nestedViewCounts = calcNestedViewCounts(hostViewAndBinderIndices);
    var mergedProtoView = DomProtoView.create(templateCloner, mainProtoView.original.type, rootElement, mainProtoView.original.encapsulation, fragmentsRootNodeCount, rootTextNodeIndices, mergedElementBinders, new Map());
    return new RenderProtoViewMergeMapping(new DomProtoViewRef(mergedProtoView), fragmentsRootNodeCount.length, mappedElementIndices, mergedBoundElements.length, mappedTextIndices, hostElementIndicesByViewIndex, nestedViewCounts);
  }
  function cloneProtoViews(templateCloner, protoViewRefs, targetClonedProtoViews, targetHostViewAndBinderIndices) {
    var hostProtoView = resolveInternalDomProtoView(protoViewRefs[0]);
    var hostPvIdx = targetClonedProtoViews.length;
    targetClonedProtoViews.push(cloneAndQueryProtoView(templateCloner, hostProtoView, false));
    if (targetHostViewAndBinderIndices.length === 0) {
      targetHostViewAndBinderIndices.push([null, null]);
    }
    var protoViewIdx = 1;
    for (var i = 0; i < hostProtoView.elementBinders.length; i++) {
      var binder = hostProtoView.elementBinders[i];
      if (binder.hasNestedProtoView) {
        var nestedEntry = protoViewRefs[protoViewIdx++];
        if (isPresent(nestedEntry)) {
          targetHostViewAndBinderIndices.push([hostPvIdx, i]);
          if (isArray(nestedEntry)) {
            cloneProtoViews(templateCloner, nestedEntry, targetClonedProtoViews, targetHostViewAndBinderIndices);
          } else {
            targetClonedProtoViews.push(cloneAndQueryProtoView(templateCloner, resolveInternalDomProtoView(nestedEntry), false));
          }
        }
      }
    }
  }
  function markBoundTextNodeParentsAsBoundElements(mergableProtoViews) {
    mergableProtoViews.forEach((function(mergableProtoView) {
      mergableProtoView.boundTextNodes.forEach((function(textNode) {
        var parentNode = textNode.parentNode;
        if (isPresent(parentNode) && DOM.isElementNode(parentNode)) {
          DOM.addClass(parentNode, NG_BINDING_CLASS);
        }
      }));
    }));
  }
  function indexBoundTextNodes(mergableProtoViews) {
    var boundTextNodeMap = new Map();
    for (var pvIndex = 0; pvIndex < mergableProtoViews.length; pvIndex++) {
      var mergableProtoView = mergableProtoViews[pvIndex];
      mergableProtoView.boundTextNodes.forEach((function(textNode) {
        boundTextNodeMap.set(textNode, null);
      }));
    }
    return boundTextNodeMap;
  }
  function mergeEmbeddedPvsIntoComponentOrRootPv(clonedProtoViews, hostViewAndBinderIndices) {
    var nearestHostComponentOrRootPvIndices = calcNearestHostComponentOrRootPvIndices(clonedProtoViews, hostViewAndBinderIndices);
    for (var viewIdx = 1; viewIdx < clonedProtoViews.length; viewIdx++) {
      var clonedProtoView = clonedProtoViews[viewIdx];
      if (clonedProtoView.original.type === ViewType.EMBEDDED) {
        var hostComponentIdx = nearestHostComponentOrRootPvIndices[viewIdx];
        var hostPv = clonedProtoViews[hostComponentIdx];
        clonedProtoView.fragments.forEach((function(fragment) {
          return hostPv.fragments.push(fragment);
        }));
      }
    }
  }
  function calcNearestHostComponentOrRootPvIndices(clonedProtoViews, hostViewAndBinderIndices) {
    var nearestHostComponentOrRootPvIndices = ListWrapper.createFixedSize(clonedProtoViews.length);
    nearestHostComponentOrRootPvIndices[0] = null;
    for (var viewIdx = 1; viewIdx < hostViewAndBinderIndices.length; viewIdx++) {
      var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
      var hostProtoView = clonedProtoViews[hostViewIdx];
      if (hostViewIdx === 0 || hostProtoView.original.type === ViewType.COMPONENT) {
        nearestHostComponentOrRootPvIndices[viewIdx] = hostViewIdx;
      } else {
        nearestHostComponentOrRootPvIndices[viewIdx] = nearestHostComponentOrRootPvIndices[hostViewIdx];
      }
    }
    return nearestHostComponentOrRootPvIndices;
  }
  function mergeComponents(clonedProtoViews, hostViewAndBinderIndices, targetFragments, targetElementsWithNativeShadowRoot) {
    var hostProtoView = clonedProtoViews[0];
    hostProtoView.fragments.forEach((function(fragment) {
      return targetFragments.push(fragment);
    }));
    for (var viewIdx = 1; viewIdx < clonedProtoViews.length; viewIdx++) {
      var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
      var hostBinderIdx = hostViewAndBinderIndices[viewIdx][1];
      var hostProtoView = clonedProtoViews[hostViewIdx];
      var clonedProtoView = clonedProtoViews[viewIdx];
      if (clonedProtoView.original.type === ViewType.COMPONENT) {
        mergeComponent(hostProtoView, hostBinderIdx, clonedProtoView, targetFragments, targetElementsWithNativeShadowRoot);
      }
    }
  }
  function mergeComponent(hostProtoView, binderIdx, nestedProtoView, targetFragments, targetElementsWithNativeShadowRoot) {
    var hostElement = hostProtoView.boundElements[binderIdx];
    var fragmentElements = mapFragmentsIntoElements(nestedProtoView.fragments);
    var contentElements = findContentElements(fragmentElements);
    var projectableNodes = DOM.childNodesAsList(hostElement);
    for (var i = 0; i < contentElements.length; i++) {
      var contentElement = contentElements[i];
      var select = DOM.getAttribute(contentElement, 'select');
      projectableNodes = projectMatchingNodes(select, contentElement, projectableNodes);
    }
    var fragments = extractFragmentNodesFromElements(fragmentElements);
    var useNativeShadowRoot = nestedProtoView.original.encapsulation === ViewEncapsulation.NATIVE;
    if (useNativeShadowRoot) {
      targetElementsWithNativeShadowRoot.add(hostElement);
    }
    MapWrapper.forEach(nestedProtoView.original.hostAttributes, (function(attrValue, attrName) {
      DOM.setAttribute(hostElement, attrName, attrValue);
    }));
    appendComponentNodesToHost(hostProtoView, binderIdx, fragments[0], useNativeShadowRoot);
    for (var i = 1; i < fragments.length; i++) {
      targetFragments.push(fragments[i]);
    }
  }
  function mapFragmentsIntoElements(fragments) {
    return fragments.map((function(fragment) {
      var fragmentElement = DOM.createTemplate('');
      fragment.forEach((function(node) {
        return DOM.appendChild(DOM.content(fragmentElement), node);
      }));
      return fragmentElement;
    }));
  }
  function extractFragmentNodesFromElements(fragmentElements) {
    return fragmentElements.map((function(fragmentElement) {
      return DOM.childNodesAsList(DOM.content(fragmentElement));
    }));
  }
  function findContentElements(fragmentElements) {
    var contentElements = [];
    fragmentElements.forEach((function(fragmentElement) {
      var fragmentContentElements = DOM.querySelectorAll(DOM.content(fragmentElement), NG_CONTENT_ELEMENT_NAME);
      for (var i = 0; i < fragmentContentElements.length; i++) {
        contentElements.push(fragmentContentElements[i]);
      }
    }));
    return sortContentElements(contentElements);
  }
  function appendComponentNodesToHost(hostProtoView, binderIdx, componentRootNodes, useNativeShadowRoot) {
    var hostElement = hostProtoView.boundElements[binderIdx];
    if (useNativeShadowRoot) {
      var shadowRootWrapper = DOM.createElement(NG_SHADOW_ROOT_ELEMENT_NAME);
      for (var i = 0; i < componentRootNodes.length; i++) {
        DOM.appendChild(shadowRootWrapper, componentRootNodes[i]);
      }
      var firstChild = DOM.firstChild(hostElement);
      if (isPresent(firstChild)) {
        DOM.insertBefore(firstChild, shadowRootWrapper);
      } else {
        DOM.appendChild(hostElement, shadowRootWrapper);
      }
    } else {
      DOM.clearNodes(hostElement);
      for (var i = 0; i < componentRootNodes.length; i++) {
        DOM.appendChild(hostElement, componentRootNodes[i]);
      }
    }
  }
  function projectMatchingNodes(selector, contentElement, nodes) {
    var remaining = [];
    DOM.insertBefore(contentElement, DOM.createComment('['));
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var matches = false;
      if (isWildcard(selector)) {
        matches = true;
      } else if (DOM.isElementNode(node) && DOM.elementMatches(node, selector)) {
        matches = true;
      }
      if (matches) {
        DOM.insertBefore(contentElement, node);
      } else {
        remaining.push(node);
      }
    }
    DOM.insertBefore(contentElement, DOM.createComment(']'));
    DOM.remove(contentElement);
    return remaining;
  }
  function isWildcard(selector) {
    return isBlank(selector) || selector.length === 0 || selector == '*';
  }
  function sortContentElements(contentElements) {
    var firstWildcard = null;
    var sorted = [];
    contentElements.forEach((function(contentElement) {
      var select = DOM.getAttribute(contentElement, 'select');
      if (isWildcard(select)) {
        if (isBlank(firstWildcard)) {
          firstWildcard = contentElement;
        }
      } else {
        sorted.push(contentElement);
      }
    }));
    if (isPresent(firstWildcard)) {
      sorted.push(firstWildcard);
    }
    return sorted;
  }
  function createRootElementFromFragments(fragments) {
    var rootElement = DOM.createTemplate('');
    var rootNode = DOM.content(rootElement);
    for (var i = 0; i < fragments.length; i++) {
      var fragment = fragments[i];
      if (i >= 1) {
        DOM.appendChild(rootNode, DOM.createComment('|'));
      }
      fragment.forEach((function(node) {
        DOM.appendChild(rootNode, node);
      }));
    }
    return rootElement;
  }
  function calcRootTextNodeIndices(rootNode, boundTextNodes, targetBoundTextIndices) {
    var rootTextNodeIndices = [];
    queryBoundTextNodeIndices(rootNode, boundTextNodes, (function(textNode, nodeIndex, _) {
      rootTextNodeIndices.push(nodeIndex);
      targetBoundTextIndices.set(textNode, targetBoundTextIndices.size);
    }));
    return rootTextNodeIndices;
  }
  function calcElementBinders(clonedProtoViews, mergedBoundElements, elementsWithNativeShadowRoot, boundTextNodes, targetBoundTextIndices) {
    var elementBinderByElement = indexElementBindersByElement(clonedProtoViews);
    var mergedElementBinders = [];
    for (var i = 0; i < mergedBoundElements.length; i++) {
      var element = mergedBoundElements[i];
      var textNodeIndices = [];
      queryBoundTextNodeIndices(element, boundTextNodes, (function(textNode, nodeIndex, _) {
        textNodeIndices.push(nodeIndex);
        targetBoundTextIndices.set(textNode, targetBoundTextIndices.size);
      }));
      mergedElementBinders.push(updateElementBinders(elementBinderByElement.get(element), textNodeIndices, SetWrapper.has(elementsWithNativeShadowRoot, element)));
    }
    return mergedElementBinders;
  }
  function indexElementBindersByElement(mergableProtoViews) {
    var elementBinderByElement = new Map();
    mergableProtoViews.forEach((function(mergableProtoView) {
      for (var i = 0; i < mergableProtoView.boundElements.length; i++) {
        var el = mergableProtoView.boundElements[i];
        if (isPresent(el)) {
          elementBinderByElement.set(el, mergableProtoView.original.elementBinders[i]);
        }
      }
    }));
    return elementBinderByElement;
  }
  function updateElementBinders(elementBinder, textNodeIndices, hasNativeShadowRoot) {
    var result;
    if (isBlank(elementBinder)) {
      result = new DomElementBinder({
        textNodeIndices: textNodeIndices,
        hasNestedProtoView: false,
        eventLocals: null,
        localEvents: [],
        globalEvents: [],
        hasNativeShadowRoot: false
      });
    } else {
      result = new DomElementBinder({
        textNodeIndices: textNodeIndices,
        hasNestedProtoView: false,
        eventLocals: elementBinder.eventLocals,
        localEvents: elementBinder.localEvents,
        globalEvents: elementBinder.globalEvents,
        hasNativeShadowRoot: hasNativeShadowRoot
      });
    }
    return result;
  }
  function calcMappedElementIndices(clonedProtoViews, mergedBoundElements) {
    var mergedBoundElementIndices = indexArray(mergedBoundElements);
    var mappedElementIndices = [];
    clonedProtoViews.forEach((function(clonedProtoView) {
      clonedProtoView.boundElements.forEach((function(boundElement) {
        var mappedElementIndex = mergedBoundElementIndices.get(boundElement);
        mappedElementIndices.push(mappedElementIndex);
      }));
    }));
    return mappedElementIndices;
  }
  function calcMappedTextIndices(clonedProtoViews, mergedBoundTextIndices) {
    var mappedTextIndices = [];
    clonedProtoViews.forEach((function(clonedProtoView) {
      clonedProtoView.boundTextNodes.forEach((function(textNode) {
        var mappedTextIndex = mergedBoundTextIndices.get(textNode);
        mappedTextIndices.push(mappedTextIndex);
      }));
    }));
    return mappedTextIndices;
  }
  function calcHostElementIndicesByViewIndex(clonedProtoViews, hostViewAndBinderIndices) {
    var hostElementIndices = [null];
    var viewElementOffsets = [0];
    var elementIndex = clonedProtoViews[0].original.elementBinders.length;
    for (var viewIdx = 1; viewIdx < hostViewAndBinderIndices.length; viewIdx++) {
      viewElementOffsets.push(elementIndex);
      elementIndex += clonedProtoViews[viewIdx].original.elementBinders.length;
      var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
      var hostBinderIdx = hostViewAndBinderIndices[viewIdx][1];
      hostElementIndices.push(viewElementOffsets[hostViewIdx] + hostBinderIdx);
    }
    return hostElementIndices;
  }
  function calcNestedViewCounts(hostViewAndBinderIndices) {
    var nestedViewCounts = ListWrapper.createFixedSize(hostViewAndBinderIndices.length);
    ListWrapper.fill(nestedViewCounts, 0);
    for (var viewIdx = hostViewAndBinderIndices.length - 1; viewIdx >= 1; viewIdx--) {
      var hostViewAndElementIdx = hostViewAndBinderIndices[viewIdx];
      if (isPresent(hostViewAndElementIdx)) {
        nestedViewCounts[hostViewAndElementIdx[0]] += nestedViewCounts[viewIdx] + 1;
      }
    }
    return nestedViewCounts;
  }
  function indexArray(arr) {
    var map = new Map();
    for (var i = 0; i < arr.length; i++) {
      map.set(arr[i], i);
    }
    return map;
  }
  $__export("mergeProtoViewsRecursively", mergeProtoViewsRecursively);
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      isArray = $__m.isArray;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      SetWrapper = $__m.SetWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DomProtoView = $__m.DomProtoView;
      DomProtoViewRef = $__m.DomProtoViewRef;
      resolveInternalDomProtoView = $__m.resolveInternalDomProtoView;
    }, function($__m) {
      DomElementBinder = $__m.DomElementBinder;
    }, function($__m) {
      RenderProtoViewMergeMapping = $__m.RenderProtoViewMergeMapping;
      ViewType = $__m.ViewType;
      ViewEncapsulation = $__m.ViewEncapsulation;
    }, function($__m) {
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
      NG_CONTENT_ELEMENT_NAME = $__m.NG_CONTENT_ELEMENT_NAME;
      cloneAndQueryProtoView = $__m.cloneAndQueryProtoView;
      queryBoundElements = $__m.queryBoundElements;
      queryBoundTextNodeIndices = $__m.queryBoundTextNodeIndices;
      NG_SHADOW_ROOT_ELEMENT_NAME = $__m.NG_SHADOW_ROOT_ELEMENT_NAME;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/render/dom/template_cloner", ["angular2/src/facade/lang", "angular2/di", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/dom_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/template_cloner";
  var __decorate,
      __metadata,
      __param,
      isString,
      Injectable,
      Inject,
      DOM,
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE,
      TemplateCloner;
  return {
    setters: [function($__m) {
      isString = $__m.isString;
    }, function($__m) {
      Injectable = $__m.Injectable;
      Inject = $__m.Inject;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = $__m.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      TemplateCloner = (($traceurRuntime.createClass)(function(maxInMemoryElementsPerTemplate) {
        this.maxInMemoryElementsPerTemplate = maxInMemoryElementsPerTemplate;
      }, {
        prepareForClone: function(templateRoot) {
          var elementCount = DOM.querySelectorAll(DOM.content(templateRoot), '*').length;
          if (this.maxInMemoryElementsPerTemplate >= 0 && elementCount >= this.maxInMemoryElementsPerTemplate) {
            return DOM.getInnerHTML(templateRoot);
          } else {
            return templateRoot;
          }
        },
        cloneContent: function(preparedTemplateRoot, importNode) {
          var templateContent;
          if (isString(preparedTemplateRoot)) {
            templateContent = DOM.content(DOM.createTemplate(preparedTemplateRoot));
            if (importNode) {
              templateContent = DOM.importIntoDoc(templateContent);
            }
          } else {
            templateContent = DOM.content(preparedTemplateRoot);
            if (importNode) {
              templateContent = DOM.importIntoDoc(templateContent);
            } else {
              templateContent = DOM.clone(templateContent);
            }
          }
          return templateContent;
        }
      }, {}));
      $__export("TemplateCloner", TemplateCloner);
      $__export("TemplateCloner", TemplateCloner = __decorate([Injectable(), __param(0, Inject(MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE)), __metadata('design:paramtypes', [Object])], TemplateCloner));
    }
  };
});

System.register("angular2/src/render/dom/view/view", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/view";
  var DOM,
      Map,
      isPresent,
      stringify,
      RenderViewRef,
      camelCaseToDashCase,
      DomViewRef,
      DomView;
  function resolveInternalDomView(viewRef) {
    return viewRef._view;
  }
  $__export("resolveInternalDomView", resolveInternalDomView);
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Map = $__m.Map;
    }, function($__m) {
      isPresent = $__m.isPresent;
      stringify = $__m.stringify;
    }, function($__m) {
      RenderViewRef = $__m.RenderViewRef;
    }, function($__m) {
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }],
    execute: function() {
      DomViewRef = (function($__super) {
        function DomViewRef(_view) {
          $traceurRuntime.superConstructor(DomViewRef).call(this);
          this._view = _view;
        }
        return ($traceurRuntime.createClass)(DomViewRef, {}, {}, $__super);
      }(RenderViewRef));
      $__export("DomViewRef", DomViewRef);
      DomView = (function() {
        function DomView(proto, boundTextNodes, boundElements) {
          this.proto = proto;
          this.boundTextNodes = boundTextNodes;
          this.boundElements = boundElements;
          this.hydrated = false;
          this.eventDispatcher = null;
          this.eventHandlerRemovers = [];
        }
        return ($traceurRuntime.createClass)(DomView, {
          setElementProperty: function(elementIndex, propertyName, value) {
            DOM.setProperty(this.boundElements[elementIndex], propertyName, value);
          },
          setElementAttribute: function(elementIndex, attributeName, value) {
            var element = this.boundElements[elementIndex];
            var dashCasedAttributeName = camelCaseToDashCase(attributeName);
            if (isPresent(value)) {
              DOM.setAttribute(element, dashCasedAttributeName, stringify(value));
            } else {
              DOM.removeAttribute(element, dashCasedAttributeName);
            }
          },
          setElementClass: function(elementIndex, className, isAdd) {
            var element = this.boundElements[elementIndex];
            if (isAdd) {
              DOM.addClass(element, className);
            } else {
              DOM.removeClass(element, className);
            }
          },
          setElementStyle: function(elementIndex, styleName, value) {
            var element = this.boundElements[elementIndex];
            var dashCasedStyleName = camelCaseToDashCase(styleName);
            if (isPresent(value)) {
              DOM.setStyle(element, dashCasedStyleName, stringify(value));
            } else {
              DOM.removeStyle(element, dashCasedStyleName);
            }
          },
          invokeElementMethod: function(elementIndex, methodName, args) {
            var element = this.boundElements[elementIndex];
            DOM.invoke(element, methodName, args);
          },
          setText: function(textIndex, value) {
            DOM.setText(this.boundTextNodes[textIndex], value);
          },
          dispatchEvent: function(elementIndex, eventName, event) {
            var allowDefaultBehavior = true;
            if (isPresent(this.eventDispatcher)) {
              var evalLocals = new Map();
              evalLocals.set('$event', event);
              allowDefaultBehavior = this.eventDispatcher.dispatchRenderEvent(elementIndex, eventName, evalLocals);
              if (!allowDefaultBehavior) {
                DOM.preventDefault(event);
              }
            }
            return allowDefaultBehavior;
          }
        }, {});
      }());
      $__export("DomView", DomView);
    }
  };
});

System.register("angular2/src/render/dom/view/fragment", ["angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/fragment";
  var RenderFragmentRef,
      DomFragmentRef;
  function resolveInternalDomFragment(fragmentRef) {
    return fragmentRef._nodes;
  }
  $__export("resolveInternalDomFragment", resolveInternalDomFragment);
  return {
    setters: [function($__m) {
      RenderFragmentRef = $__m.RenderFragmentRef;
    }],
    execute: function() {
      DomFragmentRef = (function($__super) {
        function DomFragmentRef(_nodes) {
          $traceurRuntime.superConstructor(DomFragmentRef).call(this);
          this._nodes = _nodes;
        }
        return ($traceurRuntime.createClass)(DomFragmentRef, {}, {}, $__super);
      }(RenderFragmentRef));
      $__export("DomFragmentRef", DomFragmentRef);
    }
  };
});

System.register("angular2/src/render/dom/schema/dom_element_schema_registry", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/schema/element_schema_registry"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/schema/dom_element_schema_registry";
  var isPresent,
      StringMapWrapper,
      DOM,
      ElementSchemaRegistry,
      DomElementSchemaRegistry;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ElementSchemaRegistry = $__m.ElementSchemaRegistry;
    }],
    execute: function() {
      DomElementSchemaRegistry = (function($__super) {
        function DomElementSchemaRegistry() {
          $traceurRuntime.superConstructor(DomElementSchemaRegistry).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(DomElementSchemaRegistry, {
          hasProperty: function(elm, propName) {
            var tagName = DOM.tagName(elm);
            if (tagName.indexOf('-') !== -1) {
              return true;
            } else {
              return DOM.hasProperty(elm, propName);
            }
          },
          getMappedPropName: function(propName) {
            var mappedPropName = StringMapWrapper.get(DOM.attrToPropMap, propName);
            return isPresent(mappedPropName) ? mappedPropName : propName;
          }
        }, {}, $__super);
      }(ElementSchemaRegistry));
      $__export("DomElementSchemaRegistry", DomElementSchemaRegistry);
    }
  };
});

System.register("angular2/src/profile/wtf_init", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/profile/wtf_init";
  function wtfInit() {}
  $__export("wtfInit", wtfInit);
  return {
    setters: [],
    execute: function() {
    }
  };
});

System.register("angular2/src/core/platform_bindings", ["angular2/di", "angular2/src/core/exception_handler", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/platform_bindings";
  var bind,
      ExceptionHandler,
      DOM,
      EXCEPTION_BINDING;
  return {
    setters: [function($__m) {
      bind = $__m.bind;
    }, function($__m) {
      ExceptionHandler = $__m.ExceptionHandler;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      EXCEPTION_BINDING = bind(ExceptionHandler).toFactory((function() {
        return new ExceptionHandler(DOM, false);
      }), []);
      $__export("EXCEPTION_BINDING", EXCEPTION_BINDING);
    }
  };
});

System.register("angular2/src/core/application_ref", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application_ref";
  var ApplicationRef;
  return {
    setters: [],
    execute: function() {
      ApplicationRef = (function() {
        function ApplicationRef(hostComponent, hostComponentType, injector) {
          this._hostComponent = hostComponent;
          this._injector = injector;
          this._hostComponentType = hostComponentType;
        }
        return ($traceurRuntime.createClass)(ApplicationRef, {
          get hostComponentType() {
            return this._hostComponentType;
          },
          get hostComponent() {
            return this._hostComponent.instance;
          },
          dispose: function() {
            this._hostComponent.dispose();
          },
          get injector() {
            return this._injector;
          }
        }, {});
      }());
      $__export("ApplicationRef", ApplicationRef);
    }
  };
});

System.register("angular2/src/directives/ng_class", ["angular2/src/facade/lang", "angular2/metadata", "angular2/core", "angular2/src/render/api", "angular2/change_detection", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_class";
  var __decorate,
      __metadata,
      isPresent,
      isString,
      Directive,
      LifecycleEvent,
      ElementRef,
      Renderer,
      IterableDiffers,
      KeyValueDiffers,
      ListWrapper,
      StringMapWrapper,
      isListLikeIterable,
      NgClass;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isString = $__m.isString;
    }, function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      IterableDiffers = $__m.IterableDiffers;
      KeyValueDiffers = $__m.KeyValueDiffers;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
      isListLikeIterable = $__m.isListLikeIterable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgClass = (($traceurRuntime.createClass)(function(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
      }, {
        set initialClasses(v) {
          this._applyInitialClasses(true);
          this._initialClasses = isPresent(v) && isString(v) ? v.split(' ') : [];
          this._applyInitialClasses(false);
          this._applyClasses(this._rawClass, false);
        },
        set rawClass(v) {
          this._cleanupClasses(this._rawClass);
          if (isString(v)) {
            v = v.split(' ');
          }
          this._rawClass = v;
          if (isPresent(v)) {
            if (isListLikeIterable(v)) {
              this._differ = this._iterableDiffers.find(v).create(null);
              this._mode = 'iterable';
            } else {
              this._differ = this._keyValueDiffers.find(v).create(null);
              this._mode = 'keyValue';
            }
          } else {
            this._differ = null;
          }
        },
        onCheck: function() {
          if (isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawClass);
            if (isPresent(changes)) {
              if (this._mode == 'iterable') {
                this._applyIterableChanges(changes);
              } else {
                this._applyKeyValueChanges(changes);
              }
            }
          }
        },
        onDestroy: function() {
          this._cleanupClasses(this._rawClass);
        },
        _cleanupClasses: function(rawClassVal) {
          this._applyClasses(rawClassVal, true);
          this._applyInitialClasses(false);
        },
        _applyKeyValueChanges: function(changes) {
          var $__0 = this;
          changes.forEachAddedItem((function(record) {
            $__0._toggleClass(record.key, record.currentValue);
          }));
          changes.forEachChangedItem((function(record) {
            $__0._toggleClass(record.key, record.currentValue);
          }));
          changes.forEachRemovedItem((function(record) {
            if (record.previousValue) {
              $__0._toggleClass(record.key, false);
            }
          }));
        },
        _applyIterableChanges: function(changes) {
          var $__0 = this;
          changes.forEachAddedItem((function(record) {
            $__0._toggleClass(record.item, true);
          }));
          changes.forEachRemovedItem((function(record) {
            $__0._toggleClass(record.item, false);
          }));
        },
        _applyInitialClasses: function(isCleanup) {
          var $__0 = this;
          ListWrapper.forEach(this._initialClasses, (function(className) {
            $__0._toggleClass(className, !isCleanup);
          }));
        },
        _applyClasses: function(rawClassVal, isCleanup) {
          var $__0 = this;
          if (isPresent(rawClassVal)) {
            if (isListLikeIterable(rawClassVal)) {
              ListWrapper.forEach(rawClassVal, (function(className) {
                return $__0._toggleClass(className, !isCleanup);
              }));
            } else {
              StringMapWrapper.forEach(rawClassVal, (function(expVal, className) {
                if (expVal)
                  $__0._toggleClass(className, !isCleanup);
              }));
            }
          }
        },
        _toggleClass: function(className, enabled) {
          this._renderer.setElementClass(this._ngEl, className, enabled);
        }
      }, {}));
      $__export("NgClass", NgClass);
      $__export("NgClass", NgClass = __decorate([Directive({
        selector: '[ng-class]',
        lifecycle: [LifecycleEvent.onCheck, LifecycleEvent.onDestroy],
        properties: ['rawClass: ng-class', 'initialClasses: class']
      }), __metadata('design:paramtypes', [IterableDiffers, KeyValueDiffers, ElementRef, Renderer])], NgClass));
    }
  };
});

System.register("angular2/src/directives/ng_for", ["angular2/metadata", "angular2/core", "angular2/change_detection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_for";
  var __decorate,
      __metadata,
      Directive,
      LifecycleEvent,
      ViewContainerRef,
      TemplateRef,
      ChangeDetectorRef,
      IterableDiffers,
      isPresent,
      isBlank,
      NgFor,
      RecordViewTuple;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
      IterableDiffers = $__m.IterableDiffers;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgFor = (($traceurRuntime.createClass)(function(viewContainer, templateRef, iterableDiffers, cdr) {
        this.viewContainer = viewContainer;
        this.templateRef = templateRef;
        this.iterableDiffers = iterableDiffers;
        this.cdr = cdr;
      }, {
        set ngForOf(value) {
          this._ngForOf = value;
          if (isBlank(this._differ) && isPresent(value)) {
            this._differ = this.iterableDiffers.find(value).create(this.cdr);
          }
        },
        onCheck: function() {
          if (isPresent(this._differ)) {
            var changes = this._differ.diff(this._ngForOf);
            if (isPresent(changes))
              this._applyChanges(changes);
          }
        },
        _applyChanges: function(changes) {
          var recordViewTuples = [];
          changes.forEachRemovedItem((function(removedRecord) {
            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
          }));
          changes.forEachMovedItem((function(movedRecord) {
            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
          }));
          var insertTuples = NgFor.bulkRemove(recordViewTuples, this.viewContainer);
          changes.forEachAddedItem((function(addedRecord) {
            return insertTuples.push(new RecordViewTuple(addedRecord, null));
          }));
          NgFor.bulkInsert(insertTuples, this.viewContainer, this.templateRef);
          for (var i = 0; i < insertTuples.length; i++) {
            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
          }
        },
        _perViewChange: function(view, record) {
          view.setLocal('\$implicit', record.item);
          view.setLocal('index', record.currentIndex);
        }
      }, {
        bulkRemove: function(tuples, viewContainer) {
          tuples.sort((function(a, b) {
            return a.record.previousIndex - b.record.previousIndex;
          }));
          var movedTuples = [];
          for (var i = tuples.length - 1; i >= 0; i--) {
            var tuple = tuples[i];
            if (isPresent(tuple.record.currentIndex)) {
              tuple.view = viewContainer.detach(tuple.record.previousIndex);
              movedTuples.push(tuple);
            } else {
              viewContainer.remove(tuple.record.previousIndex);
            }
          }
          return movedTuples;
        },
        bulkInsert: function(tuples, viewContainer, templateRef) {
          tuples.sort((function(a, b) {
            return a.record.currentIndex - b.record.currentIndex;
          }));
          for (var i = 0; i < tuples.length; i++) {
            var tuple = tuples[i];
            if (isPresent(tuple.view)) {
              viewContainer.insert(tuple.view, tuple.record.currentIndex);
            } else {
              tuple.view = viewContainer.createEmbeddedView(templateRef, tuple.record.currentIndex);
            }
          }
          return tuples;
        }
      }));
      $__export("NgFor", NgFor);
      $__export("NgFor", NgFor = __decorate([Directive({
        selector: '[ng-for][ng-for-of]',
        properties: ['ngForOf'],
        lifecycle: [LifecycleEvent.onCheck]
      }), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef, IterableDiffers, ChangeDetectorRef])], NgFor));
      RecordViewTuple = (function() {
        function RecordViewTuple(record, view) {
          this.record = record;
          this.view = view;
        }
        return ($traceurRuntime.createClass)(RecordViewTuple, {}, {});
      }());
      $__export("RecordViewTuple", RecordViewTuple);
    }
  };
});

System.register("angular2/src/directives/ng_if", ["angular2/metadata", "angular2/core", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_if";
  var __decorate,
      __metadata,
      Directive,
      ViewContainerRef,
      TemplateRef,
      isBlank,
      NgIf;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgIf = (($traceurRuntime.createClass)(function(_viewContainer, _templateRef) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._prevCondition = null;
      }, {set ngIf(newCondition) {
          if (newCondition && (isBlank(this._prevCondition) || !this._prevCondition)) {
            this._prevCondition = true;
            this._viewContainer.createEmbeddedView(this._templateRef);
          } else if (!newCondition && (isBlank(this._prevCondition) || this._prevCondition)) {
            this._prevCondition = false;
            this._viewContainer.clear();
          }
        }}, {}));
      $__export("NgIf", NgIf);
      $__export("NgIf", NgIf = __decorate([Directive({
        selector: '[ng-if]',
        properties: ['ngIf']
      }), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef])], NgIf));
    }
  };
});

System.register("angular2/src/directives/ng_non_bindable", ["angular2/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_non_bindable";
  var __decorate,
      __metadata,
      Directive,
      NgNonBindable;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgNonBindable = (($traceurRuntime.createClass)(function() {}, {}, {}));
      $__export("NgNonBindable", NgNonBindable);
      $__export("NgNonBindable", NgNonBindable = __decorate([Directive({
        selector: '[ng-non-bindable]',
        compileChildren: false
      }), __metadata('design:paramtypes', [])], NgNonBindable));
    }
  };
});

System.register("angular2/src/directives/ng_switch", ["angular2/metadata", "angular2/di", "angular2/core", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_switch";
  var __decorate,
      __metadata,
      __param,
      Directive,
      Host,
      ViewContainerRef,
      TemplateRef,
      isPresent,
      isBlank,
      normalizeBlank,
      CONST_EXPR,
      ListWrapper,
      Map,
      _WHEN_DEFAULT,
      SwitchView,
      NgSwitch,
      NgSwitchWhen,
      NgSwitchDefault;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      Host = $__m.Host;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      normalizeBlank = $__m.normalizeBlank;
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      _WHEN_DEFAULT = CONST_EXPR(new Object());
      SwitchView = (function() {
        function SwitchView(_viewContainerRef, _templateRef) {
          this._viewContainerRef = _viewContainerRef;
          this._templateRef = _templateRef;
        }
        return ($traceurRuntime.createClass)(SwitchView, {
          create: function() {
            this._viewContainerRef.createEmbeddedView(this._templateRef);
          },
          destroy: function() {
            this._viewContainerRef.clear();
          }
        }, {});
      }());
      $__export("SwitchView", SwitchView);
      NgSwitch = (($traceurRuntime.createClass)(function() {
        this._useDefault = false;
        this._valueViews = new Map();
        this._activeViews = [];
      }, {
        set ngSwitch(value) {
          this._emptyAllActiveViews();
          this._useDefault = false;
          var views = this._valueViews.get(value);
          if (isBlank(views)) {
            this._useDefault = true;
            views = normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));
          }
          this._activateViews(views);
          this._switchValue = value;
        },
        _onWhenValueChanged: function(oldWhen, newWhen, view) {
          this._deregisterView(oldWhen, view);
          this._registerView(newWhen, view);
          if (oldWhen === this._switchValue) {
            view.destroy();
            ListWrapper.remove(this._activeViews, view);
          } else if (newWhen === this._switchValue) {
            if (this._useDefault) {
              this._useDefault = false;
              this._emptyAllActiveViews();
            }
            view.create();
            this._activeViews.push(view);
          }
          if (this._activeViews.length === 0 && !this._useDefault) {
            this._useDefault = true;
            this._activateViews(this._valueViews.get(_WHEN_DEFAULT));
          }
        },
        _emptyAllActiveViews: function() {
          var activeContainers = this._activeViews;
          for (var i = 0; i < activeContainers.length; i++) {
            activeContainers[i].destroy();
          }
          this._activeViews = [];
        },
        _activateViews: function(views) {
          if (isPresent(views)) {
            for (var i = 0; i < views.length; i++) {
              views[i].create();
            }
            this._activeViews = views;
          }
        },
        _registerView: function(value, view) {
          var views = this._valueViews.get(value);
          if (isBlank(views)) {
            views = [];
            this._valueViews.set(value, views);
          }
          views.push(view);
        },
        _deregisterView: function(value, view) {
          if (value === _WHEN_DEFAULT)
            return ;
          var views = this._valueViews.get(value);
          if (views.length == 1) {
            this._valueViews.delete(value);
          } else {
            ListWrapper.remove(views, view);
          }
        }
      }, {}));
      $__export("NgSwitch", NgSwitch);
      $__export("NgSwitch", NgSwitch = __decorate([Directive({
        selector: '[ng-switch]',
        properties: ['ngSwitch']
      }), __metadata('design:paramtypes', [])], NgSwitch));
      NgSwitchWhen = (($traceurRuntime.createClass)(function(viewContainer, templateRef, _switch) {
        this._switch = _switch;
        this._value = _WHEN_DEFAULT;
        this._view = new SwitchView(viewContainer, templateRef);
      }, {set ngSwitchWhen(value) {
          this._switch._onWhenValueChanged(this._value, value, this._view);
          this._value = value;
        }}, {}));
      $__export("NgSwitchWhen", NgSwitchWhen);
      $__export("NgSwitchWhen", NgSwitchWhen = __decorate([Directive({
        selector: '[ng-switch-when]',
        properties: ['ngSwitchWhen']
      }), __param(2, Host()), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef, NgSwitch])], NgSwitchWhen));
      NgSwitchDefault = (($traceurRuntime.createClass)(function(viewContainer, templateRef, sswitch) {
        sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));
      }, {}, {}));
      $__export("NgSwitchDefault", NgSwitchDefault);
      $__export("NgSwitchDefault", NgSwitchDefault = __decorate([Directive({selector: '[ng-switch-default]'}), __param(2, Host()), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef, NgSwitch])], NgSwitchDefault));
    }
  };
});

System.register("angular2/src/directives/ng_style", ["angular2/metadata", "angular2/core", "angular2/change_detection", "angular2/src/facade/lang", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_style";
  var __decorate,
      __metadata,
      Directive,
      LifecycleEvent,
      ElementRef,
      KeyValueDiffers,
      isPresent,
      isBlank,
      Renderer,
      NgStyle;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      KeyValueDiffers = $__m.KeyValueDiffers;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgStyle = (($traceurRuntime.createClass)(function(_differs, _ngEl, _renderer) {
        this._differs = _differs;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
      }, {
        set rawStyle(v) {
          this._rawStyle = v;
          if (isBlank(this._differ) && isPresent(v)) {
            this._differ = this._differs.find(this._rawStyle).create(null);
          }
        },
        onCheck: function() {
          if (isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawStyle);
            if (isPresent(changes)) {
              this._applyChanges(changes);
            }
          }
        },
        _applyChanges: function(changes) {
          var $__0 = this;
          changes.forEachAddedItem((function(record) {
            $__0._setStyle(record.key, record.currentValue);
          }));
          changes.forEachChangedItem((function(record) {
            $__0._setStyle(record.key, record.currentValue);
          }));
          changes.forEachRemovedItem((function(record) {
            $__0._setStyle(record.key, null);
          }));
        },
        _setStyle: function(name, val) {
          this._renderer.setElementStyle(this._ngEl, name, val);
        }
      }, {}));
      $__export("NgStyle", NgStyle);
      $__export("NgStyle", NgStyle = __decorate([Directive({
        selector: '[ng-style]',
        lifecycle: [LifecycleEvent.onCheck],
        properties: ['rawStyle: ng-style']
      }), __metadata('design:paramtypes', [KeyValueDiffers, ElementRef, Renderer])], NgStyle));
    }
  };
});

System.register("angular2/src/forms/validators", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/validators";
  var isBlank,
      isPresent,
      ListWrapper,
      StringMapWrapper,
      Validators;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      Validators = (function() {
        function Validators() {}
        return ($traceurRuntime.createClass)(Validators, {}, {
          required: function(c) {
            return isBlank(c.value) || c.value == "" ? {"required": true} : null;
          },
          nullValidator: function(c) {
            return null;
          },
          compose: function(validators) {
            return function(c) {
              var res = ListWrapper.reduce(validators, (function(res, validator) {
                var errors = validator(c);
                return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
              }), {});
              return StringMapWrapper.isEmpty(res) ? null : res;
            };
          },
          group: function(c) {
            var res = {};
            StringMapWrapper.forEach(c.controls, (function(control, name) {
              if (c.contains(name) && isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
              }
            }));
            return StringMapWrapper.isEmpty(res) ? null : res;
          },
          array: function(c) {
            var res = {};
            ListWrapper.forEach(c.controls, (function(control) {
              if (isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
              }
            }));
            return StringMapWrapper.isEmpty(res) ? null : res;
          },
          _mergeErrors: function(control, res) {
            StringMapWrapper.forEach(control.errors, (function(value, error) {
              if (!StringMapWrapper.contains(res, error)) {
                res[error] = [];
              }
              var current = res[error];
              current.push(control);
            }));
          }
        });
      }());
      $__export("Validators", Validators);
    }
  };
});

System.register("angular2/src/forms/directives/abstract_control_directive", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/abstract_control_directive";
  var AbstractControlDirective;
  return {
    setters: [],
    execute: function() {
      AbstractControlDirective = (function() {
        function AbstractControlDirective() {}
        return ($traceurRuntime.createClass)(AbstractControlDirective, {
          get control() {
            return null;
          },
          get value() {
            return this.control.value;
          },
          get valid() {
            return this.control.valid;
          },
          get errors() {
            return this.control.errors;
          },
          get pristine() {
            return this.control.pristine;
          },
          get dirty() {
            return this.control.dirty;
          },
          get touched() {
            return this.control.touched;
          },
          get untouched() {
            return this.control.untouched;
          }
        }, {});
      }());
      $__export("AbstractControlDirective", AbstractControlDirective);
    }
  };
});

System.register("angular2/src/forms/directives/control_container", ["angular2/src/forms/directives/abstract_control_directive"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/control_container";
  var AbstractControlDirective,
      ControlContainer;
  return {
    setters: [function($__m) {
      AbstractControlDirective = $__m.AbstractControlDirective;
    }],
    execute: function() {
      ControlContainer = (function($__super) {
        function ControlContainer() {
          $traceurRuntime.superConstructor(ControlContainer).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(ControlContainer, {
          get formDirective() {
            return null;
          },
          get path() {
            return null;
          }
        }, {}, $__super);
      }(AbstractControlDirective));
      $__export("ControlContainer", ControlContainer);
    }
  };
});

System.register("angular2/src/forms/directives/ng_control", ["angular2/src/forms/directives/abstract_control_directive"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_control";
  var AbstractControlDirective,
      NgControl;
  return {
    setters: [function($__m) {
      AbstractControlDirective = $__m.AbstractControlDirective;
    }],
    execute: function() {
      NgControl = (function($__super) {
        function NgControl() {
          var $__2;
          for (var args = [],
              $__1 = 0; $__1 < arguments.length; $__1++)
            args[$__1] = arguments[$__1];
          ($__2 = $traceurRuntime.superConstructor(NgControl)).call.apply($__2, $traceurRuntime.spread([this], args));
          this.name = null;
          this.valueAccessor = null;
        }
        return ($traceurRuntime.createClass)(NgControl, {
          get validator() {
            return null;
          },
          get path() {
            return null;
          },
          viewToModelUpdate: function(newValue) {}
        }, {}, $__super);
      }(AbstractControlDirective));
      $__export("NgControl", NgControl);
    }
  };
});

System.register("angular2/src/forms/directives/validators", ["angular2/di", "angular2/src/facade/lang", "angular2/metadata", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/validators";
  var __decorate,
      __metadata,
      forwardRef,
      Binding,
      CONST_EXPR,
      Directive,
      Validators,
      NgValidator,
      requiredValidatorBinding,
      NgRequiredValidator;
  return {
    setters: [function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgValidator = (function() {
        function NgValidator() {}
        return ($traceurRuntime.createClass)(NgValidator, {get validator() {
            throw "Is not implemented";
          }}, {});
      }());
      $__export("NgValidator", NgValidator);
      requiredValidatorBinding = CONST_EXPR(new Binding(NgValidator, {toAlias: forwardRef((function() {
          return NgRequiredValidator;
        }))}));
      NgRequiredValidator = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {get validator() {
            return Validators.required;
          }}, {}, $__super);
      }(NgValidator));
      $__export("NgRequiredValidator", NgRequiredValidator);
      $__export("NgRequiredValidator", NgRequiredValidator = __decorate([Directive({
        selector: '[required][ng-control],[required][ng-form-control],[required][ng-model]',
        bindings: [requiredValidatorBinding]
      }), __metadata('design:paramtypes', [])], NgRequiredValidator));
    }
  };
});

System.register("angular2/src/forms/directives/shared", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/shared";
  var ListWrapper,
      StringMapWrapper,
      isBlank,
      BaseException,
      looseIdentical,
      Validators;
  function controlPath(name, parent) {
    var p = ListWrapper.clone(parent.path);
    p.push(name);
    return p;
  }
  function setUpControl(c, dir) {
    if (isBlank(c))
      _throwError(dir, "Cannot find control");
    if (isBlank(dir.valueAccessor))
      _throwError(dir, "No value accessor for");
    c.validator = Validators.compose([c.validator, dir.validator]);
    dir.valueAccessor.writeValue(c.value);
    dir.valueAccessor.registerOnChange((function(newValue) {
      dir.viewToModelUpdate(newValue);
      c.updateValue(newValue, {emitModelToViewChange: false});
      c.markAsDirty();
    }));
    c.registerOnChange((function(newValue) {
      return dir.valueAccessor.writeValue(newValue);
    }));
    dir.valueAccessor.registerOnTouched((function() {
      return c.markAsTouched();
    }));
  }
  function composeNgValidator(ngValidators) {
    if (isBlank(ngValidators))
      return Validators.nullValidator;
    return Validators.compose(ngValidators.map((function(v) {
      return v.validator;
    })));
  }
  function _throwError(dir, message) {
    var path = ListWrapper.join(dir.path, " -> ");
    throw new BaseException((message + " '" + path + "'"));
  }
  function setProperty(renderer, elementRef, propName, propValue) {
    renderer.setElementProperty(elementRef, propName, propValue);
  }
  function isPropertyUpdated(changes, viewModel) {
    if (!StringMapWrapper.contains(changes, "model"))
      return false;
    var change = changes["model"];
    if (change.isFirstChange())
      return true;
    return !looseIdentical(viewModel, change.currentValue);
  }
  $__export("controlPath", controlPath);
  $__export("setUpControl", setUpControl);
  $__export("composeNgValidator", composeNgValidator);
  $__export("setProperty", setProperty);
  $__export("isPropertyUpdated", isPropertyUpdated);
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      looseIdentical = $__m.looseIdentical;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/forms/directives/ng_form_control", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/core", "angular2/metadata", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_form_control";
  var __decorate,
      __metadata,
      __param,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      QueryList,
      Query,
      Directive,
      LifecycleEvent,
      forwardRef,
      Binding,
      NgControl,
      NgValidator,
      setUpControl,
      composeNgValidator,
      isPropertyUpdated,
      formControlBinding,
      NgFormControl;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      NgValidator = $__m.NgValidator;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
      composeNgValidator = $__m.composeNgValidator;
      isPropertyUpdated = $__m.isPropertyUpdated;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      formControlBinding = CONST_EXPR(new Binding(NgControl, {toAlias: forwardRef((function() {
          return NgFormControl;
        }))}));
      NgFormControl = (function($__super) {
        function $__0(ngValidators) {
          $traceurRuntime.superConstructor($__0).call(this);
          this.update = new EventEmitter();
          this._added = false;
          this.ngValidators = ngValidators;
        }
        return ($traceurRuntime.createClass)($__0, {
          onChange: function(c) {
            if (!this._added) {
              setUpControl(this.form, this);
              this.form.updateValidity();
              this._added = true;
            }
            if (isPropertyUpdated(c, this.viewModel)) {
              this.form.updateValue(this.model);
            }
          },
          get path() {
            return [];
          },
          get control() {
            return this.form;
          },
          get validator() {
            return composeNgValidator(this.ngValidators);
          },
          viewToModelUpdate: function(newValue) {
            this.viewModel = newValue;
            ObservableWrapper.callNext(this.update, newValue);
          }
        }, {}, $__super);
      }(NgControl));
      $__export("NgFormControl", NgFormControl);
      $__export("NgFormControl", NgFormControl = __decorate([Directive({
        selector: '[ng-form-control]',
        bindings: [formControlBinding],
        properties: ['form: ngFormControl', 'model: ngModel'],
        events: ['update: ngModel'],
        lifecycle: [LifecycleEvent.onChange],
        exportAs: 'form'
      }), __param(0, Query(NgValidator)), __metadata('design:paramtypes', [QueryList])], NgFormControl));
    }
  };
});

System.register("angular2/src/forms/directives/ng_model", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/core", "angular2/metadata", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/forms/model", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_model";
  var __decorate,
      __metadata,
      __param,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      QueryList,
      Query,
      Directive,
      LifecycleEvent,
      forwardRef,
      Binding,
      NgControl,
      Control,
      NgValidator,
      setUpControl,
      composeNgValidator,
      isPropertyUpdated,
      formControlBinding,
      NgModel;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      Control = $__m.Control;
    }, function($__m) {
      NgValidator = $__m.NgValidator;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
      composeNgValidator = $__m.composeNgValidator;
      isPropertyUpdated = $__m.isPropertyUpdated;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      formControlBinding = CONST_EXPR(new Binding(NgControl, {toAlias: forwardRef((function() {
          return NgModel;
        }))}));
      NgModel = (function($__super) {
        function $__0(ngValidators) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._control = new Control();
          this._added = false;
          this.update = new EventEmitter();
          this.ngValidators = ngValidators;
        }
        return ($traceurRuntime.createClass)($__0, {
          onChange: function(c) {
            if (!this._added) {
              setUpControl(this._control, this);
              this._control.updateValidity();
              this._added = true;
            }
            if (isPropertyUpdated(c, this.viewModel)) {
              this._control.updateValue(this.model);
            }
          },
          get control() {
            return this._control;
          },
          get path() {
            return [];
          },
          get validator() {
            return composeNgValidator(this.ngValidators);
          },
          viewToModelUpdate: function(newValue) {
            this.viewModel = newValue;
            ObservableWrapper.callNext(this.update, newValue);
          }
        }, {}, $__super);
      }(NgControl));
      $__export("NgModel", NgModel);
      $__export("NgModel", NgModel = __decorate([Directive({
        selector: '[ng-model]:not([ng-control]):not([ng-form-control])',
        bindings: [formControlBinding],
        properties: ['model: ngModel'],
        events: ['update: ngModel'],
        lifecycle: [LifecycleEvent.onChange],
        exportAs: 'form'
      }), __param(0, Query(NgValidator)), __metadata('design:paramtypes', [QueryList])], NgModel));
    }
  };
});

System.register("angular2/src/forms/directives/ng_control_group", ["angular2/metadata", "angular2/di", "angular2/src/facade/lang", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_control_group";
  var __decorate,
      __metadata,
      __param,
      Directive,
      LifecycleEvent,
      Host,
      SkipSelf,
      forwardRef,
      Binding,
      CONST_EXPR,
      ControlContainer,
      controlPath,
      controlGroupBinding,
      NgControlGroup;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      Host = $__m.Host;
      SkipSelf = $__m.SkipSelf;
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      controlPath = $__m.controlPath;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      controlGroupBinding = CONST_EXPR(new Binding(ControlContainer, {toAlias: forwardRef((function() {
          return NgControlGroup;
        }))}));
      NgControlGroup = (function($__super) {
        function $__0(_parent) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._parent = _parent;
        }
        return ($traceurRuntime.createClass)($__0, {
          onInit: function() {
            this.formDirective.addControlGroup(this);
          },
          onDestroy: function() {
            this.formDirective.removeControlGroup(this);
          },
          get control() {
            return this.formDirective.getControlGroup(this);
          },
          get path() {
            return controlPath(this.name, this._parent);
          },
          get formDirective() {
            return this._parent.formDirective;
          }
        }, {}, $__super);
      }(ControlContainer));
      $__export("NgControlGroup", NgControlGroup);
      $__export("NgControlGroup", NgControlGroup = __decorate([Directive({
        selector: '[ng-control-group]',
        bindings: [controlGroupBinding],
        properties: ['name: ng-control-group'],
        lifecycle: [LifecycleEvent.onInit, LifecycleEvent.onDestroy],
        exportAs: 'form'
      }), __param(0, Host()), __param(0, SkipSelf()), __metadata('design:paramtypes', [ControlContainer])], NgControlGroup));
    }
  };
});

System.register("angular2/src/forms/directives/ng_form_model", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/metadata", "angular2/di", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_form_model";
  var __decorate,
      __metadata,
      CONST_EXPR,
      ListWrapper,
      ObservableWrapper,
      EventEmitter,
      Directive,
      LifecycleEvent,
      forwardRef,
      Binding,
      ControlContainer,
      setUpControl,
      formDirectiveBinding,
      NgFormModel;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
      EventEmitter = $__m.EventEmitter;
    }, function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      formDirectiveBinding = CONST_EXPR(new Binding(ControlContainer, {toAlias: forwardRef((function() {
          return NgFormModel;
        }))}));
      NgFormModel = (function($__super) {
        function $__1() {
          var $__4;
          for (var args = [],
              $__3 = 0; $__3 < arguments.length; $__3++)
            args[$__3] = arguments[$__3];
          ($__4 = $traceurRuntime.superConstructor($__1)).call.apply($__4, $traceurRuntime.spread([this], args));
          this.form = null;
          this.directives = [];
          this.ngSubmit = new EventEmitter();
        }
        return ($traceurRuntime.createClass)($__1, {
          onChange: function(_) {
            this._updateDomValue();
          },
          get formDirective() {
            return this;
          },
          get control() {
            return this.form;
          },
          get path() {
            return [];
          },
          addControl: function(dir) {
            var c = this.form.find(dir.path);
            setUpControl(c, dir);
            c.updateValidity();
            this.directives.push(dir);
          },
          getControl: function(dir) {
            return this.form.find(dir.path);
          },
          removeControl: function(dir) {
            ListWrapper.remove(this.directives, dir);
          },
          addControlGroup: function(dir) {},
          removeControlGroup: function(dir) {},
          getControlGroup: function(dir) {
            return this.form.find(dir.path);
          },
          updateModel: function(dir, value) {
            var c = this.form.find(dir.path);
            c.updateValue(value);
          },
          onSubmit: function() {
            ObservableWrapper.callNext(this.ngSubmit, null);
            return false;
          },
          _updateDomValue: function() {
            var $__0 = this;
            ListWrapper.forEach(this.directives, (function(dir) {
              var c = $__0.form.find(dir.path);
              dir.valueAccessor.writeValue(c.value);
            }));
          }
        }, {}, $__super);
      }(ControlContainer));
      $__export("NgFormModel", NgFormModel);
      $__export("NgFormModel", NgFormModel = __decorate([Directive({
        selector: '[ng-form-model]',
        bindings: [formDirectiveBinding],
        properties: ['form: ng-form-model'],
        lifecycle: [LifecycleEvent.onChange],
        host: {'(submit)': 'onSubmit()'},
        events: ['ngSubmit'],
        exportAs: 'form'
      }), __metadata('design:paramtypes', [])], NgFormModel));
    }
  };
});

System.register("angular2/src/forms/directives/ng_form", ["angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/metadata", "angular2/di", "angular2/src/forms/directives/control_container", "angular2/src/forms/model", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_form";
  var __decorate,
      __metadata,
      PromiseWrapper,
      ObservableWrapper,
      EventEmitter,
      ListWrapper,
      isPresent,
      CONST_EXPR,
      Directive,
      forwardRef,
      Binding,
      ControlContainer,
      ControlGroup,
      Control,
      setUpControl,
      formDirectiveBinding,
      NgForm;
  return {
    setters: [function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
      ObservableWrapper = $__m.ObservableWrapper;
      EventEmitter = $__m.EventEmitter;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      ControlGroup = $__m.ControlGroup;
      Control = $__m.Control;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      formDirectiveBinding = CONST_EXPR(new Binding(ControlContainer, {toAlias: forwardRef((function() {
          return NgForm;
        }))}));
      NgForm = (function($__super) {
        function $__1() {
          $traceurRuntime.superConstructor($__1).call(this);
          this.ngSubmit = new EventEmitter();
          this.form = new ControlGroup({});
        }
        return ($traceurRuntime.createClass)($__1, {
          get formDirective() {
            return this;
          },
          get control() {
            return this.form;
          },
          get path() {
            return [];
          },
          get controls() {
            return this.form.controls;
          },
          addControl: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              var c = new Control();
              setUpControl(c, dir);
              container.addControl(dir.name, c);
              c.updateValidity();
            }));
          },
          getControl: function(dir) {
            return this.form.find(dir.path);
          },
          removeControl: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              if (isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
              }
            }));
          },
          addControlGroup: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              var c = new ControlGroup({});
              container.addControl(dir.name, c);
              c.updateValidity();
            }));
          },
          removeControlGroup: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              if (isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
              }
            }));
          },
          getControlGroup: function(dir) {
            return this.form.find(dir.path);
          },
          updateModel: function(dir, value) {
            var $__0 = this;
            this._later((function(_) {
              var c = $__0.form.find(dir.path);
              c.updateValue(value);
            }));
          },
          onSubmit: function() {
            ObservableWrapper.callNext(this.ngSubmit, null);
            return false;
          },
          _findContainer: function(path) {
            ListWrapper.removeLast(path);
            return ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
          },
          _later: function(fn) {
            var c = PromiseWrapper.completer();
            PromiseWrapper.then(c.promise, fn, (function(_) {}));
            c.resolve(null);
          }
        }, {}, $__super);
      }(ControlContainer));
      $__export("NgForm", NgForm);
      $__export("NgForm", NgForm = __decorate([Directive({
        selector: 'form:not([ng-no-form]):not([ng-form-model]),ng-form,[ng-form]',
        bindings: [formDirectiveBinding],
        host: {'(submit)': 'onSubmit()'},
        events: ['ngSubmit'],
        exportAs: 'form'
      }), __metadata('design:paramtypes', [])], NgForm));
    }
  };
});

System.register("angular2/render", ["angular2/src/render/render"], function($__export) {
  "use strict";
  var __moduleName = "angular2/render";
  return {
    setters: [function($__m) {
      $__export("RenderDirectiveMetadata", $__m.RenderDirectiveMetadata);
      $__export("DomRenderer", $__m.DomRenderer);
      $__export("Renderer", $__m.Renderer);
      $__export("RenderViewRef", $__m.RenderViewRef);
      $__export("RenderProtoViewRef", $__m.RenderProtoViewRef);
      $__export("RenderFragmentRef", $__m.RenderFragmentRef);
      $__export("RenderViewWithFragments", $__m.RenderViewWithFragments);
      $__export("ViewDefinition", $__m.ViewDefinition);
      $__export("DOCUMENT", $__m.DOCUMENT);
      $__export("APP_ID", $__m.APP_ID);
      $__export("MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE", $__m.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/forms/directives/checkbox_value_accessor", ["angular2/render", "angular2/metadata", "angular2/core", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/facade/lang", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/checkbox_value_accessor";
  var __decorate,
      __metadata,
      __param,
      Renderer,
      Directive,
      ElementRef,
      Self,
      NgControl,
      isPresent,
      setProperty,
      CheckboxControlValueAccessor;
  return {
    setters: [function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Self = $__m.Self;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      setProperty = $__m.setProperty;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      CheckboxControlValueAccessor = (($traceurRuntime.createClass)(function(cd, renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.onChange = (function(_) {});
        this.onTouched = (function() {});
        this.cd = cd;
        cd.valueAccessor = this;
      }, {
        writeValue: function(value) {
          setProperty(this.renderer, this.elementRef, "checked", value);
        },
        get ngClassUntouched() {
          return isPresent(this.cd.control) ? this.cd.control.untouched : false;
        },
        get ngClassTouched() {
          return isPresent(this.cd.control) ? this.cd.control.touched : false;
        },
        get ngClassPristine() {
          return isPresent(this.cd.control) ? this.cd.control.pristine : false;
        },
        get ngClassDirty() {
          return isPresent(this.cd.control) ? this.cd.control.dirty : false;
        },
        get ngClassValid() {
          return isPresent(this.cd.control) ? this.cd.control.valid : false;
        },
        get ngClassInvalid() {
          return isPresent(this.cd.control) ? !this.cd.control.valid : false;
        },
        registerOnChange: function(fn) {
          this.onChange = fn;
        },
        registerOnTouched: function(fn) {
          this.onTouched = fn;
        }
      }, {}));
      $__export("CheckboxControlValueAccessor", CheckboxControlValueAccessor);
      $__export("CheckboxControlValueAccessor", CheckboxControlValueAccessor = __decorate([Directive({
        selector: 'input[type=checkbox][ng-control],input[type=checkbox][ng-form-control],input[type=checkbox][ng-model]',
        host: {
          '(change)': 'onChange($event.target.checked)',
          '(blur)': 'onTouched()',
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }), __param(0, Self()), __metadata('design:paramtypes', [NgControl, Renderer, ElementRef])], CheckboxControlValueAccessor));
    }
  };
});

System.register("angular2/src/forms/directives/select_control_value_accessor", ["angular2/render", "angular2/core", "angular2/di", "angular2/metadata", "angular2/src/forms/directives/ng_control", "angular2/src/facade/lang", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/select_control_value_accessor";
  var __decorate,
      __metadata,
      __param,
      Renderer,
      ElementRef,
      QueryList,
      Self,
      Query,
      Directive,
      NgControl,
      isPresent,
      setProperty,
      NgSelectOption,
      SelectControlValueAccessor;
  return {
    setters: [function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
      QueryList = $__m.QueryList;
    }, function($__m) {
      Self = $__m.Self;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      setProperty = $__m.setProperty;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      NgSelectOption = (($traceurRuntime.createClass)(function() {}, {}, {}));
      $__export("NgSelectOption", NgSelectOption);
      $__export("NgSelectOption", NgSelectOption = __decorate([Directive({selector: 'option'}), __metadata('design:paramtypes', [])], NgSelectOption));
      SelectControlValueAccessor = (($traceurRuntime.createClass)(function(cd, renderer, elementRef, query) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.onChange = (function(_) {});
        this.onTouched = (function() {});
        this.cd = cd;
        cd.valueAccessor = this;
        this._updateValueWhenListOfOptionsChanges(query);
      }, {
        writeValue: function(value) {
          this.value = value;
          setProperty(this.renderer, this.elementRef, "value", value);
        },
        get ngClassUntouched() {
          return isPresent(this.cd.control) ? this.cd.control.untouched : false;
        },
        get ngClassTouched() {
          return isPresent(this.cd.control) ? this.cd.control.touched : false;
        },
        get ngClassPristine() {
          return isPresent(this.cd.control) ? this.cd.control.pristine : false;
        },
        get ngClassDirty() {
          return isPresent(this.cd.control) ? this.cd.control.dirty : false;
        },
        get ngClassValid() {
          return isPresent(this.cd.control) ? this.cd.control.valid : false;
        },
        get ngClassInvalid() {
          return isPresent(this.cd.control) ? !this.cd.control.valid : false;
        },
        registerOnChange: function(fn) {
          this.onChange = fn;
        },
        registerOnTouched: function(fn) {
          this.onTouched = fn;
        },
        _updateValueWhenListOfOptionsChanges: function(query) {
          var $__0 = this;
          query.onChange((function() {
            return $__0.writeValue($__0.value);
          }));
        }
      }, {}));
      $__export("SelectControlValueAccessor", SelectControlValueAccessor);
      $__export("SelectControlValueAccessor", SelectControlValueAccessor = __decorate([Directive({
        selector: 'select[ng-control],select[ng-form-control],select[ng-model]',
        host: {
          '(change)': 'onChange($event.target.value)',
          '(input)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()',
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }), __param(0, Self()), __param(3, Query(NgSelectOption, {descendants: true})), __metadata('design:paramtypes', [NgControl, Renderer, ElementRef, QueryList])], SelectControlValueAccessor));
    }
  };
});

System.register("angular2/src/forms/directives", ["angular2/src/facade/lang", "angular2/src/forms/directives/ng_control_name", "angular2/src/forms/directives/ng_form_control", "angular2/src/forms/directives/ng_model", "angular2/src/forms/directives/ng_control_group", "angular2/src/forms/directives/ng_form_model", "angular2/src/forms/directives/ng_form", "angular2/src/forms/directives/default_value_accessor", "angular2/src/forms/directives/checkbox_value_accessor", "angular2/src/forms/directives/select_control_value_accessor", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/ng_control"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives";
  var CONST_EXPR,
      NgControlName,
      NgFormControl,
      NgModel,
      NgControlGroup,
      NgFormModel,
      NgForm,
      DefaultValueAccessor,
      CheckboxControlValueAccessor,
      SelectControlValueAccessor,
      NgSelectOption,
      NgRequiredValidator,
      FORM_DIRECTIVES;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      NgControlName = $__m.NgControlName;
      $__export("NgControlName", $__m.NgControlName);
    }, function($__m) {
      NgFormControl = $__m.NgFormControl;
      $__export("NgFormControl", $__m.NgFormControl);
    }, function($__m) {
      NgModel = $__m.NgModel;
      $__export("NgModel", $__m.NgModel);
    }, function($__m) {
      NgControlGroup = $__m.NgControlGroup;
      $__export("NgControlGroup", $__m.NgControlGroup);
    }, function($__m) {
      NgFormModel = $__m.NgFormModel;
      $__export("NgFormModel", $__m.NgFormModel);
    }, function($__m) {
      NgForm = $__m.NgForm;
      $__export("NgForm", $__m.NgForm);
    }, function($__m) {
      DefaultValueAccessor = $__m.DefaultValueAccessor;
      $__export("DefaultValueAccessor", $__m.DefaultValueAccessor);
    }, function($__m) {
      CheckboxControlValueAccessor = $__m.CheckboxControlValueAccessor;
      $__export("CheckboxControlValueAccessor", $__m.CheckboxControlValueAccessor);
    }, function($__m) {
      SelectControlValueAccessor = $__m.SelectControlValueAccessor;
      NgSelectOption = $__m.NgSelectOption;
      $__export("SelectControlValueAccessor", $__m.SelectControlValueAccessor);
      $__export("NgSelectOption", $__m.NgSelectOption);
    }, function($__m) {
      NgRequiredValidator = $__m.NgRequiredValidator;
      $__export("NgValidator", $__m.NgValidator);
      $__export("NgRequiredValidator", $__m.NgRequiredValidator);
    }, function($__m) {
      $__export("NgControl", $__m.NgControl);
    }],
    execute: function() {
      FORM_DIRECTIVES = CONST_EXPR([NgControlName, NgControlGroup, NgFormControl, NgModel, NgFormModel, NgForm, NgSelectOption, DefaultValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, NgRequiredValidator]);
      $__export("FORM_DIRECTIVES", FORM_DIRECTIVES);
    }
  };
});

System.register("angular2/src/forms/form_builder", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/forms/model"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/form_builder";
  var __decorate,
      __metadata,
      Injectable,
      StringMapWrapper,
      ListWrapper,
      isPresent,
      isArray,
      modelModule,
      FormBuilder;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isArray = $__m.isArray;
    }, function($__m) {
      modelModule = $__m;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      FormBuilder = (($traceurRuntime.createClass)(function() {}, {
        group: function(controlsConfig) {
          var extra = arguments[1] !== (void 0) ? arguments[1] : null;
          var controls = this._reduceControls(controlsConfig);
          var optionals = isPresent(extra) ? StringMapWrapper.get(extra, "optionals") : null;
          var validator = isPresent(extra) ? StringMapWrapper.get(extra, "validator") : null;
          if (isPresent(validator)) {
            return new modelModule.ControlGroup(controls, optionals, validator);
          } else {
            return new modelModule.ControlGroup(controls, optionals);
          }
        },
        control: function(value) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : null;
          if (isPresent(validator)) {
            return new modelModule.Control(value, validator);
          } else {
            return new modelModule.Control(value);
          }
        },
        array: function(controlsConfig) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : null;
          var $__0 = this;
          var controls = ListWrapper.map(controlsConfig, (function(c) {
            return $__0._createControl(c);
          }));
          if (isPresent(validator)) {
            return new modelModule.ControlArray(controls, validator);
          } else {
            return new modelModule.ControlArray(controls);
          }
        },
        _reduceControls: function(controlsConfig) {
          var $__0 = this;
          var controls = {};
          StringMapWrapper.forEach(controlsConfig, (function(controlConfig, controlName) {
            controls[controlName] = $__0._createControl(controlConfig);
          }));
          return controls;
        },
        _createControl: function(controlConfig) {
          if (controlConfig instanceof modelModule.Control || controlConfig instanceof modelModule.ControlGroup || controlConfig instanceof modelModule.ControlArray) {
            return controlConfig;
          } else if (isArray(controlConfig)) {
            var value = ListWrapper.get(controlConfig, 0);
            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
            return this.control(value, validator);
          } else {
            return this.control(controlConfig);
          }
        }
      }, {}));
      $__export("FormBuilder", FormBuilder);
      $__export("FormBuilder", FormBuilder = __decorate([Injectable(), __metadata('design:paramtypes', [])], FormBuilder));
    }
  };
});

System.register("angular2/profile", ["angular2/src/profile/profile"], function($__export) {
  "use strict";
  var __moduleName = "angular2/profile";
  return {
    setters: [function($__m) {
      $__export("wtfCreateScope", $__m.wtfCreateScope);
      $__export("wtfLeave", $__m.wtfLeave);
      $__export("wtfStartTimeRange", $__m.wtfStartTimeRange);
      $__export("wtfEndTimeRange", $__m.wtfEndTimeRange);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/di/decorators", ["angular2/src/di/metadata", "angular2/src/util/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/decorators";
  var InjectMetadata,
      OptionalMetadata,
      InjectableMetadata,
      SelfMetadata,
      HostMetadata,
      SkipSelfMetadata,
      makeDecorator,
      makeParamDecorator,
      Inject,
      Optional,
      Injectable,
      Self,
      Host,
      SkipSelf;
  return {
    setters: [function($__m) {
      InjectMetadata = $__m.InjectMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      InjectableMetadata = $__m.InjectableMetadata;
      SelfMetadata = $__m.SelfMetadata;
      HostMetadata = $__m.HostMetadata;
      SkipSelfMetadata = $__m.SkipSelfMetadata;
    }, function($__m) {
      makeDecorator = $__m.makeDecorator;
      makeParamDecorator = $__m.makeParamDecorator;
    }],
    execute: function() {
      Inject = makeParamDecorator(InjectMetadata);
      $__export("Inject", Inject);
      Optional = makeParamDecorator(OptionalMetadata);
      $__export("Optional", Optional);
      Injectable = makeDecorator(InjectableMetadata);
      $__export("Injectable", Injectable);
      Self = makeParamDecorator(SelfMetadata);
      $__export("Self", Self);
      Host = makeParamDecorator(HostMetadata);
      $__export("Host", Host);
      SkipSelf = makeParamDecorator(SkipSelfMetadata);
      $__export("SkipSelf", SkipSelf);
    }
  };
});

System.register("angular2/src/reflection/reflection", ["angular2/src/reflection/reflector", "angular2/src/reflection/reflection_capabilities"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflection";
  var Reflector,
      ReflectionCapabilities,
      reflector;
  return {
    setters: [function($__m) {
      Reflector = $__m.Reflector;
      $__export("Reflector", $__m.Reflector);
      $__export("ReflectionInfo", $__m.ReflectionInfo);
    }, function($__m) {
      ReflectionCapabilities = $__m.ReflectionCapabilities;
    }],
    execute: function() {
      reflector = new Reflector(new ReflectionCapabilities());
      $__export("reflector", reflector);
    }
  };
});

System.register("angular2/src/di/key", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/di/type_literal", "angular2/src/di/forward_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/key";
  var MapWrapper,
      stringify,
      isBlank,
      BaseException,
      TypeLiteral,
      resolveForwardRef,
      Key,
      KeyRegistry,
      _globalKeyRegistry;
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      TypeLiteral = $__m.TypeLiteral;
      $__export("TypeLiteral", $__m.TypeLiteral);
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }],
    execute: function() {
      Key = (function() {
        function Key(token, id) {
          this.token = token;
          this.id = id;
          if (isBlank(token)) {
            throw new BaseException('Token must be defined!');
          }
        }
        return ($traceurRuntime.createClass)(Key, {get displayName() {
            return stringify(this.token);
          }}, {
          get: function(token) {
            return _globalKeyRegistry.get(resolveForwardRef(token));
          },
          get numberOfKeys() {
            return _globalKeyRegistry.numberOfKeys;
          }
        });
      }());
      $__export("Key", Key);
      KeyRegistry = (function() {
        function KeyRegistry() {
          this._allKeys = new Map();
        }
        return ($traceurRuntime.createClass)(KeyRegistry, {
          get: function(token) {
            if (token instanceof Key)
              return token;
            var theToken = token;
            if (token instanceof TypeLiteral) {
              theToken = token.type;
            }
            token = theToken;
            if (this._allKeys.has(token)) {
              return this._allKeys.get(token);
            }
            var newKey = new Key(token, Key.numberOfKeys);
            this._allKeys.set(token, newKey);
            return newKey;
          },
          get numberOfKeys() {
            return MapWrapper.size(this._allKeys);
          }
        }, {});
      }());
      $__export("KeyRegistry", KeyRegistry);
      _globalKeyRegistry = new KeyRegistry();
    }
  };
});

System.register("angular2/src/change_detection/change_detection_util", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/constants", "angular2/src/change_detection/pipe_lifecycle_reflector", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection_util";
  var CONST_EXPR,
      isPresent,
      isBlank,
      BaseException,
      StringMapWrapper,
      CHECK_ALWAYS,
      CHECK_ONCE,
      isDefaultChangeDetectionStrategy,
      implementsOnDestroy,
      BindingTarget,
      DirectiveIndex,
      WrappedValue,
      _wrappedValues,
      _wrappedIndex,
      SimpleChange,
      _simpleChangesIndex,
      _simpleChanges,
      ChangeDetectionUtil;
  function _simpleChange(previousValue, currentValue) {
    var index = _simpleChangesIndex++ % 20;
    var s = _simpleChanges[index];
    s.previousValue = previousValue;
    s.currentValue = currentValue;
    return s;
  }
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
      CHECK_ONCE = $__m.CHECK_ONCE;
      isDefaultChangeDetectionStrategy = $__m.isDefaultChangeDetectionStrategy;
    }, function($__m) {
      implementsOnDestroy = $__m.implementsOnDestroy;
    }, function($__m) {
      BindingTarget = $__m.BindingTarget;
    }, function($__m) {
      DirectiveIndex = $__m.DirectiveIndex;
    }],
    execute: function() {
      WrappedValue = (function() {
        function WrappedValue(wrapped) {
          this.wrapped = wrapped;
        }
        return ($traceurRuntime.createClass)(WrappedValue, {}, {wrap: function(value) {
            var w = _wrappedValues[_wrappedIndex++ % 5];
            w.wrapped = value;
            return w;
          }});
      }());
      $__export("WrappedValue", WrappedValue);
      _wrappedValues = [new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null)];
      _wrappedIndex = 0;
      SimpleChange = (function() {
        function SimpleChange(previousValue, currentValue) {
          this.previousValue = previousValue;
          this.currentValue = currentValue;
        }
        return ($traceurRuntime.createClass)(SimpleChange, {isFirstChange: function() {
            return this.previousValue === ChangeDetectionUtil.uninitialized;
          }}, {});
      }());
      $__export("SimpleChange", SimpleChange);
      _simpleChangesIndex = 0;
      _simpleChanges = [new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null)];
      ChangeDetectionUtil = (function() {
        function ChangeDetectionUtil() {}
        return ($traceurRuntime.createClass)(ChangeDetectionUtil, {}, {
          arrayFn0: function() {
            return [];
          },
          arrayFn1: function(a1) {
            return [a1];
          },
          arrayFn2: function(a1, a2) {
            return [a1, a2];
          },
          arrayFn3: function(a1, a2, a3) {
            return [a1, a2, a3];
          },
          arrayFn4: function(a1, a2, a3, a4) {
            return [a1, a2, a3, a4];
          },
          arrayFn5: function(a1, a2, a3, a4, a5) {
            return [a1, a2, a3, a4, a5];
          },
          arrayFn6: function(a1, a2, a3, a4, a5, a6) {
            return [a1, a2, a3, a4, a5, a6];
          },
          arrayFn7: function(a1, a2, a3, a4, a5, a6, a7) {
            return [a1, a2, a3, a4, a5, a6, a7];
          },
          arrayFn8: function(a1, a2, a3, a4, a5, a6, a7, a8) {
            return [a1, a2, a3, a4, a5, a6, a7, a8];
          },
          arrayFn9: function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
          },
          operation_negate: function(value) {
            return !value;
          },
          operation_add: function(left, right) {
            return left + right;
          },
          operation_subtract: function(left, right) {
            return left - right;
          },
          operation_multiply: function(left, right) {
            return left * right;
          },
          operation_divide: function(left, right) {
            return left / right;
          },
          operation_remainder: function(left, right) {
            return left % right;
          },
          operation_equals: function(left, right) {
            return left == right;
          },
          operation_not_equals: function(left, right) {
            return left != right;
          },
          operation_identical: function(left, right) {
            return left === right;
          },
          operation_not_identical: function(left, right) {
            return left !== right;
          },
          operation_less_then: function(left, right) {
            return left < right;
          },
          operation_greater_then: function(left, right) {
            return left > right;
          },
          operation_less_or_equals_then: function(left, right) {
            return left <= right;
          },
          operation_greater_or_equals_then: function(left, right) {
            return left >= right;
          },
          operation_logical_and: function(left, right) {
            return left && right;
          },
          operation_logical_or: function(left, right) {
            return left || right;
          },
          cond: function(cond, trueVal, falseVal) {
            return cond ? trueVal : falseVal;
          },
          mapFn: function(keys) {
            function buildMap(values) {
              var res = StringMapWrapper.create();
              for (var i = 0; i < keys.length; ++i) {
                StringMapWrapper.set(res, keys[i], values[i]);
              }
              return res;
            }
            switch (keys.length) {
              case 0:
                return (function() {
                  return [];
                });
              case 1:
                return (function(a1) {
                  return buildMap([a1]);
                });
              case 2:
                return (function(a1, a2) {
                  return buildMap([a1, a2]);
                });
              case 3:
                return (function(a1, a2, a3) {
                  return buildMap([a1, a2, a3]);
                });
              case 4:
                return (function(a1, a2, a3, a4) {
                  return buildMap([a1, a2, a3, a4]);
                });
              case 5:
                return (function(a1, a2, a3, a4, a5) {
                  return buildMap([a1, a2, a3, a4, a5]);
                });
              case 6:
                return (function(a1, a2, a3, a4, a5, a6) {
                  return buildMap([a1, a2, a3, a4, a5, a6]);
                });
              case 7:
                return (function(a1, a2, a3, a4, a5, a6, a7) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7]);
                });
              case 8:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]);
                });
              case 9:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                });
              default:
                throw new BaseException("Does not support literal maps with more than 9 elements");
            }
          },
          keyedAccess: function(obj, args) {
            return obj[args[0]];
          },
          unwrapValue: function(value) {
            if (value instanceof WrappedValue) {
              return value.wrapped;
            } else {
              return value;
            }
          },
          changeDetectionMode: function(strategy) {
            return isDefaultChangeDetectionStrategy(strategy) ? CHECK_ALWAYS : CHECK_ONCE;
          },
          simpleChange: function(previousValue, currentValue) {
            return _simpleChange(previousValue, currentValue);
          },
          isValueBlank: function(value) {
            return isBlank(value);
          },
          s: function(value) {
            return isPresent(value) ? ("" + value) : '';
          },
          protoByIndex: function(protos, selfIndex) {
            return selfIndex < 1 ? null : protos[selfIndex - 1];
          },
          callPipeOnDestroy: function(pipe) {
            if (implementsOnDestroy(pipe)) {
              pipe.onDestroy();
            }
          },
          bindingTarget: function(mode, elementIndex, name, unit, debug) {
            return new BindingTarget(mode, elementIndex, name, unit, debug);
          },
          directiveIndex: function(elementIndex, directiveIndex) {
            return new DirectiveIndex(elementIndex, directiveIndex);
          }
        });
      }());
      $__export("ChangeDetectionUtil", ChangeDetectionUtil);
      ChangeDetectionUtil.uninitialized = CONST_EXPR(new Object());
    }
  };
});

System.register("angular2/src/profile/profile", ["angular2/src/profile/wtf_impl"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/profile/profile";
  var impl,
      wtfEnabled,
      wtfCreateScope,
      wtfLeave,
      wtfStartTimeRange,
      wtfEndTimeRange;
  function noopScope(arg0, arg1) {
    return null;
  }
  return {
    setters: [function($__m) {
      impl = $__m;
    }],
    execute: function() {
      wtfEnabled = impl.detectWTF();
      $__export("wtfEnabled", wtfEnabled);
      wtfCreateScope = wtfEnabled ? impl.createScope : (function(signature, flags) {
        return noopScope;
      });
      $__export("wtfCreateScope", wtfCreateScope);
      wtfLeave = wtfEnabled ? impl.leave : (function(s, r) {
        return r;
      });
      $__export("wtfLeave", wtfLeave);
      wtfStartTimeRange = wtfEnabled ? impl.startTimeRange : (function(rangeType, action) {
        return null;
      });
      $__export("wtfStartTimeRange", wtfStartTimeRange);
      wtfEndTimeRange = wtfEnabled ? impl.endTimeRange : (function(r) {
        return null;
      });
      $__export("wtfEndTimeRange", wtfEndTimeRange);
    }
  };
});

System.register("angular2/src/change_detection/codegen_logic_util", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/codegen_facade", "angular2/src/change_detection/proto_record", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/codegen_logic_util";
  var ListWrapper,
      BaseException,
      StringWrapper,
      isBlank,
      codify,
      combineGeneratedStrings,
      rawString,
      RecordType,
      ON_PUSH_OBSERVE,
      CodegenLogicUtil;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
      isBlank = $__m.isBlank;
    }, function($__m) {
      codify = $__m.codify;
      combineGeneratedStrings = $__m.combineGeneratedStrings;
      rawString = $__m.rawString;
    }, function($__m) {
      RecordType = $__m.RecordType;
    }, function($__m) {
      ON_PUSH_OBSERVE = $__m.ON_PUSH_OBSERVE;
    }],
    execute: function() {
      CodegenLogicUtil = (function() {
        function CodegenLogicUtil(_names, _utilName, _changeDetection) {
          this._names = _names;
          this._utilName = _utilName;
          this._changeDetection = _changeDetection;
        }
        return ($traceurRuntime.createClass)(CodegenLogicUtil, {
          genPropertyBindingEvalValue: function(protoRec) {
            var $__0 = this;
            return this.genEvalValue(protoRec, (function(idx) {
              return $__0._names.getLocalName(idx);
            }), this._names.getLocalsAccessorName());
          },
          genEventBindingEvalValue: function(eventRecord, protoRec) {
            var $__0 = this;
            return this.genEvalValue(protoRec, (function(idx) {
              return $__0._names.getEventLocalName(eventRecord, idx);
            }), "locals");
          },
          genEvalValue: function(protoRec, getLocalName, localsAccessor) {
            var context = (protoRec.contextIndex == -1) ? this._names.getDirectiveName(protoRec.directiveIndex) : getLocalName(protoRec.contextIndex);
            var argString = ListWrapper.map(protoRec.args, (function(arg) {
              return getLocalName(arg);
            })).join(", ");
            var rhs;
            switch (protoRec.mode) {
              case RecordType.SELF:
                rhs = context;
                break;
              case RecordType.CONST:
                rhs = codify(protoRec.funcOrValue);
                break;
              case RecordType.PROPERTY_READ:
                rhs = this._observe((context + "." + protoRec.name), protoRec);
                break;
              case RecordType.SAFE_PROPERTY:
                var read = this._observe((context + "." + protoRec.name), protoRec);
                rhs = (this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(read, protoRec));
                break;
              case RecordType.PROPERTY_WRITE:
                rhs = (context + "." + protoRec.name + " = " + getLocalName(protoRec.args[0]));
                break;
              case RecordType.LOCAL:
                rhs = this._observe((localsAccessor + ".get(" + rawString(protoRec.name) + ")"), protoRec);
                break;
              case RecordType.INVOKE_METHOD:
                rhs = this._observe((context + "." + protoRec.name + "(" + argString + ")"), protoRec);
                break;
              case RecordType.SAFE_INVOKE_METHOD:
                var invoke = (context + "." + protoRec.name + "(" + argString + ")");
                rhs = (this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(invoke, protoRec));
                break;
              case RecordType.INVOKE_CLOSURE:
                rhs = (context + "(" + argString + ")");
                break;
              case RecordType.PRIMITIVE_OP:
                rhs = (this._utilName + "." + protoRec.name + "(" + argString + ")");
                break;
              case RecordType.COLLECTION_LITERAL:
                rhs = (this._utilName + "." + protoRec.name + "(" + argString + ")");
                break;
              case RecordType.INTERPOLATE:
                rhs = this._genInterpolation(protoRec);
                break;
              case RecordType.KEYED_READ:
                rhs = this._observe((context + "[" + getLocalName(protoRec.args[0]) + "]"), protoRec);
                break;
              case RecordType.KEYED_WRITE:
                rhs = (context + "[" + getLocalName(protoRec.args[0]) + "] = " + getLocalName(protoRec.args[1]));
                break;
              case RecordType.CHAIN:
                rhs = 'null';
                break;
              default:
                throw new BaseException(("Unknown operation " + protoRec.mode));
            }
            return (getLocalName(protoRec.selfIndex) + " = " + rhs + ";");
          },
          _observe: function(exp, rec) {
            if (StringWrapper.equals(this._changeDetection, ON_PUSH_OBSERVE)) {
              return ("this.observeValue(" + exp + ", " + rec.selfIndex + ")");
            } else {
              return exp;
            }
          },
          genPropertyBindingTargets: function(propertyBindingTargets, genDebugInfo) {
            var $__0 = this;
            var bs = propertyBindingTargets.map((function(b) {
              if (isBlank(b))
                return "null";
              var debug = genDebugInfo ? codify(b.debug) : "null";
              return ($__0._utilName + ".bindingTarget(" + codify(b.mode) + ", " + b.elementIndex + ", " + codify(b.name) + ", " + codify(b.unit) + ", " + debug + ")");
            }));
            return ("[" + bs.join(", ") + "]");
          },
          genDirectiveIndices: function(directiveRecords) {
            var $__0 = this;
            var bs = directiveRecords.map((function(b) {
              return ($__0._utilName + ".directiveIndex(" + b.directiveIndex.elementIndex + ", " + b.directiveIndex.directiveIndex + ")");
            }));
            return ("[" + bs.join(", ") + "]");
          },
          _genInterpolation: function(protoRec) {
            var iVals = [];
            for (var i = 0; i < protoRec.args.length; ++i) {
              iVals.push(codify(protoRec.fixedArgs[i]));
              iVals.push((this._utilName + ".s(" + this._names.getLocalName(protoRec.args[i]) + ")"));
            }
            iVals.push(codify(protoRec.fixedArgs[protoRec.args.length]));
            return combineGeneratedStrings(iVals);
          },
          genHydrateDirectives: function(directiveRecords) {
            var res = [];
            for (var i = 0; i < directiveRecords.length; ++i) {
              var r = directiveRecords[i];
              res.push((this._names.getDirectiveName(r.directiveIndex) + " = " + this._genReadDirective(i) + ";"));
            }
            return res.join("\n");
          },
          _genReadDirective: function(index) {
            if (StringWrapper.equals(this._changeDetection, ON_PUSH_OBSERVE)) {
              return ("this.observeDirective(this.getDirectiveFor(directives, " + index + "), " + index + ")");
            } else {
              return ("this.getDirectiveFor(directives, " + index + ")");
            }
          },
          genHydrateDetectors: function(directiveRecords) {
            var res = [];
            for (var i = 0; i < directiveRecords.length; ++i) {
              var r = directiveRecords[i];
              if (!r.isDefaultChangeDetection()) {
                res.push((this._names.getDetectorName(r.directiveIndex) + " = this.getDetectorFor(directives, " + i + ");"));
              }
            }
            return res.join("\n");
          }
        }, {});
      }());
      $__export("CodegenLogicUtil", CodegenLogicUtil);
    }
  };
});

System.register("angular2/src/change_detection/proto_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/ast", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/dynamic_change_detector", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/event_binding", "angular2/src/change_detection/coalesce", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/proto_change_detector";
  var BaseException,
      isPresent,
      isString,
      ListWrapper,
      ImplicitReceiver,
      ChangeDetectionUtil,
      DynamicChangeDetector,
      DirectiveIndex,
      EventBinding,
      coalesce,
      ProtoRecord,
      RecordType,
      DynamicProtoChangeDetector,
      ProtoRecordBuilder,
      _ConvertAstIntoProtoRecords;
  function createPropertyRecords(definition) {
    var recordBuilder = new ProtoRecordBuilder();
    ListWrapper.forEachWithIndex(definition.bindingRecords, (function(b, index) {
      return recordBuilder.add(b, definition.variableNames, index);
    }));
    return coalesce(recordBuilder.records);
  }
  function createEventRecords(definition) {
    var varNames = ListWrapper.concat(['$event'], definition.variableNames);
    return definition.eventRecords.map((function(er) {
      var records = _ConvertAstIntoProtoRecords.create(er, varNames);
      var dirIndex = er.implicitReceiver instanceof DirectiveIndex ? er.implicitReceiver : null;
      return new EventBinding(er.target.name, er.target.elementIndex, dirIndex, records);
    }));
  }
  function _arrayFn(length) {
    switch (length) {
      case 0:
        return ChangeDetectionUtil.arrayFn0;
      case 1:
        return ChangeDetectionUtil.arrayFn1;
      case 2:
        return ChangeDetectionUtil.arrayFn2;
      case 3:
        return ChangeDetectionUtil.arrayFn3;
      case 4:
        return ChangeDetectionUtil.arrayFn4;
      case 5:
        return ChangeDetectionUtil.arrayFn5;
      case 6:
        return ChangeDetectionUtil.arrayFn6;
      case 7:
        return ChangeDetectionUtil.arrayFn7;
      case 8:
        return ChangeDetectionUtil.arrayFn8;
      case 9:
        return ChangeDetectionUtil.arrayFn9;
      default:
        throw new BaseException("Does not support literal maps with more than 9 elements");
    }
  }
  function _mapPrimitiveName(keys) {
    var stringifiedKeys = ListWrapper.join(ListWrapper.map(keys, (function(k) {
      return isString(k) ? ("\"" + k + "\"") : ("" + k);
    })), ", ");
    return ("mapFn([" + stringifiedKeys + "])");
  }
  function _operationToPrimitiveName(operation) {
    switch (operation) {
      case '+':
        return "operation_add";
      case '-':
        return "operation_subtract";
      case '*':
        return "operation_multiply";
      case '/':
        return "operation_divide";
      case '%':
        return "operation_remainder";
      case '==':
        return "operation_equals";
      case '!=':
        return "operation_not_equals";
      case '===':
        return "operation_identical";
      case '!==':
        return "operation_not_identical";
      case '<':
        return "operation_less_then";
      case '>':
        return "operation_greater_then";
      case '<=':
        return "operation_less_or_equals_then";
      case '>=':
        return "operation_greater_or_equals_then";
      case '&&':
        return "operation_logical_and";
      case '||':
        return "operation_logical_or";
      default:
        throw new BaseException(("Unsupported operation " + operation));
    }
  }
  function _operationToFunction(operation) {
    switch (operation) {
      case '+':
        return ChangeDetectionUtil.operation_add;
      case '-':
        return ChangeDetectionUtil.operation_subtract;
      case '*':
        return ChangeDetectionUtil.operation_multiply;
      case '/':
        return ChangeDetectionUtil.operation_divide;
      case '%':
        return ChangeDetectionUtil.operation_remainder;
      case '==':
        return ChangeDetectionUtil.operation_equals;
      case '!=':
        return ChangeDetectionUtil.operation_not_equals;
      case '===':
        return ChangeDetectionUtil.operation_identical;
      case '!==':
        return ChangeDetectionUtil.operation_not_identical;
      case '<':
        return ChangeDetectionUtil.operation_less_then;
      case '>':
        return ChangeDetectionUtil.operation_greater_then;
      case '<=':
        return ChangeDetectionUtil.operation_less_or_equals_then;
      case '>=':
        return ChangeDetectionUtil.operation_greater_or_equals_then;
      case '&&':
        return ChangeDetectionUtil.operation_logical_and;
      case '||':
        return ChangeDetectionUtil.operation_logical_or;
      default:
        throw new BaseException(("Unsupported operation " + operation));
    }
  }
  function s(v) {
    return isPresent(v) ? ("" + v) : '';
  }
  function _interpolationFn(strings) {
    var length = strings.length;
    var c0 = length > 0 ? strings[0] : null;
    var c1 = length > 1 ? strings[1] : null;
    var c2 = length > 2 ? strings[2] : null;
    var c3 = length > 3 ? strings[3] : null;
    var c4 = length > 4 ? strings[4] : null;
    var c5 = length > 5 ? strings[5] : null;
    var c6 = length > 6 ? strings[6] : null;
    var c7 = length > 7 ? strings[7] : null;
    var c8 = length > 8 ? strings[8] : null;
    var c9 = length > 9 ? strings[9] : null;
    switch (length - 1) {
      case 1:
        return (function(a1) {
          return c0 + s(a1) + c1;
        });
      case 2:
        return (function(a1, a2) {
          return c0 + s(a1) + c1 + s(a2) + c2;
        });
      case 3:
        return (function(a1, a2, a3) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3;
        });
      case 4:
        return (function(a1, a2, a3, a4) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4;
        });
      case 5:
        return (function(a1, a2, a3, a4, a5) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
        });
      case 6:
        return (function(a1, a2, a3, a4, a5, a6) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
        });
      case 7:
        return (function(a1, a2, a3, a4, a5, a6, a7) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7;
        });
      case 8:
        return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8;
        });
      case 9:
        return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8 + s(a9) + c9;
        });
      default:
        throw new BaseException("Does not support more than 9 expressions");
    }
  }
  $__export("createPropertyRecords", createPropertyRecords);
  $__export("createEventRecords", createEventRecords);
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      isPresent = $__m.isPresent;
      isString = $__m.isString;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ImplicitReceiver = $__m.ImplicitReceiver;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      DynamicChangeDetector = $__m.DynamicChangeDetector;
    }, function($__m) {
      DirectiveIndex = $__m.DirectiveIndex;
    }, function($__m) {
      EventBinding = $__m.EventBinding;
    }, function($__m) {
      coalesce = $__m.coalesce;
    }, function($__m) {
      ProtoRecord = $__m.ProtoRecord;
      RecordType = $__m.RecordType;
    }],
    execute: function() {
      DynamicProtoChangeDetector = (function() {
        function DynamicProtoChangeDetector(definition) {
          this.definition = definition;
          this._propertyBindingRecords = createPropertyRecords(definition);
          this._eventBindingRecords = createEventRecords(definition);
          this._propertyBindingTargets = this.definition.bindingRecords.map((function(b) {
            return b.target;
          }));
          this._directiveIndices = this.definition.directiveRecords.map((function(d) {
            return d.directiveIndex;
          }));
        }
        return ($traceurRuntime.createClass)(DynamicProtoChangeDetector, {instantiate: function(dispatcher) {
            return new DynamicChangeDetector(this.definition.id, dispatcher, this._propertyBindingRecords.length, this._propertyBindingTargets, this._directiveIndices, this.definition.strategy, this._propertyBindingRecords, this._eventBindingRecords, this.definition.directiveRecords, this.definition.genConfig);
          }}, {});
      }());
      $__export("DynamicProtoChangeDetector", DynamicProtoChangeDetector);
      ProtoRecordBuilder = (function() {
        function ProtoRecordBuilder() {
          this.records = [];
        }
        return ($traceurRuntime.createClass)(ProtoRecordBuilder, {
          add: function(b, variableNames, bindingIndex) {
            var oldLast = ListWrapper.last(this.records);
            if (isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {
              oldLast.lastInDirective = false;
            }
            var numberOfRecordsBefore = this.records.length;
            this._appendRecords(b, variableNames, bindingIndex);
            var newLast = ListWrapper.last(this.records);
            if (isPresent(newLast) && newLast !== oldLast) {
              newLast.lastInBinding = true;
              newLast.lastInDirective = true;
              this._setArgumentToPureFunction(numberOfRecordsBefore);
            }
          },
          _setArgumentToPureFunction: function(startIndex) {
            var $__0 = this;
            for (var i = startIndex; i < this.records.length; ++i) {
              var rec = this.records[i];
              if (rec.isPureFunction()) {
                rec.args.forEach((function(recordIndex) {
                  return $__0.records[recordIndex - 1].argumentToPureFunction = true;
                }));
              }
            }
          },
          _appendRecords: function(b, variableNames, bindingIndex) {
            if (b.isDirectiveLifecycle()) {
              this.records.push(new ProtoRecord(RecordType.DIRECTIVE_LIFECYCLE, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, false, false, false, false, null));
            } else {
              _ConvertAstIntoProtoRecords.append(this.records, b, variableNames, bindingIndex);
            }
          }
        }, {});
      }());
      $__export("ProtoRecordBuilder", ProtoRecordBuilder);
      _ConvertAstIntoProtoRecords = (function() {
        function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _variableNames, _bindingIndex) {
          this._records = _records;
          this._bindingRecord = _bindingRecord;
          this._variableNames = _variableNames;
          this._bindingIndex = _bindingIndex;
        }
        return ($traceurRuntime.createClass)(_ConvertAstIntoProtoRecords, {
          visitImplicitReceiver: function(ast) {
            return this._bindingRecord.implicitReceiver;
          },
          visitInterpolation: function(ast) {
            var args = this._visitAll(ast.expressions);
            return this._addRecord(RecordType.INTERPOLATE, "interpolate", _interpolationFn(ast.strings), args, ast.strings, 0);
          },
          visitLiteralPrimitive: function(ast) {
            return this._addRecord(RecordType.CONST, "literal", ast.value, [], null, 0);
          },
          visitPropertyRead: function(ast) {
            var receiver = ast.receiver.visit(this);
            if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name) && ast.receiver instanceof ImplicitReceiver) {
              return this._addRecord(RecordType.LOCAL, ast.name, ast.name, [], null, receiver);
            } else {
              return this._addRecord(RecordType.PROPERTY_READ, ast.name, ast.getter, [], null, receiver);
            }
          },
          visitPropertyWrite: function(ast) {
            if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name) && ast.receiver instanceof ImplicitReceiver) {
              throw new BaseException(("Cannot reassign a variable binding " + ast.name));
            } else {
              var receiver = ast.receiver.visit(this);
              var value = ast.value.visit(this);
              return this._addRecord(RecordType.PROPERTY_WRITE, ast.name, ast.setter, [value], null, receiver);
            }
          },
          visitKeyedWrite: function(ast) {
            var obj = ast.obj.visit(this);
            var key = ast.key.visit(this);
            var value = ast.value.visit(this);
            return this._addRecord(RecordType.KEYED_WRITE, null, null, [key, value], null, obj);
          },
          visitSafePropertyRead: function(ast) {
            var receiver = ast.receiver.visit(this);
            return this._addRecord(RecordType.SAFE_PROPERTY, ast.name, ast.getter, [], null, receiver);
          },
          visitMethodCall: function(ast) {
            var receiver = ast.receiver.visit(this);
            var args = this._visitAll(ast.args);
            if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name)) {
              var target = this._addRecord(RecordType.LOCAL, ast.name, ast.name, [], null, receiver);
              return this._addRecord(RecordType.INVOKE_CLOSURE, "closure", null, args, null, target);
            } else {
              return this._addRecord(RecordType.INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
            }
          },
          visitSafeMethodCall: function(ast) {
            var receiver = ast.receiver.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RecordType.SAFE_INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
          },
          visitFunctionCall: function(ast) {
            var target = ast.target.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RecordType.INVOKE_CLOSURE, "closure", null, args, null, target);
          },
          visitLiteralArray: function(ast) {
            var primitiveName = ("arrayFn" + ast.expressions.length);
            return this._addRecord(RecordType.COLLECTION_LITERAL, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
          },
          visitLiteralMap: function(ast) {
            return this._addRecord(RecordType.COLLECTION_LITERAL, _mapPrimitiveName(ast.keys), ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
          },
          visitBinary: function(ast) {
            var left = ast.left.visit(this);
            var right = ast.right.visit(this);
            return this._addRecord(RecordType.PRIMITIVE_OP, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
          },
          visitPrefixNot: function(ast) {
            var exp = ast.expression.visit(this);
            return this._addRecord(RecordType.PRIMITIVE_OP, "operation_negate", ChangeDetectionUtil.operation_negate, [exp], null, 0);
          },
          visitConditional: function(ast) {
            var c = ast.condition.visit(this);
            var t = ast.trueExp.visit(this);
            var f = ast.falseExp.visit(this);
            return this._addRecord(RecordType.PRIMITIVE_OP, "cond", ChangeDetectionUtil.cond, [c, t, f], null, 0);
          },
          visitPipe: function(ast) {
            var value = ast.exp.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RecordType.PIPE, ast.name, ast.name, args, null, value);
          },
          visitKeyedRead: function(ast) {
            var obj = ast.obj.visit(this);
            var key = ast.key.visit(this);
            return this._addRecord(RecordType.KEYED_READ, "keyedAccess", ChangeDetectionUtil.keyedAccess, [key], null, obj);
          },
          visitChain: function(ast) {
            var $__0 = this;
            var args = ast.expressions.map((function(e) {
              return e.visit($__0);
            }));
            return this._addRecord(RecordType.CHAIN, "chain", null, args, null, 0);
          },
          visitIf: function(ast) {
            throw new BaseException('Not supported');
          },
          _visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          _addRecord: function(type, name, funcOrValue, args, fixedArgs, context) {
            var selfIndex = this._records.length + 1;
            if (context instanceof DirectiveIndex) {
              this._records.push(new ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
            } else {
              this._records.push(new ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
            }
            return selfIndex;
          }
        }, {
          append: function(records, b, variableNames, bindingIndex) {
            var c = new _ConvertAstIntoProtoRecords(records, b, variableNames, bindingIndex);
            b.ast.visit(c);
          },
          create: function(b, variableNames) {
            var rec = [];
            _ConvertAstIntoProtoRecords.append(rec, b, variableNames, null);
            rec[rec.length - 1].lastInBinding = true;
            return rec;
          }
        });
      }());
    }
  };
});

System.register("angular2/src/core/metadata/view", ["angular2/src/facade/lang", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/metadata/view";
  var __decorate,
      __metadata,
      CONST,
      ViewMetadata;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }, function($__m) {
      $__export("ViewEncapsulation", $__m.ViewEncapsulation);
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ViewMetadata = (($traceurRuntime.createClass)(function() {
        var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
            templateUrl = $__2.templateUrl,
            template = $__2.template,
            directives = $__2.directives,
            pipes = $__2.pipes,
            encapsulation = $__2.encapsulation,
            styles = $__2.styles,
            styleUrls = $__2.styleUrls;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
      }, {}, {}));
      $__export("ViewMetadata", ViewMetadata);
      $__export("ViewMetadata", ViewMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], ViewMetadata));
    }
  };
});

System.register("angular2/src/dom/browser_adapter", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/dom/generic_browser_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/browser_adapter";
  var ListWrapper,
      isBlank,
      isPresent,
      global,
      setRootDomAdapter,
      GenericBrowserDomAdapter,
      _attrToPropMap,
      DOM_KEY_LOCATION_NUMPAD,
      _keyMap,
      _chromeNumKeyPadMap,
      BrowserDomAdapter,
      baseElement,
      urlParsingNode;
  function getBaseElementHref() {
    if (isBlank(baseElement)) {
      baseElement = document.querySelector('base');
      if (isBlank(baseElement)) {
        return null;
      }
    }
    return baseElement.getAttribute('href');
  }
  function relativePath(url) {
    if (isBlank(urlParsingNode)) {
      urlParsingNode = document.createElement("a");
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      global = $__m.global;
    }, function($__m) {
      setRootDomAdapter = $__m.setRootDomAdapter;
    }, function($__m) {
      GenericBrowserDomAdapter = $__m.GenericBrowserDomAdapter;
    }],
    execute: function() {
      _attrToPropMap = {
        'class': 'className',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex'
      };
      DOM_KEY_LOCATION_NUMPAD = 3;
      _keyMap = {
        '\b': 'Backspace',
        '\t': 'Tab',
        '\x7F': 'Delete',
        '\x1B': 'Escape',
        'Del': 'Delete',
        'Esc': 'Escape',
        'Left': 'ArrowLeft',
        'Right': 'ArrowRight',
        'Up': 'ArrowUp',
        'Down': 'ArrowDown',
        'Menu': 'ContextMenu',
        'Scroll': 'ScrollLock',
        'Win': 'OS'
      };
      _chromeNumKeyPadMap = {
        'A': '1',
        'B': '2',
        'C': '3',
        'D': '4',
        'E': '5',
        'F': '6',
        'G': '7',
        'H': '8',
        'I': '9',
        'J': '*',
        'K': '+',
        'M': '-',
        'N': '.',
        'O': '/',
        '\x60': '0',
        '\x90': 'NumLock'
      };
      BrowserDomAdapter = (function($__super) {
        function BrowserDomAdapter() {
          $traceurRuntime.superConstructor(BrowserDomAdapter).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(BrowserDomAdapter, {
          hasProperty: function(element, name) {
            return name in element;
          },
          setProperty: function(el, name, value) {
            el[name] = value;
          },
          getProperty: function(el, name) {
            return el[name];
          },
          invoke: function(el, methodName, args) {
            el[methodName].apply(el, args);
          },
          logError: function(error) {
            window.console.error(error);
          },
          log: function(error) {
            window.console.log(error);
          },
          logGroup: function(error) {
            if (window.console.group) {
              window.console.group(error);
            } else {
              window.console.log(error);
            }
          },
          logGroupEnd: function() {
            if (window.console.groupEnd) {
              window.console.groupEnd();
            }
          },
          get attrToPropMap() {
            return _attrToPropMap;
          },
          query: function(selector) {
            return document.querySelector(selector);
          },
          querySelector: function(el, selector) {
            return el.querySelector(selector);
          },
          querySelectorAll: function(el, selector) {
            return el.querySelectorAll(selector);
          },
          on: function(el, evt, listener) {
            el.addEventListener(evt, listener, false);
          },
          onAndCancel: function(el, evt, listener) {
            el.addEventListener(evt, listener, false);
            return (function() {
              el.removeEventListener(evt, listener, false);
            });
          },
          dispatchEvent: function(el, evt) {
            el.dispatchEvent(evt);
          },
          createMouseEvent: function(eventType) {
            var evt = document.createEvent('MouseEvent');
            evt.initEvent(eventType, true, true);
            return evt;
          },
          createEvent: function(eventType) {
            var evt = document.createEvent('Event');
            evt.initEvent(eventType, true, true);
            return evt;
          },
          preventDefault: function(evt) {
            evt.preventDefault();
            evt.returnValue = false;
          },
          isPrevented: function(evt) {
            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
          },
          getInnerHTML: function(el) {
            return el.innerHTML;
          },
          getOuterHTML: function(el) {
            return el.outerHTML;
          },
          nodeName: function(node) {
            return node.nodeName;
          },
          nodeValue: function(node) {
            return node.nodeValue;
          },
          type: function(node) {
            return node.type;
          },
          content: function(node) {
            if (this.hasProperty(node, "content")) {
              return node.content;
            } else {
              return node;
            }
          },
          firstChild: function(el) {
            return el.firstChild;
          },
          nextSibling: function(el) {
            return el.nextSibling;
          },
          parentElement: function(el) {
            return el.parentNode;
          },
          childNodes: function(el) {
            return el.childNodes;
          },
          childNodesAsList: function(el) {
            var childNodes = el.childNodes;
            var res = ListWrapper.createFixedSize(childNodes.length);
            for (var i = 0; i < childNodes.length; i++) {
              res[i] = childNodes[i];
            }
            return res;
          },
          clearNodes: function(el) {
            while (el.firstChild) {
              el.removeChild(el.firstChild);
            }
          },
          appendChild: function(el, node) {
            el.appendChild(node);
          },
          removeChild: function(el, node) {
            el.removeChild(node);
          },
          replaceChild: function(el, newChild, oldChild) {
            el.replaceChild(newChild, oldChild);
          },
          remove: function(node) {
            node.parentNode.removeChild(node);
            return node;
          },
          insertBefore: function(el, node) {
            el.parentNode.insertBefore(node, el);
          },
          insertAllBefore: function(el, nodes) {
            ListWrapper.forEach(nodes, (function(n) {
              el.parentNode.insertBefore(n, el);
            }));
          },
          insertAfter: function(el, node) {
            el.parentNode.insertBefore(node, el.nextSibling);
          },
          setInnerHTML: function(el, value) {
            el.innerHTML = value;
          },
          getText: function(el) {
            return el.textContent;
          },
          setText: function(el, value) {
            el.textContent = value;
          },
          getValue: function(el) {
            return el.value;
          },
          setValue: function(el, value) {
            el.value = value;
          },
          getChecked: function(el) {
            return el.checked;
          },
          setChecked: function(el, value) {
            el.checked = value;
          },
          createComment: function(text) {
            return document.createComment(text);
          },
          createTemplate: function(html) {
            var t = document.createElement('template');
            t.innerHTML = html;
            return t;
          },
          createElement: function(tagName) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            return doc.createElement(tagName);
          },
          createTextNode: function(text) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            return doc.createTextNode(text);
          },
          createScriptTag: function(attrName, attrValue) {
            var doc = arguments[2] !== (void 0) ? arguments[2] : document;
            var el = doc.createElement('SCRIPT');
            el.setAttribute(attrName, attrValue);
            return el;
          },
          createStyleElement: function(css) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            var style = doc.createElement('style');
            this.appendChild(style, this.createTextNode(css));
            return style;
          },
          createShadowRoot: function(el) {
            return el.createShadowRoot();
          },
          getShadowRoot: function(el) {
            return el.shadowRoot;
          },
          getHost: function(el) {
            return el.host;
          },
          clone: function(node) {
            return node.cloneNode(true);
          },
          getElementsByClassName: function(element, name) {
            return element.getElementsByClassName(name);
          },
          getElementsByTagName: function(element, name) {
            return element.getElementsByTagName(name);
          },
          classList: function(element) {
            return Array.prototype.slice.call(element.classList, 0);
          },
          addClass: function(element, classname) {
            element.classList.add(classname);
          },
          removeClass: function(element, classname) {
            element.classList.remove(classname);
          },
          hasClass: function(element, classname) {
            return element.classList.contains(classname);
          },
          setStyle: function(element, stylename, stylevalue) {
            element.style[stylename] = stylevalue;
          },
          removeStyle: function(element, stylename) {
            element.style[stylename] = null;
          },
          getStyle: function(element, stylename) {
            return element.style[stylename];
          },
          tagName: function(element) {
            return element.tagName;
          },
          attributeMap: function(element) {
            var res = new Map();
            var elAttrs = element.attributes;
            for (var i = 0; i < elAttrs.length; i++) {
              var attrib = elAttrs[i];
              res.set(attrib.name, attrib.value);
            }
            return res;
          },
          hasAttribute: function(element, attribute) {
            return element.hasAttribute(attribute);
          },
          getAttribute: function(element, attribute) {
            return element.getAttribute(attribute);
          },
          setAttribute: function(element, name, value) {
            element.setAttribute(name, value);
          },
          removeAttribute: function(element, attribute) {
            element.removeAttribute(attribute);
          },
          templateAwareRoot: function(el) {
            return this.isTemplateElement(el) ? this.content(el) : el;
          },
          createHtmlDocument: function() {
            return document.implementation.createHTMLDocument('fakeTitle');
          },
          defaultDoc: function() {
            return document;
          },
          getBoundingClientRect: function(el) {
            try {
              return el.getBoundingClientRect();
            } catch (e) {
              return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
              };
            }
          },
          getTitle: function() {
            return document.title;
          },
          setTitle: function(newTitle) {
            document.title = newTitle || '';
          },
          elementMatches: function(n, selector) {
            var matches = false;
            if (n instanceof HTMLElement) {
              if (n.matches) {
                matches = n.matches(selector);
              } else if (n.msMatchesSelector) {
                matches = n.msMatchesSelector(selector);
              } else if (n.webkitMatchesSelector) {
                matches = n.webkitMatchesSelector(selector);
              }
            }
            return matches;
          },
          isTemplateElement: function(el) {
            return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
          },
          isTextNode: function(node) {
            return node.nodeType === Node.TEXT_NODE;
          },
          isCommentNode: function(node) {
            return node.nodeType === Node.COMMENT_NODE;
          },
          isElementNode: function(node) {
            return node.nodeType === Node.ELEMENT_NODE;
          },
          hasShadowRoot: function(node) {
            return node instanceof HTMLElement && isPresent(node.shadowRoot);
          },
          isShadowRoot: function(node) {
            return node instanceof DocumentFragment;
          },
          importIntoDoc: function(node) {
            var toImport = node;
            if (this.isTemplateElement(node)) {
              toImport = this.content(node);
            }
            return document.importNode(toImport, true);
          },
          adoptNode: function(node) {
            return document.adoptNode(node);
          },
          isPageRule: function(rule) {
            return rule.type === CSSRule.PAGE_RULE;
          },
          isStyleRule: function(rule) {
            return rule.type === CSSRule.STYLE_RULE;
          },
          isMediaRule: function(rule) {
            return rule.type === CSSRule.MEDIA_RULE;
          },
          isKeyframesRule: function(rule) {
            return rule.type === CSSRule.KEYFRAMES_RULE;
          },
          getHref: function(el) {
            return el.href;
          },
          getEventKey: function(event) {
            var key = event.key;
            if (isBlank(key)) {
              key = event.keyIdentifier;
              if (isBlank(key)) {
                return 'Unidentified';
              }
              if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                  key = _chromeNumKeyPadMap[key];
                }
              }
            }
            if (_keyMap.hasOwnProperty(key)) {
              key = _keyMap[key];
            }
            return key;
          },
          getGlobalEventTarget: function(target) {
            if (target == "window") {
              return window;
            } else if (target == "document") {
              return document;
            } else if (target == "body") {
              return document.body;
            }
          },
          getHistory: function() {
            return window.history;
          },
          getLocation: function() {
            return window.location;
          },
          getBaseHref: function() {
            var href = getBaseElementHref();
            if (isBlank(href)) {
              return null;
            }
            return relativePath(href);
          },
          resetBaseElement: function() {
            baseElement = null;
          },
          getUserAgent: function() {
            return window.navigator.userAgent;
          },
          setData: function(element, name, value) {
            this.setAttribute(element, 'data-' + name, value);
          },
          getData: function(element, name) {
            return this.getAttribute(element, 'data-' + name);
          },
          setGlobalVar: function(name, value) {
            global[name] = value;
          }
        }, {makeCurrent: function() {
            setRootDomAdapter(new BrowserDomAdapter());
          }}, $__super);
      }(GenericBrowserDomAdapter));
      $__export("BrowserDomAdapter", BrowserDomAdapter);
      baseElement = null;
      urlParsingNode = null;
    }
  };
});

System.register("angular2/src/facade/async", ["angular2/src/facade/lang", "rx"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/async";
  var global,
      Rx,
      PromiseWrapper,
      TimerWrapper,
      ObservableWrapper,
      Observable,
      EventEmitter;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }, function($__m) {
      Rx = $__m;
    }],
    execute: function() {
      $__export("Promise", Promise);
      PromiseWrapper = (function() {
        function PromiseWrapper() {}
        return ($traceurRuntime.createClass)(PromiseWrapper, {}, {
          resolve: function(obj) {
            return Promise.resolve(obj);
          },
          reject: function(obj, _) {
            return Promise.reject(obj);
          },
          catchError: function(promise, onError) {
            return promise.catch(onError);
          },
          all: function(promises) {
            if (promises.length == 0)
              return Promise.resolve([]);
            return Promise.all(promises);
          },
          then: function(promise, success, rejection) {
            return promise.then(success, rejection);
          },
          wrap: function(computation) {
            return new Promise((function(res, rej) {
              try {
                res(computation());
              } catch (e) {
                rej(e);
              }
            }));
          },
          completer: function() {
            var resolve;
            var reject;
            var p = new Promise(function(res, rej) {
              resolve = res;
              reject = rej;
            });
            return {
              promise: p,
              resolve: resolve,
              reject: reject
            };
          }
        });
      }());
      $__export("PromiseWrapper", PromiseWrapper);
      TimerWrapper = (function() {
        function TimerWrapper() {}
        return ($traceurRuntime.createClass)(TimerWrapper, {}, {
          setTimeout: function(fn, millis) {
            return global.setTimeout(fn, millis);
          },
          clearTimeout: function(id) {
            global.clearTimeout(id);
          },
          setInterval: function(fn, millis) {
            return global.setInterval(fn, millis);
          },
          clearInterval: function(id) {
            global.clearInterval(id);
          }
        });
      }());
      $__export("TimerWrapper", TimerWrapper);
      ObservableWrapper = (function() {
        function ObservableWrapper() {}
        return ($traceurRuntime.createClass)(ObservableWrapper, {}, {
          subscribe: function(emitter, onNext) {
            var onThrow = arguments[2] !== (void 0) ? arguments[2] : null;
            var onReturn = arguments[3] !== (void 0) ? arguments[3] : null;
            return emitter.observer({
              next: onNext,
              throw: onThrow,
              return: onReturn
            });
          },
          isObservable: function(obs) {
            return obs instanceof Observable;
          },
          dispose: function(subscription) {
            subscription.dispose();
          },
          callNext: function(emitter, value) {
            emitter.next(value);
          },
          callThrow: function(emitter, error) {
            emitter.throw(error);
          },
          callReturn: function(emitter) {
            emitter.return(null);
          }
        });
      }());
      $__export("ObservableWrapper", ObservableWrapper);
      Observable = (function() {
        function Observable() {}
        return ($traceurRuntime.createClass)(Observable, {observer: function(generator) {
            return null;
          }}, {});
      }());
      $__export("Observable", Observable);
      EventEmitter = (function($__super) {
        function EventEmitter() {
          $traceurRuntime.superConstructor(EventEmitter).call(this);
          this._subject = new Rx.Subject();
          this._immediateScheduler = Rx.Scheduler.immediate;
        }
        return ($traceurRuntime.createClass)(EventEmitter, {
          observer: function(generator) {
            return this._subject.observeOn(this._immediateScheduler).subscribe((function(value) {
              setTimeout((function() {
                return generator.next(value);
              }));
            }), (function(error) {
              return generator.throw ? generator.throw(error) : null;
            }), (function() {
              return generator.return ? generator.return() : null;
            }));
          },
          toRx: function() {
            return this._subject;
          },
          next: function(value) {
            this._subject.onNext(value);
          },
          throw: function(error) {
            this._subject.onError(error);
          },
          return: function(value) {
            this._subject.onCompleted();
          }
        }, {}, $__super);
      }(Observable));
      $__export("EventEmitter", EventEmitter);
    }
  };
});

System.register("angular2/src/core/compiler/view", ["angular2/src/facade/collection", "angular2/src/change_detection/change_detection", "angular2/src/change_detection/interfaces", "angular2/src/core/compiler/element_binder", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view";
  var ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      Locals,
      DebugContext,
      ElementBinder,
      isPresent,
      BaseException,
      ViewRef,
      ProtoViewRef,
      internalView,
      camelCaseToDashCase,
      REFLECT_PREFIX,
      AppProtoViewMergeMapping,
      AppViewContainer,
      AppView,
      _Context,
      EventEvaluationError,
      AppProtoView;
  function inverseIndexMapping(input, resultLength) {
    var result = ListWrapper.createGrowableSize(resultLength);
    for (var i = 0; i < input.length; i++) {
      var value = input[i];
      if (isPresent(value)) {
        result[input[i]] = i;
      }
    }
    return result;
  }
  function _localsToStringMap(locals) {
    var res = {};
    var c = locals;
    while (isPresent(c)) {
      res = StringMapWrapper.merge(res, MapWrapper.toStringMap(c.current));
      c = c.parent;
    }
    return res;
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      Locals = $__m.Locals;
    }, function($__m) {
      DebugContext = $__m.DebugContext;
      $__export("DebugContext", $__m.DebugContext);
    }, function($__m) {
      ElementBinder = $__m.ElementBinder;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ViewRef = $__m.ViewRef;
      ProtoViewRef = $__m.ProtoViewRef;
      internalView = $__m.internalView;
    }, function($__m) {
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }],
    execute: function() {
      REFLECT_PREFIX = 'ng-reflect-';
      AppProtoViewMergeMapping = (function() {
        function AppProtoViewMergeMapping(renderProtoViewMergeMapping) {
          this.renderProtoViewRef = renderProtoViewMergeMapping.mergedProtoViewRef;
          this.renderFragmentCount = renderProtoViewMergeMapping.fragmentCount;
          this.renderElementIndices = renderProtoViewMergeMapping.mappedElementIndices;
          this.renderInverseElementIndices = inverseIndexMapping(this.renderElementIndices, renderProtoViewMergeMapping.mappedElementCount);
          this.renderTextIndices = renderProtoViewMergeMapping.mappedTextIndices;
          this.hostElementIndicesByViewIndex = renderProtoViewMergeMapping.hostElementIndicesByViewIndex;
          this.nestedViewIndicesByElementIndex = inverseIndexMapping(this.hostElementIndicesByViewIndex, this.renderElementIndices.length);
          this.nestedViewCountByViewIndex = renderProtoViewMergeMapping.nestedViewCountByViewIndex;
        }
        return ($traceurRuntime.createClass)(AppProtoViewMergeMapping, {}, {});
      }());
      $__export("AppProtoViewMergeMapping", AppProtoViewMergeMapping);
      AppViewContainer = (function() {
        function AppViewContainer() {
          this.views = [];
        }
        return ($traceurRuntime.createClass)(AppViewContainer, {}, {});
      }());
      $__export("AppViewContainer", AppViewContainer);
      AppView = (function() {
        function AppView(renderer, proto, mainMergeMapping, viewOffset, elementOffset, textOffset, protoLocals, render, renderFragment) {
          this.renderer = renderer;
          this.proto = proto;
          this.mainMergeMapping = mainMergeMapping;
          this.viewOffset = viewOffset;
          this.elementOffset = elementOffset;
          this.textOffset = textOffset;
          this.render = render;
          this.renderFragment = renderFragment;
          this.views = null;
          this.elementInjectors = null;
          this.viewContainers = null;
          this.preBuiltObjects = null;
          this.changeDetector = null;
          this.context = null;
          this.ref = new ViewRef(this);
          this.locals = new Locals(null, MapWrapper.clone(protoLocals));
        }
        return ($traceurRuntime.createClass)(AppView, {
          init: function(changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers) {
            this.changeDetector = changeDetector;
            this.elementInjectors = elementInjectors;
            this.rootElementInjectors = rootElementInjectors;
            this.preBuiltObjects = preBuiltObjects;
            this.views = views;
            this.elementRefs = elementRefs;
            this.viewContainers = viewContainers;
          },
          setLocal: function(contextName, value) {
            if (!this.hydrated())
              throw new BaseException('Cannot set locals on dehydrated view.');
            if (!this.proto.variableBindings.has(contextName)) {
              return ;
            }
            var templateName = this.proto.variableBindings.get(contextName);
            this.locals.set(templateName, value);
          },
          hydrated: function() {
            return isPresent(this.context);
          },
          triggerEventHandlers: function(eventName, eventObj, boundElementIndex) {
            var locals = new Map();
            locals.set('$event', eventObj);
            this.dispatchEvent(boundElementIndex, eventName, locals);
          },
          notifyOnBinding: function(b, currentValue) {
            if (b.isTextNode()) {
              this.renderer.setText(this.render, this.mainMergeMapping.renderTextIndices[b.elementIndex + this.textOffset], currentValue);
            } else {
              var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
              if (b.isElementProperty()) {
                this.renderer.setElementProperty(elementRef, b.name, currentValue);
              } else if (b.isElementAttribute()) {
                this.renderer.setElementAttribute(elementRef, b.name, currentValue);
              } else if (b.isElementClass()) {
                this.renderer.setElementClass(elementRef, b.name, currentValue);
              } else if (b.isElementStyle()) {
                var unit = isPresent(b.unit) ? b.unit : '';
                this.renderer.setElementStyle(elementRef, b.name, ("" + currentValue + unit));
              } else {
                throw new BaseException('Unsupported directive record');
              }
            }
          },
          logBindingUpdate: function(b, value) {
            if (b.isDirective() || b.isElementProperty()) {
              var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
              this.renderer.setElementAttribute(elementRef, ("" + REFLECT_PREFIX + camelCaseToDashCase(b.name)), ("" + value));
            }
          },
          notifyOnAllChangesDone: function() {
            var eiCount = this.proto.elementBinders.length;
            var ei = this.elementInjectors;
            for (var i = eiCount - 1; i >= 0; i--) {
              if (isPresent(ei[i + this.elementOffset]))
                ei[i + this.elementOffset].onAllChangesDone();
            }
          },
          getDirectiveFor: function(directive) {
            var elementInjector = this.elementInjectors[this.elementOffset + directive.elementIndex];
            return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
          },
          getNestedView: function(boundElementIndex) {
            var viewIndex = this.mainMergeMapping.nestedViewIndicesByElementIndex[boundElementIndex];
            return isPresent(viewIndex) ? this.views[viewIndex] : null;
          },
          getHostElement: function() {
            var boundElementIndex = this.mainMergeMapping.hostElementIndicesByViewIndex[this.viewOffset];
            return isPresent(boundElementIndex) ? this.elementRefs[boundElementIndex] : null;
          },
          getDebugContext: function(elementIndex, directiveIndex) {
            try {
              var offsettedIndex = this.elementOffset + elementIndex;
              var hasRefForIndex = offsettedIndex < this.elementRefs.length;
              var elementRef = hasRefForIndex ? this.elementRefs[this.elementOffset + elementIndex] : null;
              var host = this.getHostElement();
              var ei = hasRefForIndex ? this.elementInjectors[this.elementOffset + elementIndex] : null;
              var element = isPresent(elementRef) ? elementRef.nativeElement : null;
              var componentElement = isPresent(host) ? host.nativeElement : null;
              var directive = isPresent(directiveIndex) ? this.getDirectiveFor(directiveIndex) : null;
              var injector = isPresent(ei) ? ei.getInjector() : null;
              return new DebugContext(element, componentElement, directive, this.context, _localsToStringMap(this.locals), injector);
            } catch (e) {
              return null;
            }
          },
          getDetectorFor: function(directive) {
            var childView = this.getNestedView(this.elementOffset + directive.elementIndex);
            return isPresent(childView) ? childView.changeDetector : null;
          },
          invokeElementMethod: function(elementIndex, methodName, args) {
            this.renderer.invokeElementMethod(this.elementRefs[elementIndex], methodName, args);
          },
          dispatchRenderEvent: function(renderElementIndex, eventName, locals) {
            var elementRef = this.elementRefs[this.mainMergeMapping.renderInverseElementIndices[renderElementIndex]];
            var view = internalView(elementRef.parentView);
            return view.dispatchEvent(elementRef.boundElementIndex, eventName, locals);
          },
          dispatchEvent: function(boundElementIndex, eventName, locals) {
            try {
              if (this.hydrated()) {
                return !this.changeDetector.handleEvent(eventName, boundElementIndex - this.elementOffset, new Locals(this.locals, locals));
              } else {
                return true;
              }
            } catch (e) {
              var c = this.getDebugContext(boundElementIndex - this.elementOffset, null);
              var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector) : null;
              throw new EventEvaluationError(eventName, e, e.stack, context);
            }
          }
        }, {});
      }());
      $__export("AppView", AppView);
      _Context = (function() {
        function _Context(element, componentElement, context, locals, injector) {
          this.element = element;
          this.componentElement = componentElement;
          this.context = context;
          this.locals = locals;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(_Context, {}, {});
      }());
      EventEvaluationError = (function($__super) {
        function EventEvaluationError(eventName, originalException, originalStack, context) {
          $traceurRuntime.superConstructor(EventEvaluationError).call(this, ("Error during evaluation of \"" + eventName + "\""), originalException, originalStack, context);
        }
        return ($traceurRuntime.createClass)(EventEvaluationError, {}, {}, $__super);
      }(BaseException));
      AppProtoView = (function() {
        function AppProtoView(type, isEmbeddedFragment, render, protoChangeDetector, variableBindings, variableLocations, textBindingCount, pipes) {
          var $__0 = this;
          this.type = type;
          this.isEmbeddedFragment = isEmbeddedFragment;
          this.render = render;
          this.protoChangeDetector = protoChangeDetector;
          this.variableBindings = variableBindings;
          this.variableLocations = variableLocations;
          this.textBindingCount = textBindingCount;
          this.pipes = pipes;
          this.elementBinders = [];
          this.protoLocals = new Map();
          this.ref = new ProtoViewRef(this);
          if (isPresent(variableBindings)) {
            MapWrapper.forEach(variableBindings, (function(templateName, _) {
              $__0.protoLocals.set(templateName, null);
            }));
          }
        }
        return ($traceurRuntime.createClass)(AppProtoView, {bindElement: function(parent, distanceToParent, protoElementInjector) {
            var componentDirective = arguments[3] !== (void 0) ? arguments[3] : null;
            var elBinder = new ElementBinder(this.elementBinders.length, parent, distanceToParent, protoElementInjector, componentDirective);
            this.elementBinders.push(elBinder);
            return elBinder;
          }}, {});
      }());
      $__export("AppProtoView", AppProtoView);
    }
  };
});

System.register("angular2/src/core/compiler/view_manager_utils", ["angular2/di", "angular2/src/facade/collection", "angular2/src/core/compiler/element_injector", "angular2/src/facade/lang", "angular2/src/core/compiler/view", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/template_ref", "angular2/src/core/pipes/pipes", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_manager_utils";
  var __decorate,
      __metadata,
      Injector,
      Injectable,
      ListWrapper,
      MapWrapper,
      eli,
      isPresent,
      isBlank,
      viewModule,
      internalView,
      ElementRef,
      TemplateRef,
      Pipes,
      ViewType,
      AppViewManagerUtils;
  return {
    setters: [function($__m) {
      Injector = $__m.Injector;
      Injectable = $__m.Injectable;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      eli = $__m;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      internalView = $__m.internalView;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      Pipes = $__m.Pipes;
    }, function($__m) {
      ViewType = $__m.ViewType;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppViewManagerUtils = (($traceurRuntime.createClass)(function() {}, {
        getComponentInstance: function(parentView, boundElementIndex) {
          var eli = parentView.elementInjectors[boundElementIndex];
          return eli.getComponent();
        },
        createView: function(mergedParentViewProto, renderViewWithFragments, viewManager, renderer) {
          var renderFragments = renderViewWithFragments.fragmentRefs;
          var renderView = renderViewWithFragments.viewRef;
          var elementCount = mergedParentViewProto.mergeMapping.renderElementIndices.length;
          var viewCount = mergedParentViewProto.mergeMapping.nestedViewCountByViewIndex[0] + 1;
          var elementRefs = ListWrapper.createFixedSize(elementCount);
          var viewContainers = ListWrapper.createFixedSize(elementCount);
          var preBuiltObjects = ListWrapper.createFixedSize(elementCount);
          var elementInjectors = ListWrapper.createFixedSize(elementCount);
          var views = ListWrapper.createFixedSize(viewCount);
          var elementOffset = 0;
          var textOffset = 0;
          var fragmentIdx = 0;
          for (var viewOffset = 0; viewOffset < viewCount; viewOffset++) {
            var hostElementIndex = mergedParentViewProto.mergeMapping.hostElementIndicesByViewIndex[viewOffset];
            var parentView = isPresent(hostElementIndex) ? internalView(elementRefs[hostElementIndex].parentView) : null;
            var protoView = isPresent(hostElementIndex) ? parentView.proto.elementBinders[hostElementIndex - parentView.elementOffset].nestedProtoView : mergedParentViewProto;
            var renderFragment = null;
            if (viewOffset === 0 || protoView.type === ViewType.EMBEDDED) {
              renderFragment = renderFragments[fragmentIdx++];
            }
            var currentView = new viewModule.AppView(renderer, protoView, mergedParentViewProto.mergeMapping, viewOffset, elementOffset, textOffset, protoView.protoLocals, renderView, renderFragment);
            views[viewOffset] = currentView;
            var rootElementInjectors = [];
            for (var binderIdx = 0; binderIdx < protoView.elementBinders.length; binderIdx++) {
              var binder = protoView.elementBinders[binderIdx];
              var boundElementIndex = elementOffset + binderIdx;
              var elementInjector = null;
              var protoElementInjector = binder.protoElementInjector;
              if (isPresent(protoElementInjector)) {
                if (isPresent(protoElementInjector.parent)) {
                  var parentElementInjector = elementInjectors[elementOffset + protoElementInjector.parent.index];
                  elementInjector = protoElementInjector.instantiate(parentElementInjector);
                } else {
                  elementInjector = protoElementInjector.instantiate(null);
                  rootElementInjectors.push(elementInjector);
                }
              }
              elementInjectors[boundElementIndex] = elementInjector;
              var el = new ElementRef(currentView.ref, boundElementIndex, mergedParentViewProto.mergeMapping.renderElementIndices[boundElementIndex], renderer);
              elementRefs[el.boundElementIndex] = el;
              if (isPresent(elementInjector)) {
                var templateRef = binder.hasEmbeddedProtoView() ? new TemplateRef(el) : null;
                preBuiltObjects[boundElementIndex] = new eli.PreBuiltObjects(viewManager, currentView, el, templateRef);
              }
            }
            currentView.init(protoView.protoChangeDetector.instantiate(currentView), elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers);
            if (isPresent(parentView) && protoView.type === ViewType.COMPONENT) {
              parentView.changeDetector.addShadowDomChild(currentView.changeDetector);
            }
            elementOffset += protoView.elementBinders.length;
            textOffset += protoView.textBindingCount;
          }
          return views[0];
        },
        hydrateRootHostView: function(hostView, injector) {
          this._hydrateView(hostView, injector, null, new Object(), null);
        },
        attachViewInContainer: function(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view) {
          if (isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
          }
          parentView.changeDetector.addChild(view.changeDetector);
          var viewContainer = parentView.viewContainers[boundElementIndex];
          if (isBlank(viewContainer)) {
            viewContainer = new viewModule.AppViewContainer();
            parentView.viewContainers[boundElementIndex] = viewContainer;
          }
          ListWrapper.insert(viewContainer.views, atIndex, view);
          var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
          var sibling;
          if (atIndex == 0) {
            sibling = elementInjector;
          } else {
            sibling = ListWrapper.last(viewContainer.views[atIndex - 1].rootElementInjectors);
          }
          for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
            if (isPresent(elementInjector.parent)) {
              view.rootElementInjectors[i].linkAfter(elementInjector.parent, sibling);
            } else {
              contextView.rootElementInjectors.push(view.rootElementInjectors[i]);
            }
          }
        },
        detachViewInContainer: function(parentView, boundElementIndex, atIndex) {
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          view.changeDetector.remove();
          ListWrapper.removeAt(viewContainer.views, atIndex);
          for (var i = 0; i < view.rootElementInjectors.length; ++i) {
            var inj = view.rootElementInjectors[i];
            if (isPresent(inj.parent)) {
              inj.unlink();
            } else {
              var removeIdx = ListWrapper.indexOf(parentView.rootElementInjectors, inj);
              if (removeIdx >= 0) {
                ListWrapper.removeAt(parentView.rootElementInjectors, removeIdx);
              }
            }
          }
        },
        hydrateViewInContainer: function(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, imperativelyCreatedBindings) {
          if (isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
          }
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
          var injector = isPresent(imperativelyCreatedBindings) ? Injector.fromResolvedBindings(imperativelyCreatedBindings) : null;
          this._hydrateView(view, injector, elementInjector.getHost(), contextView.context, contextView.locals);
        },
        _hydrateView: function(initView, imperativelyCreatedInjector, hostElementInjector, context, parentLocals) {
          var viewIdx = initView.viewOffset;
          var endViewOffset = viewIdx + initView.mainMergeMapping.nestedViewCountByViewIndex[viewIdx];
          while (viewIdx <= endViewOffset) {
            var currView = initView.views[viewIdx];
            var currProtoView = currView.proto;
            if (currView !== initView && currView.proto.type === ViewType.EMBEDDED) {
              viewIdx += initView.mainMergeMapping.nestedViewCountByViewIndex[viewIdx] + 1;
            } else {
              if (currView !== initView) {
                imperativelyCreatedInjector = null;
                parentLocals = null;
                var hostElementIndex = initView.mainMergeMapping.hostElementIndicesByViewIndex[viewIdx];
                hostElementInjector = initView.elementInjectors[hostElementIndex];
                context = hostElementInjector.getComponent();
              }
              currView.context = context;
              currView.locals.parent = parentLocals;
              var binders = currProtoView.elementBinders;
              for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                var boundElementIndex = binderIdx + currView.elementOffset;
                var elementInjector = initView.elementInjectors[boundElementIndex];
                if (isPresent(elementInjector)) {
                  elementInjector.hydrate(imperativelyCreatedInjector, hostElementInjector, currView.preBuiltObjects[boundElementIndex]);
                  this._populateViewLocals(currView, elementInjector, boundElementIndex);
                  this._setUpEventEmitters(currView, elementInjector, boundElementIndex);
                  this._setUpHostActions(currView, elementInjector, boundElementIndex);
                }
              }
              var pipes = isPresent(hostElementInjector) ? new Pipes(currView.proto.pipes, hostElementInjector.getInjector()) : null;
              currView.changeDetector.hydrate(currView.context, currView.locals, currView, pipes);
              viewIdx++;
            }
          }
        },
        _populateViewLocals: function(view, elementInjector, boundElementIdx) {
          if (isPresent(elementInjector.getDirectiveVariableBindings())) {
            MapWrapper.forEach(elementInjector.getDirectiveVariableBindings(), (function(directiveIndex, name) {
              if (isBlank(directiveIndex)) {
                view.locals.set(name, view.elementRefs[boundElementIdx].nativeElement);
              } else {
                view.locals.set(name, elementInjector.getDirectiveAtIndex(directiveIndex));
              }
            }));
          }
        },
        _setUpEventEmitters: function(view, elementInjector, boundElementIndex) {
          var emitters = elementInjector.getEventEmitterAccessors();
          for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
            var directiveEmitters = emitters[directiveIndex];
            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
            for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
              var eventEmitterAccessor = directiveEmitters[eventIndex];
              eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
            }
          }
        },
        _setUpHostActions: function(view, elementInjector, boundElementIndex) {
          var hostActions = elementInjector.getHostActionAccessors();
          for (var directiveIndex = 0; directiveIndex < hostActions.length; ++directiveIndex) {
            var directiveHostActions = hostActions[directiveIndex];
            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
            for (var index = 0; index < directiveHostActions.length; ++index) {
              var hostActionAccessor = directiveHostActions[index];
              hostActionAccessor.subscribe(view, boundElementIndex, directive);
            }
          }
        },
        dehydrateView: function(initView) {
          var endViewOffset = initView.viewOffset + initView.mainMergeMapping.nestedViewCountByViewIndex[initView.viewOffset];
          for (var viewIdx = initView.viewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = initView.views[viewIdx];
            if (currView.hydrated()) {
              if (isPresent(currView.locals)) {
                currView.locals.clearValues();
              }
              currView.context = null;
              currView.changeDetector.dehydrate();
              var binders = currView.proto.elementBinders;
              for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                var eli = initView.elementInjectors[currView.elementOffset + binderIdx];
                if (isPresent(eli)) {
                  eli.dehydrate();
                }
              }
            }
          }
        }
      }, {}));
      $__export("AppViewManagerUtils", AppViewManagerUtils);
      $__export("AppViewManagerUtils", AppViewManagerUtils = __decorate([Injectable(), __metadata('design:paramtypes', [])], AppViewManagerUtils));
    }
  };
});

System.register("angular2/src/pipes/uppercase_pipe", ["angular2/src/facade/lang", "angular2/di", "angular2/src/pipes/invalid_pipe_argument_exception", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/uppercase_pipe";
  var __decorate,
      __metadata,
      isString,
      StringWrapper,
      CONST,
      isBlank,
      Injectable,
      InvalidPipeArgumentException,
      Pipe,
      UpperCasePipe;
  return {
    setters: [function($__m) {
      isString = $__m.isString;
      StringWrapper = $__m.StringWrapper;
      CONST = $__m.CONST;
      isBlank = $__m.isBlank;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      InvalidPipeArgumentException = $__m.InvalidPipeArgumentException;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      UpperCasePipe = (($traceurRuntime.createClass)(function() {}, {transform: function(value) {
          var args = arguments[1] !== (void 0) ? arguments[1] : null;
          if (isBlank(value))
            return value;
          if (!isString(value)) {
            throw new InvalidPipeArgumentException(UpperCasePipe, value);
          }
          return StringWrapper.toUpperCase(value);
        }}, {}));
      $__export("UpperCasePipe", UpperCasePipe);
      $__export("UpperCasePipe", UpperCasePipe = __decorate([CONST(), Pipe({name: 'uppercase'}), Injectable(), __metadata('design:paramtypes', [])], UpperCasePipe));
    }
  };
});

System.register("angular2/src/pipes/date_pipe", ["angular2/src/facade/lang", "angular2/src/facade/intl", "angular2/di", "angular2/src/facade/collection", "angular2/src/pipes/invalid_pipe_argument_exception", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/date_pipe";
  var __decorate,
      __metadata,
      isDate,
      isNumber,
      isPresent,
      DateWrapper,
      CONST,
      isBlank,
      DateFormatter,
      Injectable,
      StringMapWrapper,
      InvalidPipeArgumentException,
      Pipe,
      defaultLocale,
      DatePipe;
  return {
    setters: [function($__m) {
      isDate = $__m.isDate;
      isNumber = $__m.isNumber;
      isPresent = $__m.isPresent;
      DateWrapper = $__m.DateWrapper;
      CONST = $__m.CONST;
      isBlank = $__m.isBlank;
    }, function($__m) {
      DateFormatter = $__m.DateFormatter;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      InvalidPipeArgumentException = $__m.InvalidPipeArgumentException;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      defaultLocale = 'en-US';
      DatePipe = (($traceurRuntime.createClass)(function() {}, {
        transform: function(value, args) {
          if (isBlank(value))
            return null;
          if (!this.supports(value)) {
            throw new InvalidPipeArgumentException(DatePipe, value);
          }
          var pattern = isPresent(args) && args.length > 0 ? args[0] : 'mediumDate';
          if (isNumber(value)) {
            value = DateWrapper.fromMillis(value);
          }
          if (StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
            pattern = StringMapWrapper.get(DatePipe._ALIASES, pattern);
          }
          return DateFormatter.format(value, defaultLocale, pattern);
        },
        supports: function(obj) {
          return isDate(obj) || isNumber(obj);
        }
      }, {}));
      $__export("DatePipe", DatePipe);
      DatePipe._ALIASES = {
        'medium': 'yMMMdjms',
        'short': 'yMdjm',
        'fullDate': 'yMMMMEEEEd',
        'longDate': 'yMMMMd',
        'mediumDate': 'yMMMd',
        'shortDate': 'yMd',
        'mediumTime': 'jms',
        'shortTime': 'jm'
      };
      $__export("DatePipe", DatePipe = __decorate([CONST(), Pipe({name: 'date'}), Injectable(), __metadata('design:paramtypes', [])], DatePipe));
    }
  };
});

System.register("angular2/src/pipes/limit_to_pipe", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/math", "angular2/di", "angular2/src/pipes/invalid_pipe_argument_exception", "angular2/src/core/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/pipes/limit_to_pipe";
  var __decorate,
      __metadata,
      isBlank,
      isString,
      isArray,
      StringWrapper,
      BaseException,
      ListWrapper,
      Math,
      Injectable,
      InvalidPipeArgumentException,
      Pipe,
      LimitToPipe;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isString = $__m.isString;
      isArray = $__m.isArray;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Math = $__m.Math;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      InvalidPipeArgumentException = $__m.InvalidPipeArgumentException;
    }, function($__m) {
      Pipe = $__m.Pipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      LimitToPipe = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return isString(obj) || isArray(obj);
        },
        transform: function(value) {
          var args = arguments[1] !== (void 0) ? arguments[1] : null;
          if (isBlank(args) || args.length == 0) {
            throw new BaseException('limitTo pipe requires one argument');
          }
          if (!this.supports(value)) {
            throw new InvalidPipeArgumentException(LimitToPipe, value);
          }
          if (isBlank(value))
            return value;
          var limit = args[0];
          var left = 0,
              right = Math.min(limit, value.length);
          if (limit < 0) {
            left = Math.max(0, value.length + limit);
            right = value.length;
          }
          if (isString(value)) {
            return StringWrapper.substring(value, left, right);
          }
          return ListWrapper.slice(value, left, right);
        }
      }, {}));
      $__export("LimitToPipe", LimitToPipe);
      $__export("LimitToPipe", LimitToPipe = __decorate([Pipe({name: 'limitTo'}), Injectable(), __metadata('design:paramtypes', [])], LimitToPipe));
    }
  };
});

System.register("angular2/src/render/dom/compiler/style_inliner", ["angular2/di", "angular2/src/render/xhr", "angular2/src/facade/collection", "angular2/src/services/url_resolver", "angular2/src/render/dom/compiler/style_url_resolver", "angular2/src/facade/lang", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/style_inliner";
  var __decorate,
      __metadata,
      Injectable,
      XHR,
      ListWrapper,
      UrlResolver,
      StyleUrlResolver,
      isBlank,
      isPresent,
      RegExpWrapper,
      StringWrapper,
      isPromise,
      PromiseWrapper,
      StyleInliner,
      _importRe,
      _urlRe,
      _mediaQueryRe;
  function _extractUrl(importRule) {
    var match = RegExpWrapper.firstMatch(_urlRe, importRule);
    if (isBlank(match))
      return null;
    return isPresent(match[1]) ? match[1] : match[2];
  }
  function _extractMediaQuery(importRule) {
    var match = RegExpWrapper.firstMatch(_mediaQueryRe, importRule);
    if (isBlank(match))
      return null;
    var mediaQuery = match[1].trim();
    return (mediaQuery.length > 0) ? mediaQuery : null;
  }
  function _wrapInMediaRule(css, query) {
    return (isBlank(query)) ? css : ("@media " + query + " {\n" + css + "\n}");
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
      isPromise = $__m.isPromise;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      StyleInliner = (($traceurRuntime.createClass)(function(_xhr, _styleUrlResolver, _urlResolver) {
        this._xhr = _xhr;
        this._styleUrlResolver = _styleUrlResolver;
        this._urlResolver = _urlResolver;
      }, {
        inlineImports: function(cssText, baseUrl) {
          return this._inlineImports(cssText, baseUrl, []);
        },
        _inlineImports: function(cssText, baseUrl, inlinedUrls) {
          var $__0 = this;
          var partIndex = 0;
          var parts = StringWrapper.split(cssText, _importRe);
          if (parts.length === 1) {
            return cssText;
          }
          var promises = [];
          while (partIndex < parts.length - 1) {
            var prefix = parts[partIndex];
            var rule = parts[partIndex + 1];
            var url = _extractUrl(rule);
            if (isPresent(url)) {
              url = this._urlResolver.resolve(baseUrl, url);
            }
            var mediaQuery = _extractMediaQuery(rule);
            var promise = void 0;
            if (isBlank(url)) {
              promise = PromiseWrapper.resolve(("/* Invalid import rule: \"@import " + rule + ";\" */"));
            } else if (ListWrapper.contains(inlinedUrls, url)) {
              promise = PromiseWrapper.resolve(prefix);
            } else {
              inlinedUrls.push(url);
              promise = PromiseWrapper.then(this._xhr.get(url), (function(rawCss) {
                var inlinedCss = $__0._inlineImports(rawCss, url, inlinedUrls);
                if (isPromise(inlinedCss)) {
                  return inlinedCss.then((function(css) {
                    return prefix + $__0._transformImportedCss(css, mediaQuery, url) + '\n';
                  }));
                } else {
                  return prefix + $__0._transformImportedCss(inlinedCss, mediaQuery, url) + '\n';
                }
              }), (function(error) {
                return ("/* failed to import " + url + " */\n");
              }));
            }
            promises.push(promise);
            partIndex += 2;
          }
          return PromiseWrapper.all(promises).then(function(cssParts) {
            var cssText = cssParts.join('');
            if (partIndex < parts.length) {
              cssText += parts[partIndex];
            }
            return cssText;
          });
        },
        _transformImportedCss: function(css, mediaQuery, url) {
          css = this._styleUrlResolver.resolveUrls(css, url);
          return _wrapInMediaRule(css, mediaQuery);
        }
      }, {}));
      $__export("StyleInliner", StyleInliner);
      $__export("StyleInliner", StyleInliner = __decorate([Injectable(), __metadata('design:paramtypes', [XHR, StyleUrlResolver, UrlResolver])], StyleInliner));
      _importRe = /@import\s+([^;]+);/g;
      _urlRe = RegExpWrapper.create('url\\(\\s*?[\'"]?([^\'")]+)[\'"]?|' + '[\'"]([^\'")]+)[\'"]');
      _mediaQueryRe = /['"][^'"]+['"]\s*\)?\s*(.*)/g;
    }
  };
});

System.register("angular2/src/render/dom/events/hammer_gestures", ["angular2/src/render/dom/events/hammer_common", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/hammer_gestures";
  var HammerGesturesPluginCommon,
      isPresent,
      BaseException,
      HammerGesturesPlugin;
  return {
    setters: [function($__m) {
      HammerGesturesPluginCommon = $__m.HammerGesturesPluginCommon;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      HammerGesturesPlugin = (function($__super) {
        function HammerGesturesPlugin() {
          $traceurRuntime.superConstructor(HammerGesturesPlugin).call(this);
        }
        return ($traceurRuntime.createClass)(HammerGesturesPlugin, {
          supports: function(eventName) {
            if (!$traceurRuntime.superGet(this, HammerGesturesPlugin.prototype, "supports").call(this, eventName))
              return false;
            if (!isPresent(window['Hammer'])) {
              throw new BaseException(("Hammer.js is not loaded, can not bind " + eventName + " event"));
            }
            return true;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            if (shouldSupportBubble)
              throw new BaseException('Hammer.js plugin does not support bubbling gestures.');
            var zone = this.manager.getZone();
            eventName = eventName.toLowerCase();
            zone.runOutsideAngular(function() {
              var mc = new Hammer(element);
              mc.get('pinch').set({enable: true});
              mc.get('rotate').set({enable: true});
              mc.on(eventName, function(eventObj) {
                zone.run(function() {
                  handler(eventObj);
                });
              });
            });
          }
        }, {}, $__super);
      }(HammerGesturesPluginCommon));
      $__export("HammerGesturesPlugin", HammerGesturesPlugin);
    }
  };
});

System.register("angular2/src/core/testability/testability", ["angular2/di", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/testability/get_testability", "angular2/src/core/zone/ng_zone", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/testability/testability";
  var __decorate,
      __metadata,
      Injectable,
      DOM,
      Map,
      MapWrapper,
      BaseException,
      getTestabilityModule,
      NgZone,
      PromiseWrapper,
      Testability,
      TestabilityRegistry;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      BaseException = $__m.BaseException;
    }, function($__m) {
      getTestabilityModule = $__m;
    }, function($__m) {
      NgZone = $__m.NgZone;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Testability = (($traceurRuntime.createClass)(function(_ngZone) {
        this._ngZone = _ngZone;
        this._pendingCount = 0;
        this._callbacks = [];
        this._isAngularEventPending = false;
        this._watchAngularEvents(_ngZone);
      }, {
        _watchAngularEvents: function(_ngZone) {
          var $__0 = this;
          _ngZone.overrideOnTurnStart((function() {
            $__0._isAngularEventPending = true;
          }));
          _ngZone.overrideOnEventDone((function() {
            $__0._isAngularEventPending = false;
            $__0._runCallbacksIfReady();
          }), true);
        },
        increasePendingRequestCount: function() {
          this._pendingCount += 1;
          return this._pendingCount;
        },
        decreasePendingRequestCount: function() {
          this._pendingCount -= 1;
          if (this._pendingCount < 0) {
            throw new BaseException('pending async requests below zero');
          }
          this._runCallbacksIfReady();
          return this._pendingCount;
        },
        _runCallbacksIfReady: function() {
          var $__0 = this;
          if (this._pendingCount != 0 || this._isAngularEventPending) {
            return ;
          }
          PromiseWrapper.resolve(null).then((function(_) {
            while ($__0._callbacks.length !== 0) {
              ($__0._callbacks.pop())();
            }
          }));
        },
        whenStable: function(callback) {
          this._callbacks.push(callback);
          this._runCallbacksIfReady();
        },
        getPendingRequestCount: function() {
          return this._pendingCount;
        },
        isAngularEventPending: function() {
          return this._isAngularEventPending;
        },
        findBindings: function(using, binding, exactMatch) {
          return [];
        }
      }, {}));
      $__export("Testability", Testability);
      $__export("Testability", Testability = __decorate([Injectable(), __metadata('design:paramtypes', [NgZone])], Testability));
      TestabilityRegistry = (($traceurRuntime.createClass)(function() {
        this._applications = new Map();
        getTestabilityModule.GetTestability.addToWindow(this);
      }, {
        registerApplication: function(token, testability) {
          this._applications.set(token, testability);
        },
        getAllTestabilities: function() {
          return MapWrapper.values(this._applications);
        },
        findTestabilityInTree: function(elem) {
          var findInAncestors = arguments[1] !== (void 0) ? arguments[1] : true;
          if (elem == null) {
            return null;
          }
          if (this._applications.has(elem)) {
            return this._applications.get(elem);
          } else if (!findInAncestors) {
            return null;
          }
          if (DOM.isShadowRoot(elem)) {
            return this.findTestabilityInTree(DOM.getHost(elem));
          }
          return this.findTestabilityInTree(DOM.parentElement(elem));
        }
      }, {}));
      $__export("TestabilityRegistry", TestabilityRegistry);
      $__export("TestabilityRegistry", TestabilityRegistry = __decorate([Injectable(), __metadata('design:paramtypes', [])], TestabilityRegistry));
    }
  };
});

System.register("angular2/src/render/dom/view/shared_styles_host", ["angular2/src/dom/dom_adapter", "angular2/di", "angular2/src/facade/collection", "angular2/src/render/dom/dom_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/shared_styles_host";
  var __decorate,
      __metadata,
      __param,
      DOM,
      Inject,
      Injectable,
      SetWrapper,
      DOCUMENT,
      SharedStylesHost,
      DomSharedStylesHost;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
    }, function($__m) {
      SetWrapper = $__m.SetWrapper;
    }, function($__m) {
      DOCUMENT = $__m.DOCUMENT;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      SharedStylesHost = (($traceurRuntime.createClass)(function() {
        this._styles = [];
        this._stylesSet = new Set();
      }, {
        addStyles: function(styles) {
          var $__0 = this;
          var additions = [];
          styles.forEach((function(style) {
            if (!SetWrapper.has($__0._stylesSet, style)) {
              $__0._stylesSet.add(style);
              $__0._styles.push(style);
              additions.push(style);
            }
          }));
          this.onStylesAdded(additions);
        },
        onStylesAdded: function(additions) {},
        getAllStyles: function() {
          return this._styles;
        }
      }, {}));
      $__export("SharedStylesHost", SharedStylesHost);
      $__export("SharedStylesHost", SharedStylesHost = __decorate([Injectable(), __metadata('design:paramtypes', [])], SharedStylesHost));
      DomSharedStylesHost = (function($__super) {
        function $__1(doc) {
          $traceurRuntime.superConstructor($__1).call(this);
          this._hostNodes = new Set();
          this._hostNodes.add(doc.head);
        }
        return ($traceurRuntime.createClass)($__1, {
          _addStylesToHost: function(styles, host) {
            for (var i = 0; i < styles.length; i++) {
              var style = styles[i];
              DOM.appendChild(host, DOM.createStyleElement(style));
            }
          },
          addHost: function(hostNode) {
            this._addStylesToHost(this._styles, hostNode);
            this._hostNodes.add(hostNode);
          },
          removeHost: function(hostNode) {
            SetWrapper.delete(this._hostNodes, hostNode);
          },
          onStylesAdded: function(additions) {
            var $__0 = this;
            this._hostNodes.forEach((function(hostNode) {
              $__0._addStylesToHost(additions, hostNode);
            }));
          }
        }, {}, $__super);
      }(SharedStylesHost));
      $__export("DomSharedStylesHost", DomSharedStylesHost);
      $__export("DomSharedStylesHost", DomSharedStylesHost = __decorate([Injectable(), __param(0, Inject(DOCUMENT)), __metadata('design:paramtypes', [Object])], DomSharedStylesHost));
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view_builder", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/change_detection/change_detection", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/element_binder", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view_builder";
  var isPresent,
      isBlank,
      BaseException,
      StringWrapper,
      ListWrapper,
      MapWrapper,
      Set,
      SetWrapper,
      DOM,
      ASTWithSource,
      AstTransformer,
      PropertyRead,
      LiteralArray,
      ImplicitReceiver,
      DomProtoView,
      DomProtoViewRef,
      DomElementBinder,
      Event,
      ViewType,
      ViewEncapsulation,
      ProtoViewDto,
      DirectiveBinder,
      RenderElementBinder,
      EventBinding,
      ElementPropertyBinding,
      PropertyBindingType,
      NG_BINDING_CLASS,
      EVENT_TARGET_SEPARATOR,
      queryBoundTextNodeIndices,
      camelCaseToDashCase,
      ProtoViewBuilder,
      ElementBinderBuilder,
      DirectiveBuilder,
      EventBuilder,
      PROPERTY_PARTS_SEPARATOR,
      ATTRIBUTE_PREFIX,
      CLASS_PREFIX,
      STYLE_PREFIX;
  function buildElementPropertyBindings(schemaRegistry, protoElement, isNgComponent, bindingsInTemplate, directiveTemplatePropertyNames) {
    var propertyBindings = [];
    MapWrapper.forEach(bindingsInTemplate, (function(ast, propertyNameInTemplate) {
      var propertyBinding = createElementPropertyBinding(schemaRegistry, ast, propertyNameInTemplate);
      if (isPresent(directiveTemplatePropertyNames) && SetWrapper.has(directiveTemplatePropertyNames, propertyNameInTemplate)) {} else if (isValidElementPropertyBinding(schemaRegistry, protoElement, isNgComponent, propertyBinding)) {
        propertyBindings.push(propertyBinding);
      } else {
        var exMsg = ("Can't bind to '" + propertyNameInTemplate + "' since it isn't a known property of the '<" + DOM.tagName(protoElement).toLowerCase() + ">' element");
        if (isPresent(directiveTemplatePropertyNames)) {
          exMsg += ' and there are no matching directives with a corresponding property';
        }
        throw new BaseException(exMsg);
      }
    }));
    return propertyBindings;
  }
  function isValidElementPropertyBinding(schemaRegistry, protoElement, isNgComponent, binding) {
    if (binding.type === PropertyBindingType.PROPERTY) {
      if (!isNgComponent) {
        return schemaRegistry.hasProperty(protoElement, binding.property);
      } else {
        return DOM.hasProperty(protoElement, binding.property);
      }
    }
    return true;
  }
  function createElementPropertyBinding(schemaRegistry, ast, propertyNameInTemplate) {
    var parts = StringWrapper.split(propertyNameInTemplate, PROPERTY_PARTS_SEPARATOR);
    if (parts.length === 1) {
      var propName = schemaRegistry.getMappedPropName(parts[0]);
      return new ElementPropertyBinding(PropertyBindingType.PROPERTY, ast, propName);
    } else if (parts[0] == ATTRIBUTE_PREFIX) {
      return new ElementPropertyBinding(PropertyBindingType.ATTRIBUTE, ast, parts[1]);
    } else if (parts[0] == CLASS_PREFIX) {
      return new ElementPropertyBinding(PropertyBindingType.CLASS, ast, camelCaseToDashCase(parts[1]));
    } else if (parts[0] == STYLE_PREFIX) {
      var unit = parts.length > 2 ? parts[2] : null;
      return new ElementPropertyBinding(PropertyBindingType.STYLE, ast, parts[1], unit);
    } else {
      throw new BaseException(("Invalid property name " + propertyNameInTemplate));
    }
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Set = $__m.Set;
      SetWrapper = $__m.SetWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ASTWithSource = $__m.ASTWithSource;
      AstTransformer = $__m.AstTransformer;
      PropertyRead = $__m.PropertyRead;
      LiteralArray = $__m.LiteralArray;
      ImplicitReceiver = $__m.ImplicitReceiver;
    }, function($__m) {
      DomProtoView = $__m.DomProtoView;
      DomProtoViewRef = $__m.DomProtoViewRef;
    }, function($__m) {
      DomElementBinder = $__m.DomElementBinder;
      Event = $__m.Event;
    }, function($__m) {
      ViewType = $__m.ViewType;
      ViewEncapsulation = $__m.ViewEncapsulation;
      ProtoViewDto = $__m.ProtoViewDto;
      DirectiveBinder = $__m.DirectiveBinder;
      RenderElementBinder = $__m.RenderElementBinder;
      EventBinding = $__m.EventBinding;
      ElementPropertyBinding = $__m.ElementPropertyBinding;
      PropertyBindingType = $__m.PropertyBindingType;
    }, function($__m) {
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
      EVENT_TARGET_SEPARATOR = $__m.EVENT_TARGET_SEPARATOR;
      queryBoundTextNodeIndices = $__m.queryBoundTextNodeIndices;
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }],
    execute: function() {
      ProtoViewBuilder = (function() {
        function ProtoViewBuilder(rootElement, type, viewEncapsulation) {
          this.rootElement = rootElement;
          this.type = type;
          this.viewEncapsulation = viewEncapsulation;
          this.variableBindings = new Map();
          this.elements = [];
          this.rootTextBindings = new Map();
          this.ngContentCount = 0;
          this.hostAttributes = new Map();
        }
        return ($traceurRuntime.createClass)(ProtoViewBuilder, {
          bindElement: function(element) {
            var description = arguments[1] !== (void 0) ? arguments[1] : null;
            var builder = new ElementBinderBuilder(this.elements.length, element, description);
            this.elements.push(builder);
            DOM.addClass(element, NG_BINDING_CLASS);
            return builder;
          },
          bindVariable: function(name, value) {
            this.variableBindings.set(value, name);
          },
          bindRootText: function(textNode, expression) {
            this.rootTextBindings.set(textNode, expression);
          },
          bindNgContent: function() {
            this.ngContentCount++;
          },
          setHostAttribute: function(name, value) {
            this.hostAttributes.set(name, value);
          },
          build: function(schemaRegistry, templateCloner) {
            var domElementBinders = [];
            var apiElementBinders = [];
            var textNodeExpressions = [];
            var rootTextNodeIndices = [];
            var transitiveNgContentCount = this.ngContentCount;
            queryBoundTextNodeIndices(DOM.content(this.rootElement), this.rootTextBindings, (function(node, nodeIndex, expression) {
              textNodeExpressions.push(expression);
              rootTextNodeIndices.push(nodeIndex);
            }));
            ListWrapper.forEach(this.elements, (function(ebb) {
              var directiveTemplatePropertyNames = new Set();
              var apiDirectiveBinders = ListWrapper.map(ebb.directives, (function(dbb) {
                ebb.eventBuilder.merge(dbb.eventBuilder);
                ListWrapper.forEach(dbb.templatePropertyNames, (function(name) {
                  return directiveTemplatePropertyNames.add(name);
                }));
                return new DirectiveBinder({
                  directiveIndex: dbb.directiveIndex,
                  propertyBindings: dbb.propertyBindings,
                  eventBindings: dbb.eventBindings,
                  hostPropertyBindings: buildElementPropertyBindings(schemaRegistry, ebb.element, true, dbb.hostPropertyBindings, null)
                });
              }));
              var nestedProtoView = isPresent(ebb.nestedProtoView) ? ebb.nestedProtoView.build(schemaRegistry, templateCloner) : null;
              if (isPresent(nestedProtoView)) {
                transitiveNgContentCount += nestedProtoView.transitiveNgContentCount;
              }
              var parentIndex = isPresent(ebb.parent) ? ebb.parent.index : -1;
              var textNodeIndices = [];
              queryBoundTextNodeIndices(ebb.element, ebb.textBindings, (function(node, nodeIndex, expression) {
                textNodeExpressions.push(expression);
                textNodeIndices.push(nodeIndex);
              }));
              apiElementBinders.push(new RenderElementBinder({
                index: ebb.index,
                parentIndex: parentIndex,
                distanceToParent: ebb.distanceToParent,
                directives: apiDirectiveBinders,
                nestedProtoView: nestedProtoView,
                propertyBindings: buildElementPropertyBindings(schemaRegistry, ebb.element, isPresent(ebb.componentId), ebb.propertyBindings, directiveTemplatePropertyNames),
                variableBindings: ebb.variableBindings,
                eventBindings: ebb.eventBindings,
                readAttributes: ebb.readAttributes
              }));
              domElementBinders.push(new DomElementBinder({
                textNodeIndices: textNodeIndices,
                hasNestedProtoView: isPresent(nestedProtoView) || isPresent(ebb.componentId),
                hasNativeShadowRoot: false,
                eventLocals: new LiteralArray(ebb.eventBuilder.buildEventLocals()),
                localEvents: ebb.eventBuilder.buildLocalEvents(),
                globalEvents: ebb.eventBuilder.buildGlobalEvents()
              }));
            }));
            var rootNodeCount = DOM.childNodes(DOM.content(this.rootElement)).length;
            return new ProtoViewDto({
              render: new DomProtoViewRef(DomProtoView.create(templateCloner, this.type, this.rootElement, this.viewEncapsulation, [rootNodeCount], rootTextNodeIndices, domElementBinders, this.hostAttributes)),
              type: this.type,
              elementBinders: apiElementBinders,
              variableBindings: this.variableBindings,
              textBindings: textNodeExpressions,
              transitiveNgContentCount: transitiveNgContentCount
            });
          }
        }, {});
      }());
      $__export("ProtoViewBuilder", ProtoViewBuilder);
      ElementBinderBuilder = (function() {
        function ElementBinderBuilder(index, element, description) {
          this.index = index;
          this.element = element;
          this.parent = null;
          this.distanceToParent = 0;
          this.directives = [];
          this.nestedProtoView = null;
          this.propertyBindings = new Map();
          this.variableBindings = new Map();
          this.eventBindings = [];
          this.eventBuilder = new EventBuilder();
          this.textBindings = new Map();
          this.readAttributes = new Map();
          this.componentId = null;
        }
        return ($traceurRuntime.createClass)(ElementBinderBuilder, {
          setParent: function(parent, distanceToParent) {
            this.parent = parent;
            if (isPresent(parent)) {
              this.distanceToParent = distanceToParent;
            }
            return this;
          },
          readAttribute: function(attrName) {
            if (isBlank(this.readAttributes.get(attrName))) {
              this.readAttributes.set(attrName, DOM.getAttribute(this.element, attrName));
            }
          },
          bindDirective: function(directiveIndex) {
            var directive = new DirectiveBuilder(directiveIndex);
            this.directives.push(directive);
            return directive;
          },
          bindNestedProtoView: function(rootElement) {
            if (isPresent(this.nestedProtoView)) {
              throw new BaseException('Only one nested view per element is allowed');
            }
            this.nestedProtoView = new ProtoViewBuilder(rootElement, ViewType.EMBEDDED, ViewEncapsulation.NONE);
            return this.nestedProtoView;
          },
          bindProperty: function(name, expression) {
            this.propertyBindings.set(name, expression);
          },
          bindVariable: function(name, value) {
            if (isPresent(this.nestedProtoView)) {
              this.nestedProtoView.bindVariable(name, value);
            } else {
              this.variableBindings.set(value, name);
            }
          },
          bindEvent: function(name, expression) {
            var target = arguments[2] !== (void 0) ? arguments[2] : null;
            this.eventBindings.push(this.eventBuilder.add(name, expression, target));
          },
          bindText: function(textNode, expression) {
            this.textBindings.set(textNode, expression);
          },
          setComponentId: function(componentId) {
            this.componentId = componentId;
          }
        }, {});
      }());
      $__export("ElementBinderBuilder", ElementBinderBuilder);
      DirectiveBuilder = (function() {
        function DirectiveBuilder(directiveIndex) {
          this.directiveIndex = directiveIndex;
          this.propertyBindings = new Map();
          this.templatePropertyNames = [];
          this.hostPropertyBindings = new Map();
          this.eventBindings = [];
          this.eventBuilder = new EventBuilder();
        }
        return ($traceurRuntime.createClass)(DirectiveBuilder, {
          bindProperty: function(name, expression, elProp) {
            this.propertyBindings.set(name, expression);
            if (isPresent(elProp)) {
              this.templatePropertyNames.push(elProp);
            }
          },
          bindHostProperty: function(name, expression) {
            this.hostPropertyBindings.set(name, expression);
          },
          bindEvent: function(name, expression) {
            var target = arguments[2] !== (void 0) ? arguments[2] : null;
            this.eventBindings.push(this.eventBuilder.add(name, expression, target));
          }
        }, {});
      }());
      $__export("DirectiveBuilder", DirectiveBuilder);
      EventBuilder = (function($__super) {
        function EventBuilder() {
          $traceurRuntime.superConstructor(EventBuilder).call(this);
          this.locals = [];
          this.localEvents = [];
          this.globalEvents = [];
          this._implicitReceiver = new ImplicitReceiver();
        }
        return ($traceurRuntime.createClass)(EventBuilder, {
          add: function(name, source, target) {
            var adjustedAst = source.ast;
            var fullName = isPresent(target) ? target + EVENT_TARGET_SEPARATOR + name : name;
            var result = new EventBinding(fullName, new ASTWithSource(adjustedAst, source.source, source.location));
            var event = new Event(name, target, fullName);
            if (isBlank(target)) {
              this.localEvents.push(event);
            } else {
              this.globalEvents.push(event);
            }
            return result;
          },
          visitPropertyRead: function(ast) {
            var isEventAccess = false;
            var current = ast;
            while (!isEventAccess && (current instanceof PropertyRead)) {
              var am = current;
              if (am.name == '$event') {
                isEventAccess = true;
              }
              current = am.receiver;
            }
            if (isEventAccess) {
              this.locals.push(ast);
              var index = this.locals.length - 1;
              return new PropertyRead(this._implicitReceiver, ("" + index), (function(arr) {
                return arr[index];
              }));
            } else {
              return ast;
            }
          },
          buildEventLocals: function() {
            return this.locals;
          },
          buildLocalEvents: function() {
            return this.localEvents;
          },
          buildGlobalEvents: function() {
            return this.globalEvents;
          },
          merge: function(eventBuilder) {
            this._merge(this.localEvents, eventBuilder.localEvents);
            this._merge(this.globalEvents, eventBuilder.globalEvents);
            ListWrapper.concat(this.locals, eventBuilder.locals);
          },
          _merge: function(host, tobeAdded) {
            var names = [];
            for (var i = 0; i < host.length; i++) {
              names.push(host[i].fullName);
            }
            for (var j = 0; j < tobeAdded.length; j++) {
              if (!ListWrapper.contains(names, tobeAdded[j].fullName)) {
                host.push(tobeAdded[j]);
              }
            }
          }
        }, {}, $__super);
      }(AstTransformer));
      PROPERTY_PARTS_SEPARATOR = new RegExp('\\.');
      ATTRIBUTE_PREFIX = 'attr';
      CLASS_PREFIX = 'class';
      STYLE_PREFIX = 'style';
    }
  };
});

System.register("angular2/src/render/dom/compiler/directive_parser", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/compiler/selector", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/directive_parser";
  var isPresent,
      isBlank,
      BaseException,
      StringWrapper,
      MapWrapper,
      ListWrapper,
      DOM,
      SelectorMatcher,
      CssSelector,
      RenderDirectiveMetadata,
      EventConfig,
      dashCaseToCamelCase,
      camelCaseToDashCase,
      DirectiveParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      SelectorMatcher = $__m.SelectorMatcher;
      CssSelector = $__m.CssSelector;
    }, function($__m) {
      RenderDirectiveMetadata = $__m.RenderDirectiveMetadata;
    }, function($__m) {
      EventConfig = $__m.EventConfig;
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }],
    execute: function() {
      DirectiveParser = (function() {
        function DirectiveParser(_parser, _directives) {
          this._parser = _parser;
          this._directives = _directives;
          this._selectorMatcher = new SelectorMatcher();
          for (var i = 0; i < _directives.length; i++) {
            var directive = _directives[i];
            var selector = CssSelector.parse(directive.selector);
            this._selectorMatcher.addSelectables(selector, i);
          }
        }
        return ($traceurRuntime.createClass)(DirectiveParser, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            var $__0 = this;
            var attrs = current.attrs();
            var classList = current.classList();
            var cssSelector = new CssSelector();
            var foundDirectiveIndices = [];
            var elementBinder = null;
            cssSelector.setElement(DOM.nodeName(current.element));
            for (var i = 0; i < classList.length; i++) {
              cssSelector.addClassName(classList[i]);
            }
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              cssSelector.addAttribute(attrName, attrValue);
            }));
            this._selectorMatcher.match(cssSelector, (function(selector, directiveIndex) {
              var directive = $__0._directives[directiveIndex];
              elementBinder = current.bindElement();
              if (directive.type === RenderDirectiveMetadata.COMPONENT_TYPE) {
                $__0._ensureHasOnlyOneComponent(elementBinder, current.elementDescription);
                ListWrapper.insert(foundDirectiveIndices, 0, directiveIndex);
                elementBinder.setComponentId(directive.id);
              } else {
                foundDirectiveIndices.push(directiveIndex);
              }
            }));
            ListWrapper.forEach(foundDirectiveIndices, (function(directiveIndex) {
              var dirMetadata = $__0._directives[directiveIndex];
              var directiveBinderBuilder = elementBinder.bindDirective(directiveIndex);
              current.compileChildren = current.compileChildren && dirMetadata.compileChildren;
              if (isPresent(dirMetadata.properties)) {
                ListWrapper.forEach(dirMetadata.properties, (function(bindConfig) {
                  $__0._bindDirectiveProperty(bindConfig, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(dirMetadata.hostListeners)) {
                $__0._sortedKeysForEach(dirMetadata.hostListeners, (function(action, eventName) {
                  $__0._bindDirectiveEvent(eventName, action, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(dirMetadata.hostProperties)) {
                $__0._sortedKeysForEach(dirMetadata.hostProperties, (function(expression, hostPropertyName) {
                  $__0._bindHostProperty(hostPropertyName, expression, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(dirMetadata.hostAttributes)) {
                $__0._sortedKeysForEach(dirMetadata.hostAttributes, (function(hostAttrValue, hostAttrName) {
                  $__0._addHostAttribute(hostAttrName, hostAttrValue, current);
                }));
              }
              if (isPresent(dirMetadata.readAttributes)) {
                ListWrapper.forEach(dirMetadata.readAttributes, (function(attrName) {
                  elementBinder.readAttribute(attrName);
                }));
              }
            }));
          },
          _sortedKeysForEach: function(map, fn) {
            var keys = MapWrapper.keys(map);
            ListWrapper.sort(keys, (function(a, b) {
              var compareVal = StringWrapper.compare(a, b);
              return compareVal == 0 ? -1 : compareVal;
            }));
            ListWrapper.forEach(keys, (function(key) {
              fn(MapWrapper.get(map, key), key);
            }));
          },
          _ensureHasOnlyOneComponent: function(elementBinder, elDescription) {
            if (isPresent(elementBinder.componentId)) {
              throw new BaseException(("Only one component directive is allowed per element - check " + elDescription));
            }
          },
          _bindDirectiveProperty: function(bindConfig, compileElement, directiveBinderBuilder) {
            var dirProperty;
            var elProp;
            var pipes;
            var assignIndex = bindConfig.indexOf(':');
            if (assignIndex > -1) {
              dirProperty = StringWrapper.substring(bindConfig, 0, assignIndex).trim();
              pipes = this._splitBindConfig(StringWrapper.substring(bindConfig, assignIndex + 1));
              elProp = ListWrapper.removeAt(pipes, 0);
            } else {
              dirProperty = bindConfig;
              elProp = bindConfig;
              pipes = [];
            }
            elProp = dashCaseToCamelCase(elProp);
            var bindingAst = compileElement.bindElement().propertyBindings.get(elProp);
            if (isBlank(bindingAst)) {
              var attributeValue = compileElement.attrs().get(camelCaseToDashCase(elProp));
              if (isPresent(attributeValue)) {
                bindingAst = this._parser.wrapLiteralPrimitive(attributeValue, compileElement.elementDescription);
              }
            }
            if (isPresent(bindingAst)) {
              directiveBinderBuilder.bindProperty(dirProperty, bindingAst, elProp);
            }
          },
          _bindDirectiveEvent: function(eventName, action, compileElement, directiveBinderBuilder) {
            var ast = this._parser.parseAction(action, compileElement.elementDescription);
            var parsedEvent = EventConfig.parse(eventName);
            var targetName = parsedEvent.isLongForm ? parsedEvent.fieldName : null;
            directiveBinderBuilder.bindEvent(parsedEvent.eventName, ast, targetName);
          },
          _bindHostProperty: function(hostPropertyName, expression, compileElement, directiveBinderBuilder) {
            var ast = this._parser.parseSimpleBinding(expression, ("hostProperties of " + compileElement.elementDescription));
            directiveBinderBuilder.bindHostProperty(hostPropertyName, ast);
          },
          _addHostAttribute: function(attrName, attrValue, compileElement) {
            if (StringWrapper.equals(attrName, 'class')) {
              ListWrapper.forEach(attrValue.split(' '), (function(className) {
                DOM.addClass(compileElement.element, className);
              }));
            } else if (!DOM.hasAttribute(compileElement.element, attrName)) {
              DOM.setAttribute(compileElement.element, attrName, attrValue);
            }
          },
          _splitBindConfig: function(bindConfig) {
            return ListWrapper.map(bindConfig.split('|'), (function(s) {
              return s.trim();
            }));
          }
        }, {});
      }());
      $__export("DirectiveParser", DirectiveParser);
    }
  };
});

System.register("angular2/src/render/dom/compiler/style_encapsulator", ["angular2/src/render/api", "angular2/src/render/dom/util", "angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/render/dom/compiler/shadow_css"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/style_encapsulator";
  var ViewEncapsulation,
      ViewType,
      NG_CONTENT_ELEMENT_NAME,
      isElementWithTag,
      DOM,
      isBlank,
      isPresent,
      ShadowCss,
      StyleEncapsulator;
  function getHostAttribute(compId) {
    return ("_nghost-" + compId);
  }
  function getContentAttribute(compId) {
    return ("_ngcontent-" + compId);
  }
  return {
    setters: [function($__m) {
      ViewEncapsulation = $__m.ViewEncapsulation;
      ViewType = $__m.ViewType;
    }, function($__m) {
      NG_CONTENT_ELEMENT_NAME = $__m.NG_CONTENT_ELEMENT_NAME;
      isElementWithTag = $__m.isElementWithTag;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      ShadowCss = $__m.ShadowCss;
    }],
    execute: function() {
      StyleEncapsulator = (function() {
        function StyleEncapsulator(_appId, _view, _componentUIDsCache) {
          this._appId = _appId;
          this._view = _view;
          this._componentUIDsCache = _componentUIDsCache;
        }
        return ($traceurRuntime.createClass)(StyleEncapsulator, {
          processElement: function(parent, current, control) {
            if (isElementWithTag(current.element, NG_CONTENT_ELEMENT_NAME)) {
              current.inheritedProtoView.bindNgContent();
            } else {
              if (this._view.encapsulation === ViewEncapsulation.EMULATED) {
                this._processEmulatedScopedElement(current, parent);
              }
            }
          },
          processStyle: function(style) {
            var encapsulation = this._view.encapsulation;
            if (encapsulation === ViewEncapsulation.EMULATED) {
              return this._shimCssForComponent(style, this._view.componentId);
            } else {
              return style;
            }
          },
          _processEmulatedScopedElement: function(current, parent) {
            var element = current.element;
            var hostComponentId = this._view.componentId;
            var viewType = current.inheritedProtoView.type;
            if (viewType !== ViewType.HOST && isPresent(hostComponentId)) {
              var contentAttribute = getContentAttribute(this._getComponentId(hostComponentId));
              DOM.setAttribute(element, contentAttribute, '');
              if (isBlank(parent) && viewType == ViewType.COMPONENT) {
                var hostAttribute = getHostAttribute(this._getComponentId(hostComponentId));
                current.inheritedProtoView.setHostAttribute(hostAttribute, '');
              }
            }
          },
          _shimCssForComponent: function(cssText, componentId) {
            var id = this._getComponentId(componentId);
            var shadowCss = new ShadowCss();
            return shadowCss.shimCssText(cssText, getContentAttribute(id), getHostAttribute(id));
          },
          _getComponentId: function(componentStringId) {
            var id = this._componentUIDsCache.get(componentStringId);
            if (isBlank(id)) {
              id = (this._appId + "-" + this._componentUIDsCache.size);
              this._componentUIDsCache.set(componentStringId, id);
            }
            return id;
          }
        }, {});
      }());
      $__export("StyleEncapsulator", StyleEncapsulator);
    }
  };
});

System.register("angular2/src/render/dom/dom_renderer", ["angular2/di", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/view", "angular2/src/render/dom/view/fragment", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/render/dom/util", "angular2/src/profile/profile", "angular2/src/render/api", "angular2/src/render/dom/template_cloner", "angular2/src/render/dom/dom_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/dom_renderer";
  var __decorate,
      __metadata,
      __param,
      Inject,
      Injectable,
      isPresent,
      isBlank,
      BaseException,
      DOM,
      EventManager,
      resolveInternalDomProtoView,
      DomView,
      DomViewRef,
      resolveInternalDomView,
      DomFragmentRef,
      resolveInternalDomFragment,
      DomSharedStylesHost,
      cloneAndQueryProtoView,
      wtfLeave,
      wtfCreateScope,
      Renderer,
      RenderViewWithFragments,
      TemplateCloner,
      DOCUMENT,
      REFLECT_PREFIX,
      DomRenderer;
  function moveNodesAfterSibling(sibling, nodes) {
    if (nodes.length > 0 && isPresent(DOM.parentElement(sibling))) {
      for (var i = 0; i < nodes.length; i++) {
        DOM.insertBefore(sibling, nodes[i]);
      }
      DOM.insertBefore(nodes[nodes.length - 1], sibling);
    }
  }
  function moveChildNodes(source, target) {
    var currChild = DOM.firstChild(source);
    while (isPresent(currChild)) {
      var nextChild = DOM.nextSibling(currChild);
      DOM.appendChild(target, currChild);
      currChild = nextChild;
    }
  }
  return {
    setters: [function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      EventManager = $__m.EventManager;
    }, function($__m) {
      resolveInternalDomProtoView = $__m.resolveInternalDomProtoView;
    }, function($__m) {
      DomView = $__m.DomView;
      DomViewRef = $__m.DomViewRef;
      resolveInternalDomView = $__m.resolveInternalDomView;
    }, function($__m) {
      DomFragmentRef = $__m.DomFragmentRef;
      resolveInternalDomFragment = $__m.resolveInternalDomFragment;
    }, function($__m) {
      DomSharedStylesHost = $__m.DomSharedStylesHost;
    }, function($__m) {
      cloneAndQueryProtoView = $__m.cloneAndQueryProtoView;
    }, function($__m) {
      wtfLeave = $__m.wtfLeave;
      wtfCreateScope = $__m.wtfCreateScope;
    }, function($__m) {
      Renderer = $__m.Renderer;
      RenderViewWithFragments = $__m.RenderViewWithFragments;
    }, function($__m) {
      TemplateCloner = $__m.TemplateCloner;
    }, function($__m) {
      DOCUMENT = $__m.DOCUMENT;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      REFLECT_PREFIX = 'ng-reflect-';
      DomRenderer = (function($__super) {
        function $__0(_eventManager, _domSharedStylesHost, _templateCloner, document) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._eventManager = _eventManager;
          this._domSharedStylesHost = _domSharedStylesHost;
          this._templateCloner = _templateCloner;
          this._scope_createRootHostView = wtfCreateScope('DomRenderer#createRootHostView()');
          this._scope_createView = wtfCreateScope('DomRenderer#createView()');
          this._scope_detachFragment = wtfCreateScope('DomRenderer#detachFragment()');
          this._scope_setEventDispatcher = wtfCreateScope('DomRenderer#setEventDispatcher()');
          this._document = document;
        }
        return ($traceurRuntime.createClass)($__0, {
          createRootHostView: function(hostProtoViewRef, fragmentCount, hostElementSelector) {
            var s = this._scope_createRootHostView();
            var hostProtoView = resolveInternalDomProtoView(hostProtoViewRef);
            var element = DOM.querySelector(this._document, hostElementSelector);
            if (isBlank(element)) {
              wtfLeave(s);
              throw new BaseException(("The selector \"" + hostElementSelector + "\" did not match any elements"));
            }
            return wtfLeave(s, this._createView(hostProtoView, element));
          },
          createView: function(protoViewRef, fragmentCount) {
            var s = this._scope_createView();
            var protoView = resolveInternalDomProtoView(protoViewRef);
            return wtfLeave(s, this._createView(protoView, null));
          },
          destroyView: function(viewRef) {
            var view = resolveInternalDomView(viewRef);
            var elementBinders = view.proto.elementBinders;
            for (var i = 0; i < elementBinders.length; i++) {
              var binder = elementBinders[i];
              if (binder.hasNativeShadowRoot) {
                this._domSharedStylesHost.removeHost(DOM.getShadowRoot(view.boundElements[i]));
              }
            }
          },
          getNativeElementSync: function(location) {
            if (isBlank(location.renderBoundElementIndex)) {
              return null;
            }
            return resolveInternalDomView(location.renderView).boundElements[location.renderBoundElementIndex];
          },
          getRootNodes: function(fragment) {
            return resolveInternalDomFragment(fragment);
          },
          attachFragmentAfterFragment: function(previousFragmentRef, fragmentRef) {
            var previousFragmentNodes = resolveInternalDomFragment(previousFragmentRef);
            if (previousFragmentNodes.length > 0) {
              var sibling = previousFragmentNodes[previousFragmentNodes.length - 1];
              moveNodesAfterSibling(sibling, resolveInternalDomFragment(fragmentRef));
            }
          },
          attachFragmentAfterElement: function(elementRef, fragmentRef) {
            if (isBlank(elementRef.renderBoundElementIndex)) {
              return ;
            }
            var parentView = resolveInternalDomView(elementRef.renderView);
            var element = parentView.boundElements[elementRef.renderBoundElementIndex];
            moveNodesAfterSibling(element, resolveInternalDomFragment(fragmentRef));
          },
          detachFragment: function(fragmentRef) {
            var s = this._scope_detachFragment();
            var fragmentNodes = resolveInternalDomFragment(fragmentRef);
            for (var i = 0; i < fragmentNodes.length; i++) {
              DOM.remove(fragmentNodes[i]);
            }
            wtfLeave(s);
          },
          hydrateView: function(viewRef) {
            var view = resolveInternalDomView(viewRef);
            if (view.hydrated)
              throw new BaseException('The view is already hydrated.');
            view.hydrated = true;
            view.eventHandlerRemovers = [];
            var binders = view.proto.elementBinders;
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              if (isPresent(binder.globalEvents)) {
                for (var i = 0; i < binder.globalEvents.length; i++) {
                  var globalEvent = binder.globalEvents[i];
                  var remover = this._createGlobalEventListener(view, binderIdx, globalEvent.name, globalEvent.target, globalEvent.fullName);
                  view.eventHandlerRemovers.push(remover);
                }
              }
            }
          },
          dehydrateView: function(viewRef) {
            var view = resolveInternalDomView(viewRef);
            for (var i = 0; i < view.eventHandlerRemovers.length; i++) {
              view.eventHandlerRemovers[i]();
            }
            view.eventHandlerRemovers = null;
            view.hydrated = false;
          },
          setElementProperty: function(location, propertyName, propertyValue) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementProperty(location.renderBoundElementIndex, propertyName, propertyValue);
          },
          setElementAttribute: function(location, attributeName, attributeValue) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementAttribute(location.renderBoundElementIndex, attributeName, attributeValue);
          },
          setElementClass: function(location, className, isAdd) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementClass(location.renderBoundElementIndex, className, isAdd);
          },
          setElementStyle: function(location, styleName, styleValue) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementStyle(location.renderBoundElementIndex, styleName, styleValue);
          },
          invokeElementMethod: function(location, methodName, args) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.invokeElementMethod(location.renderBoundElementIndex, methodName, args);
          },
          setText: function(viewRef, textNodeIndex, text) {
            if (isBlank(textNodeIndex)) {
              return ;
            }
            var view = resolveInternalDomView(viewRef);
            DOM.setText(view.boundTextNodes[textNodeIndex], text);
          },
          setEventDispatcher: function(viewRef, dispatcher) {
            var s = this._scope_setEventDispatcher();
            var view = resolveInternalDomView(viewRef);
            view.eventDispatcher = dispatcher;
            wtfLeave(s);
          },
          _createView: function(protoView, inplaceElement) {
            var clonedProtoView = cloneAndQueryProtoView(this._templateCloner, protoView, true);
            var boundElements = clonedProtoView.boundElements;
            if (isPresent(inplaceElement)) {
              if (protoView.fragmentsRootNodeCount[0] !== 1) {
                throw new BaseException('Root proto views can only contain one element!');
              }
              DOM.clearNodes(inplaceElement);
              var tempRoot = clonedProtoView.fragments[0][0];
              moveChildNodes(tempRoot, inplaceElement);
              if (boundElements.length > 0 && boundElements[0] === tempRoot) {
                boundElements[0] = inplaceElement;
              }
              clonedProtoView.fragments[0][0] = inplaceElement;
            }
            var view = new DomView(protoView, clonedProtoView.boundTextNodes, boundElements);
            var binders = protoView.elementBinders;
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              var element = boundElements[binderIdx];
              if (binder.hasNativeShadowRoot) {
                var shadowRootWrapper = DOM.firstChild(element);
                var shadowRoot = DOM.createShadowRoot(element);
                this._domSharedStylesHost.addHost(shadowRoot);
                moveChildNodes(shadowRootWrapper, shadowRoot);
                DOM.remove(shadowRootWrapper);
              }
              if (isPresent(binder.eventLocals) && isPresent(binder.localEvents)) {
                for (var i = 0; i < binder.localEvents.length; i++) {
                  this._createEventListener(view, element, binderIdx, binder.localEvents[i].name, binder.eventLocals);
                }
              }
            }
            return new RenderViewWithFragments(new DomViewRef(view), clonedProtoView.fragments.map((function(nodes) {
              return new DomFragmentRef(nodes);
            })));
          },
          _createEventListener: function(view, element, elementIndex, eventName, eventLocals) {
            this._eventManager.addEventListener(element, eventName, (function(event) {
              view.dispatchEvent(elementIndex, eventName, event);
            }));
          },
          _createGlobalEventListener: function(view, elementIndex, eventName, eventTarget, fullName) {
            return this._eventManager.addGlobalEventListener(eventTarget, eventName, (function(event) {
              view.dispatchEvent(elementIndex, fullName, event);
            }));
          }
        }, {}, $__super);
      }(Renderer));
      $__export("DomRenderer", DomRenderer);
      $__export("DomRenderer", DomRenderer = __decorate([Injectable(), __param(3, Inject(DOCUMENT)), __metadata('design:paramtypes', [EventManager, DomSharedStylesHost, TemplateCloner, Object])], DomRenderer));
    }
  };
});

System.register("angular2/directives", ["angular2/src/facade/lang", "angular2/src/directives/ng_class", "angular2/src/directives/ng_for", "angular2/src/directives/ng_if", "angular2/src/directives/ng_non_bindable", "angular2/src/directives/ng_switch", "angular2/src/directives/ng_style"], function($__export) {
  "use strict";
  var __moduleName = "angular2/directives";
  var CONST_EXPR,
      NgClass,
      NgFor,
      NgIf,
      NgNonBindable,
      NgSwitch,
      NgSwitchWhen,
      NgSwitchDefault,
      CORE_DIRECTIVES;
  var $__exportNames = {CORE_DIRECTIVES: true};
  var $__exportNames = {CORE_DIRECTIVES: true};
  var $__exportNames = {CORE_DIRECTIVES: true};
  var $__exportNames = {CORE_DIRECTIVES: true};
  var $__exportNames = {CORE_DIRECTIVES: true};
  var $__exportNames = {CORE_DIRECTIVES: true};
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      NgClass = $__m.NgClass;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgFor = $__m.NgFor;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgIf = $__m.NgIf;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgNonBindable = $__m.NgNonBindable;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgSwitch = $__m.NgSwitch;
      NgSwitchWhen = $__m.NgSwitchWhen;
      NgSwitchDefault = $__m.NgSwitchDefault;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {
      CORE_DIRECTIVES = CONST_EXPR([NgClass, NgFor, NgIf, NgNonBindable, NgSwitch, NgSwitchWhen, NgSwitchDefault]);
      $__export("CORE_DIRECTIVES", CORE_DIRECTIVES);
    }
  };
});

System.register("angular2/src/forms/model", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/model";
  var StringWrapper,
      isPresent,
      isBlank,
      EventEmitter,
      ObservableWrapper,
      StringMapWrapper,
      ListWrapper,
      List,
      Validators,
      VALID,
      INVALID,
      AbstractControl,
      Control,
      ControlGroup,
      ControlArray;
  function isControl(c) {
    return c instanceof AbstractControl;
  }
  function _find(c, path) {
    if (isBlank(path))
      return null;
    if (!(path instanceof List)) {
      path = StringWrapper.split(path, new RegExp("/"));
    }
    if (path instanceof List && ListWrapper.isEmpty(path))
      return null;
    return ListWrapper.reduce(path, (function(v, name) {
      if (v instanceof ControlGroup) {
        return isPresent(v.controls[name]) ? v.controls[name] : null;
      } else if (v instanceof ControlArray) {
        var index = name;
        return isPresent(v.at(index)) ? v.at(index) : null;
      } else {
        return null;
      }
    }), c);
  }
  $__export("isControl", isControl);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
      VALID = "VALID";
      $__export("VALID", VALID);
      INVALID = "INVALID";
      $__export("INVALID", INVALID);
      AbstractControl = (function() {
        function AbstractControl(validator) {
          this.validator = validator;
          this._pristine = true;
          this._touched = false;
        }
        return ($traceurRuntime.createClass)(AbstractControl, {
          get value() {
            return this._value;
          },
          get status() {
            return this._status;
          },
          get valid() {
            return this._status === VALID;
          },
          get errors() {
            return this._errors;
          },
          get pristine() {
            return this._pristine;
          },
          get dirty() {
            return !this.pristine;
          },
          get touched() {
            return this._touched;
          },
          get untouched() {
            return !this._touched;
          },
          get valueChanges() {
            return this._valueChanges;
          },
          markAsTouched: function() {
            this._touched = true;
          },
          markAsDirty: function() {
            var onlySelf = (arguments[0] !== (void 0) ? arguments[0] : {}).onlySelf;
            onlySelf = isPresent(onlySelf) ? onlySelf : false;
            this._pristine = false;
            if (isPresent(this._parent) && !onlySelf) {
              this._parent.markAsDirty({onlySelf: onlySelf});
            }
          },
          setParent: function(parent) {
            this._parent = parent;
          },
          updateValidity: function() {
            var onlySelf = (arguments[0] !== (void 0) ? arguments[0] : {}).onlySelf;
            onlySelf = isPresent(onlySelf) ? onlySelf : false;
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
            if (isPresent(this._parent) && !onlySelf) {
              this._parent.updateValidity({onlySelf: onlySelf});
            }
          },
          updateValueAndValidity: function() {
            var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
                onlySelf = $__2.onlySelf,
                emitEvent = $__2.emitEvent;
            onlySelf = isPresent(onlySelf) ? onlySelf : false;
            emitEvent = isPresent(emitEvent) ? emitEvent : true;
            this._updateValue();
            if (emitEvent) {
              ObservableWrapper.callNext(this._valueChanges, this._value);
            }
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
            if (isPresent(this._parent) && !onlySelf) {
              this._parent.updateValueAndValidity({
                onlySelf: onlySelf,
                emitEvent: emitEvent
              });
            }
          },
          find: function(path) {
            return _find(this, path);
          },
          getError: function(errorCode) {
            var path = arguments[1] !== (void 0) ? arguments[1] : null;
            var c = isPresent(path) && !ListWrapper.isEmpty(path) ? this.find(path) : this;
            if (isPresent(c) && isPresent(c._errors)) {
              return StringMapWrapper.get(c._errors, errorCode);
            } else {
              return null;
            }
          },
          hasError: function(errorCode) {
            var path = arguments[1] !== (void 0) ? arguments[1] : null;
            return isPresent(this.getError(errorCode, path));
          },
          _updateValue: function() {}
        }, {});
      }());
      $__export("AbstractControl", AbstractControl);
      Control = (function($__super) {
        function Control() {
          var value = arguments[0] !== (void 0) ? arguments[0] : null;
          var validator = arguments[1] !== (void 0) ? arguments[1] : Validators.nullValidator;
          $traceurRuntime.superConstructor(Control).call(this, validator);
          this._value = value;
          this.updateValidity({onlySelf: true});
          this._valueChanges = new EventEmitter();
        }
        return ($traceurRuntime.createClass)(Control, {
          updateValue: function(value) {
            var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
                onlySelf = $__2.onlySelf,
                emitEvent = $__2.emitEvent,
                emitModelToViewChange = $__2.emitModelToViewChange;
            emitModelToViewChange = isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
            this._value = value;
            if (isPresent(this._onChange) && emitModelToViewChange)
              this._onChange(this._value);
            this.updateValueAndValidity({
              onlySelf: onlySelf,
              emitEvent: emitEvent
            });
          },
          registerOnChange: function(fn) {
            this._onChange = fn;
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("Control", Control);
      ControlGroup = (function($__super) {
        function ControlGroup(controls) {
          var optionals = arguments[1] !== (void 0) ? arguments[1] : null;
          var validator = arguments[2] !== (void 0) ? arguments[2] : Validators.group;
          $traceurRuntime.superConstructor(ControlGroup).call(this, validator);
          this.controls = controls;
          this._optionals = isPresent(optionals) ? optionals : {};
          this._valueChanges = new EventEmitter();
          this._setParentForControls();
          this._value = this._reduceValue();
          this.updateValidity({onlySelf: true});
        }
        return ($traceurRuntime.createClass)(ControlGroup, {
          addControl: function(name, c) {
            this.controls[name] = c;
            c.setParent(this);
          },
          removeControl: function(name) {
            StringMapWrapper.delete(this.controls, name);
          },
          include: function(controlName) {
            StringMapWrapper.set(this._optionals, controlName, true);
            this.updateValueAndValidity();
          },
          exclude: function(controlName) {
            StringMapWrapper.set(this._optionals, controlName, false);
            this.updateValueAndValidity();
          },
          contains: function(controlName) {
            var c = StringMapWrapper.contains(this.controls, controlName);
            return c && this._included(controlName);
          },
          _setParentForControls: function() {
            var $__0 = this;
            StringMapWrapper.forEach(this.controls, (function(control, name) {
              control.setParent($__0);
            }));
          },
          _updateValue: function() {
            this._value = this._reduceValue();
          },
          _reduceValue: function() {
            return this._reduceChildren({}, (function(acc, control, name) {
              acc[name] = control.value;
              return acc;
            }));
          },
          _reduceChildren: function(initValue, fn) {
            var $__0 = this;
            var res = initValue;
            StringMapWrapper.forEach(this.controls, (function(control, name) {
              if ($__0._included(name)) {
                res = fn(res, control, name);
              }
            }));
            return res;
          },
          _included: function(controlName) {
            var isOptional = StringMapWrapper.contains(this._optionals, controlName);
            return !isOptional || StringMapWrapper.get(this._optionals, controlName);
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("ControlGroup", ControlGroup);
      ControlArray = (function($__super) {
        function ControlArray(controls) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : Validators.array;
          $traceurRuntime.superConstructor(ControlArray).call(this, validator);
          this.controls = controls;
          this._valueChanges = new EventEmitter();
          this._setParentForControls();
          this._updateValue();
          this.updateValidity({onlySelf: true});
        }
        return ($traceurRuntime.createClass)(ControlArray, {
          at: function(index) {
            return this.controls[index];
          },
          push: function(control) {
            this.controls.push(control);
            control.setParent(this);
            this.updateValueAndValidity();
          },
          insert: function(index, control) {
            ListWrapper.insert(this.controls, index, control);
            control.setParent(this);
            this.updateValueAndValidity();
          },
          removeAt: function(index) {
            ListWrapper.removeAt(this.controls, index);
            this.updateValueAndValidity();
          },
          get length() {
            return this.controls.length;
          },
          _updateValue: function() {
            this._value = ListWrapper.map(this.controls, (function(c) {
              return c.value;
            }));
          },
          _setParentForControls: function() {
            var $__0 = this;
            ListWrapper.forEach(this.controls, (function(control) {
              control.setParent($__0);
            }));
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("ControlArray", ControlArray);
    }
  };
});

System.register("angular2/src/forms/directives/ng_control_name", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/core", "angular2/metadata", "angular2/di", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/ng_control", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_control_name";
  var __decorate,
      __metadata,
      __param,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      QueryList,
      Query,
      Directive,
      LifecycleEvent,
      forwardRef,
      Host,
      SkipSelf,
      Binding,
      ControlContainer,
      NgControl,
      NgValidator,
      controlPath,
      composeNgValidator,
      isPropertyUpdated,
      controlNameBinding,
      NgControlName;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Host = $__m.Host;
      SkipSelf = $__m.SkipSelf;
      Binding = $__m.Binding;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      NgValidator = $__m.NgValidator;
    }, function($__m) {
      controlPath = $__m.controlPath;
      composeNgValidator = $__m.composeNgValidator;
      isPropertyUpdated = $__m.isPropertyUpdated;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      controlNameBinding = CONST_EXPR(new Binding(NgControl, {toAlias: forwardRef((function() {
          return NgControlName;
        }))}));
      NgControlName = (function($__super) {
        function $__0(parent, ngValidators) {
          $traceurRuntime.superConstructor($__0).call(this);
          this.update = new EventEmitter();
          this._added = false;
          this._parent = parent;
          this.ngValidators = ngValidators;
        }
        return ($traceurRuntime.createClass)($__0, {
          onChange: function(c) {
            if (!this._added) {
              this.formDirective.addControl(this);
              this._added = true;
            }
            if (isPropertyUpdated(c, this.viewModel)) {
              this.viewModel = this.model;
              this.formDirective.updateModel(this, this.model);
            }
          },
          onDestroy: function() {
            this.formDirective.removeControl(this);
          },
          viewToModelUpdate: function(newValue) {
            this.viewModel = newValue;
            ObservableWrapper.callNext(this.update, newValue);
          },
          get path() {
            return controlPath(this.name, this._parent);
          },
          get formDirective() {
            return this._parent.formDirective;
          },
          get control() {
            return this.formDirective.getControl(this);
          },
          get validator() {
            return composeNgValidator(this.ngValidators);
          }
        }, {}, $__super);
      }(NgControl));
      $__export("NgControlName", NgControlName);
      $__export("NgControlName", NgControlName = __decorate([Directive({
        selector: '[ng-control]',
        bindings: [controlNameBinding],
        properties: ['name: ngControl', 'model: ngModel'],
        events: ['update: ngModel'],
        lifecycle: [LifecycleEvent.onDestroy, LifecycleEvent.onChange],
        exportAs: 'form'
      }), __param(0, Host()), __param(0, SkipSelf()), __param(1, Query(NgValidator)), __metadata('design:paramtypes', [ControlContainer, QueryList])], NgControlName));
    }
  };
});

System.register("angular2/src/forms/directives/default_value_accessor", ["angular2/render", "angular2/metadata", "angular2/core", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/facade/lang", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/default_value_accessor";
  var __decorate,
      __metadata,
      __param,
      Renderer,
      Directive,
      ElementRef,
      Self,
      NgControl,
      isBlank,
      isPresent,
      setProperty,
      DefaultValueAccessor;
  return {
    setters: [function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Self = $__m.Self;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      setProperty = $__m.setProperty;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      DefaultValueAccessor = (($traceurRuntime.createClass)(function(cd, renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.onChange = (function(_) {});
        this.onTouched = (function() {});
        this.cd = cd;
        cd.valueAccessor = this;
      }, {
        writeValue: function(value) {
          var normalizedValue = isBlank(value) ? '' : value;
          setProperty(this.renderer, this.elementRef, 'value', normalizedValue);
        },
        get ngClassUntouched() {
          return isPresent(this.cd.control) ? this.cd.control.untouched : false;
        },
        get ngClassTouched() {
          return isPresent(this.cd.control) ? this.cd.control.touched : false;
        },
        get ngClassPristine() {
          return isPresent(this.cd.control) ? this.cd.control.pristine : false;
        },
        get ngClassDirty() {
          return isPresent(this.cd.control) ? this.cd.control.dirty : false;
        },
        get ngClassValid() {
          return isPresent(this.cd.control) ? this.cd.control.valid : false;
        },
        get ngClassInvalid() {
          return isPresent(this.cd.control) ? !this.cd.control.valid : false;
        },
        registerOnChange: function(fn) {
          this.onChange = fn;
        },
        registerOnTouched: function(fn) {
          this.onTouched = fn;
        }
      }, {}));
      $__export("DefaultValueAccessor", DefaultValueAccessor);
      $__export("DefaultValueAccessor", DefaultValueAccessor = __decorate([Directive({
        selector: 'input:not([type=checkbox])[ng-control],textarea[ng-control],input:not([type=checkbox])[ng-form-control],textarea[ng-form-control],input:not([type=checkbox])[ng-model],textarea[ng-model]',
        host: {
          '(change)': 'onChange($event.target.value)',
          '(input)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()',
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }), __param(0, Self()), __metadata('design:paramtypes', [NgControl, Renderer, ElementRef])], DefaultValueAccessor));
    }
  };
});

System.register("angular2/src/di/binding", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection", "angular2/src/di/key", "angular2/src/di/metadata", "angular2/src/di/exceptions", "angular2/src/di/forward_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/binding";
  var __decorate,
      __metadata,
      Type,
      isBlank,
      isPresent,
      CONST,
      CONST_EXPR,
      BaseException,
      stringify,
      isArray,
      ListWrapper,
      reflector,
      Key,
      InjectMetadata,
      OptionalMetadata,
      SelfMetadata,
      HostMetadata,
      SkipSelfMetadata,
      DependencyMetadata,
      NoAnnotationError,
      resolveForwardRef,
      Dependency,
      _EMPTY_LIST,
      Binding,
      ResolvedBinding,
      BindingBuilder;
  function bind(token) {
    return new BindingBuilder(token);
  }
  function _constructDependencies(factoryFunction, dependencies) {
    if (isBlank(dependencies)) {
      return _dependenciesFor(factoryFunction);
    } else {
      var params = ListWrapper.map(dependencies, (function(t) {
        return [t];
      }));
      return ListWrapper.map(dependencies, (function(t) {
        return _extractToken(factoryFunction, t, params);
      }));
    }
  }
  function _dependenciesFor(typeOrFunc) {
    var params = reflector.parameters(typeOrFunc);
    if (isBlank(params))
      return [];
    if (ListWrapper.any(params, (function(p) {
      return isBlank(p);
    }))) {
      throw new NoAnnotationError(typeOrFunc, params);
    }
    return ListWrapper.map(params, (function(p) {
      return _extractToken(typeOrFunc, p, params);
    }));
  }
  function _extractToken(typeOrFunc, metadata, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!isArray(metadata)) {
      return _createDependency(metadata, optional, null, null, depProps);
    }
    var lowerBoundVisibility = null;
    var upperBoundVisibility = null;
    for (var i = 0; i < metadata.length; ++i) {
      var paramMetadata = metadata[i];
      if (paramMetadata instanceof Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof InjectMetadata) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof OptionalMetadata) {
        optional = true;
      } else if (paramMetadata instanceof SelfMetadata) {
        upperBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof HostMetadata) {
        upperBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof SkipSelfMetadata) {
        lowerBoundVisibility = paramMetadata;
      } else if (paramMetadata instanceof DependencyMetadata) {
        if (isPresent(paramMetadata.token)) {
          token = paramMetadata.token;
        }
        depProps.push(paramMetadata);
      }
    }
    token = resolveForwardRef(token);
    if (isPresent(token)) {
      return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    } else {
      throw new NoAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
    return new Dependency(Key.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
  }
  $__export("bind", bind);
  return {
    setters: [function($__m) {
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      CONST = $__m.CONST;
      CONST_EXPR = $__m.CONST_EXPR;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
      isArray = $__m.isArray;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      Key = $__m.Key;
    }, function($__m) {
      InjectMetadata = $__m.InjectMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      SelfMetadata = $__m.SelfMetadata;
      HostMetadata = $__m.HostMetadata;
      SkipSelfMetadata = $__m.SkipSelfMetadata;
      DependencyMetadata = $__m.DependencyMetadata;
    }, function($__m) {
      NoAnnotationError = $__m.NoAnnotationError;
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Dependency = (function() {
        function Dependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
          this.key = key;
          this.optional = optional;
          this.lowerBoundVisibility = lowerBoundVisibility;
          this.upperBoundVisibility = upperBoundVisibility;
          this.properties = properties;
        }
        return ($traceurRuntime.createClass)(Dependency, {}, {fromKey: function(key) {
            return new Dependency(key, false, null, null, []);
          }});
      }());
      $__export("Dependency", Dependency);
      _EMPTY_LIST = CONST_EXPR([]);
      Binding = (($traceurRuntime.createClass)(function(token, $__3) {
        var $__4 = $__3,
            toClass = $__4.toClass,
            toValue = $__4.toValue,
            toAlias = $__4.toAlias,
            toFactory = $__4.toFactory,
            deps = $__4.deps;
        this.token = token;
        this.toClass = toClass;
        this.toValue = toValue;
        this.toAlias = toAlias;
        this.toFactory = toFactory;
        this.dependencies = deps;
      }, {resolve: function() {
          var $__0 = this;
          var factoryFn;
          var resolvedDeps;
          if (isPresent(this.toClass)) {
            var toClass = resolveForwardRef(this.toClass);
            factoryFn = reflector.factory(toClass);
            resolvedDeps = _dependenciesFor(toClass);
          } else if (isPresent(this.toAlias)) {
            factoryFn = (function(aliasInstance) {
              return aliasInstance;
            });
            resolvedDeps = [Dependency.fromKey(Key.get(this.toAlias))];
          } else if (isPresent(this.toFactory)) {
            factoryFn = this.toFactory;
            resolvedDeps = _constructDependencies(this.toFactory, this.dependencies);
          } else {
            factoryFn = (function() {
              return $__0.toValue;
            });
            resolvedDeps = _EMPTY_LIST;
          }
          return new ResolvedBinding(Key.get(this.token), factoryFn, resolvedDeps);
        }}, {}));
      $__export("Binding", Binding);
      $__export("Binding", Binding = __decorate([CONST(), __metadata('design:paramtypes', [Object, Object])], Binding));
      ResolvedBinding = (function() {
        function ResolvedBinding(key, factory, dependencies) {
          this.key = key;
          this.factory = factory;
          this.dependencies = dependencies;
        }
        return ($traceurRuntime.createClass)(ResolvedBinding, {}, {});
      }());
      $__export("ResolvedBinding", ResolvedBinding);
      BindingBuilder = (function() {
        function BindingBuilder(token) {
          this.token = token;
        }
        return ($traceurRuntime.createClass)(BindingBuilder, {
          toClass: function(type) {
            return new Binding(this.token, {toClass: type});
          },
          toValue: function(value) {
            return new Binding(this.token, {toValue: value});
          },
          toAlias: function(aliasToken) {
            if (isBlank(aliasToken)) {
              throw new BaseException(("Can not alias " + stringify(this.token) + " to a blank value!"));
            }
            return new Binding(this.token, {toAlias: aliasToken});
          },
          toFactory: function(factoryFunction, dependencies) {
            return new Binding(this.token, {
              toFactory: factoryFunction,
              deps: dependencies
            });
          }
        }, {});
      }());
      $__export("BindingBuilder", BindingBuilder);
    }
  };
});

System.register("angular2/src/change_detection/abstract_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/change_detector_ref", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/constants", "angular2/src/profile/profile", "angular2/src/change_detection/observable_facade"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/abstract_change_detector";
  var isPresent,
      isBlank,
      BaseException,
      StringWrapper,
      ListWrapper,
      ChangeDetectionUtil,
      ChangeDetectorRef,
      ChangeDetectionError,
      ExpressionChangedAfterItHasBeenCheckedException,
      DehydratedException,
      CHECK_ONCE,
      CHECKED,
      DETACHED,
      wtfCreateScope,
      wtfLeave,
      isObservable,
      ON_PUSH_OBSERVE,
      _scope_check,
      _Context,
      AbstractChangeDetector;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      ChangeDetectionError = $__m.ChangeDetectionError;
      ExpressionChangedAfterItHasBeenCheckedException = $__m.ExpressionChangedAfterItHasBeenCheckedException;
      DehydratedException = $__m.DehydratedException;
    }, function($__m) {
      CHECK_ONCE = $__m.CHECK_ONCE;
      CHECKED = $__m.CHECKED;
      DETACHED = $__m.DETACHED;
      ON_PUSH_OBSERVE = $__m.ON_PUSH_OBSERVE;
    }, function($__m) {
      wtfCreateScope = $__m.wtfCreateScope;
      wtfLeave = $__m.wtfLeave;
    }, function($__m) {
      isObservable = $__m.isObservable;
    }],
    execute: function() {
      _scope_check = wtfCreateScope("ChangeDetector#check(ascii id, bool throwOnChange)");
      _Context = (function() {
        function _Context(element, componentElement, context, locals, injector, expression) {
          this.element = element;
          this.componentElement = componentElement;
          this.context = context;
          this.locals = locals;
          this.injector = injector;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(_Context, {}, {});
      }());
      AbstractChangeDetector = (function() {
        function AbstractChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, bindingTargets, directiveIndices, strategy) {
          this.id = id;
          this.dispatcher = dispatcher;
          this.numberOfPropertyProtoRecords = numberOfPropertyProtoRecords;
          this.bindingTargets = bindingTargets;
          this.directiveIndices = directiveIndices;
          this.strategy = strategy;
          this.lightDomChildren = [];
          this.shadowDomChildren = [];
          this.alreadyChecked = false;
          this.locals = null;
          this.mode = null;
          this.pipes = null;
          this.ref = new ChangeDetectorRef(this);
        }
        return ($traceurRuntime.createClass)(AbstractChangeDetector, {
          addChild: function(cd) {
            this.lightDomChildren.push(cd);
            cd.parent = this;
          },
          removeChild: function(cd) {
            ListWrapper.remove(this.lightDomChildren, cd);
          },
          addShadowDomChild: function(cd) {
            this.shadowDomChildren.push(cd);
            cd.parent = this;
          },
          removeShadowDomChild: function(cd) {
            ListWrapper.remove(this.shadowDomChildren, cd);
          },
          remove: function() {
            this.parent.removeChild(this);
          },
          handleEvent: function(eventName, elIndex, locals) {
            var res = this.handleEventInternal(eventName, elIndex, locals);
            this.markPathToRootAsCheckOnce();
            return res;
          },
          handleEventInternal: function(eventName, elIndex, locals) {
            return false;
          },
          detectChanges: function() {
            this.runDetectChanges(false);
          },
          checkNoChanges: function() {
            throw new BaseException("Not implemented");
          },
          runDetectChanges: function(throwOnChange) {
            if (StringWrapper.equals(this.mode, DETACHED) || StringWrapper.equals(this.mode, CHECKED))
              return ;
            var s = _scope_check(this.id, throwOnChange);
            this.detectChangesInRecords(throwOnChange);
            this._detectChangesInLightDomChildren(throwOnChange);
            if (throwOnChange === false)
              this.callOnAllChangesDone();
            this._detectChangesInShadowDomChildren(throwOnChange);
            if (StringWrapper.equals(this.mode, CHECK_ONCE))
              this.mode = CHECKED;
            wtfLeave(s);
          },
          detectChangesInRecords: function(throwOnChange) {
            if (!this.hydrated()) {
              this.throwDehydratedError();
            }
            try {
              this.detectChangesInRecordsInternal(throwOnChange);
            } catch (e) {
              this._throwError(e, e.stack);
            }
          },
          detectChangesInRecordsInternal: function(throwOnChange) {},
          hydrate: function(context, locals, directives, pipes) {
            this.mode = ChangeDetectionUtil.changeDetectionMode(this.strategy);
            this.context = context;
            if (StringWrapper.equals(this.strategy, ON_PUSH_OBSERVE)) {
              this.observeComponent(context);
            }
            this.locals = locals;
            this.pipes = pipes;
            this.hydrateDirectives(directives);
            this.alreadyChecked = false;
          },
          hydrateDirectives: function(directives) {},
          dehydrate: function() {
            this.dehydrateDirectives(true);
            if (StringWrapper.equals(this.strategy, ON_PUSH_OBSERVE)) {
              this._unsubsribeFromObservables();
            }
            this.context = null;
            this.locals = null;
            this.pipes = null;
          },
          dehydrateDirectives: function(destroyPipes) {},
          hydrated: function() {
            return this.context !== null;
          },
          callOnAllChangesDone: function() {
            this.dispatcher.notifyOnAllChangesDone();
          },
          _detectChangesInLightDomChildren: function(throwOnChange) {
            var c = this.lightDomChildren;
            for (var i = 0; i < c.length; ++i) {
              c[i].runDetectChanges(throwOnChange);
            }
          },
          _detectChangesInShadowDomChildren: function(throwOnChange) {
            var c = this.shadowDomChildren;
            for (var i = 0; i < c.length; ++i) {
              c[i].runDetectChanges(throwOnChange);
            }
          },
          markAsCheckOnce: function() {
            this.mode = CHECK_ONCE;
          },
          markPathToRootAsCheckOnce: function() {
            var c = this;
            while (isPresent(c) && !StringWrapper.equals(c.mode, DETACHED)) {
              if (StringWrapper.equals(c.mode, CHECKED))
                c.mode = CHECK_ONCE;
              c = c.parent;
            }
          },
          _unsubsribeFromObservables: function() {
            if (isPresent(this.subscriptions)) {
              for (var i = 0; i < this.subscriptions.length; ++i) {
                var s = this.subscriptions[i];
                if (isPresent(this.subscriptions[i])) {
                  s.cancel();
                  this.subscriptions[i] = null;
                }
              }
            }
          },
          observeValue: function(value, index) {
            var $__0 = this;
            if (isObservable(value)) {
              this._createArrayToStoreObservables();
              if (isBlank(this.subscriptions[index])) {
                this.streams[index] = value.changes;
                this.subscriptions[index] = value.changes.listen((function(_) {
                  return $__0.ref.requestCheck();
                }));
              } else if (this.streams[index] !== value.changes) {
                this.subscriptions[index].cancel();
                this.streams[index] = value.changes;
                this.subscriptions[index] = value.changes.listen((function(_) {
                  return $__0.ref.requestCheck();
                }));
              }
            }
            return value;
          },
          observeDirective: function(value, index) {
            var $__0 = this;
            if (isObservable(value)) {
              this._createArrayToStoreObservables();
              var arrayIndex = this.numberOfPropertyProtoRecords + index + 2;
              this.streams[arrayIndex] = value.changes;
              this.subscriptions[arrayIndex] = value.changes.listen((function(_) {
                return $__0.ref.requestCheck();
              }));
            }
            return value;
          },
          observeComponent: function(value) {
            var $__0 = this;
            if (isObservable(value)) {
              this._createArrayToStoreObservables();
              var index = this.numberOfPropertyProtoRecords + 1;
              this.streams[index] = value.changes;
              this.subscriptions[index] = value.changes.listen((function(_) {
                return $__0.ref.requestCheck();
              }));
            }
            return value;
          },
          _createArrayToStoreObservables: function() {
            if (isBlank(this.subscriptions)) {
              this.subscriptions = ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords + this.directiveIndices.length + 2);
              this.streams = ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords + this.directiveIndices.length + 2);
            }
          },
          getDirectiveFor: function(directives, index) {
            return directives.getDirectiveFor(this.directiveIndices[index]);
          },
          getDetectorFor: function(directives, index) {
            return directives.getDetectorFor(this.directiveIndices[index]);
          },
          notifyDispatcher: function(value) {
            this.dispatcher.notifyOnBinding(this._currentBinding(), value);
          },
          logBindingUpdate: function(value) {
            this.dispatcher.logBindingUpdate(this._currentBinding(), value);
          },
          addChange: function(changes, oldValue, newValue) {
            if (isBlank(changes)) {
              changes = {};
            }
            changes[this._currentBinding().name] = ChangeDetectionUtil.simpleChange(oldValue, newValue);
            return changes;
          },
          _throwError: function(exception, stack) {
            var c = this.dispatcher.getDebugContext(this._currentBinding().elementIndex, null);
            var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector, this._currentBinding().debug) : null;
            throw new ChangeDetectionError(this._currentBinding().debug, exception, stack, context);
          },
          throwOnChangeError: function(oldValue, newValue) {
            throw new ExpressionChangedAfterItHasBeenCheckedException(this._currentBinding().debug, oldValue, newValue, null);
          },
          throwDehydratedError: function() {
            throw new DehydratedException();
          },
          _currentBinding: function() {
            return this.bindingTargets[this.propertyBindingIndex];
          }
        }, {});
      }());
      $__export("AbstractChangeDetector", AbstractChangeDetector);
    }
  };
});

System.register("angular2/src/core/compiler/view_manager", ["angular2/di", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref", "angular2/src/render/api", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/view_pool", "angular2/src/core/compiler/view_listener", "angular2/src/profile/profile"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_manager";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      isBlank,
      BaseException,
      internalView,
      internalProtoView,
      Renderer,
      ViewType,
      AppViewManagerUtils,
      AppViewPool,
      AppViewListener,
      wtfCreateScope,
      wtfLeave,
      AppViewManager;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      internalView = $__m.internalView;
      internalProtoView = $__m.internalProtoView;
    }, function($__m) {
      Renderer = $__m.Renderer;
      ViewType = $__m.ViewType;
    }, function($__m) {
      AppViewManagerUtils = $__m.AppViewManagerUtils;
    }, function($__m) {
      AppViewPool = $__m.AppViewPool;
    }, function($__m) {
      AppViewListener = $__m.AppViewListener;
    }, function($__m) {
      wtfCreateScope = $__m.wtfCreateScope;
      wtfLeave = $__m.wtfLeave;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppViewManager = (($traceurRuntime.createClass)(function(_viewPool, _viewListener, _utils, _renderer) {
        this._viewPool = _viewPool;
        this._viewListener = _viewListener;
        this._utils = _utils;
        this._renderer = _renderer;
        this._scope_createRootHostView = wtfCreateScope('AppViewManager#createRootHostView()');
        this._scope_destroyRootHostView = wtfCreateScope('AppViewManager#destroyRootHostView()');
        this._scope_createEmbeddedViewInContainer = wtfCreateScope('AppViewManager#createEmbeddedViewInContainer()');
        this._scope_createHostViewInContainer = wtfCreateScope('AppViewManager#createHostViewInContainer()');
        this._scope_destroyViewInContainer = wtfCreateScope('AppViewMananger#destroyViewInContainer()');
        this._scope_attachViewInContainer = wtfCreateScope('AppViewMananger#attachViewInContainer()');
        this._scope_detachViewInContainer = wtfCreateScope('AppViewMananger#detachViewInContainer()');
      }, {
        getViewContainer: function(location) {
          var hostView = internalView(location.parentView);
          return hostView.elementInjectors[location.boundElementIndex].getViewContainerRef();
        },
        getHostElement: function(hostViewRef) {
          var hostView = internalView(hostViewRef);
          if (hostView.proto.type !== ViewType.HOST) {
            throw new BaseException('This operation is only allowed on host views');
          }
          return hostView.elementRefs[hostView.elementOffset];
        },
        getNamedElementInComponentView: function(hostLocation, variableName) {
          var hostView = internalView(hostLocation.parentView);
          var boundElementIndex = hostLocation.boundElementIndex;
          var componentView = hostView.getNestedView(boundElementIndex);
          if (isBlank(componentView)) {
            throw new BaseException(("There is no component directive at element " + boundElementIndex));
          }
          var binderIdx = componentView.proto.variableLocations.get(variableName);
          if (isBlank(binderIdx)) {
            throw new BaseException(("Could not find variable " + variableName));
          }
          return componentView.elementRefs[componentView.elementOffset + binderIdx];
        },
        getComponent: function(hostLocation) {
          var hostView = internalView(hostLocation.parentView);
          var boundElementIndex = hostLocation.boundElementIndex;
          return this._utils.getComponentInstance(hostView, boundElementIndex);
        },
        createRootHostView: function(hostProtoViewRef, overrideSelector, injector) {
          var s = this._scope_createRootHostView();
          var hostProtoView = internalProtoView(hostProtoViewRef);
          var hostElementSelector = overrideSelector;
          if (isBlank(hostElementSelector)) {
            hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
          }
          var renderViewWithFragments = this._renderer.createRootHostView(hostProtoView.mergeMapping.renderProtoViewRef, hostProtoView.mergeMapping.renderFragmentCount, hostElementSelector);
          var hostView = this._createMainView(hostProtoView, renderViewWithFragments);
          this._renderer.hydrateView(hostView.render);
          this._utils.hydrateRootHostView(hostView, injector);
          return wtfLeave(s, hostView.ref);
        },
        destroyRootHostView: function(hostViewRef) {
          var s = this._scope_destroyRootHostView();
          var hostView = internalView(hostViewRef);
          this._renderer.detachFragment(hostView.renderFragment);
          this._renderer.dehydrateView(hostView.render);
          this._viewDehydrateRecurse(hostView);
          this._viewListener.viewDestroyed(hostView);
          this._renderer.destroyView(hostView.render);
          wtfLeave(s);
        },
        createEmbeddedViewInContainer: function(viewContainerLocation, atIndex, templateRef) {
          var s = this._scope_createEmbeddedViewInContainer();
          var protoView = internalProtoView(templateRef.protoViewRef);
          if (protoView.type !== ViewType.EMBEDDED) {
            throw new BaseException('This method can only be called with embedded ProtoViews!');
          }
          return wtfLeave(s, this._createViewInContainer(viewContainerLocation, atIndex, protoView, templateRef.elementRef, null));
        },
        createHostViewInContainer: function(viewContainerLocation, atIndex, protoViewRef, imperativelyCreatedInjector) {
          var s = this._scope_createHostViewInContainer();
          var protoView = internalProtoView(protoViewRef);
          if (protoView.type !== ViewType.HOST) {
            throw new BaseException('This method can only be called with host ProtoViews!');
          }
          return wtfLeave(s, this._createViewInContainer(viewContainerLocation, atIndex, protoView, viewContainerLocation, imperativelyCreatedInjector));
        },
        _createViewInContainer: function(viewContainerLocation, atIndex, protoView, context, imperativelyCreatedInjector) {
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          var contextView = internalView(context.parentView);
          var contextBoundElementIndex = context.boundElementIndex;
          var embeddedFragmentView = contextView.getNestedView(contextBoundElementIndex);
          var view;
          if (protoView.type === ViewType.EMBEDDED && isPresent(embeddedFragmentView) && !embeddedFragmentView.hydrated()) {
            view = embeddedFragmentView;
            this._attachRenderView(parentView, boundElementIndex, atIndex, view);
          } else {
            view = this._createPooledView(protoView);
            this._attachRenderView(parentView, boundElementIndex, atIndex, view);
            this._renderer.hydrateView(view.render);
          }
          this._utils.attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view);
          this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, imperativelyCreatedInjector);
          return view.ref;
        },
        _attachRenderView: function(parentView, boundElementIndex, atIndex, view) {
          var elementRef = parentView.elementRefs[boundElementIndex];
          if (atIndex === 0) {
            this._renderer.attachFragmentAfterElement(elementRef, view.renderFragment);
          } else {
            var prevView = parentView.viewContainers[boundElementIndex].views[atIndex - 1];
            this._renderer.attachFragmentAfterFragment(prevView.renderFragment, view.renderFragment);
          }
        },
        destroyViewInContainer: function(viewContainerLocation, atIndex) {
          var s = this._scope_destroyViewInContainer();
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          this._destroyViewInContainer(parentView, boundElementIndex, atIndex);
          wtfLeave(s);
        },
        attachViewInContainer: function(viewContainerLocation, atIndex, viewRef) {
          var s = this._scope_attachViewInContainer();
          var view = internalView(viewRef);
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, atIndex, view);
          this._attachRenderView(parentView, boundElementIndex, atIndex, view);
          return wtfLeave(s, viewRef);
        },
        detachViewInContainer: function(viewContainerLocation, atIndex) {
          var s = this._scope_detachViewInContainer();
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
          this._renderer.detachFragment(view.renderFragment);
          return wtfLeave(s, view.ref);
        },
        _createMainView: function(protoView, renderViewWithFragments) {
          var mergedParentView = this._utils.createView(protoView, renderViewWithFragments, this, this._renderer);
          this._renderer.setEventDispatcher(mergedParentView.render, mergedParentView);
          this._viewListener.viewCreated(mergedParentView);
          return mergedParentView;
        },
        _createPooledView: function(protoView) {
          var view = this._viewPool.getView(protoView);
          if (isBlank(view)) {
            view = this._createMainView(protoView, this._renderer.createView(protoView.mergeMapping.renderProtoViewRef, protoView.mergeMapping.renderFragmentCount));
          }
          return view;
        },
        _destroyPooledView: function(view) {
          var wasReturned = this._viewPool.returnView(view);
          if (!wasReturned) {
            this._viewListener.viewDestroyed(view);
            this._renderer.destroyView(view.render);
          }
        },
        _destroyViewInContainer: function(parentView, boundElementIndex, atIndex) {
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          this._viewDehydrateRecurse(view);
          this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
          if (view.viewOffset > 0) {
            this._renderer.detachFragment(view.renderFragment);
          } else {
            this._renderer.dehydrateView(view.render);
            this._renderer.detachFragment(view.renderFragment);
            this._destroyPooledView(view);
          }
        },
        _viewDehydrateRecurse: function(view) {
          if (view.hydrated()) {
            this._utils.dehydrateView(view);
          }
          var viewContainers = view.viewContainers;
          var startViewOffset = view.viewOffset;
          var endViewOffset = view.viewOffset + view.mainMergeMapping.nestedViewCountByViewIndex[view.viewOffset];
          var elementOffset = view.elementOffset;
          for (var viewIdx = startViewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = view.views[viewIdx];
            for (var binderIdx = 0; binderIdx < currView.proto.elementBinders.length; binderIdx++, elementOffset++) {
              var vc = viewContainers[elementOffset];
              if (isPresent(vc)) {
                for (var j = vc.views.length - 1; j >= 0; j--) {
                  this._destroyViewInContainer(currView, elementOffset, j);
                }
              }
            }
          }
        }
      }, {}));
      $__export("AppViewManager", AppViewManager);
      $__export("AppViewManager", AppViewManager = __decorate([Injectable(), __metadata('design:paramtypes', [AppViewPool, AppViewListener, AppViewManagerUtils, Renderer])], AppViewManager));
    }
  };
});

System.register("angular2/pipes", ["angular2/src/pipes/uppercase_pipe", "angular2/src/pipes/lowercase_pipe", "angular2/src/pipes/async_pipe", "angular2/src/pipes/json_pipe", "angular2/src/pipes/date_pipe", "angular2/src/pipes/number_pipe", "angular2/src/pipes/limit_to_pipe", "angular2/src/pipes/default_pipes"], function($__export) {
  "use strict";
  var __moduleName = "angular2/pipes";
  return {
    setters: [function($__m) {
      $__export("UpperCasePipe", $__m.UpperCasePipe);
    }, function($__m) {
      $__export("LowerCasePipe", $__m.LowerCasePipe);
    }, function($__m) {
      $__export("AsyncPipe", $__m.AsyncPipe);
    }, function($__m) {
      $__export("JsonPipe", $__m.JsonPipe);
    }, function($__m) {
      $__export("DatePipe", $__m.DatePipe);
    }, function($__m) {
      $__export("DecimalPipe", $__m.DecimalPipe);
      $__export("PercentPipe", $__m.PercentPipe);
      $__export("CurrencyPipe", $__m.CurrencyPipe);
    }, function($__m) {
      $__export("LimitToPipe", $__m.LimitToPipe);
    }, function($__m) {
      $__export("DEFAULT_PIPES_TOKEN", $__m.DEFAULT_PIPES_TOKEN);
      $__export("DEFAULT_PIPES", $__m.DEFAULT_PIPES);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/render/dom/compiler/view_loader", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/render/xhr", "angular2/src/render/dom/compiler/style_inliner", "angular2/src/render/dom/compiler/style_url_resolver", "angular2/src/profile/profile"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/view_loader";
  var __decorate,
      __metadata,
      Injectable,
      isBlank,
      isPresent,
      BaseException,
      stringify,
      isPromise,
      StringWrapper,
      Map,
      MapWrapper,
      ListWrapper,
      PromiseWrapper,
      DOM,
      XHR,
      StyleInliner,
      StyleUrlResolver,
      wtfStartTimeRange,
      wtfEndTimeRange,
      TemplateAndStyles,
      ViewLoader;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
      isPromise = $__m.isPromise;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      StyleInliner = $__m.StyleInliner;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      wtfStartTimeRange = $__m.wtfStartTimeRange;
      wtfEndTimeRange = $__m.wtfEndTimeRange;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      TemplateAndStyles = (function() {
        function TemplateAndStyles(template, styles) {
          this.template = template;
          this.styles = styles;
        }
        return ($traceurRuntime.createClass)(TemplateAndStyles, {}, {});
      }());
      $__export("TemplateAndStyles", TemplateAndStyles);
      ViewLoader = (($traceurRuntime.createClass)(function(_xhr, _styleInliner, _styleUrlResolver) {
        this._xhr = _xhr;
        this._styleInliner = _styleInliner;
        this._styleUrlResolver = _styleUrlResolver;
        this._cache = new Map();
      }, {
        load: function(viewDef) {
          var $__0 = this;
          var r = wtfStartTimeRange('ViewLoader#load()', stringify(viewDef.componentId));
          var tplAndStyles = [this._loadHtml(viewDef.template, viewDef.templateAbsUrl, viewDef.componentId)];
          if (isPresent(viewDef.styles)) {
            viewDef.styles.forEach((function(cssText) {
              var textOrPromise = $__0._resolveAndInlineCssText(cssText, viewDef.templateAbsUrl);
              tplAndStyles.push(textOrPromise);
            }));
          }
          if (isPresent(viewDef.styleAbsUrls)) {
            viewDef.styleAbsUrls.forEach((function(url) {
              var promise = $__0._loadText(url).then((function(cssText) {
                return $__0._resolveAndInlineCssText(cssText, viewDef.templateAbsUrl);
              }));
              tplAndStyles.push(promise);
            }));
          }
          return PromiseWrapper.all(tplAndStyles).then((function(res) {
            var loadedTplAndStyles = res[0];
            var styles = ListWrapper.slice(res, 1);
            var templateAndStyles = new TemplateAndStyles(loadedTplAndStyles.template, loadedTplAndStyles.styles.concat(styles));
            wtfEndTimeRange(r);
            return templateAndStyles;
          }));
        },
        _loadText: function(url) {
          var response = this._cache.get(url);
          if (isBlank(response)) {
            response = PromiseWrapper.catchError(this._xhr.get(url), (function(_) {
              return PromiseWrapper.reject(new BaseException(("Failed to fetch url \"" + url + "\"")), null);
            }));
            this._cache.set(url, response);
          }
          return response;
        },
        _loadHtml: function(template, templateAbsUrl, componentId) {
          var $__0 = this;
          var html;
          if (isPresent(template)) {
            html = PromiseWrapper.resolve(template);
          } else if (isPresent(templateAbsUrl)) {
            html = this._loadText(templateAbsUrl);
          } else {
            throw new BaseException(("View should have either the templateUrl or template property set but none was found for the '" + componentId + "' component"));
          }
          return html.then((function(html) {
            var tplEl = DOM.createTemplate(html);
            if (isPresent(templateAbsUrl) && templateAbsUrl.indexOf("/") >= 0) {
              var baseUrl = templateAbsUrl.substring(0, templateAbsUrl.lastIndexOf("/"));
              $__0._substituteBaseUrl(DOM.content(tplEl), baseUrl);
            }
            var styleEls = DOM.querySelectorAll(DOM.content(tplEl), 'STYLE');
            var unresolvedStyles = [];
            for (var i = 0; i < styleEls.length; i++) {
              var styleEl = styleEls[i];
              unresolvedStyles.push(DOM.getText(styleEl));
              DOM.remove(styleEl);
            }
            var syncStyles = [];
            var asyncStyles = [];
            for (var i$__3 = 0; i$__3 < styleEls.length; i$__3++) {
              var styleEl = styleEls[i$__3];
              var resolvedStyled = $__0._resolveAndInlineCssText(DOM.getText(styleEl), templateAbsUrl);
              if (isPromise(resolvedStyled)) {
                asyncStyles.push(resolvedStyled);
              } else {
                syncStyles.push(resolvedStyled);
              }
            }
            if (asyncStyles.length === 0) {
              return PromiseWrapper.resolve(new TemplateAndStyles(DOM.getInnerHTML(tplEl), syncStyles));
            } else {
              return PromiseWrapper.all(asyncStyles).then((function(loadedStyles) {
                return new TemplateAndStyles(DOM.getInnerHTML(tplEl), syncStyles.concat(loadedStyles));
              }));
            }
          }));
        },
        _substituteBaseUrl: function(element, baseUrl) {
          if (DOM.isElementNode(element)) {
            var attrs = DOM.attributeMap(element);
            MapWrapper.forEach(attrs, (function(v, k) {
              if (isPresent(v) && v.indexOf('$baseUrl') >= 0) {
                DOM.setAttribute(element, k, StringWrapper.replaceAll(v, /\$baseUrl/g, baseUrl));
              }
            }));
          }
          var children = DOM.childNodes(element);
          for (var i = 0; i < children.length; i++) {
            if (DOM.isElementNode(children[i])) {
              this._substituteBaseUrl(children[i], baseUrl);
            }
          }
        },
        _resolveAndInlineCssText: function(cssText, baseUrl) {
          cssText = this._styleUrlResolver.resolveUrls(cssText, baseUrl);
          return this._styleInliner.inlineImports(cssText, baseUrl);
        }
      }, {}));
      $__export("ViewLoader", ViewLoader);
      $__export("ViewLoader", ViewLoader = __decorate([Injectable(), __metadata('design:paramtypes', [XHR, StyleInliner, StyleUrlResolver])], ViewLoader));
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_pipeline", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/dom/view/proto_view_builder"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_pipeline";
  var isPresent,
      DOM,
      CompileElement,
      CompileControl,
      ProtoViewBuilder,
      CompilePipeline;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      ProtoViewBuilder = $__m.ProtoViewBuilder;
    }],
    execute: function() {
      CompilePipeline = (function() {
        function CompilePipeline(steps) {
          this.steps = steps;
          this._control = new CompileControl(steps);
        }
        return ($traceurRuntime.createClass)(CompilePipeline, {
          processStyles: function(styles) {
            var $__0 = this;
            return styles.map((function(style) {
              $__0.steps.forEach((function(step) {
                style = step.processStyle(style);
              }));
              return style;
            }));
          },
          processElements: function(rootElement, protoViewType, viewDef) {
            var results = [];
            var compilationCtxtDescription = viewDef.componentId;
            var rootCompileElement = new CompileElement(rootElement, compilationCtxtDescription);
            rootCompileElement.inheritedProtoView = new ProtoViewBuilder(rootElement, protoViewType, viewDef.encapsulation);
            rootCompileElement.isViewRoot = true;
            this._processElement(results, null, rootCompileElement, compilationCtxtDescription);
            return results;
          },
          _processElement: function(results, parent, current) {
            var compilationCtxtDescription = arguments[3] !== (void 0) ? arguments[3] : '';
            var additionalChildren = this._control.internalProcess(results, 0, parent, current);
            if (current.compileChildren) {
              var node = DOM.firstChild(DOM.templateAwareRoot(current.element));
              while (isPresent(node)) {
                var nextNode = DOM.nextSibling(node);
                if (DOM.isElementNode(node)) {
                  var childCompileElement = new CompileElement(node, compilationCtxtDescription);
                  childCompileElement.inheritedProtoView = current.inheritedProtoView;
                  childCompileElement.inheritedElementBinder = current.inheritedElementBinder;
                  childCompileElement.distanceToInheritedBinder = current.distanceToInheritedBinder + 1;
                  this._processElement(results, current, childCompileElement);
                }
                node = nextNode;
              }
            }
            if (isPresent(additionalChildren)) {
              for (var i = 0; i < additionalChildren.length; i++) {
                this._processElement(results, current, additionalChildren[i]);
              }
            }
          }
        }, {});
      }());
      $__export("CompilePipeline", CompilePipeline);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_step_factory", ["angular2/src/render/dom/compiler/property_binding_parser", "angular2/src/render/dom/compiler/text_interpolation_parser", "angular2/src/render/dom/compiler/directive_parser", "angular2/src/render/dom/compiler/view_splitter", "angular2/src/render/dom/compiler/style_encapsulator"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_step_factory";
  var PropertyBindingParser,
      TextInterpolationParser,
      DirectiveParser,
      ViewSplitter,
      StyleEncapsulator,
      CompileStepFactory,
      DefaultStepFactory;
  return {
    setters: [function($__m) {
      PropertyBindingParser = $__m.PropertyBindingParser;
    }, function($__m) {
      TextInterpolationParser = $__m.TextInterpolationParser;
    }, function($__m) {
      DirectiveParser = $__m.DirectiveParser;
    }, function($__m) {
      ViewSplitter = $__m.ViewSplitter;
    }, function($__m) {
      StyleEncapsulator = $__m.StyleEncapsulator;
    }],
    execute: function() {
      CompileStepFactory = (function() {
        function CompileStepFactory() {}
        return ($traceurRuntime.createClass)(CompileStepFactory, {createSteps: function(view) {
            return null;
          }}, {});
      }());
      $__export("CompileStepFactory", CompileStepFactory);
      DefaultStepFactory = (function($__super) {
        function DefaultStepFactory(_parser, _appId) {
          $traceurRuntime.superConstructor(DefaultStepFactory).call(this);
          this._parser = _parser;
          this._appId = _appId;
          this._componentUIDsCache = new Map();
        }
        return ($traceurRuntime.createClass)(DefaultStepFactory, {createSteps: function(view) {
            return [new ViewSplitter(this._parser), new PropertyBindingParser(this._parser), new DirectiveParser(this._parser, view.directives), new TextInterpolationParser(this._parser), new StyleEncapsulator(this._appId, view, this._componentUIDsCache)];
          }}, {}, $__super);
      }(CompileStepFactory));
      $__export("DefaultStepFactory", DefaultStepFactory);
    }
  };
});

System.register("angular2/forms", ["angular2/src/forms/model", "angular2/src/forms/directives/abstract_control_directive", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/ng_control_name", "angular2/src/forms/directives/ng_form_control", "angular2/src/forms/directives/ng_model", "angular2/src/forms/directives/ng_control", "angular2/src/forms/directives/ng_control_group", "angular2/src/forms/directives/ng_form_model", "angular2/src/forms/directives/ng_form", "angular2/src/forms/directives/default_value_accessor", "angular2/src/forms/directives/checkbox_value_accessor", "angular2/src/forms/directives/select_control_value_accessor", "angular2/src/forms/directives", "angular2/src/forms/validators", "angular2/src/forms/directives/validators", "angular2/src/forms/form_builder", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/forms";
  var FormBuilder,
      CONST_EXPR,
      FORM_BINDINGS;
  return {
    setters: [function($__m) {
      $__export("AbstractControl", $__m.AbstractControl);
      $__export("Control", $__m.Control);
      $__export("ControlGroup", $__m.ControlGroup);
      $__export("ControlArray", $__m.ControlArray);
    }, function($__m) {
      $__export("AbstractControlDirective", $__m.AbstractControlDirective);
    }, function($__m) {
      $__export("ControlContainer", $__m.ControlContainer);
    }, function($__m) {
      $__export("NgControlName", $__m.NgControlName);
    }, function($__m) {
      $__export("NgFormControl", $__m.NgFormControl);
    }, function($__m) {
      $__export("NgModel", $__m.NgModel);
    }, function($__m) {
      $__export("NgControl", $__m.NgControl);
    }, function($__m) {
      $__export("NgControlGroup", $__m.NgControlGroup);
    }, function($__m) {
      $__export("NgFormModel", $__m.NgFormModel);
    }, function($__m) {
      $__export("NgForm", $__m.NgForm);
    }, function($__m) {
      $__export("DefaultValueAccessor", $__m.DefaultValueAccessor);
    }, function($__m) {
      $__export("CheckboxControlValueAccessor", $__m.CheckboxControlValueAccessor);
    }, function($__m) {
      $__export("NgSelectOption", $__m.NgSelectOption);
      $__export("SelectControlValueAccessor", $__m.SelectControlValueAccessor);
    }, function($__m) {
      $__export("FORM_DIRECTIVES", $__m.FORM_DIRECTIVES);
    }, function($__m) {
      $__export("Validators", $__m.Validators);
    }, function($__m) {
      $__export("NgValidator", $__m.NgValidator);
      $__export("NgRequiredValidator", $__m.NgRequiredValidator);
    }, function($__m) {
      FormBuilder = $__m.FormBuilder;
      $__export("FormBuilder", $__m.FormBuilder);
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      FORM_BINDINGS = CONST_EXPR([FormBuilder]);
      $__export("FORM_BINDINGS", FORM_BINDINGS);
    }
  };
});

System.register("angular2/src/di/injector", ["angular2/src/facade/collection", "angular2/src/di/binding", "angular2/src/di/exceptions", "angular2/src/facade/lang", "angular2/src/di/key", "angular2/src/di/forward_ref", "angular2/src/di/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/injector";
  var Map,
      List,
      MapWrapper,
      ListWrapper,
      ResolvedBinding,
      Binding,
      BindingBuilder,
      bind,
      AbstractBindingError,
      NoBindingError,
      CyclicDependencyError,
      InstantiationError,
      InvalidBindingError,
      OutOfBoundsError,
      Type,
      isPresent,
      CONST_EXPR,
      Key,
      resolveForwardRef,
      SelfMetadata,
      HostMetadata,
      SkipSelfMetadata,
      _MAX_CONSTRUCTION_COUNTER,
      UNDEFINED,
      Visibility,
      ProtoInjectorInlineStrategy,
      ProtoInjectorDynamicStrategy,
      ProtoInjector,
      InjectorInlineStrategy,
      InjectorDynamicStrategy,
      BindingWithVisibility,
      Injector,
      INJECTOR_KEY;
  function canSee(src, dst) {
    return (src === dst) || (dst === Visibility.PublicAndPrivate || src === Visibility.PublicAndPrivate);
  }
  function _resolveBindings(bindings) {
    var resolvedList = ListWrapper.createFixedSize(bindings.length);
    for (var i = 0; i < bindings.length; i++) {
      var unresolved = resolveForwardRef(bindings[i]);
      var resolved = void 0;
      if (unresolved instanceof ResolvedBinding) {
        resolved = unresolved;
      } else if (unresolved instanceof Type) {
        resolved = bind(unresolved).toClass(unresolved).resolve();
      } else if (unresolved instanceof Binding) {
        resolved = unresolved.resolve();
      } else if (unresolved instanceof List) {
        resolved = _resolveBindings(unresolved);
      } else if (unresolved instanceof BindingBuilder) {
        throw new InvalidBindingError(unresolved.token);
      } else {
        throw new InvalidBindingError(unresolved);
      }
      resolvedList[i] = resolved;
    }
    return resolvedList;
  }
  function _createListOfBindings(flattenedBindings) {
    return MapWrapper.values(flattenedBindings);
  }
  function _flattenBindings(bindings, res) {
    ListWrapper.forEach(bindings, function(b) {
      if (b instanceof ResolvedBinding) {
        res.set(b.key.id, b);
      } else if (b instanceof List) {
        _flattenBindings(b, res);
      }
    });
    return res;
  }
  function _mapBindings(injector, fn) {
    var res = [];
    for (var i = 0; i < injector._proto.numberOfBindings; ++i) {
      res.push(fn(injector._proto.getBindingAtIndex(i)));
    }
    return res;
  }
  return {
    setters: [function($__m) {
      Map = $__m.Map;
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ResolvedBinding = $__m.ResolvedBinding;
      Binding = $__m.Binding;
      BindingBuilder = $__m.BindingBuilder;
      bind = $__m.bind;
    }, function($__m) {
      AbstractBindingError = $__m.AbstractBindingError;
      NoBindingError = $__m.NoBindingError;
      CyclicDependencyError = $__m.CyclicDependencyError;
      InstantiationError = $__m.InstantiationError;
      InvalidBindingError = $__m.InvalidBindingError;
      OutOfBoundsError = $__m.OutOfBoundsError;
    }, function($__m) {
      Type = $__m.Type;
      isPresent = $__m.isPresent;
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Key = $__m.Key;
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }, function($__m) {
      SelfMetadata = $__m.SelfMetadata;
      HostMetadata = $__m.HostMetadata;
      SkipSelfMetadata = $__m.SkipSelfMetadata;
    }],
    execute: function() {
      _MAX_CONSTRUCTION_COUNTER = 10;
      UNDEFINED = CONST_EXPR(new Object());
      $__export("UNDEFINED", UNDEFINED);
      $__export("Visibility", Visibility);
      (function(Visibility) {
        Visibility[Visibility["Public"] = 0] = "Public";
        Visibility[Visibility["Private"] = 1] = "Private";
        Visibility[Visibility["PublicAndPrivate"] = 2] = "PublicAndPrivate";
      })(Visibility || ($__export("Visibility", Visibility = {})));
      ProtoInjectorInlineStrategy = (function() {
        function ProtoInjectorInlineStrategy(protoEI, bwv) {
          this.binding0 = null;
          this.binding1 = null;
          this.binding2 = null;
          this.binding3 = null;
          this.binding4 = null;
          this.binding5 = null;
          this.binding6 = null;
          this.binding7 = null;
          this.binding8 = null;
          this.binding9 = null;
          this.keyId0 = null;
          this.keyId1 = null;
          this.keyId2 = null;
          this.keyId3 = null;
          this.keyId4 = null;
          this.keyId5 = null;
          this.keyId6 = null;
          this.keyId7 = null;
          this.keyId8 = null;
          this.keyId9 = null;
          this.visibility0 = null;
          this.visibility1 = null;
          this.visibility2 = null;
          this.visibility3 = null;
          this.visibility4 = null;
          this.visibility5 = null;
          this.visibility6 = null;
          this.visibility7 = null;
          this.visibility8 = null;
          this.visibility9 = null;
          var length = bwv.length;
          if (length > 0) {
            this.binding0 = bwv[0].binding;
            this.keyId0 = bwv[0].getKeyId();
            this.visibility0 = bwv[0].visibility;
          }
          if (length > 1) {
            this.binding1 = bwv[1].binding;
            this.keyId1 = bwv[1].getKeyId();
            this.visibility1 = bwv[1].visibility;
          }
          if (length > 2) {
            this.binding2 = bwv[2].binding;
            this.keyId2 = bwv[2].getKeyId();
            this.visibility2 = bwv[2].visibility;
          }
          if (length > 3) {
            this.binding3 = bwv[3].binding;
            this.keyId3 = bwv[3].getKeyId();
            this.visibility3 = bwv[3].visibility;
          }
          if (length > 4) {
            this.binding4 = bwv[4].binding;
            this.keyId4 = bwv[4].getKeyId();
            this.visibility4 = bwv[4].visibility;
          }
          if (length > 5) {
            this.binding5 = bwv[5].binding;
            this.keyId5 = bwv[5].getKeyId();
            this.visibility5 = bwv[5].visibility;
          }
          if (length > 6) {
            this.binding6 = bwv[6].binding;
            this.keyId6 = bwv[6].getKeyId();
            this.visibility6 = bwv[6].visibility;
          }
          if (length > 7) {
            this.binding7 = bwv[7].binding;
            this.keyId7 = bwv[7].getKeyId();
            this.visibility7 = bwv[7].visibility;
          }
          if (length > 8) {
            this.binding8 = bwv[8].binding;
            this.keyId8 = bwv[8].getKeyId();
            this.visibility8 = bwv[8].visibility;
          }
          if (length > 9) {
            this.binding9 = bwv[9].binding;
            this.keyId9 = bwv[9].getKeyId();
            this.visibility9 = bwv[9].visibility;
          }
        }
        return ($traceurRuntime.createClass)(ProtoInjectorInlineStrategy, {
          getBindingAtIndex: function(index) {
            if (index == 0)
              return this.binding0;
            if (index == 1)
              return this.binding1;
            if (index == 2)
              return this.binding2;
            if (index == 3)
              return this.binding3;
            if (index == 4)
              return this.binding4;
            if (index == 5)
              return this.binding5;
            if (index == 6)
              return this.binding6;
            if (index == 7)
              return this.binding7;
            if (index == 8)
              return this.binding8;
            if (index == 9)
              return this.binding9;
            throw new OutOfBoundsError(index);
          },
          createInjectorStrategy: function(injector) {
            return new InjectorInlineStrategy(injector, this);
          }
        }, {});
      }());
      $__export("ProtoInjectorInlineStrategy", ProtoInjectorInlineStrategy);
      ProtoInjectorDynamicStrategy = (function() {
        function ProtoInjectorDynamicStrategy(protoInj, bwv) {
          var len = bwv.length;
          this.bindings = ListWrapper.createFixedSize(len);
          this.keyIds = ListWrapper.createFixedSize(len);
          this.visibilities = ListWrapper.createFixedSize(len);
          for (var i = 0; i < len; i++) {
            this.bindings[i] = bwv[i].binding;
            this.keyIds[i] = bwv[i].getKeyId();
            this.visibilities[i] = bwv[i].visibility;
          }
        }
        return ($traceurRuntime.createClass)(ProtoInjectorDynamicStrategy, {
          getBindingAtIndex: function(index) {
            if (index < 0 || index >= this.bindings.length) {
              throw new OutOfBoundsError(index);
            }
            return this.bindings[index];
          },
          createInjectorStrategy: function(ei) {
            return new InjectorDynamicStrategy(this, ei);
          }
        }, {});
      }());
      $__export("ProtoInjectorDynamicStrategy", ProtoInjectorDynamicStrategy);
      ProtoInjector = (function() {
        function ProtoInjector(bwv) {
          this.numberOfBindings = bwv.length;
          this._strategy = bwv.length > _MAX_CONSTRUCTION_COUNTER ? new ProtoInjectorDynamicStrategy(this, bwv) : new ProtoInjectorInlineStrategy(this, bwv);
        }
        return ($traceurRuntime.createClass)(ProtoInjector, {getBindingAtIndex: function(index) {
            return this._strategy.getBindingAtIndex(index);
          }}, {});
      }());
      $__export("ProtoInjector", ProtoInjector);
      InjectorInlineStrategy = (function() {
        function InjectorInlineStrategy(injector, protoStrategy) {
          this.injector = injector;
          this.protoStrategy = protoStrategy;
          this.obj0 = UNDEFINED;
          this.obj1 = UNDEFINED;
          this.obj2 = UNDEFINED;
          this.obj3 = UNDEFINED;
          this.obj4 = UNDEFINED;
          this.obj5 = UNDEFINED;
          this.obj6 = UNDEFINED;
          this.obj7 = UNDEFINED;
          this.obj8 = UNDEFINED;
          this.obj9 = UNDEFINED;
        }
        return ($traceurRuntime.createClass)(InjectorInlineStrategy, {
          resetConstructionCounter: function() {
            this.injector._constructionCounter = 0;
          },
          instantiateBinding: function(binding, visibility) {
            return this.injector._new(binding, visibility);
          },
          attach: function(parent, isHost) {
            var inj = this.injector;
            inj._parent = parent;
            inj._isHost = isHost;
          },
          getObjByKeyId: function(keyId, visibility) {
            var p = this.protoStrategy;
            var inj = this.injector;
            if (p.keyId0 === keyId && canSee(p.visibility0, visibility)) {
              if (this.obj0 === UNDEFINED) {
                this.obj0 = inj._new(p.binding0, p.visibility0);
              }
              return this.obj0;
            }
            if (p.keyId1 === keyId && canSee(p.visibility1, visibility)) {
              if (this.obj1 === UNDEFINED) {
                this.obj1 = inj._new(p.binding1, p.visibility1);
              }
              return this.obj1;
            }
            if (p.keyId2 === keyId && canSee(p.visibility2, visibility)) {
              if (this.obj2 === UNDEFINED) {
                this.obj2 = inj._new(p.binding2, p.visibility2);
              }
              return this.obj2;
            }
            if (p.keyId3 === keyId && canSee(p.visibility3, visibility)) {
              if (this.obj3 === UNDEFINED) {
                this.obj3 = inj._new(p.binding3, p.visibility3);
              }
              return this.obj3;
            }
            if (p.keyId4 === keyId && canSee(p.visibility4, visibility)) {
              if (this.obj4 === UNDEFINED) {
                this.obj4 = inj._new(p.binding4, p.visibility4);
              }
              return this.obj4;
            }
            if (p.keyId5 === keyId && canSee(p.visibility5, visibility)) {
              if (this.obj5 === UNDEFINED) {
                this.obj5 = inj._new(p.binding5, p.visibility5);
              }
              return this.obj5;
            }
            if (p.keyId6 === keyId && canSee(p.visibility6, visibility)) {
              if (this.obj6 === UNDEFINED) {
                this.obj6 = inj._new(p.binding6, p.visibility6);
              }
              return this.obj6;
            }
            if (p.keyId7 === keyId && canSee(p.visibility7, visibility)) {
              if (this.obj7 === UNDEFINED) {
                this.obj7 = inj._new(p.binding7, p.visibility7);
              }
              return this.obj7;
            }
            if (p.keyId8 === keyId && canSee(p.visibility8, visibility)) {
              if (this.obj8 === UNDEFINED) {
                this.obj8 = inj._new(p.binding8, p.visibility8);
              }
              return this.obj8;
            }
            if (p.keyId9 === keyId && canSee(p.visibility9, visibility)) {
              if (this.obj9 === UNDEFINED) {
                this.obj9 = inj._new(p.binding9, p.visibility9);
              }
              return this.obj9;
            }
            return UNDEFINED;
          },
          getObjAtIndex: function(index) {
            if (index == 0)
              return this.obj0;
            if (index == 1)
              return this.obj1;
            if (index == 2)
              return this.obj2;
            if (index == 3)
              return this.obj3;
            if (index == 4)
              return this.obj4;
            if (index == 5)
              return this.obj5;
            if (index == 6)
              return this.obj6;
            if (index == 7)
              return this.obj7;
            if (index == 8)
              return this.obj8;
            if (index == 9)
              return this.obj9;
            throw new OutOfBoundsError(index);
          },
          getMaxNumberOfObjects: function() {
            return _MAX_CONSTRUCTION_COUNTER;
          }
        }, {});
      }());
      $__export("InjectorInlineStrategy", InjectorInlineStrategy);
      InjectorDynamicStrategy = (function() {
        function InjectorDynamicStrategy(protoStrategy, injector) {
          this.protoStrategy = protoStrategy;
          this.injector = injector;
          this.objs = ListWrapper.createFixedSize(protoStrategy.bindings.length);
          ListWrapper.fill(this.objs, UNDEFINED);
        }
        return ($traceurRuntime.createClass)(InjectorDynamicStrategy, {
          resetConstructionCounter: function() {
            this.injector._constructionCounter = 0;
          },
          instantiateBinding: function(binding, visibility) {
            return this.injector._new(binding, visibility);
          },
          attach: function(parent, isHost) {
            var inj = this.injector;
            inj._parent = parent;
            inj._isHost = isHost;
          },
          getObjByKeyId: function(keyId, visibility) {
            var p = this.protoStrategy;
            for (var i = 0; i < p.keyIds.length; i++) {
              if (p.keyIds[i] === keyId && canSee(p.visibilities[i], visibility)) {
                if (this.objs[i] === UNDEFINED) {
                  this.objs[i] = this.injector._new(p.bindings[i], p.visibilities[i]);
                }
                return this.objs[i];
              }
            }
            return UNDEFINED;
          },
          getObjAtIndex: function(index) {
            if (index < 0 || index >= this.objs.length) {
              throw new OutOfBoundsError(index);
            }
            return this.objs[index];
          },
          getMaxNumberOfObjects: function() {
            return this.objs.length;
          }
        }, {});
      }());
      $__export("InjectorDynamicStrategy", InjectorDynamicStrategy);
      BindingWithVisibility = (function() {
        function BindingWithVisibility(binding, visibility) {
          this.binding = binding;
          this.visibility = visibility;
        }
        return ($traceurRuntime.createClass)(BindingWithVisibility, {getKeyId: function() {
            return this.binding.key.id;
          }}, {});
      }());
      $__export("BindingWithVisibility", BindingWithVisibility);
      Injector = (function() {
        function Injector(_proto) {
          var _parent = arguments[1] !== (void 0) ? arguments[1] : null;
          var _depProvider = arguments[2] !== (void 0) ? arguments[2] : null;
          var _debugContext = arguments[3] !== (void 0) ? arguments[3] : null;
          this._proto = _proto;
          this._parent = _parent;
          this._depProvider = _depProvider;
          this._debugContext = _debugContext;
          this._isHost = false;
          this._constructionCounter = 0;
          this._strategy = _proto._strategy.createInjectorStrategy(this);
        }
        return ($traceurRuntime.createClass)(Injector, {
          debugContext: function() {
            return this._debugContext();
          },
          get: function(token) {
            return this._getByKey(Key.get(token), null, null, false, Visibility.PublicAndPrivate);
          },
          getOptional: function(token) {
            return this._getByKey(Key.get(token), null, null, true, Visibility.PublicAndPrivate);
          },
          getAt: function(index) {
            return this._strategy.getObjAtIndex(index);
          },
          get parent() {
            return this._parent;
          },
          get internalStrategy() {
            return this._strategy;
          },
          resolveAndCreateChild: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var resovledBindings = Injector.resolve(bindings);
            return this.createChildFromResolved(resovledBindings, depProvider);
          },
          createChildFromResolved: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var bd = bindings.map((function(b) {
              return new BindingWithVisibility(b, Visibility.Public);
            }));
            var proto = new ProtoInjector(bd);
            var inj = new Injector(proto, null, depProvider);
            inj._parent = this;
            return inj;
          },
          resolveAndInstantiate: function(binding) {
            return this.instantiateResolved(Injector.resolve([binding])[0]);
          },
          instantiateResolved: function(binding) {
            return this._instantiate(binding, Visibility.PublicAndPrivate);
          },
          _new: function(binding, visibility) {
            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
              throw new CyclicDependencyError(this, binding.key);
            }
            return this._instantiate(binding, visibility);
          },
          _instantiate: function(binding, visibility) {
            var factory = binding.factory;
            var deps = binding.dependencies;
            var length = deps.length;
            var d0,
                d1,
                d2,
                d3,
                d4,
                d5,
                d6,
                d7,
                d8,
                d9,
                d10,
                d11,
                d12,
                d13,
                d14,
                d15,
                d16,
                d17,
                d18,
                d19;
            try {
              d0 = length > 0 ? this._getByDependency(binding, deps[0], visibility) : null;
              d1 = length > 1 ? this._getByDependency(binding, deps[1], visibility) : null;
              d2 = length > 2 ? this._getByDependency(binding, deps[2], visibility) : null;
              d3 = length > 3 ? this._getByDependency(binding, deps[3], visibility) : null;
              d4 = length > 4 ? this._getByDependency(binding, deps[4], visibility) : null;
              d5 = length > 5 ? this._getByDependency(binding, deps[5], visibility) : null;
              d6 = length > 6 ? this._getByDependency(binding, deps[6], visibility) : null;
              d7 = length > 7 ? this._getByDependency(binding, deps[7], visibility) : null;
              d8 = length > 8 ? this._getByDependency(binding, deps[8], visibility) : null;
              d9 = length > 9 ? this._getByDependency(binding, deps[9], visibility) : null;
              d10 = length > 10 ? this._getByDependency(binding, deps[10], visibility) : null;
              d11 = length > 11 ? this._getByDependency(binding, deps[11], visibility) : null;
              d12 = length > 12 ? this._getByDependency(binding, deps[12], visibility) : null;
              d13 = length > 13 ? this._getByDependency(binding, deps[13], visibility) : null;
              d14 = length > 14 ? this._getByDependency(binding, deps[14], visibility) : null;
              d15 = length > 15 ? this._getByDependency(binding, deps[15], visibility) : null;
              d16 = length > 16 ? this._getByDependency(binding, deps[16], visibility) : null;
              d17 = length > 17 ? this._getByDependency(binding, deps[17], visibility) : null;
              d18 = length > 18 ? this._getByDependency(binding, deps[18], visibility) : null;
              d19 = length > 19 ? this._getByDependency(binding, deps[19], visibility) : null;
            } catch (e) {
              if (e instanceof AbstractBindingError) {
                e.addKey(this, binding.key);
              }
              throw e;
            }
            var obj;
            try {
              switch (length) {
                case 0:
                  obj = factory();
                  break;
                case 1:
                  obj = factory(d0);
                  break;
                case 2:
                  obj = factory(d0, d1);
                  break;
                case 3:
                  obj = factory(d0, d1, d2);
                  break;
                case 4:
                  obj = factory(d0, d1, d2, d3);
                  break;
                case 5:
                  obj = factory(d0, d1, d2, d3, d4);
                  break;
                case 6:
                  obj = factory(d0, d1, d2, d3, d4, d5);
                  break;
                case 7:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6);
                  break;
                case 8:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                  break;
                case 9:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                  break;
                case 10:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                  break;
                case 11:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                  break;
                case 12:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                  break;
                case 13:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                  break;
                case 14:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                  break;
                case 15:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                  break;
                case 16:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                  break;
                case 17:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                  break;
                case 18:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                  break;
                case 19:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                  break;
                case 20:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                  break;
              }
            } catch (e) {
              throw new InstantiationError(this, e, e.stack, binding.key);
            }
            return obj;
          },
          _getByDependency: function(binding, dep, bindingVisibility) {
            var special = isPresent(this._depProvider) ? this._depProvider.getDependency(this, binding, dep) : UNDEFINED;
            if (special !== UNDEFINED) {
              return special;
            } else {
              return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional, bindingVisibility);
            }
          },
          _getByKey: function(key, lowerBoundVisibility, upperBoundVisibility, optional, bindingVisibility) {
            if (key === INJECTOR_KEY) {
              return this;
            }
            if (upperBoundVisibility instanceof SelfMetadata) {
              return this._getByKeySelf(key, optional, bindingVisibility);
            } else if (upperBoundVisibility instanceof HostMetadata) {
              return this._getByKeyHost(key, optional, bindingVisibility, lowerBoundVisibility);
            } else {
              return this._getByKeyDefault(key, optional, bindingVisibility, lowerBoundVisibility);
            }
          },
          _throwOrNull: function(key, optional) {
            if (optional) {
              return null;
            } else {
              throw new NoBindingError(this, key);
            }
          },
          _getByKeySelf: function(key, optional, bindingVisibility) {
            var obj = this._strategy.getObjByKeyId(key.id, bindingVisibility);
            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, optional);
          },
          _getByKeyHost: function(key, optional, bindingVisibility, lowerBoundVisibility) {
            var inj = this;
            if (lowerBoundVisibility instanceof SkipSelfMetadata) {
              if (inj._isHost) {
                return this._getPrivateDependency(key, optional, inj);
              } else {
                inj = inj._parent;
              }
            }
            while (inj != null) {
              var obj = inj._strategy.getObjByKeyId(key.id, bindingVisibility);
              if (obj !== UNDEFINED)
                return obj;
              if (isPresent(inj._parent) && inj._isHost) {
                return this._getPrivateDependency(key, optional, inj);
              } else {
                inj = inj._parent;
              }
            }
            return this._throwOrNull(key, optional);
          },
          _getPrivateDependency: function(key, optional, inj) {
            var obj = inj._parent._strategy.getObjByKeyId(key.id, Visibility.Private);
            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, optional);
          },
          _getByKeyDefault: function(key, optional, bindingVisibility, lowerBoundVisibility) {
            var inj = this;
            if (lowerBoundVisibility instanceof SkipSelfMetadata) {
              bindingVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
              inj = inj._parent;
            }
            while (inj != null) {
              var obj = inj._strategy.getObjByKeyId(key.id, bindingVisibility);
              if (obj !== UNDEFINED)
                return obj;
              bindingVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
              inj = inj._parent;
            }
            return this._throwOrNull(key, optional);
          },
          get displayName() {
            return ("Injector(bindings: [" + _mapBindings(this, (function(b) {
              return (" \"" + b.key.displayName + "\" ");
            })).join(", ") + "])");
          },
          toString: function() {
            return this.displayName;
          }
        }, {
          resolve: function(bindings) {
            var resolvedBindings = _resolveBindings(bindings);
            var flatten = _flattenBindings(resolvedBindings, new Map());
            return _createListOfBindings(flatten);
          },
          resolveAndCreate: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var resolvedBindings = Injector.resolve(bindings);
            return Injector.fromResolvedBindings(resolvedBindings, depProvider);
          },
          fromResolvedBindings: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var bd = bindings.map((function(b) {
              return new BindingWithVisibility(b, Visibility.Public);
            }));
            var proto = new ProtoInjector(bd);
            var inj = new Injector(proto, null, depProvider);
            return inj;
          }
        });
      }());
      $__export("Injector", Injector);
      INJECTOR_KEY = Key.get(Injector);
    }
  };
});

System.register("angular2/src/change_detection/change_detection_jit_generator", ["angular2/src/facade/lang", "angular2/src/change_detection/abstract_change_detector", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/codegen_name_util", "angular2/src/change_detection/codegen_logic_util", "angular2/src/change_detection/codegen_facade"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection_jit_generator";
  var BaseException,
      isBlank,
      AbstractChangeDetector,
      ChangeDetectionUtil,
      CodegenNameUtil,
      sanitizeName,
      CodegenLogicUtil,
      codify,
      ABSTRACT_CHANGE_DETECTOR,
      UTIL,
      IS_CHANGED_LOCAL,
      CHANGES_LOCAL,
      ChangeDetectorJITGenerator;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
    }, function($__m) {
      AbstractChangeDetector = $__m.AbstractChangeDetector;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      CodegenNameUtil = $__m.CodegenNameUtil;
      sanitizeName = $__m.sanitizeName;
    }, function($__m) {
      CodegenLogicUtil = $__m.CodegenLogicUtil;
    }, function($__m) {
      codify = $__m.codify;
    }],
    execute: function() {
      ABSTRACT_CHANGE_DETECTOR = "AbstractChangeDetector";
      UTIL = "ChangeDetectionUtil";
      IS_CHANGED_LOCAL = "isChanged";
      CHANGES_LOCAL = "changes";
      ChangeDetectorJITGenerator = (function() {
        function ChangeDetectorJITGenerator(id, changeDetectionStrategy, records, propertyBindingTargets, eventBindings, directiveRecords, genConfig) {
          this.id = id;
          this.changeDetectionStrategy = changeDetectionStrategy;
          this.records = records;
          this.propertyBindingTargets = propertyBindingTargets;
          this.eventBindings = eventBindings;
          this.directiveRecords = directiveRecords;
          this.genConfig = genConfig;
          this._names = new CodegenNameUtil(this.records, this.eventBindings, this.directiveRecords, UTIL);
          this._logic = new CodegenLogicUtil(this._names, UTIL, changeDetectionStrategy);
          this._typeName = sanitizeName(("ChangeDetector_" + this.id));
        }
        return ($traceurRuntime.createClass)(ChangeDetectorJITGenerator, {
          generate: function() {
            var $__0 = this;
            var classDefinition = ("\n      var " + this._typeName + " = function " + this._typeName + "(dispatcher) {\n        " + ABSTRACT_CHANGE_DETECTOR + ".call(\n            this, " + JSON.stringify(this.id) + ", dispatcher, " + this.records.length + ",\n            " + this._typeName + ".gen_propertyBindingTargets, " + this._typeName + ".gen_directiveIndices,\n            " + codify(this.changeDetectionStrategy) + ");\n        this.dehydrateDirectives(false);\n      }\n\n      " + this._typeName + ".prototype = Object.create(" + ABSTRACT_CHANGE_DETECTOR + ".prototype);\n\n      " + this._typeName + ".prototype.detectChangesInRecordsInternal = function(throwOnChange) {\n        " + this._names.genInitLocals() + "\n        var " + IS_CHANGED_LOCAL + " = false;\n        var " + CHANGES_LOCAL + " = null;\n\n        " + this.records.map((function(r) {
              return $__0._genRecord(r);
            })).join("\n") + "\n\n        " + this._names.getAlreadyCheckedName() + " = true;\n      }\n\n      " + this._maybeGenHandleEventInternal() + "\n\n      " + this._genCheckNoChanges() + "\n\n      " + this._maybeGenCallOnAllChangesDone() + "\n\n      " + this._maybeGenHydrateDirectives() + "\n\n      " + this._maybeGenDehydrateDirectives() + "\n\n      " + this._genPropertyBindingTargets() + ";\n\n      " + this._genDirectiveIndices() + ";\n\n      return function(dispatcher) {\n        return new " + this._typeName + "(dispatcher);\n      }\n    ");
            return new Function(ABSTRACT_CHANGE_DETECTOR, UTIL, classDefinition)(AbstractChangeDetector, ChangeDetectionUtil);
          },
          _genPropertyBindingTargets: function() {
            var targets = this._logic.genPropertyBindingTargets(this.propertyBindingTargets, this.genConfig.genDebugInfo);
            return (this._typeName + ".gen_propertyBindingTargets = " + targets + ";");
          },
          _genDirectiveIndices: function() {
            var indices = this._logic.genDirectiveIndices(this.directiveRecords);
            return (this._typeName + ".gen_directiveIndices = " + indices + ";");
          },
          _maybeGenHandleEventInternal: function() {
            var $__0 = this;
            if (this.eventBindings.length > 0) {
              var handlers = this.eventBindings.map((function(eb) {
                return $__0._genEventBinding(eb);
              })).join("\n");
              return ("\n        " + this._typeName + ".prototype.handleEventInternal = function(eventName, elIndex, locals) {\n          var " + this._names.getPreventDefaultAccesor() + " = false;\n          " + this._names.genInitEventLocals() + "\n          " + handlers + "\n          return " + this._names.getPreventDefaultAccesor() + ";\n        }\n      ");
            } else {
              return '';
            }
          },
          _genEventBinding: function(eb) {
            var $__0 = this;
            var recs = eb.records.map((function(r) {
              return $__0._genEventBindingEval(eb, r);
            })).join("\n");
            return ("\n    if (eventName === \"" + eb.eventName + "\" && elIndex === " + eb.elIndex + ") {\n      " + recs + "\n    }");
          },
          _genEventBindingEval: function(eb, r) {
            if (r.lastInBinding) {
              var evalRecord = this._logic.genEventBindingEvalValue(eb, r);
              var markPath = this._genMarkPathToRootAsCheckOnce(r);
              var prevDefault = this._genUpdatePreventDefault(eb, r);
              return (evalRecord + "\n" + markPath + "\n" + prevDefault);
            } else {
              return this._logic.genEventBindingEvalValue(eb, r);
            }
          },
          _genMarkPathToRootAsCheckOnce: function(r) {
            var br = r.bindingRecord;
            if (br.isDefaultChangeDetection()) {
              return "";
            } else {
              return (this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markPathToRootAsCheckOnce();");
            }
          },
          _genUpdatePreventDefault: function(eb, r) {
            var local = this._names.getEventLocalName(eb, r.selfIndex);
            return ("if (" + local + " === false) { " + this._names.getPreventDefaultAccesor() + " = true};");
          },
          _maybeGenDehydrateDirectives: function() {
            var destroyPipesCode = this._names.genPipeOnDestroy();
            if (destroyPipesCode) {
              destroyPipesCode = ("if (destroyPipes) { " + destroyPipesCode + " }");
            }
            var dehydrateFieldsCode = this._names.genDehydrateFields();
            if (!destroyPipesCode && !dehydrateFieldsCode)
              return '';
            return (this._typeName + ".prototype.dehydrateDirectives = function(destroyPipes) {\n        " + destroyPipesCode + "\n        " + dehydrateFieldsCode + "\n    }");
          },
          _maybeGenHydrateDirectives: function() {
            var hydrateDirectivesCode = this._logic.genHydrateDirectives(this.directiveRecords);
            var hydrateDetectorsCode = this._logic.genHydrateDetectors(this.directiveRecords);
            if (!hydrateDirectivesCode && !hydrateDetectorsCode)
              return '';
            return (this._typeName + ".prototype.hydrateDirectives = function(directives) {\n      " + hydrateDirectivesCode + "\n      " + hydrateDetectorsCode + "\n    }");
          },
          _maybeGenCallOnAllChangesDone: function() {
            var notifications = [];
            var dirs = this.directiveRecords;
            for (var i = dirs.length - 1; i >= 0; --i) {
              var dir = dirs[i];
              if (dir.callOnAllChangesDone) {
                notifications.push((this._names.getDirectiveName(dir.directiveIndex) + ".onAllChangesDone();"));
              }
            }
            if (notifications.length > 0) {
              var directiveNotifications = notifications.join("\n");
              return ("\n        " + this._typeName + ".prototype.callOnAllChangesDone = function() {\n          " + ABSTRACT_CHANGE_DETECTOR + ".prototype.callOnAllChangesDone.call(this);\n          " + directiveNotifications + "\n        }\n      ");
            } else {
              return '';
            }
          },
          _genRecord: function(r) {
            var rec;
            if (r.isLifeCycleRecord()) {
              rec = this._genDirectiveLifecycle(r);
            } else if (r.isPipeRecord()) {
              rec = this._genPipeCheck(r);
            } else {
              rec = this._genReferenceCheck(r);
            }
            return ("\n      " + this._maybeFirstInBinding(r) + "\n      " + rec + "\n      " + this._maybeGenLastInDirective(r) + "\n    ");
          },
          _genDirectiveLifecycle: function(r) {
            if (r.name === "onCheck") {
              return this._genOnCheck(r);
            } else if (r.name === "onInit") {
              return this._genOnInit(r);
            } else if (r.name === "onChange") {
              return this._genOnChange(r);
            } else {
              throw new BaseException(("Unknown lifecycle event '" + r.name + "'"));
            }
          },
          _genPipeCheck: function(r) {
            var $__0 = this;
            var context = this._names.getLocalName(r.contextIndex);
            var argString = r.args.map((function(arg) {
              return $__0._names.getLocalName(arg);
            })).join(", ");
            var oldValue = this._names.getFieldName(r.selfIndex);
            var newValue = this._names.getLocalName(r.selfIndex);
            var pipe = this._names.getPipeName(r.selfIndex);
            var pipeType = r.name;
            var read = ("\n      if (" + pipe + " === " + UTIL + ".uninitialized) {\n        " + pipe + " = " + this._names.getPipesAccessorName() + ".get('" + pipeType + "');\n      }\n      " + newValue + " = " + pipe + ".transform(" + context + ", [" + argString + "]);\n    ");
            var check = ("\n      if (" + oldValue + " !== " + newValue + ") {\n        " + newValue + " = " + UTIL + ".unwrapValue(" + newValue + ")\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ");
            return r.shouldBeChecked() ? ("" + read + check) : read;
          },
          _genReferenceCheck: function(r) {
            var $__0 = this;
            var oldValue = this._names.getFieldName(r.selfIndex);
            var newValue = this._names.getLocalName(r.selfIndex);
            var read = ("\n      " + this._logic.genPropertyBindingEvalValue(r) + "\n    ");
            var check = ("\n      if (" + newValue + " !== " + oldValue + ") {\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ");
            var genCode = r.shouldBeChecked() ? ("" + read + check) : read;
            if (r.isPureFunction()) {
              var condition = r.args.map((function(a) {
                return $__0._names.getChangeName(a);
              })).join(" || ");
              if (r.isUsedByOtherRecord()) {
                return ("if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }");
              } else {
                return ("if (" + condition + ") { " + genCode + " }");
              }
            } else {
              return genCode;
            }
          },
          _genChangeMarker: function(r) {
            return r.argumentToPureFunction ? (this._names.getChangeName(r.selfIndex) + " = true") : "";
          },
          _genUpdateDirectiveOrElement: function(r) {
            if (!r.lastInBinding)
              return "";
            var newValue = this._names.getLocalName(r.selfIndex);
            var oldValue = this._names.getFieldName(r.selfIndex);
            var notifyDebug = this.genConfig.logBindingUpdate ? ("this.logBindingUpdate(" + newValue + ");") : "";
            var br = r.bindingRecord;
            if (br.target.isDirective()) {
              var directiveProperty = (this._names.getDirectiveName(br.directiveRecord.directiveIndex) + "." + br.target.name);
              return ("\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        " + directiveProperty + " = " + newValue + ";\n        " + notifyDebug + "\n        " + IS_CHANGED_LOCAL + " = true;\n      ");
            } else {
              return ("\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        this.notifyDispatcher(" + newValue + ");\n        " + notifyDebug + "\n      ");
            }
          },
          _genThrowOnChangeCheck: function(oldValue, newValue) {
            if (this.genConfig.genCheckNoChanges) {
              return ("\n        if(throwOnChange) {\n          this.throwOnChangeError(" + oldValue + ", " + newValue + ");\n        }\n        ");
            } else {
              return '';
            }
          },
          _genCheckNoChanges: function() {
            if (this.genConfig.genCheckNoChanges) {
              return (this._typeName + ".prototype.checkNoChanges = function() { this.runDetectChanges(true); }");
            } else {
              return '';
            }
          },
          _genAddToChanges: function(r) {
            var newValue = this._names.getLocalName(r.selfIndex);
            var oldValue = this._names.getFieldName(r.selfIndex);
            if (!r.bindingRecord.callOnChange())
              return "";
            return (CHANGES_LOCAL + " = this.addChange(" + CHANGES_LOCAL + ", " + oldValue + ", " + newValue + ");");
          },
          _maybeFirstInBinding: function(r) {
            var prev = ChangeDetectionUtil.protoByIndex(this.records, r.selfIndex - 1);
            var firstInBindng = isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
            return firstInBindng && !r.bindingRecord.isDirectiveLifecycle() ? (this._names.getPropertyBindingIndex() + " = " + r.propertyBindingIndex + ";") : '';
          },
          _maybeGenLastInDirective: function(r) {
            if (!r.lastInDirective)
              return "";
            return ("\n      " + CHANGES_LOCAL + " = null;\n      " + this._genNotifyOnPushDetectors(r) + "\n      " + IS_CHANGED_LOCAL + " = false;\n    ");
          },
          _genOnCheck: function(r) {
            var br = r.bindingRecord;
            return ("if (!throwOnChange) " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onCheck();");
          },
          _genOnInit: function(r) {
            var br = r.bindingRecord;
            return ("if (!throwOnChange && !" + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onInit();");
          },
          _genOnChange: function(r) {
            var br = r.bindingRecord;
            return ("if (!throwOnChange && " + CHANGES_LOCAL + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onChange(" + CHANGES_LOCAL + ");");
          },
          _genNotifyOnPushDetectors: function(r) {
            var br = r.bindingRecord;
            if (!r.lastInDirective || br.isDefaultChangeDetection())
              return "";
            var retVal = ("\n      if(" + IS_CHANGED_LOCAL + ") {\n        " + this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markAsCheckOnce();\n      }\n    ");
            return retVal;
          }
        }, {});
      }());
      $__export("ChangeDetectorJITGenerator", ChangeDetectorJITGenerator);
    }
  };
});

System.register("angular2/src/core/compiler/element_injector", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/di", "angular2/src/di/injector", "angular2/src/core/metadata/di", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/template_ref", "angular2/src/core/metadata/directives", "angular2/src/core/compiler/directive_lifecycle_reflector", "angular2/src/change_detection/change_detection", "angular2/src/core/compiler/query_list", "angular2/src/reflection/reflection", "angular2/src/render/api", "angular2/src/render/dom/util", "angular2/src/core/pipes/pipe_binding"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_injector";
  var isPresent,
      isBlank,
      BaseException,
      stringify,
      ObservableWrapper,
      ListWrapper,
      MapWrapper,
      Injector,
      ProtoInjector,
      Visibility,
      UNDEFINED,
      Key,
      Dependency,
      Binding,
      ResolvedBinding,
      NoBindingError,
      InjectorInlineStrategy,
      BindingWithVisibility,
      AttributeMetadata,
      QueryMetadata,
      avmModule,
      ViewContainerRef,
      ElementRef,
      TemplateRef,
      DirectiveMetadata,
      ComponentMetadata,
      LifecycleEvent,
      hasLifecycleHook,
      ChangeDetectorRef,
      QueryList,
      reflector,
      RenderDirectiveMetadata,
      EventConfig,
      PipeBinding,
      _staticKeys,
      StaticKeys,
      TreeNode,
      DirectiveDependency,
      DirectiveBinding,
      PreBuiltObjects,
      EventEmitterAccessor,
      HostActionAccessor,
      ProtoElementInjector,
      _Context,
      ElementInjector,
      ElementInjectorInlineStrategy,
      ElementInjectorDynamicStrategy,
      QueryError,
      QueryRef;
  function _createEventEmitterAccessors(bwv) {
    var binding = bwv.binding;
    if (!(binding instanceof DirectiveBinding))
      return [];
    var db = binding;
    return ListWrapper.map(db.eventEmitters, (function(eventConfig) {
      var parsedEvent = EventConfig.parse(eventConfig);
      return new EventEmitterAccessor(parsedEvent.eventName, reflector.getter(parsedEvent.fieldName));
    }));
  }
  function _createHostActionAccessors(bwv) {
    var binding = bwv.binding;
    if (!(binding instanceof DirectiveBinding))
      return [];
    var res = [];
    var db = binding;
    MapWrapper.forEach(db.hostActions, (function(actionExpression, actionName) {
      res.push(new HostActionAccessor(actionExpression, reflector.getter(actionName)));
    }));
    return res;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
    }, function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      Injector = $__m.Injector;
      ProtoInjector = $__m.ProtoInjector;
      Visibility = $__m.Visibility;
      UNDEFINED = $__m.UNDEFINED;
      Key = $__m.Key;
      Dependency = $__m.Dependency;
      Binding = $__m.Binding;
      ResolvedBinding = $__m.ResolvedBinding;
      NoBindingError = $__m.NoBindingError;
    }, function($__m) {
      InjectorInlineStrategy = $__m.InjectorInlineStrategy;
      BindingWithVisibility = $__m.BindingWithVisibility;
    }, function($__m) {
      AttributeMetadata = $__m.AttributeMetadata;
      QueryMetadata = $__m.QueryMetadata;
    }, function($__m) {
      avmModule = $__m;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      DirectiveMetadata = $__m.DirectiveMetadata;
      ComponentMetadata = $__m.ComponentMetadata;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      hasLifecycleHook = $__m.hasLifecycleHook;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      RenderDirectiveMetadata = $__m.RenderDirectiveMetadata;
    }, function($__m) {
      EventConfig = $__m.EventConfig;
    }, function($__m) {
      PipeBinding = $__m.PipeBinding;
    }],
    execute: function() {
      StaticKeys = (function() {
        function StaticKeys() {
          this.viewManagerId = Key.get(avmModule.AppViewManager).id;
          this.templateRefId = Key.get(TemplateRef).id;
          this.viewContainerId = Key.get(ViewContainerRef).id;
          this.changeDetectorRefId = Key.get(ChangeDetectorRef).id;
          this.elementRefId = Key.get(ElementRef).id;
        }
        return ($traceurRuntime.createClass)(StaticKeys, {}, {instance: function() {
            if (isBlank(_staticKeys))
              _staticKeys = new StaticKeys();
            return _staticKeys;
          }});
      }());
      $__export("StaticKeys", StaticKeys);
      TreeNode = (function() {
        function TreeNode(parent) {
          this._head = null;
          this._tail = null;
          this._next = null;
          if (isPresent(parent))
            parent.addChild(this);
        }
        return ($traceurRuntime.createClass)(TreeNode, {
          addChild: function(child) {
            if (isPresent(this._tail)) {
              this._tail._next = child;
              this._tail = child;
            } else {
              this._tail = this._head = child;
            }
            child._next = null;
            child._parent = this;
          },
          addChildAfter: function(child, prevSibling) {
            if (isBlank(prevSibling)) {
              var prevHead = this._head;
              this._head = child;
              child._next = prevHead;
              if (isBlank(this._tail))
                this._tail = child;
            } else if (isBlank(prevSibling._next)) {
              this.addChild(child);
              return ;
            } else {
              child._next = prevSibling._next;
              prevSibling._next = child;
            }
            child._parent = this;
          },
          remove: function() {
            if (isBlank(this.parent))
              return ;
            var nextSibling = this._next;
            var prevSibling = this._findPrev();
            if (isBlank(prevSibling)) {
              this.parent._head = this._next;
            } else {
              prevSibling._next = this._next;
            }
            if (isBlank(nextSibling)) {
              this._parent._tail = prevSibling;
            }
            this._parent = null;
            this._next = null;
          },
          _findPrev: function() {
            var node = this.parent._head;
            if (node == this)
              return null;
            while (node._next !== this)
              node = node._next;
            return node;
          },
          get parent() {
            return this._parent;
          },
          get children() {
            var res = [];
            var child = this._head;
            while (child != null) {
              res.push(child);
              child = child._next;
            }
            return res;
          }
        }, {});
      }());
      $__export("TreeNode", TreeNode);
      DirectiveDependency = (function($__super) {
        function DirectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties, attributeName, queryDecorator) {
          $traceurRuntime.superConstructor(DirectiveDependency).call(this, key, optional, lowerBoundVisibility, upperBoundVisibility, properties);
          this.attributeName = attributeName;
          this.queryDecorator = queryDecorator;
          this._verify();
        }
        return ($traceurRuntime.createClass)(DirectiveDependency, {_verify: function() {
            var count = 0;
            if (isPresent(this.queryDecorator))
              count++;
            if (isPresent(this.attributeName))
              count++;
            if (count > 1)
              throw new BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
          }}, {
          createFrom: function(d) {
            return new DirectiveDependency(d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties, DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
          },
          _attributeName: function(properties) {
            var p = ListWrapper.find(properties, (function(p) {
              return p instanceof AttributeMetadata;
            }));
            return isPresent(p) ? p.attributeName : null;
          },
          _query: function(properties) {
            return ListWrapper.find(properties, (function(p) {
              return p instanceof QueryMetadata;
            }));
          }
        }, $__super);
      }(Dependency));
      $__export("DirectiveDependency", DirectiveDependency);
      DirectiveBinding = (function($__super) {
        function DirectiveBinding(key, factory, dependencies, resolvedBindings, resolvedViewBindings, metadata) {
          $traceurRuntime.superConstructor(DirectiveBinding).call(this, key, factory, dependencies);
          this.resolvedBindings = resolvedBindings;
          this.resolvedViewBindings = resolvedViewBindings;
          this.metadata = metadata;
        }
        return ($traceurRuntime.createClass)(DirectiveBinding, {
          get callOnDestroy() {
            return this.metadata.callOnDestroy;
          },
          get callOnChange() {
            return this.metadata.callOnChange;
          },
          get callOnAllChangesDone() {
            return this.metadata.callOnAllChangesDone;
          },
          get displayName() {
            return this.key.displayName;
          },
          get eventEmitters() {
            return isPresent(this.metadata) && isPresent(this.metadata.events) ? this.metadata.events : [];
          },
          get hostActions() {
            return isPresent(this.metadata) && isPresent(this.metadata.hostActions) ? this.metadata.hostActions : new Map();
          },
          get changeDetection() {
            return this.metadata.changeDetection;
          }
        }, {
          createFromBinding: function(binding, ann) {
            if (isBlank(ann)) {
              ann = new DirectiveMetadata();
            }
            var rb = binding.resolve();
            var deps = ListWrapper.map(rb.dependencies, DirectiveDependency.createFrom);
            var resolvedBindings = isPresent(ann.bindings) ? Injector.resolve(ann.bindings) : [];
            var resolvedViewBindings = ann instanceof ComponentMetadata && isPresent(ann.viewBindings) ? Injector.resolve(ann.viewBindings) : [];
            var metadata = RenderDirectiveMetadata.create({
              id: stringify(rb.key.token),
              type: ann instanceof ComponentMetadata ? RenderDirectiveMetadata.COMPONENT_TYPE : RenderDirectiveMetadata.DIRECTIVE_TYPE,
              selector: ann.selector,
              compileChildren: ann.compileChildren,
              events: ann.events,
              host: isPresent(ann.host) ? MapWrapper.createFromStringMap(ann.host) : null,
              properties: ann.properties,
              readAttributes: DirectiveBinding._readAttributes(deps),
              callOnDestroy: hasLifecycleHook(LifecycleEvent.onDestroy, rb.key.token, ann),
              callOnChange: hasLifecycleHook(LifecycleEvent.onChange, rb.key.token, ann),
              callOnCheck: hasLifecycleHook(LifecycleEvent.onCheck, rb.key.token, ann),
              callOnInit: hasLifecycleHook(LifecycleEvent.onInit, rb.key.token, ann),
              callOnAllChangesDone: hasLifecycleHook(LifecycleEvent.onAllChangesDone, rb.key.token, ann),
              changeDetection: ann instanceof ComponentMetadata ? ann.changeDetection : null,
              exportAs: ann.exportAs
            });
            return new DirectiveBinding(rb.key, rb.factory, deps, resolvedBindings, resolvedViewBindings, metadata);
          },
          _readAttributes: function(deps) {
            var readAttributes = [];
            ListWrapper.forEach(deps, (function(dep) {
              if (isPresent(dep.attributeName)) {
                readAttributes.push(dep.attributeName);
              }
            }));
            return readAttributes;
          },
          createFromType: function(type, annotation) {
            var binding = new Binding(type, {toClass: type});
            return DirectiveBinding.createFromBinding(binding, annotation);
          }
        }, $__super);
      }(ResolvedBinding));
      $__export("DirectiveBinding", DirectiveBinding);
      PreBuiltObjects = (function() {
        function PreBuiltObjects(viewManager, view, elementRef, templateRef) {
          this.viewManager = viewManager;
          this.view = view;
          this.elementRef = elementRef;
          this.templateRef = templateRef;
        }
        return ($traceurRuntime.createClass)(PreBuiltObjects, {}, {});
      }());
      $__export("PreBuiltObjects", PreBuiltObjects);
      EventEmitterAccessor = (function() {
        function EventEmitterAccessor(eventName, getter) {
          this.eventName = eventName;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(EventEmitterAccessor, {subscribe: function(view, boundElementIndex, directive) {
            var $__0 = this;
            var eventEmitter = this.getter(directive);
            return ObservableWrapper.subscribe(eventEmitter, (function(eventObj) {
              return view.triggerEventHandlers($__0.eventName, eventObj, boundElementIndex);
            }));
          }}, {});
      }());
      $__export("EventEmitterAccessor", EventEmitterAccessor);
      HostActionAccessor = (function() {
        function HostActionAccessor(methodName, getter) {
          this.methodName = methodName;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(HostActionAccessor, {subscribe: function(view, boundElementIndex, directive) {
            var $__0 = this;
            var eventEmitter = this.getter(directive);
            return ObservableWrapper.subscribe(eventEmitter, (function(actionArgs) {
              return view.invokeElementMethod(boundElementIndex, $__0.methodName, actionArgs);
            }));
          }}, {});
      }());
      $__export("HostActionAccessor", HostActionAccessor);
      ProtoElementInjector = (function() {
        function ProtoElementInjector(parent, index, bwv, distanceToParent, _firstBindingIsComponent, directiveVariableBindings) {
          this.parent = parent;
          this.index = index;
          this.distanceToParent = distanceToParent;
          this._firstBindingIsComponent = _firstBindingIsComponent;
          this.directiveVariableBindings = directiveVariableBindings;
          var length = bwv.length;
          this.protoInjector = new ProtoInjector(bwv);
          this.eventEmitterAccessors = ListWrapper.createFixedSize(length);
          this.hostActionAccessors = ListWrapper.createFixedSize(length);
          for (var i = 0; i < length; ++i) {
            this.eventEmitterAccessors[i] = _createEventEmitterAccessors(bwv[i]);
            this.hostActionAccessors[i] = _createHostActionAccessors(bwv[i]);
          }
        }
        return ($traceurRuntime.createClass)(ProtoElementInjector, {
          instantiate: function(parent) {
            return new ElementInjector(this, parent);
          },
          directParent: function() {
            return this.distanceToParent < 2 ? this.parent : null;
          },
          get hasBindings() {
            return this.eventEmitterAccessors.length > 0;
          },
          getBindingAtIndex: function(index) {
            return this.protoInjector.getBindingAtIndex(index);
          }
        }, {
          create: function(parent, index, bindings, firstBindingIsComponent, distanceToParent, directiveVariableBindings) {
            var bd = [];
            ProtoElementInjector._createDirectiveBindingWithVisibility(bindings, bd, firstBindingIsComponent);
            if (firstBindingIsComponent) {
              ProtoElementInjector._createViewBindingsWithVisibility(bindings, bd);
            }
            ProtoElementInjector._createBindingsWithVisibility(bindings, bd, firstBindingIsComponent);
            return new ProtoElementInjector(parent, index, bd, distanceToParent, firstBindingIsComponent, directiveVariableBindings);
          },
          _createDirectiveBindingWithVisibility: function(dirBindings, bd, firstBindingIsComponent) {
            ListWrapper.forEach(dirBindings, (function(dirBinding) {
              bd.push(ProtoElementInjector._createBindingWithVisibility(firstBindingIsComponent, dirBinding, dirBindings, dirBinding));
            }));
          },
          _createBindingsWithVisibility: function(dirBindings, bd, firstBindingIsComponent) {
            ListWrapper.forEach(dirBindings, (function(dirBinding) {
              ListWrapper.forEach(dirBinding.resolvedBindings, (function(b) {
                bd.push(ProtoElementInjector._createBindingWithVisibility(firstBindingIsComponent, dirBinding, dirBindings, b));
              }));
            }));
          },
          _createBindingWithVisibility: function(firstBindingIsComponent, dirBinding, dirBindings, binding) {
            var isComponent = firstBindingIsComponent && dirBindings[0] === dirBinding;
            return new BindingWithVisibility(binding, isComponent ? Visibility.PublicAndPrivate : Visibility.Public);
          },
          _createViewBindingsWithVisibility: function(bindings, bd) {
            var db = bindings[0];
            ListWrapper.forEach(db.resolvedViewBindings, (function(b) {
              return bd.push(new BindingWithVisibility(b, Visibility.Private));
            }));
          }
        });
      }());
      $__export("ProtoElementInjector", ProtoElementInjector);
      _Context = (function() {
        function _Context(element, componentElement, injector) {
          this.element = element;
          this.componentElement = componentElement;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(_Context, {}, {});
      }());
      ElementInjector = (function($__super) {
        function ElementInjector(_proto, parent) {
          var $__0;
          $traceurRuntime.superConstructor(ElementInjector).call(this, parent);
          this._proto = _proto;
          this._preBuiltObjects = null;
          this._injector = new Injector(this._proto.protoInjector, null, this, ($__0 = this, function() {
            return $__0._debugContext();
          }));
          var injectorStrategy = this._injector.internalStrategy;
          this._strategy = injectorStrategy instanceof InjectorInlineStrategy ? new ElementInjectorInlineStrategy(injectorStrategy, this) : new ElementInjectorDynamicStrategy(injectorStrategy, this);
          this.hydrated = false;
          this._buildQueries();
          this._addParentQueries();
        }
        return ($traceurRuntime.createClass)(ElementInjector, {
          dehydrate: function() {
            this.hydrated = false;
            this._host = null;
            this._preBuiltObjects = null;
            this._strategy.callOnDestroy();
            this._strategy.dehydrate();
          },
          onAllChangesDone: function() {
            if (isPresent(this._query0) && this._query0.originator === this) {
              this._query0.list.fireCallbacks();
            }
            if (isPresent(this._query1) && this._query1.originator === this) {
              this._query1.list.fireCallbacks();
            }
            if (isPresent(this._query2) && this._query2.originator === this) {
              this._query2.list.fireCallbacks();
            }
          },
          hydrate: function(imperativelyCreatedInjector, host, preBuiltObjects) {
            this._host = host;
            this._preBuiltObjects = preBuiltObjects;
            if (isPresent(host)) {
              this._addViewQueries(host);
            }
            this._reattachInjectors(imperativelyCreatedInjector);
            this._strategy.hydrate();
            this._addDirectivesToQueries();
            this._addVarBindingsToQueries();
            this.hydrated = true;
            this._updateViewQueries();
          },
          _updateViewQueries: function() {
            if (isPresent(this._query0) && this._query0.isViewQuery) {
              this._query0.update();
            }
            if (isPresent(this._query1) && this._query1.isViewQuery) {
              this._query1.update();
            }
            if (isPresent(this._query2) && this._query2.isViewQuery) {
              this._query2.update();
            }
          },
          _debugContext: function() {
            var p = this._preBuiltObjects;
            var index = p.elementRef.boundElementIndex - p.view.elementOffset;
            var c = this._preBuiltObjects.view.getDebugContext(index, null);
            return isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
          },
          _reattachInjectors: function(imperativelyCreatedInjector) {
            if (isPresent(this._parent)) {
              if (isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._parent._injector, false);
              } else {
                this._reattachInjector(this._injector, this._parent._injector, false);
              }
            } else if (isPresent(this._host)) {
              if (isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._host._injector, true);
              } else {
                this._reattachInjector(this._injector, this._host._injector, true);
              }
            } else {
              if (isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, true);
              }
            }
          },
          _reattachInjector: function(injector, parentInjector, isBoundary) {
            injector.internalStrategy.attach(parentInjector, isBoundary);
          },
          hasVariableBinding: function(name) {
            var vb = this._proto.directiveVariableBindings;
            return isPresent(vb) && vb.has(name);
          },
          getVariableBinding: function(name) {
            var index = this._proto.directiveVariableBindings.get(name);
            return isPresent(index) ? this.getDirectiveAtIndex(index) : this.getElementRef();
          },
          get: function(token) {
            return this._injector.get(token);
          },
          hasDirective: function(type) {
            return isPresent(this._injector.getOptional(type));
          },
          getEventEmitterAccessors: function() {
            return this._proto.eventEmitterAccessors;
          },
          getHostActionAccessors: function() {
            return this._proto.hostActionAccessors;
          },
          getDirectiveVariableBindings: function() {
            return this._proto.directiveVariableBindings;
          },
          getComponent: function() {
            return this._strategy.getComponent();
          },
          getInjector: function() {
            return this._injector;
          },
          getElementRef: function() {
            return this._preBuiltObjects.elementRef;
          },
          getViewContainerRef: function() {
            return new ViewContainerRef(this._preBuiltObjects.viewManager, this.getElementRef());
          },
          directParent: function() {
            return this._proto.distanceToParent < 2 ? this.parent : null;
          },
          isComponentKey: function(key) {
            return this._strategy.isComponentKey(key);
          },
          getDependency: function(injector, binding, dep) {
            var key = dep.key;
            if (binding instanceof DirectiveBinding) {
              var dirDep = dep;
              var dirBin = binding;
              var staticKeys = StaticKeys.instance();
              if (key.id === staticKeys.viewManagerId)
                return this._preBuiltObjects.viewManager;
              if (isPresent(dirDep.attributeName))
                return this._buildAttribute(dirDep);
              if (isPresent(dirDep.queryDecorator))
                return this._findQuery(dirDep.queryDecorator).list;
              if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
                if (dirBin.metadata.type === RenderDirectiveMetadata.COMPONENT_TYPE) {
                  var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                  return componentView.changeDetector.ref;
                } else {
                  return this._preBuiltObjects.view.changeDetector.ref;
                }
              }
              if (dirDep.key.id === StaticKeys.instance().elementRefId) {
                return this.getElementRef();
              }
              if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
                return this.getViewContainerRef();
              }
              if (dirDep.key.id === StaticKeys.instance().templateRefId) {
                if (isBlank(this._preBuiltObjects.templateRef)) {
                  if (dirDep.optional) {
                    return null;
                  }
                  throw new NoBindingError(null, dirDep.key);
                }
                return this._preBuiltObjects.templateRef;
              }
            } else if (binding instanceof PipeBinding) {
              if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
                var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                return componentView.changeDetector.ref;
              }
            }
            return UNDEFINED;
          },
          _buildAttribute: function(dep) {
            var attributes = this._proto.attributes;
            if (isPresent(attributes) && attributes.has(dep.attributeName)) {
              return attributes.get(dep.attributeName);
            } else {
              return null;
            }
          },
          _buildQueriesForDeps: function(deps) {
            for (var i = 0; i < deps.length; i++) {
              var dep = deps[i];
              if (isPresent(dep.queryDecorator)) {
                this._createQueryRef(dep.queryDecorator);
              }
            }
          },
          _addViewQueries: function(host) {
            this._addViewQuery(host._query0, host);
            this._addViewQuery(host._query1, host);
            this._addViewQuery(host._query2, host);
          },
          _addViewQuery: function(queryRef, host) {
            if (isBlank(queryRef) || !queryRef.isViewQuery || this._hasQuery(queryRef))
              return ;
            if (queryRef.originator == host) {
              if (!queryRef.query.descendants && isPresent(this.parent))
                return ;
              this._assignQueryRef(queryRef);
            }
          },
          _addVarBindingsToQueries: function() {
            this._addVarBindingsToQuery(this._query0);
            this._addVarBindingsToQuery(this._query1);
            this._addVarBindingsToQuery(this._query2);
          },
          _addDirectivesToQueries: function() {
            this._addDirectivesToQuery(this._query0);
            this._addDirectivesToQuery(this._query1);
            this._addDirectivesToQuery(this._query2);
          },
          _addVarBindingsToQuery: function(queryRef) {
            if (isBlank(queryRef) || !queryRef.query.isVarBindingQuery)
              return ;
            var vb = queryRef.query.varBindings;
            for (var i = 0; i < vb.length; ++i) {
              if (this.hasVariableBinding(vb[i])) {
                queryRef.list.add(this.getVariableBinding(vb[i]));
              }
            }
          },
          _addDirectivesToQuery: function(queryRef) {
            if (isBlank(queryRef) || queryRef.query.isVarBindingQuery)
              return ;
            if (queryRef.isViewQuery && queryRef.originator == this)
              return ;
            var matched = [];
            this.addDirectivesMatchingQuery(queryRef.query, matched);
            matched.forEach((function(s) {
              return queryRef.list.add(s);
            }));
          },
          _createQueryRef: function(query) {
            var queryList = new QueryList();
            if (isBlank(this._query0)) {
              this._query0 = new QueryRef(query, queryList, this);
            } else if (isBlank(this._query1)) {
              this._query1 = new QueryRef(query, queryList, this);
            } else if (isBlank(this._query2)) {
              this._query2 = new QueryRef(query, queryList, this);
            } else {
              throw new QueryError();
            }
          },
          addDirectivesMatchingQuery: function(query, list) {
            var templateRef = this._preBuiltObjects.templateRef;
            if (query.selector === TemplateRef && isPresent(templateRef)) {
              list.push(templateRef);
            }
            this._strategy.addDirectivesMatchingQuery(query, list);
          },
          _buildQueries: function() {
            if (isPresent(this._proto)) {
              this._strategy.buildQueries();
            }
          },
          _findQuery: function(query) {
            if (isPresent(this._query0) && this._query0.query === query) {
              return this._query0;
            }
            if (isPresent(this._query1) && this._query1.query === query) {
              return this._query1;
            }
            if (isPresent(this._query2) && this._query2.query === query) {
              return this._query2;
            }
            throw new BaseException(("Cannot find query for directive " + query + "."));
          },
          _hasQuery: function(query) {
            return this._query0 == query || this._query1 == query || this._query2 == query;
          },
          link: function(parent) {
            parent.addChild(this);
            this._addParentQueries();
          },
          linkAfter: function(parent, prevSibling) {
            parent.addChildAfter(this, prevSibling);
            this._addParentQueries();
          },
          unlink: function() {
            var parent = this.parent;
            this.remove();
            this._removeParentQueries(parent);
          },
          _addParentQueries: function() {
            if (isBlank(this.parent))
              return ;
            this._addParentQuery(this.parent._query0);
            this._addParentQuery(this.parent._query1);
            this._addParentQuery(this.parent._query2);
          },
          _addParentQuery: function(query) {
            if (isPresent(query) && !this._hasQuery(query)) {
              this._addQueryToTree(query);
              if (this.hydrated)
                query.update();
            }
          },
          _removeParentQueries: function(parent) {
            this._removeParentQuery(parent._query0);
            this._removeParentQuery(parent._query1);
            this._removeParentQuery(parent._query2);
          },
          _removeParentQuery: function(query) {
            if (isPresent(query)) {
              this._pruneQueryFromTree(query);
              query.update();
            }
          },
          _pruneQueryFromTree: function(query) {
            this._removeQueryRef(query);
            var child = this._head;
            while (isPresent(child)) {
              child._pruneQueryFromTree(query);
              child = child._next;
            }
          },
          _addQueryToTree: function(queryRef) {
            if (queryRef.query.descendants == false) {
              if (this == queryRef.originator) {
                this._addQueryToTreeSelfAndRecurse(queryRef);
              } else if (this.parent == queryRef.originator) {
                this._assignQueryRef(queryRef);
              }
            } else {
              this._addQueryToTreeSelfAndRecurse(queryRef);
            }
          },
          _addQueryToTreeSelfAndRecurse: function(queryRef) {
            this._assignQueryRef(queryRef);
            var child = this._head;
            while (isPresent(child)) {
              child._addQueryToTree(queryRef);
              child = child._next;
            }
          },
          _assignQueryRef: function(query) {
            if (isBlank(this._query0)) {
              this._query0 = query;
              return ;
            } else if (isBlank(this._query1)) {
              this._query1 = query;
              return ;
            } else if (isBlank(this._query2)) {
              this._query2 = query;
              return ;
            }
            throw new QueryError();
          },
          _removeQueryRef: function(query) {
            if (this._query0 == query)
              this._query0 = null;
            if (this._query1 == query)
              this._query1 = null;
            if (this._query2 == query)
              this._query2 = null;
          },
          getDirectiveAtIndex: function(index) {
            return this._injector.getAt(index);
          },
          hasInstances: function() {
            return this._proto.hasBindings && this.hydrated;
          },
          getHost: function() {
            return this._host;
          },
          getBoundElementIndex: function() {
            return this._proto.index;
          },
          getRootViewInjectors: function() {
            if (!this.hydrated)
              return [];
            var view = this._preBuiltObjects.view;
            var nestedView = view.getNestedView(view.elementOffset + this.getBoundElementIndex());
            return isPresent(nestedView) ? nestedView.rootElementInjectors : [];
          }
        }, {}, $__super);
      }(TreeNode));
      $__export("ElementInjector", ElementInjector);
      ElementInjectorInlineStrategy = (function() {
        function ElementInjectorInlineStrategy(injectorStrategy, _ei) {
          this.injectorStrategy = injectorStrategy;
          this._ei = _ei;
        }
        return ($traceurRuntime.createClass)(ElementInjectorInlineStrategy, {
          hydrate: function() {
            var i = this.injectorStrategy;
            var p = i.protoStrategy;
            i.resetConstructionCounter();
            if (p.binding0 instanceof DirectiveBinding && isPresent(p.keyId0) && i.obj0 === UNDEFINED)
              i.obj0 = i.instantiateBinding(p.binding0, p.visibility0);
            if (p.binding1 instanceof DirectiveBinding && isPresent(p.keyId1) && i.obj1 === UNDEFINED)
              i.obj1 = i.instantiateBinding(p.binding1, p.visibility1);
            if (p.binding2 instanceof DirectiveBinding && isPresent(p.keyId2) && i.obj2 === UNDEFINED)
              i.obj2 = i.instantiateBinding(p.binding2, p.visibility2);
            if (p.binding3 instanceof DirectiveBinding && isPresent(p.keyId3) && i.obj3 === UNDEFINED)
              i.obj3 = i.instantiateBinding(p.binding3, p.visibility3);
            if (p.binding4 instanceof DirectiveBinding && isPresent(p.keyId4) && i.obj4 === UNDEFINED)
              i.obj4 = i.instantiateBinding(p.binding4, p.visibility4);
            if (p.binding5 instanceof DirectiveBinding && isPresent(p.keyId5) && i.obj5 === UNDEFINED)
              i.obj5 = i.instantiateBinding(p.binding5, p.visibility5);
            if (p.binding6 instanceof DirectiveBinding && isPresent(p.keyId6) && i.obj6 === UNDEFINED)
              i.obj6 = i.instantiateBinding(p.binding6, p.visibility6);
            if (p.binding7 instanceof DirectiveBinding && isPresent(p.keyId7) && i.obj7 === UNDEFINED)
              i.obj7 = i.instantiateBinding(p.binding7, p.visibility7);
            if (p.binding8 instanceof DirectiveBinding && isPresent(p.keyId8) && i.obj8 === UNDEFINED)
              i.obj8 = i.instantiateBinding(p.binding8, p.visibility8);
            if (p.binding9 instanceof DirectiveBinding && isPresent(p.keyId9) && i.obj9 === UNDEFINED)
              i.obj9 = i.instantiateBinding(p.binding9, p.visibility9);
          },
          dehydrate: function() {
            var i = this.injectorStrategy;
            i.obj0 = UNDEFINED;
            i.obj1 = UNDEFINED;
            i.obj2 = UNDEFINED;
            i.obj3 = UNDEFINED;
            i.obj4 = UNDEFINED;
            i.obj5 = UNDEFINED;
            i.obj6 = UNDEFINED;
            i.obj7 = UNDEFINED;
            i.obj8 = UNDEFINED;
            i.obj9 = UNDEFINED;
          },
          callOnDestroy: function() {
            var i = this.injectorStrategy;
            var p = i.protoStrategy;
            if (p.binding0 instanceof DirectiveBinding && p.binding0.callOnDestroy) {
              i.obj0.onDestroy();
            }
            if (p.binding1 instanceof DirectiveBinding && p.binding1.callOnDestroy) {
              i.obj1.onDestroy();
            }
            if (p.binding2 instanceof DirectiveBinding && p.binding2.callOnDestroy) {
              i.obj2.onDestroy();
            }
            if (p.binding3 instanceof DirectiveBinding && p.binding3.callOnDestroy) {
              i.obj3.onDestroy();
            }
            if (p.binding4 instanceof DirectiveBinding && p.binding4.callOnDestroy) {
              i.obj4.onDestroy();
            }
            if (p.binding5 instanceof DirectiveBinding && p.binding5.callOnDestroy) {
              i.obj5.onDestroy();
            }
            if (p.binding6 instanceof DirectiveBinding && p.binding6.callOnDestroy) {
              i.obj6.onDestroy();
            }
            if (p.binding7 instanceof DirectiveBinding && p.binding7.callOnDestroy) {
              i.obj7.onDestroy();
            }
            if (p.binding8 instanceof DirectiveBinding && p.binding8.callOnDestroy) {
              i.obj8.onDestroy();
            }
            if (p.binding9 instanceof DirectiveBinding && p.binding9.callOnDestroy) {
              i.obj9.onDestroy();
            }
          },
          getComponent: function() {
            return this.injectorStrategy.obj0;
          },
          isComponentKey: function(key) {
            return this._ei._proto._firstBindingIsComponent && isPresent(key) && key.id === this.injectorStrategy.protoStrategy.keyId0;
          },
          buildQueries: function() {
            var p = this.injectorStrategy.protoStrategy;
            if (p.binding0 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding0.dependencies);
            }
            if (p.binding1 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding1.dependencies);
            }
            if (p.binding2 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding2.dependencies);
            }
            if (p.binding3 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding3.dependencies);
            }
            if (p.binding4 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding4.dependencies);
            }
            if (p.binding5 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding5.dependencies);
            }
            if (p.binding6 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding6.dependencies);
            }
            if (p.binding7 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding7.dependencies);
            }
            if (p.binding8 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding8.dependencies);
            }
            if (p.binding9 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding9.dependencies);
            }
          },
          addDirectivesMatchingQuery: function(query, list) {
            var i = this.injectorStrategy;
            var p = i.protoStrategy;
            if (isPresent(p.binding0) && p.binding0.key.token === query.selector) {
              if (i.obj0 === UNDEFINED)
                i.obj0 = i.instantiateBinding(p.binding0, p.visibility0);
              list.push(i.obj0);
            }
            if (isPresent(p.binding1) && p.binding1.key.token === query.selector) {
              if (i.obj1 === UNDEFINED)
                i.obj1 = i.instantiateBinding(p.binding1, p.visibility1);
              list.push(i.obj1);
            }
            if (isPresent(p.binding2) && p.binding2.key.token === query.selector) {
              if (i.obj2 === UNDEFINED)
                i.obj2 = i.instantiateBinding(p.binding2, p.visibility2);
              list.push(i.obj2);
            }
            if (isPresent(p.binding3) && p.binding3.key.token === query.selector) {
              if (i.obj3 === UNDEFINED)
                i.obj3 = i.instantiateBinding(p.binding3, p.visibility3);
              list.push(i.obj3);
            }
            if (isPresent(p.binding4) && p.binding4.key.token === query.selector) {
              if (i.obj4 === UNDEFINED)
                i.obj4 = i.instantiateBinding(p.binding4, p.visibility4);
              list.push(i.obj4);
            }
            if (isPresent(p.binding5) && p.binding5.key.token === query.selector) {
              if (i.obj5 === UNDEFINED)
                i.obj5 = i.instantiateBinding(p.binding5, p.visibility5);
              list.push(i.obj5);
            }
            if (isPresent(p.binding6) && p.binding6.key.token === query.selector) {
              if (i.obj6 === UNDEFINED)
                i.obj6 = i.instantiateBinding(p.binding6, p.visibility6);
              list.push(i.obj6);
            }
            if (isPresent(p.binding7) && p.binding7.key.token === query.selector) {
              if (i.obj7 === UNDEFINED)
                i.obj7 = i.instantiateBinding(p.binding7, p.visibility7);
              list.push(i.obj7);
            }
            if (isPresent(p.binding8) && p.binding8.key.token === query.selector) {
              if (i.obj8 === UNDEFINED)
                i.obj8 = i.instantiateBinding(p.binding8, p.visibility8);
              list.push(i.obj8);
            }
            if (isPresent(p.binding9) && p.binding9.key.token === query.selector) {
              if (i.obj9 === UNDEFINED)
                i.obj9 = i.instantiateBinding(p.binding9, p.visibility9);
              list.push(i.obj9);
            }
          },
          getComponentBinding: function() {
            var p = this.injectorStrategy.protoStrategy;
            return p.binding0;
          }
        }, {});
      }());
      ElementInjectorDynamicStrategy = (function() {
        function ElementInjectorDynamicStrategy(injectorStrategy, _ei) {
          this.injectorStrategy = injectorStrategy;
          this._ei = _ei;
        }
        return ($traceurRuntime.createClass)(ElementInjectorDynamicStrategy, {
          hydrate: function() {
            var inj = this.injectorStrategy;
            var p = inj.protoStrategy;
            inj.resetConstructionCounter();
            for (var i = 0; i < p.keyIds.length; i++) {
              if (p.bindings[i] instanceof DirectiveBinding && isPresent(p.keyIds[i]) && inj.objs[i] === UNDEFINED) {
                inj.objs[i] = inj.instantiateBinding(p.bindings[i], p.visibilities[i]);
              }
            }
          },
          dehydrate: function() {
            var inj = this.injectorStrategy;
            ListWrapper.fill(inj.objs, UNDEFINED);
          },
          callOnDestroy: function() {
            var ist = this.injectorStrategy;
            var p = ist.protoStrategy;
            for (var i = 0; i < p.bindings.length; i++) {
              if (p.bindings[i] instanceof DirectiveBinding && p.bindings[i].callOnDestroy) {
                ist.objs[i].onDestroy();
              }
            }
          },
          getComponent: function() {
            return this.injectorStrategy.objs[0];
          },
          isComponentKey: function(key) {
            var p = this.injectorStrategy.protoStrategy;
            return this._ei._proto._firstBindingIsComponent && isPresent(key) && key.id === p.keyIds[0];
          },
          buildQueries: function() {
            var inj = this.injectorStrategy;
            var p = inj.protoStrategy;
            for (var i = 0; i < p.bindings.length; i++) {
              if (p.bindings[i] instanceof DirectiveBinding) {
                this._ei._buildQueriesForDeps(p.bindings[i].dependencies);
              }
            }
          },
          addDirectivesMatchingQuery: function(query, list) {
            var ist = this.injectorStrategy;
            var p = ist.protoStrategy;
            for (var i = 0; i < p.bindings.length; i++) {
              if (p.bindings[i].key.token === query.selector) {
                if (ist.objs[i] === UNDEFINED) {
                  ist.objs[i] = ist.instantiateBinding(p.bindings[i], p.visibilities[i]);
                }
                list.push(ist.objs[i]);
              }
            }
          },
          getComponentBinding: function() {
            var p = this.injectorStrategy.protoStrategy;
            return p.bindings[0];
          }
        }, {});
      }());
      QueryError = (function($__super) {
        function QueryError() {
          $traceurRuntime.superConstructor(QueryError).call(this);
          this.message = 'Only 3 queries can be concurrently active in a template.';
        }
        return ($traceurRuntime.createClass)(QueryError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("QueryError", QueryError);
      QueryRef = (function() {
        function QueryRef(query, list, originator) {
          this.query = query;
          this.list = list;
          this.originator = originator;
        }
        return ($traceurRuntime.createClass)(QueryRef, {
          get isViewQuery() {
            return this.query.isViewQuery;
          },
          update: function() {
            var aggregator = [];
            if (this.query.isViewQuery) {
              var rootViewInjectors = this.originator.getRootViewInjectors();
              for (var i = 0; i < rootViewInjectors.length; i++) {
                this.visit(rootViewInjectors[i], aggregator);
              }
            } else {
              this.visit(this.originator, aggregator);
            }
            this.list.reset(aggregator);
          },
          visit: function(inj, aggregator) {
            if (isBlank(inj) || !inj._hasQuery(this) || !inj.hydrated)
              return ;
            if (this.query.isVarBindingQuery) {
              this._aggregateVariableBindings(inj, aggregator);
            } else {
              this._aggregateDirective(inj, aggregator);
            }
            var child = inj._head;
            while (isPresent(child)) {
              this.visit(child, aggregator);
              child = child._next;
            }
          },
          _aggregateVariableBindings: function(inj, aggregator) {
            var vb = this.query.varBindings;
            for (var i = 0; i < vb.length; ++i) {
              if (inj.hasVariableBinding(vb[i])) {
                aggregator.push(inj.getVariableBinding(vb[i]));
              }
            }
          },
          _aggregateDirective: function(inj, aggregator) {
            inj.addDirectivesMatchingQuery(this.query, aggregator);
          }
        }, {});
      }());
      $__export("QueryRef", QueryRef);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compiler", ["angular2/di", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/api", "angular2/src/render/dom/compiler/compile_pipeline", "angular2/src/render/dom/compiler/view_loader", "angular2/src/render/dom/compiler/compile_step_factory", "angular2/src/render/dom/schema/element_schema_registry", "angular2/src/change_detection/change_detection", "angular2/src/render/dom/view/proto_view_merger", "angular2/src/render/dom/compiler/selector", "angular2/src/render/dom/dom_tokens", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/render/dom/util", "angular2/src/render/dom/template_cloner"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compiler";
  var __decorate,
      __metadata,
      __param,
      Injectable,
      PromiseWrapper,
      BaseException,
      DOM,
      ViewDefinition,
      ViewType,
      RenderCompiler,
      ViewEncapsulation,
      CompilePipeline,
      ViewLoader,
      TemplateAndStyles,
      DefaultStepFactory,
      ElementSchemaRegistry,
      Parser,
      pvm,
      CssSelector,
      APP_ID,
      Inject,
      SharedStylesHost,
      prependAll,
      TemplateCloner,
      DomCompiler,
      DefaultDomCompiler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
      Inject = $__m.Inject;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      BaseException = $__m.BaseException;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ViewDefinition = $__m.ViewDefinition;
      ViewType = $__m.ViewType;
      RenderCompiler = $__m.RenderCompiler;
      ViewEncapsulation = $__m.ViewEncapsulation;
    }, function($__m) {
      CompilePipeline = $__m.CompilePipeline;
    }, function($__m) {
      ViewLoader = $__m.ViewLoader;
      TemplateAndStyles = $__m.TemplateAndStyles;
    }, function($__m) {
      DefaultStepFactory = $__m.DefaultStepFactory;
    }, function($__m) {
      ElementSchemaRegistry = $__m.ElementSchemaRegistry;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      pvm = $__m;
    }, function($__m) {
      CssSelector = $__m.CssSelector;
    }, function($__m) {
      APP_ID = $__m.APP_ID;
    }, function($__m) {
      SharedStylesHost = $__m.SharedStylesHost;
    }, function($__m) {
      prependAll = $__m.prependAll;
    }, function($__m) {
      TemplateCloner = $__m.TemplateCloner;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      DomCompiler = (function($__super) {
        function DomCompiler(_schemaRegistry, _templateCloner, _stepFactory, _viewLoader, _sharedStylesHost) {
          $traceurRuntime.superConstructor(DomCompiler).call(this);
          this._schemaRegistry = _schemaRegistry;
          this._templateCloner = _templateCloner;
          this._stepFactory = _stepFactory;
          this._viewLoader = _viewLoader;
          this._sharedStylesHost = _sharedStylesHost;
        }
        return ($traceurRuntime.createClass)(DomCompiler, {
          compile: function(view) {
            var $__0 = this;
            var tplPromise = this._viewLoader.load(view);
            return PromiseWrapper.then(tplPromise, (function(tplAndStyles) {
              return $__0._compileView(view, tplAndStyles, ViewType.COMPONENT);
            }), (function(e) {
              throw new BaseException(("Failed to load the template for \"" + view.componentId + "\" : " + e));
              return null;
            }));
          },
          compileHost: function(directiveMetadata) {
            var hostViewDef = new ViewDefinition({
              componentId: directiveMetadata.id,
              templateAbsUrl: null,
              template: null,
              styles: null,
              styleAbsUrls: null,
              directives: [directiveMetadata],
              encapsulation: ViewEncapsulation.NONE
            });
            var selector = CssSelector.parse(directiveMetadata.selector)[0];
            var hostTemplate = selector.getMatchingElementTemplate();
            var templateAndStyles = new TemplateAndStyles(hostTemplate, []);
            return this._compileView(hostViewDef, templateAndStyles, ViewType.HOST);
          },
          mergeProtoViewsRecursively: function(protoViewRefs) {
            return PromiseWrapper.resolve(pvm.mergeProtoViewsRecursively(this._templateCloner, protoViewRefs));
          },
          _compileView: function(viewDef, templateAndStyles, protoViewType) {
            if (viewDef.encapsulation === ViewEncapsulation.EMULATED && templateAndStyles.styles.length === 0) {
              viewDef = this._normalizeViewEncapsulationIfThereAreNoStyles(viewDef);
            }
            var pipeline = new CompilePipeline(this._stepFactory.createSteps(viewDef));
            var compiledStyles = pipeline.processStyles(templateAndStyles.styles);
            var compileElements = pipeline.processElements(this._createTemplateElm(templateAndStyles.template), protoViewType, viewDef);
            if (viewDef.encapsulation === ViewEncapsulation.NATIVE) {
              prependAll(DOM.content(compileElements[0].element), compiledStyles.map((function(style) {
                return DOM.createStyleElement(style);
              })));
            } else {
              this._sharedStylesHost.addStyles(compiledStyles);
            }
            return PromiseWrapper.resolve(compileElements[0].inheritedProtoView.build(this._schemaRegistry, this._templateCloner));
          },
          _createTemplateElm: function(template) {
            var templateElm = DOM.createTemplate(template);
            var scriptTags = DOM.querySelectorAll(DOM.templateAwareRoot(templateElm), 'script');
            for (var i = 0; i < scriptTags.length; i++) {
              DOM.remove(scriptTags[i]);
            }
            return templateElm;
          },
          _normalizeViewEncapsulationIfThereAreNoStyles: function(viewDef) {
            if (viewDef.encapsulation === ViewEncapsulation.EMULATED) {
              return new ViewDefinition({
                componentId: viewDef.componentId,
                templateAbsUrl: viewDef.templateAbsUrl,
                template: viewDef.template,
                styleAbsUrls: viewDef.styleAbsUrls,
                styles: viewDef.styles,
                directives: viewDef.directives,
                encapsulation: ViewEncapsulation.NONE
              });
            } else {
              return viewDef;
            }
          }
        }, {}, $__super);
      }(RenderCompiler));
      $__export("DomCompiler", DomCompiler);
      DefaultDomCompiler = (function($__super) {
        function $__1(schemaRegistry, templateCloner, parser, viewLoader, sharedStylesHost, appId) {
          $traceurRuntime.superConstructor($__1).call(this, schemaRegistry, templateCloner, new DefaultStepFactory(parser, appId), viewLoader, sharedStylesHost);
        }
        return ($traceurRuntime.createClass)($__1, {}, {}, $__super);
      }(DomCompiler));
      $__export("DefaultDomCompiler", DefaultDomCompiler);
      $__export("DefaultDomCompiler", DefaultDomCompiler = __decorate([Injectable(), __param(5, Inject(APP_ID)), __metadata('design:paramtypes', [ElementSchemaRegistry, TemplateCloner, Parser, ViewLoader, SharedStylesHost, Object])], DefaultDomCompiler));
    }
  };
});

System.register("angular2/di", ["angular2/src/di/metadata", "angular2/src/di/decorators", "angular2/src/di/forward_ref", "angular2/src/di/injector", "angular2/src/di/binding", "angular2/src/di/key", "angular2/src/di/exceptions", "angular2/src/di/opaque_token"], function($__export) {
  "use strict";
  var __moduleName = "angular2/di";
  var $__exportNames = {undefined: true};
  return {
    setters: [function($__m) {
      $__export("InjectMetadata", $__m.InjectMetadata);
      $__export("OptionalMetadata", $__m.OptionalMetadata);
      $__export("InjectableMetadata", $__m.InjectableMetadata);
      $__export("SelfMetadata", $__m.SelfMetadata);
      $__export("HostMetadata", $__m.HostMetadata);
      $__export("SkipSelfMetadata", $__m.SkipSelfMetadata);
      $__export("DependencyMetadata", $__m.DependencyMetadata);
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      $__export("forwardRef", $__m.forwardRef);
      $__export("resolveForwardRef", $__m.resolveForwardRef);
    }, function($__m) {
      $__export("Injector", $__m.Injector);
      $__export("ProtoInjector", $__m.ProtoInjector);
      $__export("BindingWithVisibility", $__m.BindingWithVisibility);
      $__export("Visibility", $__m.Visibility);
      $__export("UNDEFINED", $__m.UNDEFINED);
    }, function($__m) {
      $__export("Binding", $__m.Binding);
      $__export("BindingBuilder", $__m.BindingBuilder);
      $__export("ResolvedBinding", $__m.ResolvedBinding);
      $__export("Dependency", $__m.Dependency);
      $__export("bind", $__m.bind);
    }, function($__m) {
      $__export("Key", $__m.Key);
      $__export("KeyRegistry", $__m.KeyRegistry);
      $__export("TypeLiteral", $__m.TypeLiteral);
    }, function($__m) {
      $__export("NoBindingError", $__m.NoBindingError);
      $__export("AbstractBindingError", $__m.AbstractBindingError);
      $__export("CyclicDependencyError", $__m.CyclicDependencyError);
      $__export("InstantiationError", $__m.InstantiationError);
      $__export("InvalidBindingError", $__m.InvalidBindingError);
      $__export("NoAnnotationError", $__m.NoAnnotationError);
      $__export("OutOfBoundsError", $__m.OutOfBoundsError);
    }, function($__m) {
      $__export("OpaqueToken", $__m.OpaqueToken);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/change_detection/jit_proto_change_detector", ["angular2/src/change_detection/change_detection_jit_generator", "angular2/src/change_detection/proto_change_detector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/jit_proto_change_detector";
  var ChangeDetectorJITGenerator,
      createPropertyRecords,
      createEventRecords,
      JitProtoChangeDetector;
  return {
    setters: [function($__m) {
      ChangeDetectorJITGenerator = $__m.ChangeDetectorJITGenerator;
    }, function($__m) {
      createPropertyRecords = $__m.createPropertyRecords;
      createEventRecords = $__m.createEventRecords;
    }],
    execute: function() {
      JitProtoChangeDetector = (function() {
        function JitProtoChangeDetector(definition) {
          this.definition = definition;
          this._factory = this._createFactory(definition);
        }
        return ($traceurRuntime.createClass)(JitProtoChangeDetector, {
          instantiate: function(dispatcher) {
            return this._factory(dispatcher);
          },
          _createFactory: function(definition) {
            var propertyBindingRecords = createPropertyRecords(definition);
            var eventBindingRecords = createEventRecords(definition);
            var propertyBindingTargets = this.definition.bindingRecords.map((function(b) {
              return b.target;
            }));
            return new ChangeDetectorJITGenerator(definition.id, definition.strategy, propertyBindingRecords, propertyBindingTargets, eventBindingRecords, this.definition.directiveRecords, this.definition.genConfig).generate();
          }
        }, {isSupported: function() {
            return true;
          }});
      }());
      $__export("JitProtoChangeDetector", JitProtoChangeDetector);
    }
  };
});

System.register("angular2/src/core/compiler/compiler", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/core/compiler/directive_resolver", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_injector", "angular2/src/core/compiler/view_resolver", "angular2/src/core/compiler/pipe_resolver", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/proto_view_factory", "angular2/src/services/url_resolver", "angular2/src/services/app_root_url", "angular2/src/profile/profile", "angular2/src/core/pipes/pipe_binding", "angular2/pipes", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/compiler";
  var __decorate,
      __metadata,
      __param,
      Binding,
      resolveForwardRef,
      Injectable,
      Inject,
      Type,
      isBlank,
      isType,
      isPresent,
      BaseException,
      normalizeBlank,
      stringify,
      isArray,
      isPromise,
      PromiseWrapper,
      ListWrapper,
      Map,
      MapWrapper,
      DirectiveResolver,
      AppProtoViewMergeMapping,
      DirectiveBinding,
      ViewResolver,
      PipeResolver,
      ComponentUrlMapper,
      ProtoViewFactory,
      UrlResolver,
      AppRootUrl,
      wtfStartTimeRange,
      wtfEndTimeRange,
      PipeBinding,
      DEFAULT_PIPES_TOKEN,
      RenderDirectiveMetadata,
      ViewDefinition,
      RenderCompiler,
      ViewType,
      CompilerCache,
      Compiler;
  return {
    setters: [function($__m) {
      Binding = $__m.Binding;
      resolveForwardRef = $__m.resolveForwardRef;
      Injectable = $__m.Injectable;
      Inject = $__m.Inject;
    }, function($__m) {
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isType = $__m.isType;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      normalizeBlank = $__m.normalizeBlank;
      stringify = $__m.stringify;
      isArray = $__m.isArray;
      isPromise = $__m.isPromise;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DirectiveResolver = $__m.DirectiveResolver;
    }, function($__m) {
      AppProtoViewMergeMapping = $__m.AppProtoViewMergeMapping;
    }, function($__m) {
      DirectiveBinding = $__m.DirectiveBinding;
    }, function($__m) {
      ViewResolver = $__m.ViewResolver;
    }, function($__m) {
      PipeResolver = $__m.PipeResolver;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      ProtoViewFactory = $__m.ProtoViewFactory;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      AppRootUrl = $__m.AppRootUrl;
    }, function($__m) {
      wtfStartTimeRange = $__m.wtfStartTimeRange;
      wtfEndTimeRange = $__m.wtfEndTimeRange;
    }, function($__m) {
      PipeBinding = $__m.PipeBinding;
    }, function($__m) {
      DEFAULT_PIPES_TOKEN = $__m.DEFAULT_PIPES_TOKEN;
    }, function($__m) {
      RenderDirectiveMetadata = $__m.RenderDirectiveMetadata;
      ViewDefinition = $__m.ViewDefinition;
      RenderCompiler = $__m.RenderCompiler;
      ViewType = $__m.ViewType;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      CompilerCache = (($traceurRuntime.createClass)(function() {
        this._cache = new Map();
        this._hostCache = new Map();
      }, {
        set: function(component, protoView) {
          this._cache.set(component, protoView);
        },
        get: function(component) {
          var result = this._cache.get(component);
          return normalizeBlank(result);
        },
        setHost: function(component, protoView) {
          this._hostCache.set(component, protoView);
        },
        getHost: function(component) {
          var result = this._hostCache.get(component);
          return normalizeBlank(result);
        },
        clear: function() {
          this._cache.clear();
          this._hostCache.clear();
        }
      }, {}));
      $__export("CompilerCache", CompilerCache);
      $__export("CompilerCache", CompilerCache = __decorate([Injectable(), __metadata('design:paramtypes', [])], CompilerCache));
      Compiler = (($traceurRuntime.createClass)(function(_directiveResolver, _pipeResolver, _defaultPipes, _compilerCache, _viewResolver, _componentUrlMapper, _urlResolver, _render, _protoViewFactory, appUrl) {
        this._directiveResolver = _directiveResolver;
        this._pipeResolver = _pipeResolver;
        this._compilerCache = _compilerCache;
        this._viewResolver = _viewResolver;
        this._componentUrlMapper = _componentUrlMapper;
        this._urlResolver = _urlResolver;
        this._render = _render;
        this._protoViewFactory = _protoViewFactory;
        this._compiling = new Map();
        this._defaultPipes = _defaultPipes;
        this._appUrl = appUrl.value;
      }, {
        _bindDirective: function(directiveTypeOrBinding) {
          if (directiveTypeOrBinding instanceof DirectiveBinding) {
            return directiveTypeOrBinding;
          } else if (directiveTypeOrBinding instanceof Binding) {
            var annotation = this._directiveResolver.resolve(directiveTypeOrBinding.token);
            return DirectiveBinding.createFromBinding(directiveTypeOrBinding, annotation);
          } else {
            var annotation$__3 = this._directiveResolver.resolve(directiveTypeOrBinding);
            return DirectiveBinding.createFromType(directiveTypeOrBinding, annotation$__3);
          }
        },
        _bindPipe: function(typeOrBinding) {
          var meta = this._pipeResolver.resolve(typeOrBinding);
          return PipeBinding.createFromType(typeOrBinding, meta);
        },
        compileInHost: function(componentTypeOrBinding) {
          var $__0 = this;
          var componentType = isType(componentTypeOrBinding) ? componentTypeOrBinding : componentTypeOrBinding.token;
          var r = wtfStartTimeRange('Compiler#compile()', stringify(componentType));
          var hostAppProtoView = this._compilerCache.getHost(componentType);
          var hostPvPromise;
          if (isPresent(hostAppProtoView)) {
            hostPvPromise = PromiseWrapper.resolve(hostAppProtoView);
          } else {
            var componentBinding = this._bindDirective(componentTypeOrBinding);
            Compiler._assertTypeIsComponent(componentBinding);
            var directiveMetadata = componentBinding.metadata;
            hostPvPromise = this._render.compileHost(directiveMetadata).then((function(hostRenderPv) {
              var protoViews = $__0._protoViewFactory.createAppProtoViews(componentBinding, hostRenderPv, [componentBinding], []);
              return $__0._compileNestedProtoViews(protoViews, componentType, new Map());
            })).then((function(appProtoView) {
              $__0._compilerCache.setHost(componentType, appProtoView);
              return appProtoView;
            }));
          }
          return hostPvPromise.then((function(hostAppProtoView) {
            wtfEndTimeRange(r);
            return hostAppProtoView.ref;
          }));
        },
        _compile: function(componentBinding, componentPath) {
          var $__0 = this;
          var component = componentBinding.key.token;
          var protoView = this._compilerCache.get(component);
          if (isPresent(protoView)) {
            return protoView;
          }
          var resultPromise = this._compiling.get(component);
          if (isPresent(resultPromise)) {
            return resultPromise;
          }
          var view = this._viewResolver.resolve(component);
          var directives = this._flattenDirectives(view);
          for (var i = 0; i < directives.length; i++) {
            if (!Compiler._isValidDirective(directives[i])) {
              throw new BaseException(("Unexpected directive value '" + stringify(directives[i]) + "' on the View of component '" + stringify(component) + "'"));
            }
          }
          var boundDirectives = this._removeDuplicatedDirectives(directives.map((function(directive) {
            return $__0._bindDirective(directive);
          })));
          var pipes = this._flattenPipes(view);
          var boundPipes = pipes.map((function(pipe) {
            return $__0._bindPipe(pipe);
          }));
          var renderTemplate = this._buildRenderTemplate(component, view, boundDirectives);
          resultPromise = this._render.compile(renderTemplate).then((function(renderPv) {
            var protoViews = $__0._protoViewFactory.createAppProtoViews(componentBinding, renderPv, boundDirectives, boundPipes);
            return $__0._compileNestedProtoViews(protoViews, component, componentPath);
          })).then((function(appProtoView) {
            $__0._compilerCache.set(component, appProtoView);
            MapWrapper.delete($__0._compiling, component);
            return appProtoView;
          }));
          this._compiling.set(component, resultPromise);
          return resultPromise;
        },
        _removeDuplicatedDirectives: function(directives) {
          var directivesMap = new Map();
          directives.forEach((function(dirBinding) {
            directivesMap.set(dirBinding.key.id, dirBinding);
          }));
          return MapWrapper.values(directivesMap);
        },
        _compileNestedProtoViews: function(appProtoViews, componentType, componentPath) {
          var $__0 = this;
          var nestedPVPromises = [];
          componentPath = MapWrapper.clone(componentPath);
          if (appProtoViews[0].type === ViewType.COMPONENT) {
            componentPath.set(componentType, appProtoViews[0]);
          }
          appProtoViews.forEach((function(appProtoView) {
            $__0._collectComponentElementBinders(appProtoView).forEach((function(elementBinder) {
              var nestedComponent = elementBinder.componentDirective;
              var nestedComponentType = nestedComponent.key.token;
              var elementBinderDone = (function(nestedPv) {
                elementBinder.nestedProtoView = nestedPv;
              });
              if (componentPath.has(nestedComponentType)) {
                if (appProtoView.isEmbeddedFragment) {
                  throw new BaseException(("<ng-content> is used within the recursive path of " + stringify(nestedComponentType)));
                } else if (appProtoView.type === ViewType.COMPONENT) {
                  throw new BaseException(("Unconditional component cycle in " + stringify(nestedComponentType)));
                } else {
                  elementBinderDone(componentPath.get(nestedComponentType));
                }
              } else {
                var nestedCall = $__0._compile(nestedComponent, componentPath);
                if (isPromise(nestedCall)) {
                  nestedPVPromises.push(nestedCall.then(elementBinderDone));
                } else {
                  elementBinderDone(nestedCall);
                }
              }
            }));
          }));
          return PromiseWrapper.all(nestedPVPromises).then((function(_) {
            return PromiseWrapper.all(appProtoViews.map((function(appProtoView) {
              return $__0._mergeProtoView(appProtoView);
            })));
          })).then((function(_) {
            return appProtoViews[0];
          }));
        },
        _mergeProtoView: function(appProtoView) {
          if (appProtoView.type !== ViewType.HOST && appProtoView.type !== ViewType.EMBEDDED) {
            return null;
          }
          return this._render.mergeProtoViewsRecursively(this._collectMergeRenderProtoViews(appProtoView)).then((function(mergeResult) {
            appProtoView.mergeMapping = new AppProtoViewMergeMapping(mergeResult);
          }));
        },
        _collectMergeRenderProtoViews: function(appProtoView) {
          var result = [appProtoView.render];
          for (var i = 0; i < appProtoView.elementBinders.length; i++) {
            var binder = appProtoView.elementBinders[i];
            if (isPresent(binder.nestedProtoView)) {
              if (binder.hasStaticComponent() || (binder.hasEmbeddedProtoView() && binder.nestedProtoView.isEmbeddedFragment)) {
                result.push(this._collectMergeRenderProtoViews(binder.nestedProtoView));
              } else {
                result.push(null);
              }
            }
          }
          return result;
        },
        _collectComponentElementBinders: function(appProtoView) {
          var componentElementBinders = [];
          appProtoView.elementBinders.forEach((function(elementBinder) {
            if (isPresent(elementBinder.componentDirective)) {
              componentElementBinders.push(elementBinder);
            }
          }));
          return componentElementBinders;
        },
        _buildRenderTemplate: function(component, view, directives) {
          var $__0 = this;
          var componentUrl = this._urlResolver.resolve(this._appUrl, this._componentUrlMapper.getUrl(component));
          var templateAbsUrl = null;
          var styleAbsUrls = null;
          if (isPresent(view.templateUrl) && view.templateUrl.trim().length > 0) {
            templateAbsUrl = this._urlResolver.resolve(componentUrl, view.templateUrl);
          } else if (isPresent(view.template)) {
            templateAbsUrl = componentUrl;
          }
          if (isPresent(view.styleUrls)) {
            styleAbsUrls = ListWrapper.map(view.styleUrls, (function(url) {
              return $__0._urlResolver.resolve(componentUrl, url);
            }));
          }
          return new ViewDefinition({
            componentId: stringify(component),
            templateAbsUrl: templateAbsUrl,
            template: view.template,
            styleAbsUrls: styleAbsUrls,
            styles: view.styles,
            directives: ListWrapper.map(directives, (function(directiveBinding) {
              return directiveBinding.metadata;
            })),
            encapsulation: view.encapsulation
          });
        },
        _flattenPipes: function(view) {
          if (isBlank(view.pipes))
            return this._defaultPipes;
          var pipes = ListWrapper.clone(this._defaultPipes);
          this._flattenList(view.pipes, pipes);
          return pipes;
        },
        _flattenDirectives: function(view) {
          if (isBlank(view.directives))
            return [];
          var directives = [];
          this._flattenList(view.directives, directives);
          return directives;
        },
        _flattenList: function(tree, out) {
          for (var i = 0; i < tree.length; i++) {
            var item = resolveForwardRef(tree[i]);
            if (isArray(item)) {
              this._flattenList(item, out);
            } else {
              out.push(item);
            }
          }
        }
      }, {
        _isValidDirective: function(value) {
          return isPresent(value) && (value instanceof Type || value instanceof Binding);
        },
        _assertTypeIsComponent: function(directiveBinding) {
          if (directiveBinding.metadata.type !== RenderDirectiveMetadata.COMPONENT_TYPE) {
            throw new BaseException(("Could not load '" + stringify(directiveBinding.key.token) + "' because it is not a component."));
          }
        }
      }));
      $__export("Compiler", Compiler);
      $__export("Compiler", Compiler = __decorate([Injectable(), __param(2, Inject(DEFAULT_PIPES_TOKEN)), __metadata('design:paramtypes', [DirectiveResolver, PipeResolver, Array, CompilerCache, ViewResolver, ComponentUrlMapper, UrlResolver, RenderCompiler, ProtoViewFactory, AppRootUrl])], Compiler));
    }
  };
});

System.register("angular2/src/render/render", ["angular2/src/render/dom/compiler/view_loader", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/render/dom/compiler/compiler", "angular2/src/render/dom/dom_renderer", "angular2/src/render/dom/dom_tokens", "angular2/src/render/dom/template_cloner", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/render";
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/metadata/di", ["angular2/src/facade/lang", "angular2/src/di/metadata", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/metadata/di";
  var __decorate,
      __metadata,
      CONST,
      stringify,
      StringWrapper,
      isString,
      DependencyMetadata,
      resolveForwardRef,
      AttributeMetadata,
      QueryMetadata,
      ViewQueryMetadata;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      stringify = $__m.stringify;
      StringWrapper = $__m.StringWrapper;
      isString = $__m.isString;
    }, function($__m) {
      DependencyMetadata = $__m.DependencyMetadata;
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AttributeMetadata = (function($__super) {
        function $__0(attributeName) {
          $traceurRuntime.superConstructor($__0).call(this);
          this.attributeName = attributeName;
        }
        return ($traceurRuntime.createClass)($__0, {
          get token() {
            return this;
          },
          toString: function() {
            return ("@Attribute(" + stringify(this.attributeName) + ")");
          }
        }, {}, $__super);
      }(DependencyMetadata));
      $__export("AttributeMetadata", AttributeMetadata);
      $__export("AttributeMetadata", AttributeMetadata = __decorate([CONST(), __metadata('design:paramtypes', [String])], AttributeMetadata));
      QueryMetadata = (function($__super) {
        function $__0(_selector) {
          var $__3;
          var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
              descendants = ($__3 = $__2.descendants) === void 0 ? false : $__3;
          $traceurRuntime.superConstructor($__0).call(this);
          this._selector = _selector;
          this.descendants = descendants;
        }
        return ($traceurRuntime.createClass)($__0, {
          get isViewQuery() {
            return false;
          },
          get selector() {
            return resolveForwardRef(this._selector);
          },
          get isVarBindingQuery() {
            return isString(this.selector);
          },
          get varBindings() {
            return StringWrapper.split(this.selector, new RegExp(","));
          },
          toString: function() {
            return ("@Query(" + stringify(this.selector) + ")");
          }
        }, {}, $__super);
      }(DependencyMetadata));
      $__export("QueryMetadata", QueryMetadata);
      $__export("QueryMetadata", QueryMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object, Object])], QueryMetadata));
      ViewQueryMetadata = (function($__super) {
        function $__0(_selector) {
          var $__3;
          var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
              descendants = ($__3 = $__2.descendants) === void 0 ? false : $__3;
          $traceurRuntime.superConstructor($__0).call(this, _selector, {descendants: descendants});
        }
        return ($traceurRuntime.createClass)($__0, {
          get isViewQuery() {
            return true;
          },
          toString: function() {
            return ("@ViewQuery(" + stringify(this.selector) + ")");
          }
        }, {}, $__super);
      }(QueryMetadata));
      $__export("ViewQueryMetadata", ViewQueryMetadata);
      $__export("ViewQueryMetadata", ViewQueryMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object, Object])], ViewQueryMetadata));
    }
  };
});

System.register("angular2/src/change_detection/change_detection", ["angular2/src/change_detection/jit_proto_change_detector", "angular2/src/change_detection/pregen_proto_change_detector", "angular2/src/change_detection/proto_change_detector", "angular2/src/change_detection/differs/iterable_differs", "angular2/src/change_detection/differs/default_iterable_differ", "angular2/src/change_detection/differs/keyvalue_differs", "angular2/src/change_detection/differs/default_keyvalue_differ", "angular2/src/change_detection/interfaces", "angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/parser/ast", "angular2/src/change_detection/parser/lexer", "angular2/src/change_detection/parser/parser", "angular2/src/change_detection/parser/locals", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/constants", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/dynamic_change_detector", "angular2/src/change_detection/change_detector_ref", "angular2/src/change_detection/change_detection_util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection";
  var __decorate,
      __metadata,
      JitProtoChangeDetector,
      PregenProtoChangeDetector,
      DynamicProtoChangeDetector,
      IterableDiffers,
      DefaultIterableDifferFactory,
      KeyValueDiffers,
      DefaultKeyValueDifferFactory,
      ChangeDetection,
      ChangeDetectorGenConfig,
      Injectable,
      StringMapWrapper,
      CONST_EXPR,
      isPresent,
      assertionsEnabled,
      keyValDiff,
      iterableDiff,
      defaultIterableDiffers,
      defaultKeyValueDiffers,
      preGeneratedProtoDetectors,
      PreGeneratedChangeDetection,
      DynamicChangeDetection,
      JitChangeDetection;
  return {
    setters: [function($__m) {
      JitProtoChangeDetector = $__m.JitProtoChangeDetector;
    }, function($__m) {
      PregenProtoChangeDetector = $__m.PregenProtoChangeDetector;
    }, function($__m) {
      DynamicProtoChangeDetector = $__m.DynamicProtoChangeDetector;
      $__export("DynamicProtoChangeDetector", $__m.DynamicProtoChangeDetector);
    }, function($__m) {
      IterableDiffers = $__m.IterableDiffers;
      $__export("IterableDiffers", $__m.IterableDiffers);
    }, function($__m) {
      DefaultIterableDifferFactory = $__m.DefaultIterableDifferFactory;
    }, function($__m) {
      KeyValueDiffers = $__m.KeyValueDiffers;
      $__export("KeyValueDiffers", $__m.KeyValueDiffers);
    }, function($__m) {
      DefaultKeyValueDifferFactory = $__m.DefaultKeyValueDifferFactory;
    }, function($__m) {
      ChangeDetection = $__m.ChangeDetection;
      ChangeDetectorGenConfig = $__m.ChangeDetectorGenConfig;
      $__export("ChangeDetection", $__m.ChangeDetection);
      $__export("ChangeDetectorDefinition", $__m.ChangeDetectorDefinition);
      $__export("DebugContext", $__m.DebugContext);
      $__export("ChangeDetectorGenConfig", $__m.ChangeDetectorGenConfig);
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
      isPresent = $__m.isPresent;
      assertionsEnabled = $__m.assertionsEnabled;
    }, function($__m) {
      $__export("ASTWithSource", $__m.ASTWithSource);
      $__export("AST", $__m.AST);
      $__export("AstTransformer", $__m.AstTransformer);
      $__export("PropertyRead", $__m.PropertyRead);
      $__export("LiteralArray", $__m.LiteralArray);
      $__export("ImplicitReceiver", $__m.ImplicitReceiver);
    }, function($__m) {
      $__export("Lexer", $__m.Lexer);
    }, function($__m) {
      $__export("Parser", $__m.Parser);
    }, function($__m) {
      $__export("Locals", $__m.Locals);
    }, function($__m) {
      $__export("DehydratedException", $__m.DehydratedException);
      $__export("ExpressionChangedAfterItHasBeenCheckedException", $__m.ExpressionChangedAfterItHasBeenCheckedException);
      $__export("ChangeDetectionError", $__m.ChangeDetectionError);
    }, function($__m) {
      $__export("CHECK_ONCE", $__m.CHECK_ONCE);
      $__export("CHECK_ALWAYS", $__m.CHECK_ALWAYS);
      $__export("DETACHED", $__m.DETACHED);
      $__export("CHECKED", $__m.CHECKED);
      $__export("ON_PUSH", $__m.ON_PUSH);
      $__export("DEFAULT", $__m.DEFAULT);
    }, function($__m) {
      $__export("BindingRecord", $__m.BindingRecord);
      $__export("BindingTarget", $__m.BindingTarget);
    }, function($__m) {
      $__export("DirectiveIndex", $__m.DirectiveIndex);
      $__export("DirectiveRecord", $__m.DirectiveRecord);
    }, function($__m) {
      $__export("DynamicChangeDetector", $__m.DynamicChangeDetector);
    }, function($__m) {
      $__export("ChangeDetectorRef", $__m.ChangeDetectorRef);
    }, function($__m) {
      $__export("WrappedValue", $__m.WrappedValue);
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      keyValDiff = CONST_EXPR([CONST_EXPR(new DefaultKeyValueDifferFactory())]);
      $__export("keyValDiff", keyValDiff);
      iterableDiff = CONST_EXPR([CONST_EXPR(new DefaultIterableDifferFactory())]);
      $__export("iterableDiff", iterableDiff);
      defaultIterableDiffers = CONST_EXPR(new IterableDiffers(iterableDiff));
      $__export("defaultIterableDiffers", defaultIterableDiffers);
      defaultKeyValueDiffers = CONST_EXPR(new KeyValueDiffers(keyValDiff));
      $__export("defaultKeyValueDiffers", defaultKeyValueDiffers);
      preGeneratedProtoDetectors = {};
      $__export("preGeneratedProtoDetectors", preGeneratedProtoDetectors);
      PreGeneratedChangeDetection = (function($__super) {
        function $__0(config, protoChangeDetectorsForTest) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._dynamicChangeDetection = new DynamicChangeDetection();
          this._protoChangeDetectorFactories = isPresent(protoChangeDetectorsForTest) ? protoChangeDetectorsForTest : preGeneratedProtoDetectors;
          this._genConfig = isPresent(config) ? config : new ChangeDetectorGenConfig(assertionsEnabled(), assertionsEnabled(), false);
        }
        return ($traceurRuntime.createClass)($__0, {
          getProtoChangeDetector: function(id, definition) {
            if (StringMapWrapper.contains(this._protoChangeDetectorFactories, id)) {
              return StringMapWrapper.get(this._protoChangeDetectorFactories, id)(definition);
            }
            return this._dynamicChangeDetection.getProtoChangeDetector(id, definition);
          },
          get genConfig() {
            return this._genConfig;
          },
          get generateDetectors() {
            return true;
          }
        }, {isSupported: function() {
            return PregenProtoChangeDetector.isSupported();
          }}, $__super);
      }(ChangeDetection));
      $__export("PreGeneratedChangeDetection", PreGeneratedChangeDetection);
      $__export("PreGeneratedChangeDetection", PreGeneratedChangeDetection = __decorate([Injectable(), __metadata('design:paramtypes', [ChangeDetectorGenConfig, Object])], PreGeneratedChangeDetection));
      DynamicChangeDetection = (function($__super) {
        function $__0(config) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._genConfig = isPresent(config) ? config : new ChangeDetectorGenConfig(assertionsEnabled(), assertionsEnabled(), false);
        }
        return ($traceurRuntime.createClass)($__0, {
          getProtoChangeDetector: function(id, definition) {
            return new DynamicProtoChangeDetector(definition);
          },
          get genConfig() {
            return this._genConfig;
          },
          get generateDetectors() {
            return true;
          }
        }, {}, $__super);
      }(ChangeDetection));
      $__export("DynamicChangeDetection", DynamicChangeDetection);
      $__export("DynamicChangeDetection", DynamicChangeDetection = __decorate([Injectable(), __metadata('design:paramtypes', [ChangeDetectorGenConfig])], DynamicChangeDetection));
      JitChangeDetection = (function($__super) {
        function $__0(config) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._genConfig = isPresent(config) ? config : new ChangeDetectorGenConfig(assertionsEnabled(), assertionsEnabled(), false);
        }
        return ($traceurRuntime.createClass)($__0, {
          getProtoChangeDetector: function(id, definition) {
            return new JitProtoChangeDetector(definition);
          },
          get genConfig() {
            return this._genConfig;
          },
          get generateDetectors() {
            return true;
          }
        }, {isSupported: function() {
            return JitProtoChangeDetector.isSupported();
          }}, $__super);
      }(ChangeDetection));
      $__export("JitChangeDetection", JitChangeDetection);
      $__export("JitChangeDetection", JitChangeDetection = __decorate([Injectable(), __metadata('design:paramtypes', [ChangeDetectorGenConfig])], JitChangeDetection));
    }
  };
});

System.register("angular2/src/core/application_common", ["angular2/di", "angular2/src/facade/lang", "angular2/src/dom/browser_adapter", "angular2/src/dom/dom_adapter", "angular2/src/core/compiler/compiler", "angular2/src/reflection/reflection", "angular2/src/change_detection/change_detection", "angular2/pipes", "angular2/src/core/exception_handler", "angular2/src/render/dom/compiler/view_loader", "angular2/src/render/dom/compiler/style_url_resolver", "angular2/src/render/dom/compiler/style_inliner", "angular2/src/core/compiler/view_resolver", "angular2/src/core/compiler/directive_resolver", "angular2/src/core/compiler/pipe_resolver", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/core/zone/ng_zone", "angular2/src/core/life_cycle/life_cycle", "angular2/src/render/xhr", "angular2/src/render/xhr_impl", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/events/key_events", "angular2/src/render/dom/events/hammer_gestures", "angular2/src/core/compiler/component_url_mapper", "angular2/src/services/url_resolver", "angular2/src/services/app_root_url", "angular2/src/services/anchor_based_app_root_url", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/testability/testability", "angular2/src/core/compiler/view_pool", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/view_listener", "angular2/src/core/compiler/proto_view_factory", "angular2/src/render/api", "angular2/src/render/render", "angular2/src/render/dom/schema/element_schema_registry", "angular2/src/render/dom/schema/dom_element_schema_registry", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/core/compiler/view_ref", "angular2/src/core/application_tokens", "angular2/src/profile/wtf_init", "angular2/src/core/platform_bindings", "angular2/src/core/application_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application_common";
  var Injector,
      bind,
      isBlank,
      isPresent,
      assertionsEnabled,
      BrowserDomAdapter,
      DOM,
      Compiler,
      CompilerCache,
      Reflector,
      reflector,
      Parser,
      Lexer,
      ChangeDetection,
      DynamicChangeDetection,
      JitChangeDetection,
      PreGeneratedChangeDetection,
      IterableDiffers,
      defaultIterableDiffers,
      KeyValueDiffers,
      defaultKeyValueDiffers,
      DEFAULT_PIPES,
      ExceptionHandler,
      ViewLoader,
      StyleUrlResolver,
      StyleInliner,
      ViewResolver,
      DirectiveResolver,
      PipeResolver,
      ListWrapper,
      PromiseWrapper,
      NgZone,
      LifeCycle,
      XHR,
      XHRImpl,
      EventManager,
      DomEventsPlugin,
      KeyEventsPlugin,
      HammerGesturesPlugin,
      ComponentUrlMapper,
      UrlResolver,
      AppRootUrl,
      AnchorBasedAppRootUrl,
      DynamicComponentLoader,
      TestabilityRegistry,
      Testability,
      AppViewPool,
      APP_VIEW_POOL_CAPACITY,
      AppViewManager,
      AppViewManagerUtils,
      AppViewListener,
      ProtoViewFactory,
      Renderer,
      RenderCompiler,
      DomRenderer,
      DOCUMENT,
      DefaultDomCompiler,
      APP_ID_RANDOM_BINDING,
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE,
      TemplateCloner,
      ElementSchemaRegistry,
      DomElementSchemaRegistry,
      SharedStylesHost,
      DomSharedStylesHost,
      internalView,
      APP_COMPONENT_REF_PROMISE,
      APP_COMPONENT,
      wtfInit,
      EXCEPTION_BINDING,
      ApplicationRef,
      _rootInjector,
      _rootBindings;
  function _injectorBindings(appComponentType) {
    var bestChangeDetection = new DynamicChangeDetection();
    if (PreGeneratedChangeDetection.isSupported()) {
      bestChangeDetection = new PreGeneratedChangeDetection();
    } else if (JitChangeDetection.isSupported()) {
      bestChangeDetection = new JitChangeDetection();
    }
    return [bind(DOCUMENT).toValue(DOM.defaultDoc()), bind(APP_COMPONENT).toValue(appComponentType), bind(APP_COMPONENT_REF_PROMISE).toFactory((function(dynamicComponentLoader, injector, testability, registry) {
      return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector).then((function(componentRef) {
        registry.registerApplication(componentRef.location.nativeElement, testability);
        return componentRef;
      }));
    }), [DynamicComponentLoader, Injector, Testability, TestabilityRegistry]), bind(appComponentType).toFactory((function(p) {
      return p.then((function(ref) {
        return ref.instance;
      }));
    }), [APP_COMPONENT_REF_PROMISE]), bind(LifeCycle).toFactory((function(exceptionHandler) {
      return new LifeCycle(null, assertionsEnabled());
    }), [ExceptionHandler]), bind(EventManager).toFactory((function(ngZone) {
      var plugins = [new HammerGesturesPlugin(), new KeyEventsPlugin(), new DomEventsPlugin()];
      return new EventManager(plugins, ngZone);
    }), [NgZone]), DomRenderer, bind(Renderer).toAlias(DomRenderer), APP_ID_RANDOM_BINDING, TemplateCloner, bind(MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE).toValue(20), DefaultDomCompiler, bind(ElementSchemaRegistry).toValue(new DomElementSchemaRegistry()), bind(RenderCompiler).toAlias(DefaultDomCompiler), DomSharedStylesHost, bind(SharedStylesHost).toAlias(DomSharedStylesHost), ProtoViewFactory, AppViewPool, bind(APP_VIEW_POOL_CAPACITY).toValue(10000), AppViewManager, AppViewManagerUtils, AppViewListener, Compiler, CompilerCache, ViewResolver, DEFAULT_PIPES, bind(IterableDiffers).toValue(defaultIterableDiffers), bind(KeyValueDiffers).toValue(defaultKeyValueDiffers), bind(ChangeDetection).toValue(bestChangeDetection), ViewLoader, DirectiveResolver, PipeResolver, Parser, Lexer, EXCEPTION_BINDING, bind(XHR).toValue(new XHRImpl()), ComponentUrlMapper, UrlResolver, StyleUrlResolver, StyleInliner, DynamicComponentLoader, Testability, AnchorBasedAppRootUrl, bind(AppRootUrl).toAlias(AnchorBasedAppRootUrl)];
  }
  function createNgZone() {
    return new NgZone({enableLongStackTrace: assertionsEnabled()});
  }
  function commonBootstrap(appComponentType) {
    var componentInjectableBindings = arguments[1] !== (void 0) ? arguments[1] : null;
    BrowserDomAdapter.makeCurrent();
    wtfInit();
    var bootstrapProcess = PromiseWrapper.completer();
    var zone = createNgZone();
    zone.run((function() {
      var exceptionHandler;
      try {
        var appInjector = _createAppInjector(appComponentType, componentInjectableBindings, zone);
        exceptionHandler = appInjector.get(ExceptionHandler);
        zone.overrideOnErrorHandler((function(e, s) {
          return exceptionHandler.call(e, s);
        }));
        var compRefToken = appInjector.get(APP_COMPONENT_REF_PROMISE);
        var tick = (function(componentRef) {
          var appChangeDetector = internalView(componentRef.hostView).changeDetector;
          var lc = appInjector.get(LifeCycle);
          lc.registerWith(zone, appChangeDetector);
          lc.tick();
          bootstrapProcess.resolve(new ApplicationRef(componentRef, appComponentType, appInjector));
        });
        var tickResult = PromiseWrapper.then(compRefToken, tick);
        PromiseWrapper.then(tickResult, (function(_) {}));
        PromiseWrapper.then(tickResult, null, (function(err, stackTrace) {
          bootstrapProcess.reject(err, stackTrace);
        }));
      } catch (e) {
        if (isPresent(exceptionHandler)) {
          exceptionHandler.call(e, e.stack);
        } else {
          DOM.logError(e);
        }
        bootstrapProcess.reject(e, e.stack);
      }
    }));
    return bootstrapProcess.promise;
  }
  function _createAppInjector(appComponentType, bindings, zone) {
    if (isBlank(_rootInjector))
      _rootInjector = Injector.resolveAndCreate(_rootBindings);
    var mergedBindings = isPresent(bindings) ? ListWrapper.concat(_injectorBindings(appComponentType), bindings) : _injectorBindings(appComponentType);
    mergedBindings.push(bind(NgZone).toValue(zone));
    return _rootInjector.resolveAndCreateChild(mergedBindings);
  }
  $__export("createNgZone", createNgZone);
  $__export("commonBootstrap", commonBootstrap);
  return {
    setters: [function($__m) {
      Injector = $__m.Injector;
      bind = $__m.bind;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      assertionsEnabled = $__m.assertionsEnabled;
    }, function($__m) {
      BrowserDomAdapter = $__m.BrowserDomAdapter;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Compiler = $__m.Compiler;
      CompilerCache = $__m.CompilerCache;
    }, function($__m) {
      Reflector = $__m.Reflector;
      reflector = $__m.reflector;
    }, function($__m) {
      Parser = $__m.Parser;
      Lexer = $__m.Lexer;
      ChangeDetection = $__m.ChangeDetection;
      DynamicChangeDetection = $__m.DynamicChangeDetection;
      JitChangeDetection = $__m.JitChangeDetection;
      PreGeneratedChangeDetection = $__m.PreGeneratedChangeDetection;
      IterableDiffers = $__m.IterableDiffers;
      defaultIterableDiffers = $__m.defaultIterableDiffers;
      KeyValueDiffers = $__m.KeyValueDiffers;
      defaultKeyValueDiffers = $__m.defaultKeyValueDiffers;
    }, function($__m) {
      DEFAULT_PIPES = $__m.DEFAULT_PIPES;
    }, function($__m) {
      ExceptionHandler = $__m.ExceptionHandler;
    }, function($__m) {
      ViewLoader = $__m.ViewLoader;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      StyleInliner = $__m.StyleInliner;
    }, function($__m) {
      ViewResolver = $__m.ViewResolver;
    }, function($__m) {
      DirectiveResolver = $__m.DirectiveResolver;
    }, function($__m) {
      PipeResolver = $__m.PipeResolver;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      NgZone = $__m.NgZone;
    }, function($__m) {
      LifeCycle = $__m.LifeCycle;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      XHRImpl = $__m.XHRImpl;
    }, function($__m) {
      EventManager = $__m.EventManager;
      DomEventsPlugin = $__m.DomEventsPlugin;
    }, function($__m) {
      KeyEventsPlugin = $__m.KeyEventsPlugin;
    }, function($__m) {
      HammerGesturesPlugin = $__m.HammerGesturesPlugin;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      AppRootUrl = $__m.AppRootUrl;
    }, function($__m) {
      AnchorBasedAppRootUrl = $__m.AnchorBasedAppRootUrl;
    }, function($__m) {
      DynamicComponentLoader = $__m.DynamicComponentLoader;
    }, function($__m) {
      TestabilityRegistry = $__m.TestabilityRegistry;
      Testability = $__m.Testability;
    }, function($__m) {
      AppViewPool = $__m.AppViewPool;
      APP_VIEW_POOL_CAPACITY = $__m.APP_VIEW_POOL_CAPACITY;
    }, function($__m) {
      AppViewManager = $__m.AppViewManager;
    }, function($__m) {
      AppViewManagerUtils = $__m.AppViewManagerUtils;
    }, function($__m) {
      AppViewListener = $__m.AppViewListener;
    }, function($__m) {
      ProtoViewFactory = $__m.ProtoViewFactory;
    }, function($__m) {
      Renderer = $__m.Renderer;
      RenderCompiler = $__m.RenderCompiler;
    }, function($__m) {
      DomRenderer = $__m.DomRenderer;
      DOCUMENT = $__m.DOCUMENT;
      DefaultDomCompiler = $__m.DefaultDomCompiler;
      APP_ID_RANDOM_BINDING = $__m.APP_ID_RANDOM_BINDING;
      MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = $__m.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE;
      TemplateCloner = $__m.TemplateCloner;
    }, function($__m) {
      ElementSchemaRegistry = $__m.ElementSchemaRegistry;
    }, function($__m) {
      DomElementSchemaRegistry = $__m.DomElementSchemaRegistry;
    }, function($__m) {
      SharedStylesHost = $__m.SharedStylesHost;
      DomSharedStylesHost = $__m.DomSharedStylesHost;
    }, function($__m) {
      internalView = $__m.internalView;
    }, function($__m) {
      APP_COMPONENT_REF_PROMISE = $__m.APP_COMPONENT_REF_PROMISE;
      APP_COMPONENT = $__m.APP_COMPONENT;
    }, function($__m) {
      wtfInit = $__m.wtfInit;
    }, function($__m) {
      EXCEPTION_BINDING = $__m.EXCEPTION_BINDING;
    }, function($__m) {
      ApplicationRef = $__m.ApplicationRef;
    }],
    execute: function() {
      _rootBindings = [bind(Reflector).toValue(reflector), TestabilityRegistry];
    }
  };
});

System.register("angular2/change_detection", ["angular2/src/change_detection/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/change_detection";
  return {
    setters: [function($__m) {
      $__export("CHECK_ONCE", $__m.CHECK_ONCE);
      $__export("CHECK_ALWAYS", $__m.CHECK_ALWAYS);
      $__export("DETACHED", $__m.DETACHED);
      $__export("CHECKED", $__m.CHECKED);
      $__export("ON_PUSH", $__m.ON_PUSH);
      $__export("DEFAULT", $__m.DEFAULT);
      $__export("ExpressionChangedAfterItHasBeenCheckedException", $__m.ExpressionChangedAfterItHasBeenCheckedException);
      $__export("ChangeDetectionError", $__m.ChangeDetectionError);
      $__export("Locals", $__m.Locals);
      $__export("ChangeDetectorRef", $__m.ChangeDetectorRef);
      $__export("WrappedValue", $__m.WrappedValue);
      $__export("IterableDiffers", $__m.IterableDiffers);
      $__export("KeyValueDiffers", $__m.KeyValueDiffers);
    }],
    execute: function() {}
  };
});

System.register("angular2/core", ["angular2/src/core/application_tokens", "angular2/src/core/application_common", "angular2/src/facade/lang", "angular2/src/core/application_ref", "angular2/src/services/app_root_url", "angular2/src/services/url_resolver", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/directive_resolver", "angular2/src/core/compiler/compiler", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/query_list", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/life_cycle/life_cycle", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/template_ref", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/zone/ng_zone", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/core";
  return {
    setters: [function($__m) {
      $__export("APP_COMPONENT", $__m.APP_COMPONENT);
    }, function($__m) {
      $__export("bootstrap", $__m.commonBootstrap);
    }, function($__m) {
      $__export("Type", $__m.Type);
    }, function($__m) {
      $__export("ApplicationRef", $__m.ApplicationRef);
    }, function($__m) {
      $__export("AppRootUrl", $__m.AppRootUrl);
    }, function($__m) {
      $__export("UrlResolver", $__m.UrlResolver);
    }, function($__m) {
      $__export("ComponentUrlMapper", $__m.ComponentUrlMapper);
    }, function($__m) {
      $__export("DirectiveResolver", $__m.DirectiveResolver);
    }, function($__m) {
      $__export("Compiler", $__m.Compiler);
    }, function($__m) {
      $__export("AppViewManager", $__m.AppViewManager);
    }, function($__m) {
      $__export("QueryList", $__m.QueryList);
    }, function($__m) {
      $__export("DynamicComponentLoader", $__m.DynamicComponentLoader);
      $__export("ComponentRef", $__m.ComponentRef);
    }, function($__m) {
      $__export("LifeCycle", $__m.LifeCycle);
    }, function($__m) {
      $__export("ElementRef", $__m.ElementRef);
    }, function($__m) {
      $__export("TemplateRef", $__m.TemplateRef);
    }, function($__m) {
      $__export("ViewRef", $__m.ViewRef);
      $__export("ProtoViewRef", $__m.ProtoViewRef);
    }, function($__m) {
      $__export("ViewContainerRef", $__m.ViewContainerRef);
    }, function($__m) {
      $__export("NgZone", $__m.NgZone);
    }, function($__m) {
      $__export("Observable", $__m.Observable);
      $__export("EventEmitter", $__m.EventEmitter);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/metadata/directives", ["angular2/src/facade/lang", "angular2/src/di/metadata", "angular2/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/metadata/directives";
  var __decorate,
      __metadata,
      CONST,
      InjectableMetadata,
      DEFAULT,
      DirectiveMetadata,
      ComponentMetadata,
      LifecycleEvent,
      PipeMetadata;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }, function($__m) {
      InjectableMetadata = $__m.InjectableMetadata;
    }, function($__m) {
      DEFAULT = $__m.DEFAULT;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      DirectiveMetadata = (function($__super) {
        function $__0() {
          var $__3;
          var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
              selector = $__2.selector,
              properties = $__2.properties,
              events = $__2.events,
              host = $__2.host,
              lifecycle = $__2.lifecycle,
              bindings = $__2.bindings,
              exportAs = $__2.exportAs,
              compileChildren = ($__3 = $__2.compileChildren) === void 0 ? true : $__3;
          $traceurRuntime.superConstructor($__0).call(this);
          this.selector = selector;
          this.properties = properties;
          this.events = events;
          this.host = host;
          this.exportAs = exportAs;
          this.lifecycle = lifecycle;
          this.compileChildren = compileChildren;
          this.bindings = bindings;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(InjectableMetadata));
      $__export("DirectiveMetadata", DirectiveMetadata);
      $__export("DirectiveMetadata", DirectiveMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], DirectiveMetadata));
      ComponentMetadata = (function($__super) {
        function $__0() {
          var $__3,
              $__4;
          var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
              selector = $__2.selector,
              properties = $__2.properties,
              events = $__2.events,
              host = $__2.host,
              exportAs = $__2.exportAs,
              lifecycle = $__2.lifecycle,
              bindings = $__2.bindings,
              viewBindings = $__2.viewBindings,
              changeDetection = ($__3 = $__2.changeDetection) === void 0 ? DEFAULT : $__3,
              compileChildren = ($__4 = $__2.compileChildren) === void 0 ? true : $__4;
          $traceurRuntime.superConstructor($__0).call(this, {
            selector: selector,
            properties: properties,
            events: events,
            host: host,
            exportAs: exportAs,
            bindings: bindings,
            lifecycle: lifecycle,
            compileChildren: compileChildren
          });
          this.changeDetection = changeDetection;
          this.viewBindings = viewBindings;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(DirectiveMetadata));
      $__export("ComponentMetadata", ComponentMetadata);
      $__export("ComponentMetadata", ComponentMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], ComponentMetadata));
      $__export("LifecycleEvent", LifecycleEvent);
      (function(LifecycleEvent) {
        LifecycleEvent[LifecycleEvent["onDestroy"] = 0] = "onDestroy";
        LifecycleEvent[LifecycleEvent["onChange"] = 1] = "onChange";
        LifecycleEvent[LifecycleEvent["onCheck"] = 2] = "onCheck";
        LifecycleEvent[LifecycleEvent["onInit"] = 3] = "onInit";
        LifecycleEvent[LifecycleEvent["onAllChangesDone"] = 4] = "onAllChangesDone";
      })(LifecycleEvent || ($__export("LifecycleEvent", LifecycleEvent = {})));
      PipeMetadata = (function($__super) {
        function $__0($__2) {
          var name = $__2.name;
          $traceurRuntime.superConstructor($__0).call(this);
          this.name = name;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(InjectableMetadata));
      $__export("PipeMetadata", PipeMetadata);
      $__export("PipeMetadata", PipeMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], PipeMetadata));
    }
  };
});

System.register("angular2/src/core/metadata", ["angular2/src/core/metadata/di", "angular2/src/core/metadata/directives", "angular2/src/core/metadata/view", "angular2/src/util/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/metadata";
  var QueryMetadata,
      ViewQueryMetadata,
      AttributeMetadata,
      ComponentMetadata,
      DirectiveMetadata,
      PipeMetadata,
      ViewMetadata,
      makeDecorator,
      makeParamDecorator,
      Component,
      Directive,
      View,
      Attribute,
      Query,
      ViewQuery,
      Pipe;
  return {
    setters: [function($__m) {
      QueryMetadata = $__m.QueryMetadata;
      ViewQueryMetadata = $__m.ViewQueryMetadata;
      AttributeMetadata = $__m.AttributeMetadata;
      $__export("QueryMetadata", $__m.QueryMetadata);
      $__export("ViewQueryMetadata", $__m.ViewQueryMetadata);
      $__export("AttributeMetadata", $__m.AttributeMetadata);
    }, function($__m) {
      ComponentMetadata = $__m.ComponentMetadata;
      DirectiveMetadata = $__m.DirectiveMetadata;
      PipeMetadata = $__m.PipeMetadata;
      $__export("ComponentMetadata", $__m.ComponentMetadata);
      $__export("DirectiveMetadata", $__m.DirectiveMetadata);
      $__export("PipeMetadata", $__m.PipeMetadata);
      $__export("LifecycleEvent", $__m.LifecycleEvent);
    }, function($__m) {
      ViewMetadata = $__m.ViewMetadata;
      $__export("ViewMetadata", $__m.ViewMetadata);
      $__export("ViewEncapsulation", $__m.ViewEncapsulation);
    }, function($__m) {
      makeDecorator = $__m.makeDecorator;
      makeParamDecorator = $__m.makeParamDecorator;
    }],
    execute: function() {
      Component = makeDecorator(ComponentMetadata, (function(fn) {
        return fn.View = View;
      }));
      $__export("Component", Component);
      Directive = makeDecorator(DirectiveMetadata);
      $__export("Directive", Directive);
      View = makeDecorator(ViewMetadata, (function(fn) {
        return fn.View = View;
      }));
      $__export("View", View);
      Attribute = makeParamDecorator(AttributeMetadata);
      $__export("Attribute", Attribute);
      Query = makeParamDecorator(QueryMetadata);
      $__export("Query", Query);
      ViewQuery = makeParamDecorator(ViewQueryMetadata);
      $__export("ViewQuery", ViewQuery);
      Pipe = makeDecorator(PipeMetadata);
      $__export("Pipe", Pipe);
    }
  };
});

System.register("angular2/metadata", ["angular2/src/core/metadata", "angular2/src/util/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/metadata";
  return {
    setters: [function($__m) {
      $__export("ComponentMetadata", $__m.ComponentMetadata);
      $__export("DirectiveMetadata", $__m.DirectiveMetadata);
      $__export("PipeMetadata", $__m.PipeMetadata);
      $__export("LifecycleEvent", $__m.LifecycleEvent);
      $__export("ViewMetadata", $__m.ViewMetadata);
      $__export("ViewEncapsulation", $__m.ViewEncapsulation);
      $__export("QueryMetadata", $__m.QueryMetadata);
      $__export("AttributeMetadata", $__m.AttributeMetadata);
      $__export("Attribute", $__m.Attribute);
      $__export("Component", $__m.Component);
      $__export("Directive", $__m.Directive);
      $__export("View", $__m.View);
      $__export("Query", $__m.Query);
      $__export("ViewQuery", $__m.ViewQuery);
      $__export("Pipe", $__m.Pipe);
    }, function($__m) {
      $__export("Class", $__m.Class);
    }],
    execute: function() {}
  };
});

System.register("angular2/angular2", ["angular2/metadata", "angular2/change_detection", "angular2/core", "angular2/di", "angular2/directives", "angular2/forms", "angular2/render", "angular2/profile"], function($__export) {
  "use strict";
  var __moduleName = "angular2/angular2";
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

//# sourceMappingURLDisabled=angular2.dev.js.map
System.config({"paths":{"*":"*.js","angular2/*":"angular2/*"}});

"format register";
System.register("angular2/src/router/instruction", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/instruction";
  var StringMapWrapper,
      isBlank,
      normalizeBlank,
      RouteParams,
      Instruction,
      PrimaryInstruction,
      ComponentInstruction;
  function stringifyInstruction(instruction) {
    var params = instruction.component.urlParams.length > 0 ? ('?' + instruction.component.urlParams.join('&')) : '';
    return instruction.component.urlPath + stringifyAux(instruction) + stringifyPrimary(instruction.child) + params;
  }
  function stringifyPrimary(instruction) {
    if (isBlank(instruction)) {
      return '';
    }
    var params = instruction.component.urlParams.length > 0 ? (';' + instruction.component.urlParams.join(';')) : '';
    return '/' + instruction.component.urlPath + params + stringifyAux(instruction) + stringifyPrimary(instruction.child);
  }
  function stringifyAux(instruction) {
    var routes = [];
    StringMapWrapper.forEach(instruction.auxInstruction, (function(auxInstruction, _) {
      routes.push(stringifyPrimary(auxInstruction));
    }));
    if (routes.length > 0) {
      return '(' + routes.join('//') + ')';
    }
    return '';
  }
  $__export("stringifyInstruction", stringifyInstruction);
  return {
    setters: [function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      normalizeBlank = $__m.normalizeBlank;
    }],
    execute: function() {
      RouteParams = (function() {
        function RouteParams(params) {
          this.params = params;
        }
        return ($traceurRuntime.createClass)(RouteParams, {get: function(param) {
            return normalizeBlank(StringMapWrapper.get(this.params, param));
          }}, {});
      }());
      $__export("RouteParams", RouteParams);
      Instruction = (function() {
        function Instruction(component, child, auxInstruction) {
          this.component = component;
          this.child = child;
          this.auxInstruction = auxInstruction;
        }
        return ($traceurRuntime.createClass)(Instruction, {replaceChild: function(child) {
            return new Instruction(this.component, child, this.auxInstruction);
          }}, {});
      }());
      $__export("Instruction", Instruction);
      PrimaryInstruction = (function() {
        function PrimaryInstruction(component, child, auxUrls) {
          this.component = component;
          this.child = child;
          this.auxUrls = auxUrls;
        }
        return ($traceurRuntime.createClass)(PrimaryInstruction, {}, {});
      }());
      $__export("PrimaryInstruction", PrimaryInstruction);
      ComponentInstruction = (function() {
        function ComponentInstruction(urlPath, urlParams, _recognizer) {
          var params = arguments[3] !== (void 0) ? arguments[3] : null;
          this.urlPath = urlPath;
          this.urlParams = urlParams;
          this._recognizer = _recognizer;
          this.params = params;
          this.reuse = false;
        }
        return ($traceurRuntime.createClass)(ComponentInstruction, {
          get componentType() {
            return this._recognizer.handler.componentType;
          },
          resolveComponentType: function() {
            return this._recognizer.handler.resolveComponentType();
          },
          get specificity() {
            return this._recognizer.specificity;
          },
          get terminal() {
            return this._recognizer.terminal;
          },
          routeData: function() {
            return this._recognizer.handler.data;
          }
        }, {});
      }());
      $__export("ComponentInstruction", ComponentInstruction);
    }
  };
});

System.register("angular2/src/router/lifecycle_annotations_impl", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/lifecycle_annotations_impl";
  var __decorate,
      __metadata,
      CONST,
      CONST_EXPR,
      RouteLifecycleHook,
      CanActivate,
      canReuse,
      canDeactivate,
      onActivate,
      onReuse,
      onDeactivate;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      RouteLifecycleHook = (($traceurRuntime.createClass)(function(name) {
        this.name = name;
      }, {}, {}));
      $__export("RouteLifecycleHook", RouteLifecycleHook);
      $__export("RouteLifecycleHook", RouteLifecycleHook = __decorate([CONST(), __metadata('design:paramtypes', [String])], RouteLifecycleHook));
      CanActivate = (($traceurRuntime.createClass)(function(fn) {
        this.fn = fn;
      }, {}, {}));
      $__export("CanActivate", CanActivate);
      $__export("CanActivate", CanActivate = __decorate([CONST(), __metadata('design:paramtypes', [Function])], CanActivate));
      canReuse = CONST_EXPR(new RouteLifecycleHook("canReuse"));
      $__export("canReuse", canReuse);
      canDeactivate = CONST_EXPR(new RouteLifecycleHook("canDeactivate"));
      $__export("canDeactivate", canDeactivate);
      onActivate = CONST_EXPR(new RouteLifecycleHook("onActivate"));
      $__export("onActivate", onActivate);
      onReuse = CONST_EXPR(new RouteLifecycleHook("onReuse"));
      $__export("onReuse", onReuse);
      onDeactivate = CONST_EXPR(new RouteLifecycleHook("onDeactivate"));
      $__export("onDeactivate", onDeactivate);
    }
  };
});

System.register("angular2/src/router/route_data", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_data";
  var OpaqueToken,
      CONST_EXPR,
      ROUTE_DATA;
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      ROUTE_DATA = CONST_EXPR(new OpaqueToken('routeData'));
      $__export("ROUTE_DATA", ROUTE_DATA);
    }
  };
});

System.register("angular2/src/router/lifecycle_annotations", ["angular2/src/util/decorators", "angular2/src/router/lifecycle_annotations_impl"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/lifecycle_annotations";
  var makeDecorator,
      CanActivateAnnotation,
      CanActivate;
  return {
    setters: [function($__m) {
      makeDecorator = $__m.makeDecorator;
    }, function($__m) {
      CanActivateAnnotation = $__m.CanActivate;
      $__export("canReuse", $__m.canReuse);
      $__export("canDeactivate", $__m.canDeactivate);
      $__export("onActivate", $__m.onActivate);
      $__export("onReuse", $__m.onReuse);
      $__export("onDeactivate", $__m.onDeactivate);
    }],
    execute: function() {
      CanActivate = makeDecorator(CanActivateAnnotation);
      $__export("CanActivate", CanActivate);
    }
  };
});

System.register("angular2/src/router/location_strategy", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/location_strategy";
  var BaseException,
      LocationStrategy;
  function _abstract() {
    return new BaseException('This method is abstract');
  }
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      LocationStrategy = (function() {
        function LocationStrategy() {}
        return ($traceurRuntime.createClass)(LocationStrategy, {
          path: function() {
            throw _abstract();
          },
          pushState: function(ctx, title, url) {
            throw _abstract();
          },
          forward: function() {
            throw _abstract();
          },
          back: function() {
            throw _abstract();
          },
          onPopState: function(fn) {
            throw _abstract();
          },
          getBaseHref: function() {
            throw _abstract();
          }
        }, {});
      }());
      $__export("LocationStrategy", LocationStrategy);
    }
  };
});

System.register("angular2/src/router/url_parser", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/url_parser";
  var StringMapWrapper,
      isPresent,
      isBlank,
      BaseException,
      RegExpWrapper,
      CONST_EXPR,
      Url,
      RootUrl,
      SEGMENT_RE,
      UrlParser,
      parser;
  function pathSegmentsToUrl(pathSegments) {
    var url = new Url(pathSegments[pathSegments.length - 1]);
    for (var i = pathSegments.length - 2; i >= 0; i -= 1) {
      url = new Url(pathSegments[i], url);
    }
    return url;
  }
  function matchUrlSegment(str) {
    var match = RegExpWrapper.firstMatch(SEGMENT_RE, str);
    return isPresent(match) ? match[0] : null;
  }
  function serializeParams(paramMap) {
    var params = [];
    if (isPresent(paramMap)) {
      StringMapWrapper.forEach(paramMap, (function(value, key) {
        if (value == true) {
          params.push(key);
        } else {
          params.push(key + '=' + value);
        }
      }));
    }
    return params;
  }
  $__export("pathSegmentsToUrl", pathSegmentsToUrl);
  $__export("serializeParams", serializeParams);
  return {
    setters: [function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      RegExpWrapper = $__m.RegExpWrapper;
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      Url = (function() {
        function Url(path) {
          var child = arguments[1] !== (void 0) ? arguments[1] : null;
          var auxiliary = arguments[2] !== (void 0) ? arguments[2] : CONST_EXPR([]);
          var params = arguments[3] !== (void 0) ? arguments[3] : null;
          this.path = path;
          this.child = child;
          this.auxiliary = auxiliary;
          this.params = params;
        }
        return ($traceurRuntime.createClass)(Url, {
          toString: function() {
            return this.path + this._matrixParamsToString() + this._auxToString() + this._childString();
          },
          segmentToString: function() {
            return this.path + this._matrixParamsToString();
          },
          _auxToString: function() {
            return this.auxiliary.length > 0 ? ('(' + this.auxiliary.map((function(sibling) {
              return sibling.toString();
            })).join('//') + ')') : '';
          },
          _matrixParamsToString: function() {
            if (isBlank(this.params)) {
              return '';
            }
            return ';' + serializeParams(this.params).join(';');
          },
          _childString: function() {
            return isPresent(this.child) ? ('/' + this.child.toString()) : '';
          }
        }, {});
      }());
      $__export("Url", Url);
      RootUrl = (function($__super) {
        function RootUrl(path) {
          var child = arguments[1] !== (void 0) ? arguments[1] : null;
          var auxiliary = arguments[2] !== (void 0) ? arguments[2] : CONST_EXPR([]);
          var params = arguments[3] !== (void 0) ? arguments[3] : null;
          $traceurRuntime.superConstructor(RootUrl).call(this, path, child, auxiliary, params);
        }
        return ($traceurRuntime.createClass)(RootUrl, {
          toString: function() {
            return this.path + this._auxToString() + this._childString() + this._queryParamsToString();
          },
          segmentToString: function() {
            return this.path + this._queryParamsToString();
          },
          _queryParamsToString: function() {
            if (isBlank(this.params)) {
              return '';
            }
            return '?' + serializeParams(this.params).join('&');
          }
        }, {}, $__super);
      }(Url));
      $__export("RootUrl", RootUrl);
      SEGMENT_RE = RegExpWrapper.create('^[^\\/\\(\\)\\?;=&]+');
      UrlParser = (function() {
        function UrlParser() {}
        return ($traceurRuntime.createClass)(UrlParser, {
          peekStartsWith: function(str) {
            return this.remaining.startsWith(str);
          },
          capture: function(str) {
            if (!this.remaining.startsWith(str)) {
              throw new BaseException(("Expected \"" + str + "\"."));
            }
            this.remaining = this.remaining.substring(str.length);
          },
          parse: function(url) {
            this.remaining = url;
            if (url == '' || url == '/') {
              return new Url('');
            }
            return this.parseRoot();
          },
          parseRoot: function() {
            if (this.peekStartsWith('/')) {
              this.capture('/');
            }
            var path = matchUrlSegment(this.remaining);
            this.capture(path);
            var aux = [];
            if (this.peekStartsWith('(')) {
              aux = this.parseAuxiliaryRoutes();
            }
            if (this.peekStartsWith(';')) {
              this.parseMatrixParams();
            }
            var child = null;
            if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
              this.capture('/');
              child = this.parseSegment();
            }
            var queryParams = null;
            if (this.peekStartsWith('?')) {
              queryParams = this.parseQueryParams();
            }
            return new RootUrl(path, child, aux, queryParams);
          },
          parseSegment: function() {
            if (this.remaining.length == 0) {
              return null;
            }
            if (this.peekStartsWith('/')) {
              this.capture('/');
            }
            var path = matchUrlSegment(this.remaining);
            this.capture(path);
            var matrixParams = null;
            if (this.peekStartsWith(';')) {
              matrixParams = this.parseMatrixParams();
            }
            var aux = [];
            if (this.peekStartsWith('(')) {
              aux = this.parseAuxiliaryRoutes();
            }
            var child = null;
            if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
              this.capture('/');
              child = this.parseSegment();
            }
            return new Url(path, child, aux, matrixParams);
          },
          parseQueryParams: function() {
            var params = {};
            this.capture('?');
            this.parseParam(params);
            while (this.remaining.length > 0 && this.peekStartsWith('&')) {
              this.capture('&');
              this.parseParam(params);
            }
            return params;
          },
          parseMatrixParams: function() {
            var params = {};
            while (this.remaining.length > 0 && this.peekStartsWith(';')) {
              this.capture(';');
              this.parseParam(params);
            }
            return params;
          },
          parseParam: function(params) {
            var key = matchUrlSegment(this.remaining);
            if (isBlank(key)) {
              return ;
            }
            this.capture(key);
            var value = true;
            if (this.peekStartsWith('=')) {
              this.capture('=');
              var valueMatch = matchUrlSegment(this.remaining);
              if (isPresent(valueMatch)) {
                value = valueMatch;
                this.capture(value);
              }
            }
            params[key] = value;
          },
          parseAuxiliaryRoutes: function() {
            var routes = [];
            this.capture('(');
            while (!this.peekStartsWith(')') && this.remaining.length > 0) {
              routes.push(this.parseSegment());
              if (this.peekStartsWith('//')) {
                this.capture('//');
              }
            }
            this.capture(')');
            return routes;
          }
        }, {});
      }());
      $__export("UrlParser", UrlParser);
      parser = new UrlParser();
      $__export("parser", parser);
    }
  };
});

System.register("angular2/src/router/route_config_impl", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_config_impl";
  var __decorate,
      __metadata,
      CONST,
      RouteConfig,
      Route,
      AuxRoute,
      AsyncRoute,
      Redirect;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      RouteConfig = (($traceurRuntime.createClass)(function(configs) {
        this.configs = configs;
      }, {}, {}));
      $__export("RouteConfig", RouteConfig);
      $__export("RouteConfig", RouteConfig = __decorate([CONST(), __metadata('design:paramtypes', [Object])], RouteConfig));
      Route = (($traceurRuntime.createClass)(function($__2) {
        var $__3 = $__2,
            path = $__3.path,
            component = $__3.component,
            as = $__3.as,
            data = $__3.data;
        this.path = path;
        this.component = component;
        this.as = as;
        this.loader = null;
        this.redirectTo = null;
        this.data = data;
      }, {}, {}));
      $__export("Route", Route);
      $__export("Route", Route = __decorate([CONST(), __metadata('design:paramtypes', [Object])], Route));
      AuxRoute = (($traceurRuntime.createClass)(function($__2) {
        var $__3 = $__2,
            path = $__3.path,
            component = $__3.component,
            as = $__3.as;
        this.data = null;
        this.loader = null;
        this.redirectTo = null;
        this.path = path;
        this.component = component;
        this.as = as;
      }, {}, {}));
      $__export("AuxRoute", AuxRoute);
      $__export("AuxRoute", AuxRoute = __decorate([CONST(), __metadata('design:paramtypes', [Object])], AuxRoute));
      AsyncRoute = (($traceurRuntime.createClass)(function($__2) {
        var $__3 = $__2,
            path = $__3.path,
            loader = $__3.loader,
            as = $__3.as,
            data = $__3.data;
        this.path = path;
        this.loader = loader;
        this.as = as;
        this.data = data;
      }, {}, {}));
      $__export("AsyncRoute", AsyncRoute);
      $__export("AsyncRoute", AsyncRoute = __decorate([CONST(), __metadata('design:paramtypes', [Object])], AsyncRoute));
      Redirect = (($traceurRuntime.createClass)(function($__2) {
        var $__3 = $__2,
            path = $__3.path,
            redirectTo = $__3.redirectTo;
        this.as = null;
        this.loader = null;
        this.data = null;
        this.path = path;
        this.redirectTo = redirectTo;
      }, {}, {}));
      $__export("Redirect", Redirect);
      $__export("Redirect", Redirect = __decorate([CONST(), __metadata('design:paramtypes', [Object])], Redirect));
    }
  };
});

System.register("angular2/src/router/async_route_handler", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/async_route_handler";
  var isPresent,
      AsyncRouteHandler;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      AsyncRouteHandler = (function() {
        function AsyncRouteHandler(_loader, data) {
          this._loader = _loader;
          this.data = data;
          this._resolvedComponent = null;
        }
        return ($traceurRuntime.createClass)(AsyncRouteHandler, {resolveComponentType: function() {
            var $__0 = this;
            if (isPresent(this._resolvedComponent)) {
              return this._resolvedComponent;
            }
            return this._resolvedComponent = this._loader().then((function(componentType) {
              $__0.componentType = componentType;
              return componentType;
            }));
          }}, {});
      }());
      $__export("AsyncRouteHandler", AsyncRouteHandler);
    }
  };
});

System.register("angular2/src/router/sync_route_handler", ["angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/sync_route_handler";
  var PromiseWrapper,
      SyncRouteHandler;
  return {
    setters: [function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }],
    execute: function() {
      SyncRouteHandler = (function() {
        function SyncRouteHandler(componentType, data) {
          this.componentType = componentType;
          this.data = data;
          this._resolvedComponent = null;
          this._resolvedComponent = PromiseWrapper.resolve(componentType);
        }
        return ($traceurRuntime.createClass)(SyncRouteHandler, {resolveComponentType: function() {
            return this._resolvedComponent;
          }}, {});
      }());
      $__export("SyncRouteHandler", SyncRouteHandler);
    }
  };
});

System.register("angular2/src/router/route_config_decorator", ["angular2/src/router/route_config_impl", "angular2/src/util/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_config_decorator";
  var RouteConfigAnnotation,
      makeDecorator,
      RouteConfig;
  return {
    setters: [function($__m) {
      RouteConfigAnnotation = $__m.RouteConfig;
      $__export("Route", $__m.Route);
      $__export("Redirect", $__m.Redirect);
      $__export("AuxRoute", $__m.AuxRoute);
      $__export("AsyncRoute", $__m.AsyncRoute);
    }, function($__m) {
      makeDecorator = $__m.makeDecorator;
    }],
    execute: function() {
      RouteConfig = makeDecorator(RouteConfigAnnotation);
      $__export("RouteConfig", RouteConfig);
    }
  };
});

System.register("angular2/src/router/hash_location_strategy", ["angular2/src/dom/dom_adapter", "angular2/di", "angular2/src/router/location_strategy"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/hash_location_strategy";
  var __decorate,
      __metadata,
      DOM,
      Injectable,
      LocationStrategy,
      HashLocationStrategy;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      LocationStrategy = $__m.LocationStrategy;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      HashLocationStrategy = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this);
          this._location = DOM.getLocation();
          this._history = DOM.getHistory();
        }
        return ($traceurRuntime.createClass)($__0, {
          onPopState: function(fn) {
            DOM.getGlobalEventTarget('window').addEventListener('popstate', fn, false);
          },
          getBaseHref: function() {
            return '';
          },
          path: function() {
            var path = this._location.hash;
            return path.length > 0 ? path.substring(1) : path;
          },
          pushState: function(state, title, url) {
            this._history.pushState(state, title, '#' + url);
          },
          forward: function() {
            this._history.forward();
          },
          back: function() {
            this._history.back();
          }
        }, {}, $__super);
      }(LocationStrategy));
      $__export("HashLocationStrategy", HashLocationStrategy);
      $__export("HashLocationStrategy", HashLocationStrategy = __decorate([Injectable(), __metadata('design:paramtypes', [])], HashLocationStrategy));
    }
  };
});

System.register("angular2/src/router/path_location_strategy", ["angular2/src/dom/dom_adapter", "angular2/di", "angular2/src/router/location_strategy"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/path_location_strategy";
  var __decorate,
      __metadata,
      DOM,
      Injectable,
      LocationStrategy,
      PathLocationStrategy;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      LocationStrategy = $__m.LocationStrategy;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      PathLocationStrategy = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this);
          this._location = DOM.getLocation();
          this._history = DOM.getHistory();
          this._baseHref = DOM.getBaseHref();
        }
        return ($traceurRuntime.createClass)($__0, {
          onPopState: function(fn) {
            DOM.getGlobalEventTarget('window').addEventListener('popstate', fn, false);
          },
          getBaseHref: function() {
            return this._baseHref;
          },
          path: function() {
            return this._location.pathname;
          },
          pushState: function(state, title, url) {
            this._history.pushState(state, title, url);
          },
          forward: function() {
            this._history.forward();
          },
          back: function() {
            this._history.back();
          }
        }, {}, $__super);
      }(LocationStrategy));
      $__export("PathLocationStrategy", PathLocationStrategy);
      $__export("PathLocationStrategy", PathLocationStrategy = __decorate([Injectable(), __metadata('design:paramtypes', [])], PathLocationStrategy));
    }
  };
});

System.register("angular2/src/router/pipeline", ["angular2/src/facade/async", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/pipeline";
  var __decorate,
      __metadata,
      PromiseWrapper,
      Injectable,
      Pipeline;
  return {
    setters: [function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Pipeline = (($traceurRuntime.createClass)(function() {
        this.steps = [(function(instruction) {
          return instruction.router.activateOutlets(instruction);
        })];
      }, {process: function(instruction) {
          var steps = this.steps,
              currentStep = 0;
          function processOne() {
            var result = arguments[0] !== (void 0) ? arguments[0] : true;
            if (currentStep >= steps.length) {
              return PromiseWrapper.resolve(result);
            }
            var step = steps[currentStep];
            currentStep += 1;
            return PromiseWrapper.resolve(step(instruction)).then(processOne);
          }
          return processOne();
        }}, {}));
      $__export("Pipeline", Pipeline);
      $__export("Pipeline", Pipeline = __decorate([Injectable(), __metadata('design:paramtypes', [])], Pipeline));
    }
  };
});

System.register("angular2/src/router/route_definition", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_definition";
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("angular2/src/router/location", ["angular2/src/router/location_strategy", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/location";
  var __decorate,
      __metadata,
      __param,
      LocationStrategy,
      isPresent,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      BaseException,
      isBlank,
      OpaqueToken,
      Injectable,
      Optional,
      Inject,
      APP_BASE_HREF,
      Location;
  function stripIndexHtml(url) {
    if (/\/index.html$/g.test(url)) {
      return url.substring(0, url.length - 11);
    }
    return url;
  }
  function stripTrailingSlash(url) {
    if (/\/$/g.test(url)) {
      url = url.substring(0, url.length - 1);
    }
    return url;
  }
  return {
    setters: [function($__m) {
      LocationStrategy = $__m.LocationStrategy;
    }, function($__m) {
      isPresent = $__m.isPresent;
      CONST_EXPR = $__m.CONST_EXPR;
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      OpaqueToken = $__m.OpaqueToken;
      Injectable = $__m.Injectable;
      Optional = $__m.Optional;
      Inject = $__m.Inject;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      APP_BASE_HREF = CONST_EXPR(new OpaqueToken('appBaseHref'));
      $__export("APP_BASE_HREF", APP_BASE_HREF);
      Location = (($traceurRuntime.createClass)(function(_platformStrategy, href) {
        var $__0 = this;
        this._platformStrategy = _platformStrategy;
        this._subject = new EventEmitter();
        var browserBaseHref = isPresent(href) ? href : this._platformStrategy.getBaseHref();
        if (isBlank(browserBaseHref)) {
          throw new BaseException("No base href set. Either provide a binding to \"appBaseHrefToken\" or add a base element.");
        }
        this._baseHref = stripTrailingSlash(stripIndexHtml(browserBaseHref));
        this._platformStrategy.onPopState((function(_) {
          return $__0._onPopState(_);
        }));
      }, {
        _onPopState: function(_) {
          ObservableWrapper.callNext(this._subject, {
            'url': this.path(),
            'pop': true
          });
        },
        path: function() {
          return this.normalize(this._platformStrategy.path());
        },
        normalize: function(url) {
          return stripTrailingSlash(this._stripBaseHref(stripIndexHtml(url)));
        },
        normalizeAbsolutely: function(url) {
          if (!url.startsWith('/')) {
            url = '/' + url;
          }
          return stripTrailingSlash(this._addBaseHref(url));
        },
        _stripBaseHref: function(url) {
          if (this._baseHref.length > 0 && url.startsWith(this._baseHref)) {
            return url.substring(this._baseHref.length);
          }
          return url;
        },
        _addBaseHref: function(url) {
          if (!url.startsWith(this._baseHref)) {
            return this._baseHref + url;
          }
          return url;
        },
        go: function(url) {
          var finalUrl = this.normalizeAbsolutely(url);
          this._platformStrategy.pushState(null, '', finalUrl);
        },
        forward: function() {
          this._platformStrategy.forward();
        },
        back: function() {
          this._platformStrategy.back();
        },
        subscribe: function(onNext) {
          var onThrow = arguments[1] !== (void 0) ? arguments[1] : null;
          var onReturn = arguments[2] !== (void 0) ? arguments[2] : null;
          ObservableWrapper.subscribe(this._subject, onNext, onThrow, onReturn);
        }
      }, {}));
      $__export("Location", Location);
      $__export("Location", Location = __decorate([Injectable(), __param(1, Optional()), __param(1, Inject(APP_BASE_HREF)), __metadata('design:paramtypes', [LocationStrategy, String])], Location));
    }
  };
});

System.register("angular2/src/router/path_recognizer", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/router/url_parser", "angular2/src/router/instruction"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/path_recognizer";
  var RegExpWrapper,
      StringWrapper,
      isPresent,
      isBlank,
      BaseException,
      StringMapWrapper,
      ListWrapper,
      RootUrl,
      serializeParams,
      ComponentInstruction,
      TouchMap,
      ContinuationSegment,
      StaticSegment,
      DynamicSegment,
      StarSegment,
      paramMatcher,
      wildcardMatcher,
      RESERVED_CHARS,
      PathMatch,
      PathRecognizer;
  function normalizeString(obj) {
    if (isBlank(obj)) {
      return null;
    } else {
      return obj.toString();
    }
  }
  function parsePathString(route) {
    if (StringWrapper.startsWith(route, "/")) {
      route = StringWrapper.substring(route, 1);
    }
    var segments = splitBySlash(route);
    var results = [];
    var specificity = 0;
    if (segments.length > 98) {
      throw new BaseException(("'" + route + "' has more than the maximum supported number of segments."));
    }
    var limit = segments.length - 1;
    for (var i = 0; i <= limit; i++) {
      var segment = segments[i],
          match = void 0;
      if (isPresent(match = RegExpWrapper.firstMatch(paramMatcher, segment))) {
        results.push(new DynamicSegment(match[1]));
        specificity += (100 - i);
      } else if (isPresent(match = RegExpWrapper.firstMatch(wildcardMatcher, segment))) {
        results.push(new StarSegment(match[1]));
      } else if (segment == '...') {
        if (i < limit) {
          throw new BaseException(("Unexpected \"...\" before the end of the path for \"" + route + "\"."));
        }
        results.push(new ContinuationSegment());
      } else {
        results.push(new StaticSegment(segment));
        specificity += 100 * (100 - i);
      }
    }
    var result = StringMapWrapper.create();
    StringMapWrapper.set(result, 'segments', results);
    StringMapWrapper.set(result, 'specificity', specificity);
    return result;
  }
  function pathDslHash(segments) {
    return segments.map((function(segment) {
      if (segment instanceof StarSegment) {
        return '*';
      } else if (segment instanceof ContinuationSegment) {
        return '...';
      } else if (segment instanceof DynamicSegment) {
        return ':';
      } else if (segment instanceof StaticSegment) {
        return segment.path;
      }
    })).join('/');
  }
  function splitBySlash(url) {
    return url.split('/');
  }
  function assertPath(path) {
    if (StringWrapper.contains(path, '#')) {
      throw new BaseException(("Path \"" + path + "\" should not include \"#\". Use \"HashLocationStrategy\" instead."));
    }
    var illegalCharacter = RegExpWrapper.firstMatch(RESERVED_CHARS, path);
    if (isPresent(illegalCharacter)) {
      throw new BaseException(("Path \"" + path + "\" contains \"" + illegalCharacter[0] + "\" which is not allowed in a route config."));
    }
  }
  return {
    setters: [function($__m) {
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      RootUrl = $__m.RootUrl;
      serializeParams = $__m.serializeParams;
    }, function($__m) {
      ComponentInstruction = $__m.ComponentInstruction;
    }],
    execute: function() {
      TouchMap = (function() {
        function TouchMap(map) {
          var $__0 = this;
          this.map = {};
          this.keys = {};
          if (isPresent(map)) {
            StringMapWrapper.forEach(map, (function(value, key) {
              $__0.map[key] = isPresent(value) ? value.toString() : null;
              $__0.keys[key] = true;
            }));
          }
        }
        return ($traceurRuntime.createClass)(TouchMap, {
          get: function(key) {
            StringMapWrapper.delete(this.keys, key);
            return this.map[key];
          },
          getUnused: function() {
            var $__0 = this;
            var unused = StringMapWrapper.create();
            var keys = StringMapWrapper.keys(this.keys);
            ListWrapper.forEach(keys, (function(key) {
              unused[key] = StringMapWrapper.get($__0.map, key);
            }));
            return unused;
          }
        }, {});
      }());
      $__export("TouchMap", TouchMap);
      ContinuationSegment = (function() {
        function ContinuationSegment() {
          this.name = '';
        }
        return ($traceurRuntime.createClass)(ContinuationSegment, {
          generate: function(params) {
            return '';
          },
          match: function(path) {
            return true;
          }
        }, {});
      }());
      StaticSegment = (function() {
        function StaticSegment(path) {
          this.path = path;
          this.name = '';
        }
        return ($traceurRuntime.createClass)(StaticSegment, {
          match: function(path) {
            return path == this.path;
          },
          generate: function(params) {
            return this.path;
          }
        }, {});
      }());
      DynamicSegment = (function() {
        function DynamicSegment(name) {
          this.name = name;
        }
        return ($traceurRuntime.createClass)(DynamicSegment, {
          match: function(path) {
            return true;
          },
          generate: function(params) {
            if (!StringMapWrapper.contains(params.map, this.name)) {
              throw new BaseException(("Route generator for '" + this.name + "' was not included in parameters passed."));
            }
            return normalizeString(params.get(this.name));
          }
        }, {});
      }());
      StarSegment = (function() {
        function StarSegment(name) {
          this.name = name;
        }
        return ($traceurRuntime.createClass)(StarSegment, {
          match: function(path) {
            return true;
          },
          generate: function(params) {
            return normalizeString(params.get(this.name));
          }
        }, {});
      }());
      paramMatcher = /^:([^\/]+)$/g;
      wildcardMatcher = /^\*([^\/]+)$/g;
      RESERVED_CHARS = RegExpWrapper.create('//|\\(|\\)|;|\\?|=');
      PathMatch = (function() {
        function PathMatch(instruction, remaining, remainingAux) {
          this.instruction = instruction;
          this.remaining = remaining;
          this.remainingAux = remainingAux;
        }
        return ($traceurRuntime.createClass)(PathMatch, {}, {});
      }());
      $__export("PathMatch", PathMatch);
      PathRecognizer = (function() {
        function PathRecognizer(path, handler) {
          this.path = path;
          this.handler = handler;
          this.terminal = true;
          assertPath(path);
          var parsed = parsePathString(path);
          this._segments = parsed['segments'];
          this.specificity = parsed['specificity'];
          this.hash = pathDslHash(this._segments);
          var lastSegment = this._segments[this._segments.length - 1];
          this.terminal = !(lastSegment instanceof ContinuationSegment);
        }
        return ($traceurRuntime.createClass)(PathRecognizer, {
          recognize: function(beginningSegment) {
            var nextSegment = beginningSegment;
            var currentSegment;
            var positionalParams = {};
            var captured = [];
            for (var i = 0; i < this._segments.length; i += 1) {
              var segment = this._segments[i];
              currentSegment = nextSegment;
              if (segment instanceof ContinuationSegment) {
                break;
              }
              if (isBlank(currentSegment)) {
                return null;
              }
              captured.push(currentSegment.path);
              if (segment instanceof StarSegment) {
                positionalParams[segment.name] = currentSegment.toString();
                nextSegment = null;
                break;
              }
              if (segment instanceof DynamicSegment) {
                positionalParams[segment.name] = currentSegment.path;
              } else if (!segment.match(currentSegment.path)) {
                return null;
              }
              nextSegment = currentSegment.child;
            }
            if (this.terminal && isPresent(nextSegment)) {
              return null;
            }
            var urlPath = captured.join('/');
            var auxiliary;
            var instruction;
            if (isPresent(currentSegment)) {
              var paramsSegment = beginningSegment instanceof RootUrl ? beginningSegment : currentSegment;
              var allParams = isPresent(paramsSegment.params) ? StringMapWrapper.merge(paramsSegment.params, positionalParams) : positionalParams;
              var urlParams = serializeParams(paramsSegment.params);
              instruction = new ComponentInstruction(urlPath, urlParams, this, allParams);
              auxiliary = currentSegment.auxiliary;
            } else {
              instruction = new ComponentInstruction(urlPath, [], this, positionalParams);
              auxiliary = [];
            }
            return new PathMatch(instruction, nextSegment, auxiliary);
          },
          generate: function(params) {
            var paramTokens = new TouchMap(params);
            var path = [];
            for (var i = 0; i < this._segments.length; i++) {
              var segment = this._segments[i];
              if (!(segment instanceof ContinuationSegment)) {
                path.push(segment.generate(paramTokens));
              }
            }
            var urlPath = path.join('/');
            var nonPositionalParams = paramTokens.getUnused();
            var urlParams = serializeParams(nonPositionalParams);
            return new ComponentInstruction(urlPath, urlParams, this, params);
          }
        }, {});
      }());
      $__export("PathRecognizer", PathRecognizer);
    }
  };
});

System.register("angular2/src/router/route_config_nomalizer", ["angular2/src/router/route_config_decorator", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_config_nomalizer";
  var AsyncRoute,
      AuxRoute,
      Route,
      Redirect,
      BaseException;
  function normalizeRouteConfig(config) {
    if (config instanceof Route || config instanceof Redirect || config instanceof AsyncRoute || config instanceof AuxRoute) {
      return config;
    }
    if ((!config.component) == (!config.redirectTo)) {
      throw new BaseException("Route config should contain exactly one \"component\", \"loader\", or \"redirectTo\" property.");
    }
    if (config.component) {
      if (typeof config.component == 'object') {
        var componentDefinitionObject = config.component;
        if (componentDefinitionObject.type == 'constructor') {
          return new Route({
            path: config.path,
            component: componentDefinitionObject.constructor,
            as: config.as
          });
        } else if (componentDefinitionObject.type == 'loader') {
          return new AsyncRoute({
            path: config.path,
            loader: componentDefinitionObject.loader,
            as: config.as
          });
        } else {
          throw new BaseException(("Invalid component type \"" + componentDefinitionObject.type + "\". Valid types are \"constructor\" and \"loader\"."));
        }
      }
      return new Route(config);
    }
    if (config.redirectTo) {
      return new Redirect({
        path: config.path,
        redirectTo: config.redirectTo
      });
    }
    return config;
  }
  $__export("normalizeRouteConfig", normalizeRouteConfig);
  return {
    setters: [function($__m) {
      AsyncRoute = $__m.AsyncRoute;
      AuxRoute = $__m.AuxRoute;
      Route = $__m.Route;
      Redirect = $__m.Redirect;
    }, function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/router/route_lifecycle_reflector", ["angular2/src/facade/lang", "angular2/src/router/lifecycle_annotations_impl", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_lifecycle_reflector";
  var Type,
      CanActivate,
      reflector;
  function hasLifecycleHook(e, type) {
    if (!(type instanceof Type))
      return false;
    return e.name in type.prototype;
  }
  function getCanActivateHook(type) {
    var annotations = reflector.annotations(type);
    for (var i = 0; i < annotations.length; i += 1) {
      var annotation = annotations[i];
      if (annotation instanceof CanActivate) {
        return annotation.fn;
      }
    }
    return null;
  }
  $__export("hasLifecycleHook", hasLifecycleHook);
  $__export("getCanActivateHook", getCanActivateHook);
  return {
    setters: [function($__m) {
      Type = $__m.Type;
    }, function($__m) {
      CanActivate = $__m.CanActivate;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/router/router_link", ["angular2/src/core/metadata", "angular2/src/router/router", "angular2/src/router/location", "angular2/src/router/instruction"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/router_link";
  var __decorate,
      __metadata,
      Directive,
      Router,
      Location,
      stringifyInstruction,
      RouterLink;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      Router = $__m.Router;
    }, function($__m) {
      Location = $__m.Location;
    }, function($__m) {
      stringifyInstruction = $__m.stringifyInstruction;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      RouterLink = (($traceurRuntime.createClass)(function(_router, _location) {
        this._router = _router;
        this._location = _location;
      }, {
        set routeParams(changes) {
          this._routeParams = changes;
          this._navigationInstruction = this._router.generate(this._routeParams);
          var navigationHref = '/' + stringifyInstruction(this._navigationInstruction);
          this.visibleHref = this._location.normalizeAbsolutely(navigationHref);
        },
        onClick: function() {
          this._router.navigateInstruction(this._navigationInstruction);
          return false;
        }
      }, {}));
      $__export("RouterLink", RouterLink);
      $__export("RouterLink", RouterLink = __decorate([Directive({
        selector: '[router-link]',
        properties: ['routeParams: routerLink'],
        host: {
          '(^click)': 'onClick()',
          '[attr.href]': 'visibleHref'
        }
      }), __metadata('design:paramtypes', [Router, Location])], RouterLink));
    }
  };
});

System.register("angular2/src/router/route_recognizer", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/router/path_recognizer", "angular2/src/router/route_config_impl", "angular2/src/router/async_route_handler", "angular2/src/router/sync_route_handler", "angular2/src/router/url_parser"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_recognizer";
  var isBlank,
      isPresent,
      BaseException,
      Map,
      PathRecognizer,
      Route,
      AsyncRoute,
      AuxRoute,
      Redirect,
      AsyncRouteHandler,
      SyncRouteHandler,
      Url,
      RouteRecognizer,
      Redirector;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      Map = $__m.Map;
    }, function($__m) {
      PathRecognizer = $__m.PathRecognizer;
    }, function($__m) {
      Route = $__m.Route;
      AsyncRoute = $__m.AsyncRoute;
      AuxRoute = $__m.AuxRoute;
      Redirect = $__m.Redirect;
    }, function($__m) {
      AsyncRouteHandler = $__m.AsyncRouteHandler;
    }, function($__m) {
      SyncRouteHandler = $__m.SyncRouteHandler;
    }, function($__m) {
      Url = $__m.Url;
    }],
    execute: function() {
      RouteRecognizer = (function() {
        function RouteRecognizer() {
          this.names = new Map();
          this.auxRoutes = new Map();
          this.matchers = [];
          this.redirects = [];
        }
        return ($traceurRuntime.createClass)(RouteRecognizer, {
          config: function(config) {
            var handler;
            if (config instanceof AuxRoute) {
              handler = new SyncRouteHandler(config.component, config.data);
              var path = config.path.startsWith('/') ? config.path.substring(1) : config.path;
              var recognizer = new PathRecognizer(config.path, handler);
              this.auxRoutes.set(path, recognizer);
              return recognizer.terminal;
            }
            if (config instanceof Redirect) {
              this.redirects.push(new Redirector(config.path, config.redirectTo));
              return true;
            }
            if (config instanceof Route) {
              handler = new SyncRouteHandler(config.component, config.data);
            } else if (config instanceof AsyncRoute) {
              handler = new AsyncRouteHandler(config.loader, config.data);
            }
            var recognizer = new PathRecognizer(config.path, handler);
            this.matchers.forEach((function(matcher) {
              if (recognizer.hash == matcher.hash) {
                throw new BaseException(("Configuration '" + config.path + "' conflicts with existing route '" + matcher.path + "'"));
              }
            }));
            this.matchers.push(recognizer);
            if (isPresent(config.as)) {
              this.names.set(config.as, recognizer);
            }
            return recognizer.terminal;
          },
          recognize: function(urlParse) {
            var solutions = [];
            urlParse = this._redirect(urlParse);
            this.matchers.forEach((function(pathRecognizer) {
              var pathMatch = pathRecognizer.recognize(urlParse);
              if (isPresent(pathMatch)) {
                solutions.push(pathMatch);
              }
            }));
            return solutions;
          },
          _redirect: function(urlParse) {
            for (var i = 0; i < this.redirects.length; i += 1) {
              var redirector = this.redirects[i];
              var redirectedUrl = redirector.redirect(urlParse);
              if (isPresent(redirectedUrl)) {
                return redirectedUrl;
              }
            }
            return urlParse;
          },
          recognizeAuxiliary: function(urlParse) {
            var pathRecognizer = this.auxRoutes.get(urlParse.path);
            if (isBlank(pathRecognizer)) {
              return null;
            }
            return pathRecognizer.recognize(urlParse);
          },
          hasRoute: function(name) {
            return this.names.has(name);
          },
          generate: function(name, params) {
            var pathRecognizer = this.names.get(name);
            if (isBlank(pathRecognizer)) {
              return null;
            }
            return pathRecognizer.generate(params);
          }
        }, {});
      }());
      $__export("RouteRecognizer", RouteRecognizer);
      Redirector = (function() {
        function Redirector(path, redirectTo) {
          this.segments = [];
          this.toSegments = [];
          if (path.startsWith('/')) {
            path = path.substring(1);
          }
          this.segments = path.split('/');
          if (redirectTo.startsWith('/')) {
            redirectTo = redirectTo.substring(1);
          }
          this.toSegments = redirectTo.split('/');
        }
        return ($traceurRuntime.createClass)(Redirector, {redirect: function(urlParse) {
            for (var i = 0; i < this.segments.length; i += 1) {
              if (isBlank(urlParse)) {
                return null;
              }
              var segment = this.segments[i];
              if (segment != urlParse.path) {
                return null;
              }
              urlParse = urlParse.child;
            }
            for (var i = this.toSegments.length - 1; i >= 0; i -= 1) {
              var segment$__1 = this.toSegments[i];
              urlParse = new Url(segment$__1, urlParse);
            }
            return urlParse;
          }}, {});
      }());
      $__export("Redirector", Redirector);
    }
  };
});

System.register("angular2/src/router/router", ["angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/router/instruction", "angular2/src/router/route_lifecycle_reflector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/router";
  var PromiseWrapper,
      EventEmitter,
      ObservableWrapper,
      Map,
      StringMapWrapper,
      MapWrapper,
      ListWrapper,
      isBlank,
      isString,
      StringWrapper,
      isPresent,
      BaseException,
      stringifyInstruction,
      getCanActivateHook,
      _resolveToTrue,
      _resolveToFalse,
      Router,
      RootRouter,
      ChildRouter,
      SLASH;
  function splitAndFlattenLinkParams(linkParams) {
    return ListWrapper.reduce(linkParams, (function(accumulation, item) {
      if (isString(item)) {
        return ListWrapper.concat(accumulation, StringWrapper.split(item, SLASH));
      }
      accumulation.push(item);
      return accumulation;
    }), []);
  }
  function canActivateOne(nextInstruction, prevInstruction) {
    var next = _resolveToTrue;
    if (isPresent(nextInstruction.child)) {
      next = canActivateOne(nextInstruction.child, isPresent(prevInstruction) ? prevInstruction.child : null);
    }
    return next.then((function(result) {
      if (result == false) {
        return false;
      }
      if (nextInstruction.component.reuse) {
        return true;
      }
      var hook = getCanActivateHook(nextInstruction.component.componentType);
      if (isPresent(hook)) {
        return hook(nextInstruction.component, isPresent(prevInstruction) ? prevInstruction.component : null);
      }
      return true;
    }));
  }
  return {
    setters: [function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isString = $__m.isString;
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      stringifyInstruction = $__m.stringifyInstruction;
    }, function($__m) {
      getCanActivateHook = $__m.getCanActivateHook;
    }],
    execute: function() {
      _resolveToTrue = PromiseWrapper.resolve(true);
      _resolveToFalse = PromiseWrapper.resolve(false);
      Router = (function() {
        function Router(registry, _pipeline, parent, hostComponent) {
          this.registry = registry;
          this._pipeline = _pipeline;
          this.parent = parent;
          this.hostComponent = hostComponent;
          this.navigating = false;
          this._currentInstruction = null;
          this._currentNavigation = _resolveToTrue;
          this._outlet = null;
          this._auxOutlets = new Map();
          this._subject = new EventEmitter();
        }
        return ($traceurRuntime.createClass)(Router, {
          childRouter: function(hostComponent) {
            return new ChildRouter(this, hostComponent);
          },
          registerOutlet: function(outlet) {
            if (isPresent(outlet.name)) {
              this._auxOutlets.set(outlet.name, outlet);
            } else {
              this._outlet = outlet;
            }
            if (isPresent(this._currentInstruction)) {
              return outlet.commit(this._currentInstruction);
            }
            return _resolveToTrue;
          },
          config: function(definitions) {
            var $__0 = this;
            definitions.forEach((function(routeDefinition) {
              $__0.registry.config($__0.hostComponent, routeDefinition);
            }));
            return this.renavigate();
          },
          navigate: function(url) {
            var _skipLocationChange = arguments[1] !== (void 0) ? arguments[1] : false;
            var $__0 = this;
            return this._currentNavigation = this._currentNavigation.then((function(_) {
              $__0.lastNavigationAttempt = url;
              $__0._startNavigating();
              return $__0._afterPromiseFinishNavigating($__0.recognize(url).then((function(instruction) {
                if (isBlank(instruction)) {
                  return false;
                }
                return $__0._navigate(instruction, _skipLocationChange);
              })));
            }));
          },
          navigateInstruction: function(instruction) {
            var _skipLocationChange = arguments[1] !== (void 0) ? arguments[1] : false;
            var $__0 = this;
            if (isBlank(instruction)) {
              return _resolveToFalse;
            }
            return this._currentNavigation = this._currentNavigation.then((function(_) {
              $__0._startNavigating();
              return $__0._afterPromiseFinishNavigating($__0._navigate(instruction, _skipLocationChange));
            }));
          },
          _navigate: function(instruction, _skipLocationChange) {
            var $__0 = this;
            return this._settleInstruction(instruction).then((function(_) {
              return $__0._reuse(instruction);
            })).then((function(_) {
              return $__0._canActivate(instruction);
            })).then((function(result) {
              if (!result) {
                return false;
              }
              return $__0._canDeactivate(instruction).then((function(result) {
                if (result) {
                  return $__0.commit(instruction, _skipLocationChange).then((function(_) {
                    $__0._emitNavigationFinish(stringifyInstruction(instruction));
                    return true;
                  }));
                }
              }));
            }));
          },
          _settleInstruction: function(instruction) {
            var $__0 = this;
            var unsettledInstructions = [];
            if (isBlank(instruction.component.componentType)) {
              unsettledInstructions.push(instruction.component.resolveComponentType());
            }
            if (isPresent(instruction.child)) {
              unsettledInstructions.push(this._settleInstruction(instruction.child));
            }
            StringMapWrapper.forEach(instruction.auxInstruction, (function(instruction, _) {
              unsettledInstructions.push($__0._settleInstruction(instruction));
            }));
            return PromiseWrapper.all(unsettledInstructions);
          },
          _emitNavigationFinish: function(url) {
            ObservableWrapper.callNext(this._subject, url);
          },
          _afterPromiseFinishNavigating: function(promise) {
            var $__0 = this;
            return PromiseWrapper.catchError(promise.then((function(_) {
              return $__0._finishNavigating();
            })), (function(err) {
              $__0._finishNavigating();
              throw err;
            }));
          },
          _reuse: function(instruction) {
            var $__0 = this;
            if (isBlank(this._outlet)) {
              return _resolveToFalse;
            }
            return this._outlet.canReuse(instruction).then((function(result) {
              if (isPresent($__0._outlet.childRouter) && isPresent(instruction.child)) {
                return $__0._outlet.childRouter._reuse(instruction.child);
              }
            }));
          },
          _canActivate: function(nextInstruction) {
            return canActivateOne(nextInstruction, this._currentInstruction);
          },
          _canDeactivate: function(instruction) {
            var $__0 = this;
            if (isBlank(this._outlet)) {
              return _resolveToTrue;
            }
            var next;
            if (isPresent(instruction) && instruction.component.reuse) {
              next = _resolveToTrue;
            } else {
              next = this._outlet.canDeactivate(instruction);
            }
            return next.then((function(result) {
              if (result == false) {
                return false;
              }
              if (isPresent($__0._outlet.childRouter)) {
                return $__0._outlet.childRouter._canDeactivate(isPresent(instruction) ? instruction.child : null);
              }
              return true;
            }));
          },
          commit: function(instruction) {
            var _skipLocationChange = arguments[1] !== (void 0) ? arguments[1] : false;
            this._currentInstruction = instruction;
            var next = _resolveToTrue;
            if (isPresent(this._outlet)) {
              next = this._outlet.commit(instruction);
            }
            var promises = [];
            MapWrapper.forEach(this._auxOutlets, (function(outlet, _) {
              promises.push(outlet.commit(instruction));
            }));
            return next.then((function(_) {
              return PromiseWrapper.all(promises);
            }));
          },
          _startNavigating: function() {
            this.navigating = true;
          },
          _finishNavigating: function() {
            this.navigating = false;
          },
          subscribe: function(onNext) {
            return ObservableWrapper.subscribe(this._subject, onNext);
          },
          deactivate: function(instruction) {
            if (isPresent(this._outlet)) {
              return this._outlet.deactivate(instruction);
            }
            return _resolveToTrue;
          },
          recognize: function(url) {
            return this.registry.recognize(url, this.hostComponent);
          },
          renavigate: function() {
            if (isBlank(this.lastNavigationAttempt)) {
              return this._currentNavigation;
            }
            return this.navigate(this.lastNavigationAttempt);
          },
          generate: function(linkParams) {
            var normalizedLinkParams = splitAndFlattenLinkParams(linkParams);
            var first = ListWrapper.first(normalizedLinkParams);
            var rest = ListWrapper.slice(normalizedLinkParams, 1);
            var router = this;
            if (first == '') {
              while (isPresent(router.parent)) {
                router = router.parent;
              }
            } else if (first == '..') {
              router = router.parent;
              while (ListWrapper.first(rest) == '..') {
                rest = ListWrapper.slice(rest, 1);
                router = router.parent;
                if (isBlank(router)) {
                  throw new BaseException(("Link \"" + ListWrapper.toJSON(linkParams) + "\" has too many \"../\" segments."));
                }
              }
            } else if (first != '.') {
              throw new BaseException(("Link \"" + ListWrapper.toJSON(linkParams) + "\" must start with \"/\", \"./\", or \"../\""));
            }
            if (rest[rest.length - 1] == '') {
              ListWrapper.removeLast(rest);
            }
            if (rest.length < 1) {
              var msg = ("Link \"" + ListWrapper.toJSON(linkParams) + "\" must include a route name.");
              throw new BaseException(msg);
            }
            var url = [];
            var parent = router.parent;
            while (isPresent(parent)) {
              url.unshift(parent._currentInstruction);
              parent = parent.parent;
            }
            var nextInstruction = this.registry.generate(rest, router.hostComponent);
            while (url.length > 0) {
              nextInstruction = url.pop().replaceChild(nextInstruction);
            }
            return nextInstruction;
          }
        }, {});
      }());
      $__export("Router", Router);
      RootRouter = (function($__super) {
        function RootRouter(registry, pipeline, location, hostComponent) {
          var $__0;
          $traceurRuntime.superConstructor(RootRouter).call(this, registry, pipeline, null, hostComponent);
          this._location = location;
          this._location.subscribe(($__0 = this, function(change) {
            return $__0.navigate(change['url'], isPresent(change['pop']));
          }));
          this.registry.configFromComponent(hostComponent);
          this.navigate(location.path());
        }
        return ($traceurRuntime.createClass)(RootRouter, {commit: function(instruction) {
            var _skipLocationChange = arguments[1] !== (void 0) ? arguments[1] : false;
            var $__0 = this;
            var emitUrl = stringifyInstruction(instruction);
            if (emitUrl.length > 0) {
              emitUrl = '/' + emitUrl;
            }
            var promise = $traceurRuntime.superGet(this, RootRouter.prototype, "commit").call(this, instruction);
            if (!_skipLocationChange) {
              promise = promise.then((function(_) {
                $__0._location.go(emitUrl);
              }));
            }
            return promise;
          }}, {}, $__super);
      }(Router));
      $__export("RootRouter", RootRouter);
      ChildRouter = (function($__super) {
        function ChildRouter(parent, hostComponent) {
          $traceurRuntime.superConstructor(ChildRouter).call(this, parent.registry, parent._pipeline, parent, hostComponent);
          this.parent = parent;
        }
        return ($traceurRuntime.createClass)(ChildRouter, {
          navigate: function(url) {
            var _skipLocationChange = arguments[1] !== (void 0) ? arguments[1] : false;
            return this.parent.navigate(url, _skipLocationChange);
          },
          navigateInstruction: function(instruction) {
            var _skipLocationChange = arguments[1] !== (void 0) ? arguments[1] : false;
            return this.parent.navigateInstruction(instruction, _skipLocationChange);
          }
        }, {}, $__super);
      }(Router));
      SLASH = new RegExp('/');
    }
  };
});

System.register("angular2/src/router/route_registry", ["angular2/src/router/route_recognizer", "angular2/src/router/instruction", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/router/route_config_impl", "angular2/src/reflection/reflection", "angular2/di", "angular2/src/router/route_config_nomalizer", "angular2/src/router/url_parser"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/route_registry";
  var __decorate,
      __metadata,
      RouteRecognizer,
      Instruction,
      PrimaryInstruction,
      ListWrapper,
      Map,
      PromiseWrapper,
      isPresent,
      isBlank,
      isType,
      isString,
      isStringMap,
      BaseException,
      getTypeNameForDebugging,
      RouteConfig,
      Route,
      AuxRoute,
      reflector,
      Injectable,
      normalizeRouteConfig,
      parser,
      pathSegmentsToUrl,
      _resolveToNull,
      RouteRegistry;
  function mostSpecific(instructions) {
    return ListWrapper.maximum(instructions, (function(instruction) {
      return instruction.component.specificity;
    }));
  }
  function assertTerminalComponent(component, path) {
    if (!isType(component)) {
      return ;
    }
    var annotations = reflector.annotations(component);
    if (isPresent(annotations)) {
      for (var i = 0; i < annotations.length; i++) {
        var annotation = annotations[i];
        if (annotation instanceof RouteConfig) {
          throw new BaseException(("Child routes are not allowed for \"" + path + "\". Use \"...\" on the parent's route path."));
        }
      }
    }
  }
  function assertComponentExists(component, path) {
    if (!isType(component)) {
      throw new BaseException(("Component for route \"" + path + "\" is not defined, or is not a class."));
    }
  }
  return {
    setters: [function($__m) {
      RouteRecognizer = $__m.RouteRecognizer;
    }, function($__m) {
      Instruction = $__m.Instruction;
      PrimaryInstruction = $__m.PrimaryInstruction;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      isType = $__m.isType;
      isString = $__m.isString;
      isStringMap = $__m.isStringMap;
      BaseException = $__m.BaseException;
      getTypeNameForDebugging = $__m.getTypeNameForDebugging;
    }, function($__m) {
      RouteConfig = $__m.RouteConfig;
      Route = $__m.Route;
      AuxRoute = $__m.AuxRoute;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      normalizeRouteConfig = $__m.normalizeRouteConfig;
    }, function($__m) {
      parser = $__m.parser;
      pathSegmentsToUrl = $__m.pathSegmentsToUrl;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      _resolveToNull = PromiseWrapper.resolve(null);
      RouteRegistry = (($traceurRuntime.createClass)(function() {
        this._rules = new Map();
      }, {
        config: function(parentComponent, config) {
          config = normalizeRouteConfig(config);
          if (config instanceof Route) {
            assertComponentExists(config.component, config.path);
          } else if (config instanceof AuxRoute) {
            assertComponentExists(config.component, config.path);
          }
          var recognizer = this._rules.get(parentComponent);
          if (isBlank(recognizer)) {
            recognizer = new RouteRecognizer();
            this._rules.set(parentComponent, recognizer);
          }
          var terminal = recognizer.config(config);
          if (config instanceof Route) {
            if (terminal) {
              assertTerminalComponent(config.component, config.path);
            } else {
              this.configFromComponent(config.component);
            }
          }
        },
        configFromComponent: function(component) {
          var $__0 = this;
          if (!isType(component)) {
            return ;
          }
          if (this._rules.has(component)) {
            return ;
          }
          var annotations = reflector.annotations(component);
          if (isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              if (annotation instanceof RouteConfig) {
                ListWrapper.forEach(annotation.configs, (function(config) {
                  return $__0.config(component, config);
                }));
              }
            }
          }
        },
        recognize: function(url, parentComponent) {
          var parsedUrl = parser.parse(url);
          return this._recognize(parsedUrl, parentComponent);
        },
        _recognize: function(parsedUrl, parentComponent) {
          var $__0 = this;
          return this._recognizePrimaryRoute(parsedUrl, parentComponent).then((function(instruction) {
            return $__0._completeAuxiliaryRouteMatches(instruction, parentComponent);
          }));
        },
        _recognizePrimaryRoute: function(parsedUrl, parentComponent) {
          var $__0 = this;
          var componentRecognizer = this._rules.get(parentComponent);
          if (isBlank(componentRecognizer)) {
            return PromiseWrapper.resolve(null);
          }
          var possibleMatches = componentRecognizer.recognize(parsedUrl);
          var matchPromises = ListWrapper.map(possibleMatches, (function(candidate) {
            return $__0._completePrimaryRouteMatch(candidate);
          }));
          return PromiseWrapper.all(matchPromises).then(mostSpecific);
        },
        _completePrimaryRouteMatch: function(partialMatch) {
          var $__0 = this;
          var instruction = partialMatch.instruction;
          return instruction.resolveComponentType().then((function(componentType) {
            $__0.configFromComponent(componentType);
            if (isBlank(partialMatch.remaining)) {
              if (instruction.terminal) {
                return new PrimaryInstruction(instruction, null, partialMatch.remainingAux);
              } else {
                return null;
              }
            }
            return $__0._recognizePrimaryRoute(partialMatch.remaining, componentType).then((function(childInstruction) {
              if (isBlank(childInstruction)) {
                return null;
              } else {
                return new PrimaryInstruction(instruction, childInstruction, partialMatch.remainingAux);
              }
            }));
          }));
        },
        _completeAuxiliaryRouteMatches: function(instruction, parentComponent) {
          var $__0 = this;
          if (isBlank(instruction)) {
            return _resolveToNull;
          }
          var componentRecognizer = this._rules.get(parentComponent);
          var auxInstructions = {};
          var promises = instruction.auxUrls.map((function(auxSegment) {
            var match = componentRecognizer.recognizeAuxiliary(auxSegment);
            if (isBlank(match)) {
              return _resolveToNull;
            }
            return $__0._completePrimaryRouteMatch(match).then((function(auxInstruction) {
              if (isPresent(auxInstruction)) {
                return $__0._completeAuxiliaryRouteMatches(auxInstruction, parentComponent).then((function(finishedAuxRoute) {
                  auxInstructions[auxSegment.path] = finishedAuxRoute;
                }));
              }
            }));
          }));
          return PromiseWrapper.all(promises).then((function(_) {
            if (isBlank(instruction.child)) {
              return new Instruction(instruction.component, null, auxInstructions);
            }
            return $__0._completeAuxiliaryRouteMatches(instruction.child, instruction.component.componentType).then((function(completeChild) {
              return new Instruction(instruction.component, completeChild, auxInstructions);
            }));
          }));
        },
        generate: function(linkParams, parentComponent) {
          var segments = [];
          var componentCursor = parentComponent;
          for (var i = 0; i < linkParams.length; i += 1) {
            var segment = linkParams[i];
            if (isBlank(componentCursor)) {
              throw new BaseException(("Could not find route named \"" + segment + "\"."));
            }
            if (!isString(segment)) {
              throw new BaseException(("Unexpected segment \"" + segment + "\" in link DSL. Expected a string."));
            } else if (segment == '' || segment == '.' || segment == '..') {
              throw new BaseException(("\"" + segment + "/\" is only allowed at the beginning of a link DSL."));
            }
            var params = null;
            if (i + 1 < linkParams.length) {
              var nextSegment = linkParams[i + 1];
              if (isStringMap(nextSegment)) {
                params = nextSegment;
                i += 1;
              }
            }
            var componentRecognizer = this._rules.get(componentCursor);
            if (isBlank(componentRecognizer)) {
              throw new BaseException(("Component \"" + getTypeNameForDebugging(componentCursor) + "\" has no route config."));
            }
            var response = componentRecognizer.generate(segment, params);
            if (isBlank(response)) {
              throw new BaseException(("Component \"" + getTypeNameForDebugging(componentCursor) + "\" has no route named \"" + segment + "\"."));
            }
            segments.push(response);
            componentCursor = response.componentType;
          }
          var instruction = this._generateRedirects(componentCursor);
          while (segments.length > 0) {
            instruction = new Instruction(segments.pop(), instruction, {});
          }
          return instruction;
        },
        _generateRedirects: function(componentCursor) {
          if (isBlank(componentCursor)) {
            return null;
          }
          var componentRecognizer = this._rules.get(componentCursor);
          if (isBlank(componentRecognizer)) {
            return null;
          }
          for (var i = 0; i < componentRecognizer.redirects.length; i += 1) {
            var redirect = componentRecognizer.redirects[i];
            if (redirect.segments.length == 1 && redirect.segments[0] == '') {
              var toSegments = pathSegmentsToUrl(redirect.toSegments);
              var matches = componentRecognizer.recognize(toSegments);
              var primaryInstruction = ListWrapper.maximum(matches, (function(match) {
                return match.instruction.specificity;
              }));
              if (isPresent(primaryInstruction)) {
                var child = this._generateRedirects(primaryInstruction.instruction.componentType);
                return new Instruction(primaryInstruction.instruction, child, {});
              }
              return null;
            }
          }
          return null;
        }
      }, {}));
      $__export("RouteRegistry", RouteRegistry);
      $__export("RouteRegistry", RouteRegistry = __decorate([Injectable(), __metadata('design:paramtypes', [])], RouteRegistry));
    }
  };
});

System.register("angular2/src/router/router_outlet", ["angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/metadata", "angular2/core", "angular2/di", "angular2/src/router/router", "angular2/src/router/instruction", "angular2/src/router/route_data", "angular2/src/router/lifecycle_annotations", "angular2/src/router/route_lifecycle_reflector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/router/router_outlet";
  var __decorate,
      __metadata,
      __param,
      PromiseWrapper,
      StringMapWrapper,
      isBlank,
      isPresent,
      Directive,
      Attribute,
      DynamicComponentLoader,
      ElementRef,
      Injector,
      bind,
      routerMod,
      RouteParams,
      ROUTE_DATA,
      hookMod,
      hasLifecycleHook,
      RouterOutlet;
  return {
    setters: [function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      Directive = $__m.Directive;
      Attribute = $__m.Attribute;
    }, function($__m) {
      DynamicComponentLoader = $__m.DynamicComponentLoader;
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Injector = $__m.Injector;
      bind = $__m.bind;
    }, function($__m) {
      routerMod = $__m;
    }, function($__m) {
      RouteParams = $__m.RouteParams;
    }, function($__m) {
      ROUTE_DATA = $__m.ROUTE_DATA;
    }, function($__m) {
      hookMod = $__m;
    }, function($__m) {
      hasLifecycleHook = $__m.hasLifecycleHook;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      RouterOutlet = (($traceurRuntime.createClass)(function(_elementRef, _loader, _parentRouter, nameAttr) {
        this._elementRef = _elementRef;
        this._loader = _loader;
        this._parentRouter = _parentRouter;
        this.childRouter = null;
        this.name = null;
        this._componentRef = null;
        this._currentInstruction = null;
        if (isPresent(nameAttr)) {
          this.name = nameAttr;
        }
        this._parentRouter.registerOutlet(this);
      }, {
        commit: function(instruction) {
          var $__0 = this;
          instruction = this._getInstruction(instruction);
          var componentInstruction = instruction.component;
          if (isBlank(componentInstruction)) {
            return PromiseWrapper.resolve(true);
          }
          var next;
          if (componentInstruction.reuse) {
            next = this._reuse(componentInstruction);
          } else {
            next = this.deactivate(instruction).then((function(_) {
              return $__0._activate(componentInstruction);
            }));
          }
          return next.then((function(_) {
            return $__0._commitChild(instruction);
          }));
        },
        _getInstruction: function(instruction) {
          if (isPresent(this.name)) {
            return instruction.auxInstruction[this.name];
          } else {
            return instruction;
          }
        },
        _commitChild: function(instruction) {
          if (isPresent(this.childRouter)) {
            return this.childRouter.commit(instruction.child);
          } else {
            return PromiseWrapper.resolve(true);
          }
        },
        _activate: function(instruction) {
          var $__0 = this;
          var previousInstruction = this._currentInstruction;
          this._currentInstruction = instruction;
          var componentType = instruction.componentType;
          this.childRouter = this._parentRouter.childRouter(componentType);
          var bindings = Injector.resolve([bind(ROUTE_DATA).toValue(instruction.routeData()), bind(RouteParams).toValue(new RouteParams(instruction.params)), bind(routerMod.Router).toValue(this.childRouter)]);
          return this._loader.loadNextToLocation(componentType, this._elementRef, bindings).then((function(componentRef) {
            $__0._componentRef = componentRef;
            if (hasLifecycleHook(hookMod.onActivate, componentType)) {
              return $__0._componentRef.instance.onActivate(instruction, previousInstruction);
            }
          }));
        },
        canDeactivate: function(nextInstruction) {
          if (isBlank(this._currentInstruction)) {
            return PromiseWrapper.resolve(true);
          }
          var outletInstruction = this._getInstruction(nextInstruction);
          if (hasLifecycleHook(hookMod.canDeactivate, this._currentInstruction.componentType)) {
            return PromiseWrapper.resolve(this._componentRef.instance.canDeactivate(isPresent(outletInstruction) ? outletInstruction.component : null, this._currentInstruction));
          }
          return PromiseWrapper.resolve(true);
        },
        canReuse: function(nextInstruction) {
          var result;
          var outletInstruction = this._getInstruction(nextInstruction);
          var componentInstruction = outletInstruction.component;
          if (isBlank(this._currentInstruction) || this._currentInstruction.componentType != componentInstruction.componentType) {
            result = false;
          } else if (hasLifecycleHook(hookMod.canReuse, this._currentInstruction.componentType)) {
            result = this._componentRef.instance.canReuse(componentInstruction, this._currentInstruction);
          } else {
            result = componentInstruction == this._currentInstruction || (isPresent(componentInstruction.params) && isPresent(this._currentInstruction.params) && StringMapWrapper.equals(componentInstruction.params, this._currentInstruction.params));
          }
          return PromiseWrapper.resolve(result).then((function(result) {
            componentInstruction.reuse = result;
            return result;
          }));
        },
        _reuse: function(instruction) {
          var previousInstruction = this._currentInstruction;
          this._currentInstruction = instruction;
          return PromiseWrapper.resolve(hasLifecycleHook(hookMod.onReuse, this._currentInstruction.componentType) ? this._componentRef.instance.onReuse(instruction, previousInstruction) : true);
        },
        deactivate: function(nextInstruction) {
          var $__0 = this;
          var outletInstruction = this._getInstruction(nextInstruction);
          var componentInstruction = isPresent(outletInstruction) ? outletInstruction.component : null;
          return (isPresent(this.childRouter) ? this.childRouter.deactivate(isPresent(outletInstruction) ? outletInstruction.child : null) : PromiseWrapper.resolve(true)).then((function(_) {
            if (isPresent($__0._componentRef) && isPresent($__0._currentInstruction) && hasLifecycleHook(hookMod.onDeactivate, $__0._currentInstruction.componentType)) {
              return $__0._componentRef.instance.onDeactivate(componentInstruction, $__0._currentInstruction);
            }
          })).then((function(_) {
            if (isPresent($__0._componentRef)) {
              $__0._componentRef.dispose();
              $__0._componentRef = null;
            }
          }));
        }
      }, {}));
      $__export("RouterOutlet", RouterOutlet);
      $__export("RouterOutlet", RouterOutlet = __decorate([Directive({selector: 'router-outlet'}), __param(3, Attribute('name')), __metadata('design:paramtypes', [ElementRef, DynamicComponentLoader, routerMod.Router, String])], RouterOutlet));
    }
  };
});

System.register("angular2/router", ["angular2/src/router/router", "angular2/src/router/router_outlet", "angular2/src/router/router_link", "angular2/src/router/instruction", "angular2/src/router/route_registry", "angular2/src/router/location_strategy", "angular2/src/router/hash_location_strategy", "angular2/src/router/path_location_strategy", "angular2/src/router/location", "angular2/src/router/pipeline", "angular2/src/router/route_config_decorator", "angular2/src/router/route_definition", "angular2/src/router/lifecycle_annotations", "angular2/src/router/url_parser", "angular2/angular2", "angular2/src/router/route_data", "angular2/src/core/application_tokens", "angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/router";
  var LocationStrategy,
      PathLocationStrategy,
      Router,
      RootRouter,
      RouterOutlet,
      RouterLink,
      RouteRegistry,
      Pipeline,
      Location,
      APP_COMPONENT,
      Binding,
      CONST_EXPR,
      ROUTER_DIRECTIVES,
      ROUTER_BINDINGS;
  function routerFactory(registry, pipeline, location, appRoot) {
    return new RootRouter(registry, pipeline, location, appRoot);
  }
  var $__exportNames = {
    ROUTER_DIRECTIVES: true,
    ROUTER_BINDINGS: true,
    undefined: true
  };
  var $__exportNames = {
    ROUTER_DIRECTIVES: true,
    ROUTER_BINDINGS: true,
    undefined: true
  };
  return {
    setters: [function($__m) {
      Router = $__m.Router;
      RootRouter = $__m.RootRouter;
      $__export("Router", $__m.Router);
      $__export("RootRouter", $__m.RootRouter);
    }, function($__m) {
      RouterOutlet = $__m.RouterOutlet;
      $__export("RouterOutlet", $__m.RouterOutlet);
    }, function($__m) {
      RouterLink = $__m.RouterLink;
      $__export("RouterLink", $__m.RouterLink);
    }, function($__m) {
      $__export("RouteParams", $__m.RouteParams);
      $__export("Instruction", $__m.Instruction);
      $__export("ComponentInstruction", $__m.ComponentInstruction);
    }, function($__m) {
      RouteRegistry = $__m.RouteRegistry;
      $__export("RouteRegistry", $__m.RouteRegistry);
    }, function($__m) {
      LocationStrategy = $__m.LocationStrategy;
      $__export("LocationStrategy", $__m.LocationStrategy);
    }, function($__m) {
      $__export("HashLocationStrategy", $__m.HashLocationStrategy);
    }, function($__m) {
      PathLocationStrategy = $__m.PathLocationStrategy;
      $__export("PathLocationStrategy", $__m.PathLocationStrategy);
    }, function($__m) {
      Location = $__m.Location;
      $__export("Location", $__m.Location);
      $__export("APP_BASE_HREF", $__m.APP_BASE_HREF);
    }, function($__m) {
      Pipeline = $__m.Pipeline;
      $__export("Pipeline", $__m.Pipeline);
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      $__export("CanActivate", $__m.CanActivate);
    }, function($__m) {
      $__export("Url", $__m.Url);
    }, function($__m) {
      $__export("OpaqueToken", $__m.OpaqueToken);
      $__export("Type", $__m.Type);
    }, function($__m) {
      $__export("ROUTE_DATA", $__m.ROUTE_DATA);
    }, function($__m) {
      APP_COMPONENT = $__m.APP_COMPONENT;
    }, function($__m) {
      Binding = $__m.Binding;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      ROUTER_DIRECTIVES = CONST_EXPR([RouterOutlet, RouterLink]);
      $__export("ROUTER_DIRECTIVES", ROUTER_DIRECTIVES);
      ROUTER_BINDINGS = CONST_EXPR([RouteRegistry, Pipeline, CONST_EXPR(new Binding(LocationStrategy, {toClass: PathLocationStrategy})), Location, CONST_EXPR(new Binding(Router, {
        toFactory: routerFactory,
        deps: CONST_EXPR([RouteRegistry, Pipeline, Location, APP_COMPONENT])
      }))]);
      $__export("ROUTER_BINDINGS", ROUTER_BINDINGS);
    }
  };
});

//# sourceMappingURL=router.dev.js.map
System.config({ "paths": { "ionic/*": "ionic/*", "rx": "rx" } });
System.register('ionic/components', ['ionic/components/app/app', 'ionic/components/app/id', 'ionic/components/action-menu/action-menu', 'ionic/components/aside/aside', 'ionic/components/aside/aside-toggle', 'ionic/components/button/button', 'ionic/components/card/card', 'ionic/components/checkbox/checkbox', 'ionic/components/content/content', 'ionic/components/icon/icon', 'ionic/components/item/item', 'ionic/components/item/item-group', 'ionic/components/form/input', 'ionic/components/text-input/text-input', 'ionic/components/text-input/label', 'ionic/components/list/list', 'ionic/components/show-hide-when/show-hide-when', 'ionic/components/material/button', 'ionic/components/material/ripple', 'ionic/components/modal/modal', 'ionic/components/nav/nav', 'ionic/components/nav/nav-controller', 'ionic/components/nav/nav-push', 'ionic/components/nav/nav-router', 'ionic/components/nav-bar/nav-bar', 'ionic/components/popup/popup', 'ionic/components/slides/slides', 'ionic/components/radio/radio', 'ionic/components/scroll/scroll', 'ionic/components/scroll/pull-to-refresh', 'ionic/components/search-bar/search-bar', 'ionic/components/segment/segment', 'ionic/components/switch/switch', 'ionic/components/tabs/tabs', 'ionic/components/tabs/tab', 'ionic/components/toolbar/toolbar', 'ionic/components/view/view-item'], function (_export) {
  'use strict';

  // Material components/effects
  return {
    setters: [function (_ionicComponentsAppApp) {
      for (var _key in _ionicComponentsAppApp) {
        if (_key !== 'default') _export(_key, _ionicComponentsAppApp[_key]);
      }
    }, function (_ionicComponentsAppId) {
      for (var _key2 in _ionicComponentsAppId) {
        if (_key2 !== 'default') _export(_key2, _ionicComponentsAppId[_key2]);
      }
    }, function (_ionicComponentsActionMenuActionMenu) {
      for (var _key3 in _ionicComponentsActionMenuActionMenu) {
        if (_key3 !== 'default') _export(_key3, _ionicComponentsActionMenuActionMenu[_key3]);
      }
    }, function (_ionicComponentsAsideAside) {
      for (var _key4 in _ionicComponentsAsideAside) {
        if (_key4 !== 'default') _export(_key4, _ionicComponentsAsideAside[_key4]);
      }
    }, function (_ionicComponentsAsideAsideToggle) {
      for (var _key5 in _ionicComponentsAsideAsideToggle) {
        if (_key5 !== 'default') _export(_key5, _ionicComponentsAsideAsideToggle[_key5]);
      }
    }, function (_ionicComponentsButtonButton) {
      for (var _key6 in _ionicComponentsButtonButton) {
        if (_key6 !== 'default') _export(_key6, _ionicComponentsButtonButton[_key6]);
      }
    }, function (_ionicComponentsCardCard) {
      for (var _key7 in _ionicComponentsCardCard) {
        if (_key7 !== 'default') _export(_key7, _ionicComponentsCardCard[_key7]);
      }
    }, function (_ionicComponentsCheckboxCheckbox) {
      for (var _key8 in _ionicComponentsCheckboxCheckbox) {
        if (_key8 !== 'default') _export(_key8, _ionicComponentsCheckboxCheckbox[_key8]);
      }
    }, function (_ionicComponentsContentContent) {
      for (var _key9 in _ionicComponentsContentContent) {
        if (_key9 !== 'default') _export(_key9, _ionicComponentsContentContent[_key9]);
      }
    }, function (_ionicComponentsIconIcon) {
      for (var _key10 in _ionicComponentsIconIcon) {
        if (_key10 !== 'default') _export(_key10, _ionicComponentsIconIcon[_key10]);
      }
    }, function (_ionicComponentsItemItem) {
      for (var _key11 in _ionicComponentsItemItem) {
        if (_key11 !== 'default') _export(_key11, _ionicComponentsItemItem[_key11]);
      }
    }, function (_ionicComponentsItemItemGroup) {
      for (var _key12 in _ionicComponentsItemItemGroup) {
        if (_key12 !== 'default') _export(_key12, _ionicComponentsItemItemGroup[_key12]);
      }
    }, function (_ionicComponentsFormInput) {
      for (var _key13 in _ionicComponentsFormInput) {
        if (_key13 !== 'default') _export(_key13, _ionicComponentsFormInput[_key13]);
      }
    }, function (_ionicComponentsTextInputTextInput) {
      for (var _key14 in _ionicComponentsTextInputTextInput) {
        if (_key14 !== 'default') _export(_key14, _ionicComponentsTextInputTextInput[_key14]);
      }
    }, function (_ionicComponentsTextInputLabel) {
      for (var _key15 in _ionicComponentsTextInputLabel) {
        if (_key15 !== 'default') _export(_key15, _ionicComponentsTextInputLabel[_key15]);
      }
    }, function (_ionicComponentsListList) {
      for (var _key16 in _ionicComponentsListList) {
        if (_key16 !== 'default') _export(_key16, _ionicComponentsListList[_key16]);
      }
    }, function (_ionicComponentsShowHideWhenShowHideWhen) {
      for (var _key17 in _ionicComponentsShowHideWhenShowHideWhen) {
        if (_key17 !== 'default') _export(_key17, _ionicComponentsShowHideWhenShowHideWhen[_key17]);
      }
    }, function (_ionicComponentsMaterialButton) {
      for (var _key18 in _ionicComponentsMaterialButton) {
        if (_key18 !== 'default') _export(_key18, _ionicComponentsMaterialButton[_key18]);
      }
    }, function (_ionicComponentsMaterialRipple) {
      for (var _key19 in _ionicComponentsMaterialRipple) {
        if (_key19 !== 'default') _export(_key19, _ionicComponentsMaterialRipple[_key19]);
      }
    }, function (_ionicComponentsModalModal) {
      for (var _key20 in _ionicComponentsModalModal) {
        if (_key20 !== 'default') _export(_key20, _ionicComponentsModalModal[_key20]);
      }
    }, function (_ionicComponentsNavNav) {
      for (var _key21 in _ionicComponentsNavNav) {
        if (_key21 !== 'default') _export(_key21, _ionicComponentsNavNav[_key21]);
      }
    }, function (_ionicComponentsNavNavController) {
      for (var _key22 in _ionicComponentsNavNavController) {
        if (_key22 !== 'default') _export(_key22, _ionicComponentsNavNavController[_key22]);
      }
    }, function (_ionicComponentsNavNavPush) {
      for (var _key23 in _ionicComponentsNavNavPush) {
        if (_key23 !== 'default') _export(_key23, _ionicComponentsNavNavPush[_key23]);
      }
    }, function (_ionicComponentsNavNavRouter) {
      for (var _key24 in _ionicComponentsNavNavRouter) {
        if (_key24 !== 'default') _export(_key24, _ionicComponentsNavNavRouter[_key24]);
      }
    }, function (_ionicComponentsNavBarNavBar) {
      for (var _key25 in _ionicComponentsNavBarNavBar) {
        if (_key25 !== 'default') _export(_key25, _ionicComponentsNavBarNavBar[_key25]);
      }
    }, function (_ionicComponentsPopupPopup) {
      for (var _key26 in _ionicComponentsPopupPopup) {
        if (_key26 !== 'default') _export(_key26, _ionicComponentsPopupPopup[_key26]);
      }
    }, function (_ionicComponentsSlidesSlides) {
      for (var _key27 in _ionicComponentsSlidesSlides) {
        if (_key27 !== 'default') _export(_key27, _ionicComponentsSlidesSlides[_key27]);
      }
    }, function (_ionicComponentsRadioRadio) {
      for (var _key28 in _ionicComponentsRadioRadio) {
        if (_key28 !== 'default') _export(_key28, _ionicComponentsRadioRadio[_key28]);
      }
    }, function (_ionicComponentsScrollScroll) {
      for (var _key29 in _ionicComponentsScrollScroll) {
        if (_key29 !== 'default') _export(_key29, _ionicComponentsScrollScroll[_key29]);
      }
    }, function (_ionicComponentsScrollPullToRefresh) {
      for (var _key30 in _ionicComponentsScrollPullToRefresh) {
        if (_key30 !== 'default') _export(_key30, _ionicComponentsScrollPullToRefresh[_key30]);
      }
    }, function (_ionicComponentsSearchBarSearchBar) {
      for (var _key31 in _ionicComponentsSearchBarSearchBar) {
        if (_key31 !== 'default') _export(_key31, _ionicComponentsSearchBarSearchBar[_key31]);
      }
    }, function (_ionicComponentsSegmentSegment) {
      for (var _key32 in _ionicComponentsSegmentSegment) {
        if (_key32 !== 'default') _export(_key32, _ionicComponentsSegmentSegment[_key32]);
      }
    }, function (_ionicComponentsSwitchSwitch) {
      for (var _key33 in _ionicComponentsSwitchSwitch) {
        if (_key33 !== 'default') _export(_key33, _ionicComponentsSwitchSwitch[_key33]);
      }
    }, function (_ionicComponentsTabsTabs) {
      for (var _key34 in _ionicComponentsTabsTabs) {
        if (_key34 !== 'default') _export(_key34, _ionicComponentsTabsTabs[_key34]);
      }
    }, function (_ionicComponentsTabsTab) {
      for (var _key35 in _ionicComponentsTabsTab) {
        if (_key35 !== 'default') _export(_key35, _ionicComponentsTabsTab[_key35]);
      }
    }, function (_ionicComponentsToolbarToolbar) {
      for (var _key36 in _ionicComponentsToolbarToolbar) {
        if (_key36 !== 'default') _export(_key36, _ionicComponentsToolbarToolbar[_key36]);
      }
    }, function (_ionicComponentsViewViewItem) {
      for (var _key37 in _ionicComponentsViewViewItem) {
        if (_key37 !== 'default') _export(_key37, _ionicComponentsViewViewItem[_key37]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/index", [], function (_export) {
  "use strict";

  return {
    setters: [],
    execute: function () {}
  };
});
/*
 * export everything here
 */
System.register('ionic/ionic', ['./config/config', './config/modes', './config/annotations', './net/http', './components', './platform/platform', './platform/registry', './storage/storage', './storage/local-storage', './storage/sql', './util/click-block', './util/focus', './animations/animation', './animations/builtins', './transitions/transition', './transitions/ios-transition', './transitions/md-transition', './native/plugins'], function (_export) {
  'use strict';

  return {
    setters: [function (_configConfig) {
      for (var _key in _configConfig) {
        if (_key !== 'default') _export(_key, _configConfig[_key]);
      }
    }, function (_configModes) {
      for (var _key2 in _configModes) {
        if (_key2 !== 'default') _export(_key2, _configModes[_key2]);
      }
    }, function (_configAnnotations) {
      for (var _key3 in _configAnnotations) {
        if (_key3 !== 'default') _export(_key3, _configAnnotations[_key3]);
      }
    }, function (_netHttp) {
      for (var _key4 in _netHttp) {
        if (_key4 !== 'default') _export(_key4, _netHttp[_key4]);
      }
    }, function (_components) {
      for (var _key5 in _components) {
        if (_key5 !== 'default') _export(_key5, _components[_key5]);
      }
    }, function (_platformPlatform) {
      for (var _key6 in _platformPlatform) {
        if (_key6 !== 'default') _export(_key6, _platformPlatform[_key6]);
      }
    }, function (_platformRegistry) {
      for (var _key7 in _platformRegistry) {
        if (_key7 !== 'default') _export(_key7, _platformRegistry[_key7]);
      }
    }, function (_storageStorage) {
      for (var _key8 in _storageStorage) {
        if (_key8 !== 'default') _export(_key8, _storageStorage[_key8]);
      }
    }, function (_storageLocalStorage) {
      for (var _key9 in _storageLocalStorage) {
        if (_key9 !== 'default') _export(_key9, _storageLocalStorage[_key9]);
      }
    }, function (_storageSql) {
      for (var _key10 in _storageSql) {
        if (_key10 !== 'default') _export(_key10, _storageSql[_key10]);
      }
    }, function (_utilClickBlock) {
      for (var _key11 in _utilClickBlock) {
        if (_key11 !== 'default') _export(_key11, _utilClickBlock[_key11]);
      }
    }, function (_utilFocus) {
      for (var _key12 in _utilFocus) {
        if (_key12 !== 'default') _export(_key12, _utilFocus[_key12]);
      }
    }, function (_animationsAnimation) {
      for (var _key13 in _animationsAnimation) {
        if (_key13 !== 'default') _export(_key13, _animationsAnimation[_key13]);
      }
    }, function (_animationsBuiltins) {
      for (var _key14 in _animationsBuiltins) {
        if (_key14 !== 'default') _export(_key14, _animationsBuiltins[_key14]);
      }
    }, function (_transitionsTransition) {
      for (var _key15 in _transitionsTransition) {
        if (_key15 !== 'default') _export(_key15, _transitionsTransition[_key15]);
      }
    }, function (_transitionsIosTransition) {
      for (var _key16 in _transitionsIosTransition) {
        if (_key16 !== 'default') _export(_key16, _transitionsIosTransition[_key16]);
      }
    }, function (_transitionsMdTransition) {
      for (var _key17 in _transitionsMdTransition) {
        if (_key17 !== 'default') _export(_key17, _transitionsMdTransition[_key17]);
      }
    }, function (_nativePlugins) {
      for (var _key18 in _nativePlugins) {
        if (_key18 !== 'default') _export(_key18, _nativePlugins[_key18]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/util', ['ionic/util/dom', 'ionic/util/util'], function (_export) {
  'use strict';

  var domUtil, dom;
  return {
    setters: [function (_ionicUtilDom) {
      domUtil = _ionicUtilDom;
    }, function (_ionicUtilUtil) {
      for (var _key in _ionicUtilUtil) {
        if (_key !== 'default') _export(_key, _ionicUtilUtil[_key]);
      }
    }],
    execute: function () {
      dom = domUtil;

      _export('dom', dom);
    }
  };
});
System.register('ionic/animations/animation', ['../util/dom'], function (_export) {
    'use strict';

    var CSS, RENDER_DELAY, AnimationRegistry, Animation, Animate, TRANSFORMS, ANIMATE_PROPERTIES, CUBIC_BEZIERS, EASING_FN;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertEffects(effects, fromEffect, toEffect, easingConfig) {
        easingConfig.opts = easingConfig.opts || {};
        var increment = easingConfig.opts.increment || 0.04;
        var easingFn = EASING_FN[easingConfig.name];
        var pos = undefined,
            tweenEffect = undefined,
            addEffect = undefined,
            property = undefined,
            toProperty = undefined,
            fromValue = undefined,
            diffValue = undefined;
        for (pos = increment; pos <= 1 - increment; pos += increment) {
            tweenEffect = {};
            addEffect = false;
            for (property in toEffect) {
                toProperty = toEffect[property];
                if (toProperty.tween) {
                    fromValue = fromEffect[property].num;
                    diffValue = toProperty.num - fromValue;
                    tweenEffect[property] = {
                        value: roundValue(easingFn(pos, easingConfig.opts) * diffValue + fromValue) + toProperty.unit
                    };
                    addEffect = true;
                }
            }
            if (addEffect) {
                effects.push(convertProperties(tweenEffect));
            }
        }
    }
    function parseEffect(inputEffect) {
        var val = undefined,
            r = undefined,
            num = undefined,
            property = undefined;
        var outputEffect = {};
        for (property in inputEffect) {
            val = inputEffect[property];
            r = val.toString().match(/(\d*\.?\d*)(.*)/);
            num = parseFloat(r[1]);
            outputEffect[property] = {
                value: val,
                num: num,
                unit: r[0] != r[2] ? r[2] : '',
                tween: !isNaN(num) && ANIMATE_PROPERTIES.indexOf(property) > -1
            };
        }
        return outputEffect;
    }
    function convertProperties(inputEffect) {
        var outputEffect = {};
        var transforms = [];
        var value = undefined,
            property = undefined;
        for (property in inputEffect) {
            value = inputEffect[property].value;
            if (TRANSFORMS.indexOf(property) > -1) {
                transforms.push(property + '(' + value + ')');
            } else {
                outputEffect[property] = value;
            }
        }
        if (transforms.length) {
            transforms.push('translateZ(0px)');
            outputEffect.transform = transforms.join(' ');
        }
        return outputEffect;
    }
    function inlineStyle(ele, effect) {
        if (ele && effect) {
            var transforms = [];
            var value = undefined,
                property = undefined;
            for (property in effect) {
                value = effect[property].value;
                if (TRANSFORMS.indexOf(property) > -1) {
                    transforms.push(property + '(' + value + ')');
                } else {
                    ele.style[property] = value;
                }
            }
            if (transforms.length) {
                transforms.push('translateZ(0px)');
                ele.style[CSS.transform] = transforms.join(' ');
            }
        }
    }
    function roundValue(val) {
        return Math.round(val * 10000) / 10000;
    }
    return {
        setters: [function (_utilDom) {
            CSS = _utilDom.CSS;
        }],
        execute: function () {
            RENDER_DELAY = 36;
            AnimationRegistry = {};

            /**
              Animation Steps/Process
              -----------------------
              1) Construct animation (doesn't start)
              2) Client play()'s animation, returns promise
              3) Add before classes to elements
              4) Remove before classes from elements
              5) Elements staged in "from" effect w/ inline styles
              6) Call onReady()
              7) Wait for RENDER_DELAY milliseconds (give browser time to render)
              8) Call onPlay()
              8) Run from/to animation on elements
              9) Animations finish async
             10) Set inline styles w/ the "to" effects on elements
             11) Add after classes to elements
             12) Remove after classes from elements
             13) Call onFinish()
             14) Resolve play()'s promise
            **/

            Animation = (function () {
                function Animation(ele) {
                    _classCallCheck(this, Animation);

                    this._el = [];
                    this._chld = [];
                    this._ani = [];
                    this._bfAdd = [];
                    this._bfSty = {};
                    this._bfRmv = [];
                    this._afAdd = [];
                    this._afRmv = [];
                    this._readys = [];
                    this._plays = [];
                    this._finishes = [];
                    this.elements(ele);
                }

                _createClass(Animation, [{
                    key: 'elements',
                    value: function elements(ele) {
                        if (ele) {
                            if (typeof ele === 'string') {
                                // string query selector
                                ele = document.querySelectorAll(ele);
                            }
                            if (ele.length) {
                                // array of elements
                                for (var i = 0; i < ele.length; i++) {
                                    this.addElement(ele[i]);
                                }
                            } else {
                                // single element
                                this.addElement(ele);
                            }
                        }
                        return this;
                    }
                }, {
                    key: 'addElement',
                    value: function addElement(ele) {
                        // ensure only HTML Element nodes
                        if (ele) {
                            if (ele.nativeElement) {
                                // angular ElementRef
                                ele = ele.nativeElement;
                            }
                            if (ele.nodeType === 1) {
                                this._el.push(ele);
                            }
                        }
                    }
                }, {
                    key: 'parent',
                    value: function parent(parentAnimation) {
                        this._parent = parentAnimation;
                        return this;
                    }
                }, {
                    key: 'add',
                    value: function add(childAnimations) {
                        childAnimations = Array.isArray(childAnimations) ? childAnimations : arguments;
                        for (var i = 0; i < childAnimations.length; i++) {
                            childAnimations[i].parent(this);
                            this._chld.push(childAnimations[i]);
                        }
                        return this;
                    }
                }, {
                    key: 'duration',
                    value: function duration(value) {
                        if (arguments.length) {
                            this._duration = value;
                            return this;
                        }
                        return this._duration || this._parent && this._parent.duration();
                    }
                }, {
                    key: 'easing',
                    value: function easing(name, opts) {
                        if (arguments.length) {
                            this._easing = {
                                name: name,
                                opts: opts
                            };
                            return this;
                        }
                        return this._easing || this._parent && this._parent.easing();
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        if (arguments.length) {
                            this._rate = value;
                            var i = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i].playbackRate(value);
                            }
                            for (i = 0; i < this._ani.length; i++) {
                                this._ani[i].playbackRate(value);
                            }
                            return this;
                        }
                        return this._rate || this._parent && this._parent.playbackRate();
                    }
                }, {
                    key: 'fill',
                    value: function fill(value) {
                        if (arguments.length) {
                            this._fill = value;
                            return this;
                        }
                        return this._fill || this._parent && this._parent.fill();
                    }
                }, {
                    key: 'from',
                    value: function from(property, value) {
                        if (!this._from) {
                            this._from = {};
                        }
                        this._from[property] = value;
                        return this;
                    }
                }, {
                    key: 'to',
                    value: function to(property, value) {
                        if (!this._to) {
                            this._to = {};
                        }
                        this._to[property] = value;
                        return this;
                    }
                }, {
                    key: 'fromTo',
                    value: function fromTo(property, from, to) {
                        return this.from(property, from).to(property, to);
                    }
                }, {
                    key: 'fadeIn',
                    value: function fadeIn() {
                        return this.fromTo('opacity', 0.01, 1);
                    }
                }, {
                    key: 'fadeOut',
                    value: function fadeOut() {
                        return this.fromTo('opacity', 1, 0);
                    }
                }, {
                    key: 'play',
                    value: function play() {
                        var _this = this;

                        var self = this;
                        var animations = self._ani;
                        var children = self._chld;
                        var promises = [];
                        var i = undefined,
                            l = undefined;
                        // the actual play() method which may or may not start async
                        function beginPlay() {
                            var i = undefined,
                                l = undefined;
                            var promises = [];
                            for (i = 0, l = children.length; i < l; i++) {
                                promises.push(children[i].play());
                            }
                            for (i = 0, l = animations.length; i < l; i++) {
                                promises.push(animations[i].play());
                            }
                            return Promise.all(promises);
                        }
                        if (!self._parent) {
                            var _ret = (function () {
                                var kickoff = function kickoff() {
                                    // synchronously call all onPlay()'s before play()
                                    self._onPlay();
                                    beginPlay().then(function () {
                                        self._onFinish();
                                        resolve();
                                    });
                                };

                                // this is the top level animation and is in full control
                                // of when the async play() should actually kick off
                                // stage all animations and child animations at their starting point
                                self.stage();
                                var resolve = undefined;
                                var promise = new Promise(function (res) {
                                    resolve = res;
                                });

                                if (_this._duration > RENDER_DELAY) {
                                    // begin each animation when everything is rendered in their starting point
                                    // give the browser some time to render everything in place before starting
                                    setTimeout(kickoff, RENDER_DELAY);
                                } else {
                                    // no need to render everything in there place before animating in
                                    // just kick it off immediately to render them in their "to" locations
                                    kickoff();
                                }
                                return {
                                    v: promise
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        }
                        // this is a child animation, it is told exactly when to
                        // start by the top level animation
                        return beginPlay();
                    }
                }, {
                    key: 'stage',
                    value: function stage() {
                        // before the RENDER_DELAY
                        // before the animations have started
                        if (!this._isStaged) {
                            this._isStaged = true;
                            var i = undefined,
                                p = undefined,
                                l = undefined,
                                j = undefined,
                                ele = undefined,
                                animation = undefined;
                            for (i = 0, l = this._chld.length; i < l; i++) {
                                this._chld[i].stage();
                            }
                            for (i = 0; i < this._el.length; i++) {
                                ele = this._el[i];
                                for (j = 0; j < this._bfAdd.length; j++) {
                                    ele.classList.add(this._bfAdd[j]);
                                }
                                for (p in this._bfSty) {
                                    ele.style[p] = this._bfSty[p];
                                }
                                for (j = 0; j < this._bfRmv.length; j++) {
                                    ele.classList.remove(this._bfRmv[j]);
                                }
                            }
                            if (this._to) {
                                // only animate the elements if there are defined "to" effects
                                for (i = 0; i < this._el.length; i++) {
                                    animation = new Animate(this._el[i], this._from, this._to, this.duration(), this.easing(), this.playbackRate(), this.fill());
                                    if (animation.shouldAnimate) {
                                        this._ani.push(animation);
                                    }
                                }
                            }
                            for (i = 0; i < this._readys.length; i++) {
                                this._readys[i](this);
                            }
                        }
                    }
                }, {
                    key: '_onPlay',
                    value: function _onPlay() {
                        // after the RENDER_DELAY
                        // before the animations have started
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i]._onPlay();
                        }
                        for (i = 0; i < this._plays.length; i++) {
                            this._plays[i](this);
                        }
                    }
                }, {
                    key: '_onFinish',
                    value: function _onFinish() {
                        // after the animations have finished
                        if (!this._isFinished) {
                            this._isFinished = true;
                            var i = undefined,
                                j = undefined,
                                ele = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i]._onFinish();
                            }
                            if (this.playbackRate() < 0) {
                                // reverse direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._bfAdd.length; j++) {
                                        ele.classList.remove(this._bfAdd[j]);
                                    }
                                    for (j = 0; j < this._bfRmv.length; j++) {
                                        ele.classList.add(this._bfRmv[j]);
                                    }
                                }
                            } else {
                                // normal direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._afAdd.length; j++) {
                                        ele.classList.add(this._afAdd[j]);
                                    }
                                    for (j = 0; j < this._afRmv.length; j++) {
                                        ele.classList.remove(this._afRmv[j]);
                                    }
                                }
                            }
                            for (i = 0; i < this._finishes.length; i++) {
                                this._finishes[i](this);
                            }
                        }
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this._hasFinished = false;
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].pause();
                        }
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].progress(value);
                        }
                        if (!this._initProgress) {
                            this._initProgress = true;
                            this.play();
                            this.pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].progress(value);
                        }
                    }
                }, {
                    key: 'onReady',
                    value: function onReady(fn) {
                        this._readys.push(fn);
                    }
                }, {
                    key: 'onPlay',
                    value: function onPlay(fn) {
                        this._plays.push(fn);
                    }
                }, {
                    key: 'onFinish',
                    value: function onFinish(fn) {
                        this._finishes.push(fn);
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].dispose();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].dispose();
                        }
                        this._el = this._parent = this._chld = this._ani = this._readys = this._plays = this._finishes = null;
                    }

                    /*
                     STATIC CLASSES
                     */
                }, {
                    key: 'before',
                    get: function get() {
                        var _this2 = this;

                        return {
                            addClass: function addClass(className) {
                                _this2._bfAdd.push(className);
                                return _this2;
                            },
                            removeClass: function removeClass(className) {
                                _this2._bfRmv.push(className);
                                return _this2;
                            },
                            setStyles: function setStyles(styles) {
                                _this2._bfSty = styles;
                            }
                        };
                    }
                }, {
                    key: 'after',
                    get: function get() {
                        var _this3 = this;

                        return {
                            addClass: function addClass(className) {
                                _this3._afAdd.push(className);
                                return _this3;
                            },
                            removeClass: function removeClass(className) {
                                _this3._afRmv.push(className);
                                return _this3;
                            }
                        };
                    }
                }], [{
                    key: 'create',
                    value: function create(element, name) {
                        var AnimationClass = AnimationRegistry[name];
                        if (!AnimationClass) {
                            // couldn't find an animation by the given name
                            // fallback to just the base Animation class
                            AnimationClass = Animation;
                        }
                        return new AnimationClass(element);
                    }
                }, {
                    key: 'register',
                    value: function register(name, AnimationClass) {
                        AnimationRegistry[name] = AnimationClass;
                    }
                }]);

                return Animation;
            })();

            _export('Animation', Animation);

            Animate = (function () {
                function Animate(ele, fromEffect, toEffect, duration, easingConfig, playbackRate, fill) {
                    var _this4 = this;

                    _classCallCheck(this, Animate);

                    // https://w3c.github.io/web-animations/
                    // not using the direct API methods because they're still in flux
                    // however, element.animate() seems locked in and uses the latest
                    // and correct API methods under the hood, so really doesn't matter
                    if (!fromEffect) {
                        return console.error(ele.tagName, 'animation fromEffect required, toEffect:', toEffect);
                    }
                    this.toEffect = parseEffect(toEffect);
                    this.shouldAnimate = duration > RENDER_DELAY;
                    if (!this.shouldAnimate) {
                        return inlineStyle(ele, this.toEffect);
                    }
                    this.fill = fill;
                    this.ele = ele;
                    this.promise = new Promise(function (res) {
                        _this4.resolve = res;
                    });
                    // stage where the element will start from
                    fromEffect = parseEffect(fromEffect);
                    inlineStyle(ele, fromEffect);
                    this.duration = duration;
                    this.rate = playbackRate;
                    this.easing = easingConfig && easingConfig.name || 'linear';
                    this.effects = [convertProperties(fromEffect)];
                    if (this.easing in EASING_FN) {
                        insertEffects(this.effects, fromEffect, this.toEffect, easingConfig);
                    } else if (this.easing in CUBIC_BEZIERS) {
                        this.easing = 'cubic-bezier(' + CUBIC_BEZIERS[this.easing] + ')';
                    }
                    this.effects.push(convertProperties(this.toEffect));
                }

                _createClass(Animate, [{
                    key: 'play',
                    value: function play() {
                        var self = this;
                        if (self.player) {
                            self.player.play();
                        } else {
                            self.player = self.ele.animate(self.effects, {
                                duration: self.duration || 0,
                                easing: self.easing,
                                playbackRate: self.rate || 1,
                                fill: self.fill
                            });
                            self.player.onfinish = function () {
                                // lock in where the element will stop at
                                // if the playbackRate is negative then it needs to return
                                // to its "from" effects
                                inlineStyle(self.ele, self.rate < 0 ? self.fromEffect : self.toEffect);
                                self.player = null;
                                self.resolve();
                            };
                        }
                        return self.promise;
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this.player && this.player.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        var player = this.player;
                        if (player) {
                            // passed a number between 0 and 1
                            value = Math.max(0, Math.min(1, value));
                            if (value >= 1) {
                                player.currentTime = this.duration * 0.999;
                                return player.play();
                            }
                            if (player.playState !== 'paused') {
                                player.pause();
                            }
                            player.currentTime = this.duration * value;
                        }
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        this.rate = value;
                        if (this.player) {
                            this.player.playbackRate = value;
                        }
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.ele = this.player = this.effects = this.toEffect = null;
                    }
                }]);

                return Animate;
            })();

            TRANSFORMS = ['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'perspective'];
            ANIMATE_PROPERTIES = TRANSFORMS.concat('opacity');

            // Robert Penner's Easing Functions
            // http://robertpenner.com/easing/
            CUBIC_BEZIERS = {
                // default browser suppored easing
                // ease
                // ease-in
                // ease-out
                // ease-in-out
                // Cubic
                'ease-in-cubic': '0.55,0.055,0.675,0.19',
                'ease-out-cubic': '0.215,0.61,0.355,1',
                'ease-in-Out-cubic': '0.645,0.045,0.355,1',
                // Circ
                'ease-in-circ': '0.6,0.04,0.98,0.335',
                'ease-out-circ': '0.075,0.82,0.165,1',
                'ease-in-out-circ': '0.785,0.135,0.15,0.86',
                // Expo
                'ease-in-expo': '0.95,0.05,0.795,0.035',
                'ease-out-expo': '0.19,1,0.22,1',
                'ease-in-out-expo': '1,0,0,1',
                // Quad
                'ease-in-quad': '0.55,0.085,0.68,0.53',
                'ease-out-quad': '0.25,0.46,0.45,0.94',
                'ease-in-out-quad': '0.455,0.03,0.515,0.955',
                // Quart
                'ease-in-quart': '0.895,0.03,0.685,0.22',
                'ease-out-quart': '0.165,0.84,0.44,1',
                'ease-in-out-quart': '0.77,0,0.175,1',
                // Quint
                'ease-in-quint': '0.755,0.05,0.855,0.06',
                'ease-out-quint': '0.23,1,0.32,1',
                'ease-in-out-quint': '0.86,0,0.07,1',
                // Sine
                'ease-in-sine': '0.47,0,0.745,0.715',
                'ease-out-sine': '0.39,0.575,0.565,1',
                'ease-in-out-sine': '0.445,0.05,0.55,0.95',
                // Back
                'ease-in-back': '0.6,-0.28,0.735,0.045',
                'ease-out-back': '0.175,0.885,0.32,1.275',
                'ease-in-out-back': '0.68,-0.55,0.265,1.55'
            };
            EASING_FN = {
                'elastic': function elastic(pos) {
                    return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                },
                'swing-from-to': function swingFromTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                'swing-from': function swingFrom(pos, opts) {
                    var s = opts.s || 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                'swing-to': function swingTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                },
                'bounce': function bounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'bounce-past': function bouncePast(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
                    } else if (pos < 2.5 / 2.75) {
                        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
                    }
                    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
                },
                'ease-out-bounce': function easeOutBounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'ease-from-to': function easeFromTo(pos) {
                    if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
                    return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                'ease-from': function easeFrom(pos, opts) {
                    return Math.pow(pos, opts.s || 4);
                },
                'ease-to': function easeTo(pos, opts) {
                    return Math.pow(pos, opts.s || 0.25);
                },
                /*
                 * scripty2, Thomas Fuchs (MIT Licence)
                 * https://raw.github.com/madrobby/scripty2/master/src/effects/transitions/transitions.js
                 */
                'spring': function spring(pos, opts) {
                    var damping = opts.damping || 4.5;
                    var elasticity = opts.elasticity || 6;
                    return 1 - Math.cos(pos * damping * Math.PI) * Math.exp(-pos * elasticity);
                },
                'sinusoidal': function sinusoidal(pos) {
                    return -Math.cos(pos * Math.PI) / 2 + 0.5;
                }
            };
        }
    };
});
System.register('ionic/animations/builtins', ['./animation'], function (_export) {
    'use strict';

    var Animation, SlideIn, SlideOut, FadeIn, FadeOut;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            SlideIn = (function (_Animation) {
                _inherits(SlideIn, _Animation);

                function SlideIn(element) {
                    _classCallCheck(this, SlideIn);

                    _get(Object.getPrototypeOf(SlideIn.prototype), 'constructor', this).call(this, element);
                    this.easing('cubic-bezier(0.1,0.7,0.1,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                return SlideIn;
            })(Animation);

            Animation.register('slide-in', SlideIn);

            SlideOut = (function (_Animation2) {
                _inherits(SlideOut, _Animation2);

                function SlideOut(element) {
                    _classCallCheck(this, SlideOut);

                    _get(Object.getPrototypeOf(SlideOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                return SlideOut;
            })(Animation);

            Animation.register('slide-out', SlideOut);

            FadeIn = (function (_Animation3) {
                _inherits(FadeIn, _Animation3);

                function FadeIn(element) {
                    _classCallCheck(this, FadeIn);

                    _get(Object.getPrototypeOf(FadeIn.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-in').duration(400).fadeIn();
                }

                return FadeIn;
            })(Animation);

            Animation.register('fade-in', FadeIn);

            FadeOut = (function (_Animation4) {
                _inherits(FadeOut, _Animation4);

                function FadeOut(element) {
                    _classCallCheck(this, FadeOut);

                    _get(Object.getPrototypeOf(FadeOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fadeOut();
                }

                return FadeOut;
            })(Animation);

            Animation.register('fade-out', FadeOut);
        }
    };
});
System.register('ionic/animations/scroll-to', ['../util/dom'], function (_export) {
    'use strict';

    var raf, ScrollTo;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
        }],
        execute: function () {
            ScrollTo = (function () {
                function ScrollTo(ele, x, y, duration) {
                    _classCallCheck(this, ScrollTo);

                    if (typeof ele === 'string') {
                        // string query selector
                        ele = document.querySelector(ele);
                    }
                    if (ele) {
                        if (ele.nativeElement) {
                            // angular ElementRef
                            ele = ele.nativeElement;
                        }
                        if (ele.nodeType === 1) {
                            this._el = ele;
                        }
                    }
                }

                _createClass(ScrollTo, [{
                    key: 'start',
                    value: function start(x, y, duration, tolerance) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var self = this;
                        if (!self._el) {
                            // invalid element
                            return Promise.resolve();
                        }
                        x = x || 0;
                        y = y || 0;
                        tolerance = tolerance || 0;
                        var ele = self._el;
                        var fromY = ele.scrollTop;
                        var fromX = ele.scrollLeft;
                        var xDistance = Math.abs(x - fromX);
                        var yDistance = Math.abs(y - fromY);
                        if (yDistance <= tolerance && xDistance <= tolerance) {
                            // prevent scrolling if already close to there
                            this._el = ele = null;
                            return Promise.resolve();
                        }
                        return new Promise(function (resolve, reject) {
                            var start = Date.now();
                            // start scroll loop
                            self.isPlaying = true;
                            raf(step);
                            // decelerating to zero velocity
                            function easeOutCubic(t) {
                                return --t * t * t + 1;
                            }
                            // scroll loop
                            function step() {
                                var time = Math.min(1, (Date.now() - start) / duration);
                                // where .5 would be 50% of time on a linear scale easedT gives a
                                // fraction based on the easing method
                                var easedT = easeOutCubic(time);
                                if (fromY != y) {
                                    ele.scrollTop = parseInt(easedT * (y - fromY) + fromY, 10);
                                }
                                if (fromX != x) {
                                    ele.scrollLeft = parseInt(easedT * (x - fromX) + fromX, 10);
                                }
                                if (time < 1 && self.isPlaying) {
                                    raf(step);
                                } else if (!self.isPlaying) {
                                    // stopped
                                    this._el = ele = null;
                                    reject();
                                } else {
                                    // done
                                    this._el = ele = null;
                                    resolve();
                                }
                            }
                        });
                    }
                }, {
                    key: 'stop',
                    value: function stop() {
                        this.isPlaying = false;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.stop();
                        this._el = null;
                    }
                }]);

                return ScrollTo;
            })();

            _export('ScrollTo', ScrollTo);
        }
    };
});
System.register('ionic/config/annotations', ['angular2/angular2', 'ionic/util', '../components/app/app', '../ionic'], function (_export) {
    /**
     * The core Ionic directives.  Automatically available in every IonicView
     * template.
     */
    'use strict';

    var CORE_DIRECTIVES, FORM_DIRECTIVES, NgStyle, Component, Directive, View, forwardRef, util, ionicBootstrap, Aside, AsideToggle, Button, Content, Scroll, Refresher, Slides, Slide, SlideLazy, Tabs, Tab, Card, List, ListHeader, Item, ItemGroup, ItemGroupTitle, Toolbar, Icon, Checkbox, Switch, TextInput, TextInputElement, Label, Segment, SegmentButton, SegmentControlValueAccessor, RadioGroup, RadioButton, Nav, NavbarTemplate, Navbar, NavPush, NavPop, NavRouter, IdRef, ShowWhen, HideWhen, MaterialButton, IonicDirectives, IonicViewImpl;

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    /**
     * TODO
     */

    _export('IonicView', IonicView);

    /**
     * TODO
     */

    _export('IonicDirective', IonicDirective);

    _export('IonicComponent', IonicComponent);

    _export('App', App);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    /**
     * TODO
     */

    function IonicView(args) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new IonicViewImpl(args));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicDirective(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Directive(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicComponent(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function appendConfig(cls, config) {
        config.host = config.host || {};
        cls.defaultProperties = config.defaultProperties || {};
        config.properties = config.properties || [];
        for (var prop in cls.defaultProperties) {
            // add the property to the component "properties"
            config.properties.push(prop);
            // set the component "hostProperties", so the instance's
            // property value will be used to set the element's attribute
            config.host['[attr.' + util.pascalCaseToDashCase(prop) + ']'] = prop;
        }
        cls.delegates = config.delegates;
        var componentId = config.classId || config.selector && config.selector.replace('ion-', '');
        config.host['class'] = ((config.host['class'] || '') + ' ' + componentId).trim();
        return config;
    }
    /**
     * TODO
     */

    function App() {
        var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            // get current annotations
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            // create @Component
            args.selector = args.selector || 'ion-app';
            annotations.push(new Component(args));
            // create @View
            // if no template was provided, default so it has a root ion-nav
            if (!args.templateUrl && !args.template) {
                args.template = '<ion-nav></ion-nav>';
            }
            annotations.push(new IonicViewImpl(args));
            // redefine with added annotations
            Reflect.defineMetadata('annotations', annotations, cls);
            ionicBootstrap(cls, args.config);
            return cls;
        };
    }

    return {
        setters: [function (_angular2Angular2) {
            CORE_DIRECTIVES = _angular2Angular2.CORE_DIRECTIVES;
            FORM_DIRECTIVES = _angular2Angular2.FORM_DIRECTIVES;
            NgStyle = _angular2Angular2.NgStyle;
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_componentsAppApp) {
            ionicBootstrap = _componentsAppApp.ionicBootstrap;
        }, function (_ionic) {
            Aside = _ionic.Aside;
            AsideToggle = _ionic.AsideToggle;
            Button = _ionic.Button;
            Content = _ionic.Content;
            Scroll = _ionic.Scroll;
            Refresher = _ionic.Refresher;
            Slides = _ionic.Slides;
            Slide = _ionic.Slide;
            SlideLazy = _ionic.SlideLazy;
            Tabs = _ionic.Tabs;
            Tab = _ionic.Tab;
            Card = _ionic.Card;
            List = _ionic.List;
            ListHeader = _ionic.ListHeader;
            Item = _ionic.Item;
            ItemGroup = _ionic.ItemGroup;
            ItemGroupTitle = _ionic.ItemGroupTitle;
            Toolbar = _ionic.Toolbar;
            Icon = _ionic.Icon;
            Checkbox = _ionic.Checkbox;
            Switch = _ionic.Switch;
            TextInput = _ionic.TextInput;
            TextInputElement = _ionic.TextInputElement;
            Label = _ionic.Label;
            Segment = _ionic.Segment;
            SegmentButton = _ionic.SegmentButton;
            SegmentControlValueAccessor = _ionic.SegmentControlValueAccessor;
            RadioGroup = _ionic.RadioGroup;
            RadioButton = _ionic.RadioButton;
            Nav = _ionic.Nav;
            NavbarTemplate = _ionic.NavbarTemplate;
            Navbar = _ionic.Navbar;
            NavPush = _ionic.NavPush;
            NavPop = _ionic.NavPop;
            NavRouter = _ionic.NavRouter;
            IdRef = _ionic.IdRef;
            ShowWhen = _ionic.ShowWhen;
            HideWhen = _ionic.HideWhen;
            MaterialButton = _ionic.MaterialButton;
        }],
        execute: function () {
            IonicDirectives = [
            // TODO: Why is forwardRef() required when they're already imported above????
            // Angular
            CORE_DIRECTIVES, FORM_DIRECTIVES, NgStyle,
            // Content
            forwardRef(function () {
                return Aside;
            }), forwardRef(function () {
                return AsideToggle;
            }), forwardRef(function () {
                return Button;
            }), forwardRef(function () {
                return Content;
            }), forwardRef(function () {
                return Scroll;
            }), forwardRef(function () {
                return Refresher;
            }),
            // Lists
            forwardRef(function () {
                return Card;
            }), forwardRef(function () {
                return List;
            }), forwardRef(function () {
                return ListHeader;
            }), forwardRef(function () {
                return Item;
            }), forwardRef(function () {
                return ItemGroup;
            }), forwardRef(function () {
                return ItemGroupTitle;
            }),
            // Slides
            forwardRef(function () {
                return Slides;
            }), forwardRef(function () {
                return Slide;
            }), forwardRef(function () {
                return SlideLazy;
            }),
            // Tabs
            forwardRef(function () {
                return Tabs;
            }), forwardRef(function () {
                return Tab;
            }), forwardRef(function () {
                return Toolbar;
            }),
            // Media
            forwardRef(function () {
                return Icon;
            }),
            // Forms
            forwardRef(function () {
                return Segment;
            }), forwardRef(function () {
                return SegmentButton;
            }), forwardRef(function () {
                return SegmentControlValueAccessor;
            }), forwardRef(function () {
                return Checkbox;
            }), forwardRef(function () {
                return RadioGroup;
            }), forwardRef(function () {
                return RadioButton;
            }), forwardRef(function () {
                return Switch;
            }), forwardRef(function () {
                return TextInput;
            }), forwardRef(function () {
                return TextInputElement;
            }), forwardRef(function () {
                return Label;
            }),
            // Nav
            forwardRef(function () {
                return Nav;
            }), forwardRef(function () {
                return NavbarTemplate;
            }), forwardRef(function () {
                return Navbar;
            }), forwardRef(function () {
                return NavPush;
            }), forwardRef(function () {
                return NavPop;
            }), forwardRef(function () {
                return NavRouter;
            }), forwardRef(function () {
                return IdRef;
            }),
            //forwardRef(() => Ref),
            forwardRef(function () {
                return ShowWhen;
            }), forwardRef(function () {
                return HideWhen;
            }),
            // Material
            forwardRef(function () {
                return MaterialButton;
            })];

            _export('IonicDirectives', IonicDirectives);

            IonicViewImpl = (function (_View) {
                _inherits(IonicViewImpl, _View);

                function IonicViewImpl() {
                    var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, IonicViewImpl);

                    args.directives = (args.directives || []).concat(IonicDirectives);
                    _get(Object.getPrototypeOf(IonicViewImpl.prototype), 'constructor', this).call(this, args);
                }

                return IonicViewImpl;
            })(View);
        }
    };
});
System.register('ionic/config/config', ['../util/util'], function (_export) {
    /**
    * TODO
    */
    'use strict';

    var isObject, isDefined, isFunction, extend, IonicConfig, modeConfigs;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilUtil) {
            isObject = _utilUtil.isObject;
            isDefined = _utilUtil.isDefined;
            isFunction = _utilUtil.isFunction;
            extend = _utilUtil.extend;
        }],
        execute: function () {
            IonicConfig = (function () {
                /**
                 * TODO
                 * @param  {Object} settings   The settings for your app
                 */

                function IonicConfig(settings) {
                    _classCallCheck(this, IonicConfig);

                    // defaults
                    this._settings = {};
                    // override defaults w/ user config
                    if (settings) {
                        extend(this._settings, settings);
                    }
                }

                /**
                * TODO
                */

                _createClass(IonicConfig, [{
                    key: 'setting',
                    value: function setting() {
                        var args = arguments;
                        var arg0 = args[0];
                        var arg1 = args[1];
                        var settings = this._settings;
                        switch (args.length) {
                            case 0:
                                // setting() = get settings object
                                return settings;
                            case 1:
                                // setting({...}) = set settings object
                                // setting('key') = get value
                                if (isObject(arg0)) {
                                    // setting({...}) = set settings object
                                    // arg0 = setting object
                                    this._settings = arg0;
                                    return this;
                                }
                                // time for the big show, get the value
                                // setting('key') = get value
                                // arg0 = key
                                if (!isDefined(settings[arg0])) {
                                    // if the value was already set this will all be skipped
                                    // if there was no user config then it'll check each of
                                    // the user config's platforms, which already contains
                                    // settings from default platform configs
                                    settings[arg0] = null;
                                    // check the platform settings object for this value
                                    // loop though each of the active platforms
                                    var activePlatformKeys = this._platforms;
                                    var platformSettings = settings.platforms;
                                    var platformObj = null;
                                    if (platformSettings) {
                                        var platformValue = undefined;
                                        for (var i = 0; i < activePlatformKeys.length; i++) {
                                            platformObj = platformSettings[activePlatformKeys[i]];
                                            if (platformObj) {
                                                if (isDefined(platformObj[arg0])) {
                                                    // check assigned platform settings
                                                    platformValue = platformObj[arg0];
                                                } else if (platformObj.mode) {
                                                    // check the platform default mode settings
                                                    platformObj = IonicConfig.modeConfig(platformObj.mode);
                                                    if (platformObj) {
                                                        platformValue = platformObj[arg0];
                                                    }
                                                }
                                            }
                                        }
                                        if (isDefined(platformValue)) {
                                            settings[arg0] = platformValue;
                                        }
                                    }
                                }
                                // return key's value
                                // either it came directly from the user config
                                // or it was from the users platform configs
                                // or it was from the default platform configs
                                // in that order
                                if (isFunction(settings[arg0])) {
                                    settings[arg0] = settings[arg0]();
                                }
                                return settings[arg0];
                            case 2:
                                // setting('ios', {...}) = set platform config object
                                // setting('key', 'value') = set key/value pair
                                if (isObject(arg1)) {
                                    // setting('ios', {...}) = set platform config object
                                    // arg0 = platform
                                    // arg1 = platform config object
                                    settings.platforms = settings.platforms || {};
                                    settings.platforms[arg0] = arg1;
                                } else {
                                    // setting('key', 'value') = set key/value pair
                                    // arg0 = key
                                    // arg1 = value
                                    settings[arg0] = arg1;
                                }
                                return this;
                            case 3:
                                // setting('ios', 'key', 'value') = set key/value pair for platform
                                // arg0 = platform
                                // arg1 = key
                                // arg2 = value
                                settings.platforms = settings.platforms || {};
                                settings.platforms[arg0] = settings.platforms[arg0] || {};
                                settings.platforms[arg0][arg1] = args[2];
                                return this;
                        }
                    }

                    /**
                     * TODO
                     * @param  {Object} platform   The platform
                     */
                }, {
                    key: 'setPlatform',
                    value: function setPlatform(platform) {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        this._platforms = platform.platforms();
                        // copy default platform settings into the user config platform settings
                        // user config platform settings should override default platform settings
                        this._settings.platforms = extend(platform.settings(), this._settings.platforms || {});
                    }
                }], [{
                    key: 'modeConfig',
                    value: function modeConfig(mode, config) {
                        var args = arguments;
                        if (args.length === 2) {
                            // modeConfig('ios', {...})
                            modeConfigs[mode] = extend(modeConfigs[mode] || {}, config);
                        } else {
                            // modeConfig('ios')
                            return modeConfigs[mode];
                        }
                    }
                }]);

                return IonicConfig;
            })();

            _export('IonicConfig', IonicConfig);

            modeConfigs = {};
        }
    };
});
System.register('ionic/config/modes', ['./config'], function (_export) {
    // iOS Mode Settings
    'use strict';

    var IonicConfig;
    return {
        setters: [function (_config) {
            IonicConfig = _config.IonicConfig;
        }],
        execute: function () {
            IonicConfig.modeConfig('ios', {
                actionMenuEnter: 'action-menu-slide-in',
                actionMenuLeave: 'action-menu-slide-out',
                actionMenuCancelIcon: '',
                actionMenuDestructiveIcon: '',
                backButtonText: 'Back',
                backButtonIcon: 'ion-ios-arrow-back',
                forwardIcon: 'ion-ios-arrow-forward',
                iconMode: 'ios',
                navTitleAlign: 'center',
                tabBarPlacement: 'bottom',
                viewTransition: 'ios'
            });
            // Material Design Mode Settings
            IonicConfig.modeConfig('md', {
                actionMenuEnter: 'action-menu-md-slide-in',
                actionMenuLeave: 'action-menu-md-slide-out',
                actionMenuCancelIcon: 'ion-md-close',
                actionMenuDestructiveIcon: 'ion-md-trash',
                backButtonText: '',
                backButtonIcon: 'ion-md-arrow-back',
                forwardIcon: '',
                iconMode: 'md',
                navTitleAlign: 'left',
                tabBarPlacement: 'top',
                viewTransition: 'md',
                type: 'overlay',
                mdRipple: true
            });
        }
    };
});
System.register('ionic/components/ion', ['ionic/util'], function (_export) {
    /**
     * Base class for all Ionic components. Exposes some common functionality
     * that all Ionic components need, such as accessing underlying native elements and
     * sending/receiving app-level events.
     */
    'use strict';

    var util, Ion;

    var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            Ion = (function () {
                function Ion(elementRef, config) {
                    _classCallCheck(this, Ion);

                    this.elementRef = elementRef;
                    this.config = config;
                }

                _createClass(Ion, [{
                    key: 'onInit',
                    value: function onInit() {
                        var cls = this.constructor;
                        if (cls.defaultProperties && this.config) {
                            for (var prop in cls.defaultProperties) {
                                // Priority:
                                // ---------
                                // 1) Value set from within constructor
                                // 2) Value set from the host element's attribute
                                // 3) Value set by the users global config
                                // 4) Value set by the default mode/platform config
                                // 5) Value set from the component's default
                                if (this[prop]) {
                                    // this property has already been set on the instance
                                    // could be from the user setting the element's attribute
                                    // or from the user setting it within the constructor
                                    continue;
                                }
                                // get the property values from a global user/platform config
                                var configVal = this.config.setting(prop);
                                if (configVal) {
                                    this[prop] = configVal;
                                    continue;
                                }
                                // wasn't set yet, so go with property's default value
                                this[prop] = cls.defaultProperties[prop];
                            }
                        }
                    }
                }, {
                    key: 'getDelegate',
                    value: function getDelegate(delegateName) {
                        var cls = this.constructor;
                        if (cls.delegates) {
                            var cases = cls.delegates[delegateName] || [];
                            for (var i = 0; i < cases.length; i++) {
                                var delegateCase = cases[i];
                                if (util.isArray(delegateCase)) {
                                    var _delegateCase = _slicedToArray(delegateCase, 2);

                                    var check = _delegateCase[0];
                                    var DelegateConstructor = _delegateCase[1];

                                    if (check(this)) {
                                        return new DelegateConstructor(this);
                                    }
                                } else {
                                    return new delegateCase(this);
                                }
                            }
                        }
                    }
                }, {
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this.elementRef;
                    }
                }, {
                    key: 'getNativeElement',
                    value: function getNativeElement() {
                        return this.elementRef.nativeElement;
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        return this.getNativeElement().offsetWidth;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        return this.getNativeElement().offsetHeight;
                    }
                }]);

                return Ion;
            })();

            _export('Ion', Ion);
        }
    };
});
System.register('ionic/gestures/drag-gesture', ['ionic/gestures/gesture', 'ionic/util'], function (_export) {
    //import Hammer from 'hammer';
    /*
     * BUG(ajoslin): HammerJS 2.x does not have an alternative to HammerJS 1.x's
     * dragLockToAxis, so a vertical and horizontal gesture can happen at the same time.
     */
    'use strict';

    var Gesture, util, DragGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            DragGesture = (function (_Gesture) {
                _inherits(DragGesture, _Gesture);

                function DragGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, DragGesture);

                    util.defaults(opts, {});
                    _get(Object.getPrototypeOf(DragGesture.prototype), 'constructor', this).call(this, element, opts);
                }

                _createClass(DragGesture, [{
                    key: 'listen',
                    value: function listen() {
                        var _this = this;

                        _get(Object.getPrototypeOf(DragGesture.prototype), 'listen', this).call(this);
                        this.on('panstart', function (ev) {
                            if (_this.onDragStart(ev) !== false) {
                                _this.dragging = true;
                            }
                            // ev.stopPropagation();
                        });
                        this.on('panmove', function (ev) {
                            if (!_this.dragging) return;
                            if (_this.onDrag(ev) === false) {
                                _this.dragging = false;
                            }
                            // ev.stopPropagation()
                        });
                        this.on('panend', function (ev) {
                            if (!_this.dragging) return;
                            _this.onDragEnd(ev);
                            _this.dragging = false;
                            // ev.stopPropagation()
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag() {}
                }, {
                    key: 'onDragStart',
                    value: function onDragStart() {}
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd() {}
                }]);

                return DragGesture;
            })(Gesture);

            _export('DragGesture', DragGesture);
        }
    };
});
System.register('ionic/gestures/gesture', ['ionic/util', 'ionic/gestures/hammer'], function (_export) {
    /**
     * A gesture recognizer class.
     *
     * TODO(mlynch): Re-enable the DOM event simulation that was causing issues (or verify hammer does this already, it might);
     */
    'use strict';

    var util, Hammer, Gesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicGesturesHammer) {
            Hammer = _ionicGesturesHammer.Hammer;
        }],
        execute: function () {
            Gesture = (function () {
                function Gesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Gesture);

                    util.defaults(opts, {
                        domEvents: true
                    });
                    this.element = element;
                    // Map 'x' or 'y' string to hammerjs opts
                    this.direction = opts.direction || 'x';
                    opts.direction = this.direction === 'x' ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL;
                    this._options = opts;
                    this._callbacks = {};
                }

                _createClass(Gesture, [{
                    key: 'options',
                    value: function options() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        util.extend(this._options, opts);
                    }
                }, {
                    key: 'on',
                    value: function on(type, cb) {
                        if (type == 'pinch' || type == 'rotate') {
                            this.hammertime.get('pinch').set({ enable: true });
                        }
                        this.hammertime.on(type, cb);
                        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
                        //this.element.addEventListener(type, cb);
                    }
                }, {
                    key: 'listen',
                    value: function listen() {
                        this.hammertime = Hammer(this.element, this._options);
                    }
                }, {
                    key: 'unlisten',
                    value: function unlisten() {
                        if (this.hammertime) {
                            for (var type in this._callbacks) {
                                for (var i = 0; i < this._callbacks[type].length; i++) {
                                    //this.element.removeEventListener(type, this._callbacks[type][i]);
                                    this.hammertime.off(type, this._callbacks[type]);
                                }
                            }
                            this.hammertime.destroy();
                            this.hammertime = null;
                            this._callbacks = {};
                        }
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.unlisten();
                    }
                }]);

                return Gesture;
            })();

            _export('Gesture', Gesture);
        }
    };
});
System.register('ionic/gestures/hammer', [], function (_export) {
    /*! Hammer.JS - v2.0.4 - 2014-09-28
     * http://hammerjs.github.io/
     *
     * Copyright (c) 2014 Jorik Tangelder;
     * Licensed under the MIT license */
    //(function(window, document, exportName, undefined) {
    //'use strict';
    'use strict';

    var VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now, _uniqueId, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, MOUSE_INPUT_MAP, MOUSE_ELEMENT_EVENTS, MOUSE_WINDOW_EVENTS, POINTER_INPUT_MAP, IE10_POINTER_TYPE_ENUM, POINTER_ELEMENT_EVENTS, POINTER_WINDOW_EVENTS, SINGLE_TOUCH_INPUT_MAP, SINGLE_TOUCH_TARGET_EVENTS, SINGLE_TOUCH_WINDOW_EVENTS, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, STOP, FORCED_STOP;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge]
     * @returns {Object} dest
     */
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    /**
     * get a unique id
     * @returns {number} uniqueId
     */

    function uniqueId() {
        return _uniqueId++;
    }
    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
    }

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }
        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    /**
     * Recognizer flow explained; *
     * All recognizers have the initial state of POSSIBLE when a input session starts.
     * The definition of a input session is from the first input until the last input, with all it's movement in it. *
     * Example session for mouse-input: mousedown -> mousemove -> mouseup
     *
     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
     * which determines with state it should be.
     *
     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
     * POSSIBLE to give it another change on the next cycle.
     *
     *               Possible
     *                  |
     *            +-----+---------------+
     *            |                     |
     *      +-----+-----+               |
     *      |           |               |
     *   Failed      Cancelled          |
     *                          +-------+------+
     *                          |              |
     *                      Recognized       Began
     *                                         |
     *                                      Changed
     *                                         |
     *                                  Ended/Recognized
     */

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
     * @const {string}
     */

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function (value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }
    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    return {
        setters: [],
        execute: function () {
            VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            TEST_ELEMENT = document.createElement('div');
            TYPE_FUNCTION = 'function';
            round = Math.round;
            abs = Math.abs;
            now = Date.now;
            _uniqueId = 1;
            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            SUPPORT_TOUCH = 'ontouchstart' in window;
            SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            INPUT_TYPE_TOUCH = 'touch';
            INPUT_TYPE_PEN = 'pen';
            INPUT_TYPE_MOUSE = 'mouse';
            INPUT_TYPE_KINECT = 'kinect';
            COMPUTE_INTERVAL = 25;
            INPUT_START = 1;
            INPUT_MOVE = 2;
            INPUT_END = 4;
            INPUT_CANCEL = 8;
            DIRECTION_NONE = 1;
            DIRECTION_LEFT = 2;
            DIRECTION_RIGHT = 4;
            DIRECTION_UP = 8;
            DIRECTION_DOWN = 16;
            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
            PROPS_XY = ['x', 'y'];
            PROPS_CLIENT_XY = ['clientX', 'clientY'];
            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function handler() {},
                /**
                 * bind the events
                 */
                init: function init() {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
                 * unbind the events
                 */
                destroy: function destroy() {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };
            MOUSE_ELEMENT_EVENTS = 'mousedown';
            MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];
                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }
                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }
                    // mouse must be down, and mouse events are allowed (see the TouchMouse input)
                    if (!this.pressed || !this.allow) {
                        return;
                    }
                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }
                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });
            POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

            // in IE10 the pointer types is defined as an enum
            IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };
            POINTER_ELEMENT_EVENTS = 'pointerdown';
            POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

            // IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;
                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                    var isTouch = pointerType == INPUT_TYPE_TOUCH;
                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');
                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }
                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }
                    // update the event in the store
                    store[storeIndex] = ev;
                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });
                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });
            SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }
                    if (!this.started) {
                        return;
                    }
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                    // when we're in a touch event, so  block all upcoming mouse events
                    // most mobile browser also emit mouseevents, right after touchstart
                    if (isTouch) {
                        this.mouse.allow = false;
                    } else if (isMouse && !this.mouse.allow) {
                        return;
                    }
                    // reset the allowMouse when we're done
                    if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                        this.mouse.allow = true;
                    }
                    this.callback(manager, inputEvent, inputData);
                },
                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            // magical touchAction value
            TOUCH_ACTION_COMPUTE = 'compute';
            TOUCH_ACTION_AUTO = 'auto';
            TOUCH_ACTION_MANIPULATION = 'manipulation';
            // not implemented
            TOUCH_ACTION_NONE = 'none';
            TOUCH_ACTION_PAN_X = 'pan-x';
            TOUCH_ACTION_PAN_Y = 'pan-y';
            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function set(value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }
                    if (NATIVE_TOUCH_ACTION) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },
                /**
                 * just re-set the touchAction value
                 */
                update: function update() {
                    this.set(this.manager.options.touchAction);
                },
                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function compute() {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },
                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function preventDefaults(input) {
                    // not needed with native support for the touchAction property
                    if (NATIVE_TOUCH_ACTION) {
                        return;
                    }
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;
                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }
                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE);
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                        return this.preventSrc(srcEvent);
                    }
                },
                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function preventSrc(srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            };STATE_POSSIBLE = 1;
            STATE_BEGAN = 2;
            STATE_CHANGED = 4;
            STATE_ENDED = 8;
            STATE_RECOGNIZED = STATE_ENDED;
            STATE_CANCELLED = 16;
            STATE_FAILED = 32;
            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},
                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function recognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }
                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },
                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },
                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function requireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }
                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },
                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function dropRequireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },
                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function hasRequireFailures() {
                    return this.requireFail.length > 0;
                },
                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function canRecognizeWith(otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },
                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function emit(input) {
                    var self = this;
                    var state = this.state;
                    function emit(withState) {
                        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
                    }
                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(true);
                    }
                    emit(); // simple 'eventName' events
                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(true);
                    }
                },
                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function tryEmit(input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },
                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function canEmit() {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },
                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = extend({}, inputData);
                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }
                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }
                    this.state = this.process(inputDataClone);
                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },
                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function process(inputData) {},
                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function getTouchAction() {},
                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function reset() {}
            };inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },
                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function attrTest(input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function process(input) {
                    var state = this.state;
                    var eventType = input.eventType;
                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);
                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },
                getTouchAction: function getTouchAction() {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },
                directionTest: function directionTest(input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;
                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function attrTest(input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function emit(input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this._super.emit.call(this, input);
                }
            });inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function emit(input) {
                    this._super.emit.call(this, input);
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        this.manager.emit(this.options.event + inOut, input);
                    }
                }
            });inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 500,
                    threshold: 5 // a minimal movement is ok, but keep it low
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_AUTO];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;
                    this._input = input;
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit(input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }
                    if (input && input.eventType & INPUT_END) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.65,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },
                getTouchAction: function getTouchAction() {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function attrTest(input) {
                    var direction = this.options.direction;
                    var velocity;
                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.velocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.velocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.velocityY;
                    }
                    return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function emit(input) {
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this.manager.emit(this.options.event, input);
                }
            });inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 2,
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_MANIPULATION];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;
                    this.reset();
                    if (input.eventType & INPUT_START && this.count === 0) {
                        return this.failTimeout();
                    }
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        this._input = input;
                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },
                failTimeout: function failTimeout() {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit() {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });Hammer.VERSION = '2.0.4';
            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,
                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,
                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,
                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,
                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,
                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],
                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',
                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',
                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',
                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',
                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',
                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };
            STOP = 1;
            FORCED_STOP = 2;
            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function stop(force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }
                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);
                    var recognizer;
                    var recognizers = this.recognizers;
                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;
                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                        curRecognizer = session.curRecognizer = null;
                    }
                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];
                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }
                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },
                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function get(recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }
                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },
                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function add(recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }
                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }
                    this.recognizers.push(recognizer);
                    recognizer.manager = this;
                    this.touchAction.update();
                    return recognizer;
                },
                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function remove(recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }
                    var recognizers = this.recognizers;
                    recognizer = this.get(recognizer);
                    recognizers.splice(inArray(recognizers, recognizer), 1);
                    this.touchAction.update();
                    return this;
                },
                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function on(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },
                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function off(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },
                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function emit(event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }
                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }
                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },
                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function destroy() {
                    this.element && toggleCssProps(this, false);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };extend(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,
                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,
                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,
                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,
                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,
                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });
            /*
            if (typeof define == TYPE_FUNCTION && define.amd) {
                define(function() {
                    return Hammer;
                });
            } else if (typeof module != 'undefined' && module.exports) {
                module.exports = Hammer;
            } else {
                window[exportName] = Hammer;
            }
            */

            _export('Hammer', Hammer);

            //})(window, document, 'Hammer');
        }
    };
});
System.register('ionic/gestures/slide-edge-gesture', ['ionic/gestures/slide-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var SlideGesture, util, SlideEdgeGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideEdgeGesture = (function (_SlideGesture) {
                _inherits(SlideEdgeGesture, _SlideGesture);

                function SlideEdgeGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideEdgeGesture);

                    util.defaults(opts, {
                        edge: 'left',
                        threshold: 50
                    });
                    _get(Object.getPrototypeOf(SlideEdgeGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                }

                _createClass(SlideEdgeGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        var _this = this;

                        this._containerRect = this.getContainerDimensions();
                        return this.edges.every(function (edge) {
                            return _this._checkEdge(edge, ev.center);
                        });
                    }
                }, {
                    key: 'getContainerDimensions',
                    value: function getContainerDimensions() {
                        return {
                            left: 0,
                            top: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        };
                    }
                }, {
                    key: '_checkEdge',
                    value: function _checkEdge(edge, pos) {
                        switch (edge) {
                            case 'left':
                                return pos.x <= this._containerRect.left + this.threshold;
                            case 'right':
                                return pos.x >= this._containerRect.width - this.threshold;
                            case 'top':
                                return pos.y <= this._containerRect.top + this.threshold;
                            case 'bottom':
                                return pos.y >= this._containerRect.height - this.threshold;
                        }
                    }
                }]);

                return SlideEdgeGesture;
            })(SlideGesture);

            _export('SlideEdgeGesture', SlideEdgeGesture);
        }
    };
});
System.register('ionic/gestures/slide-gesture', ['ionic/gestures/drag-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var DragGesture, util, SlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesDragGesture) {
            DragGesture = _ionicGesturesDragGesture.DragGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideGesture = (function (_DragGesture) {
                _inherits(SlideGesture, _DragGesture);

                function SlideGesture(element) {
                    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideGesture);

                    _get(Object.getPrototypeOf(SlideGesture.prototype), 'constructor', this).call(this, element, opts);
                    this.element = element;
                }

                /*
                 * Get the min and max for the slide. pageX/pageY.
                 * Only called on dragstart.
                 */

                _createClass(SlideGesture, [{
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries(slide, ev) {
                        return {
                            min: 0,
                            max: this.element.offsetWidth
                        };
                    }

                    /*
                     * Get the element's pos when the drag starts.
                     * For example, an open side menu starts at 100% and a closed
                     * sidemenu starts at 0%.
                     */
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return 0;
                    }
                }, {
                    key: 'canStart',
                    value: function canStart() {
                        return true;
                    }
                }, {
                    key: 'onDragStart',
                    value: function onDragStart(ev) {
                        var _this = this;

                        if (!this.canStart(ev)) return false;
                        this.slide = {};
                        var promise = this.onSlideBeforeStart(this.slide, ev) || Promise.resolve();
                        promise.then(function () {
                            var _getSlideBoundaries = _this.getSlideBoundaries(_this.slide, ev);

                            var min = _getSlideBoundaries.min;
                            var max = _getSlideBoundaries.max;

                            _this.slide.min = min;
                            _this.slide.max = max;
                            _this.slide.elementStartPos = _this.getElementStartPos(_this.slide, ev);
                            _this.slide.pointerStartPos = ev.center[_this.direction];
                            _this.slide.started = true;
                            _this.onSlideStart(_this.slide, ev);
                        })['catch'](function () {
                            _this.slide = null;
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.slide.pos = ev.center[this.direction];
                        this.slide.distance = util.clamp(this.slide.min, this.slide.pos - this.slide.pointerStartPos + this.slide.elementStartPos, this.slide.max);
                        this.slide.delta = this.slide.pos - this.slide.pointerStartPos;
                        this.onSlide(this.slide, ev);
                    }
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.onSlideEnd(this.slide, ev);
                        this.slide = null;
                    }
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart() {}
                }, {
                    key: 'onSlideStart',
                    value: function onSlideStart() {}
                }, {
                    key: 'onSlide',
                    value: function onSlide() {}
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd() {}
                }]);

                return SlideGesture;
            })(DragGesture);

            _export('SlideGesture', SlideGesture);
        }
    };
});
System.register('ionic/native/plugin', [], function (_export) {
    'use strict';

    var NativePluginDecorator;

    _export('NativePlugin', NativePlugin);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function NativePlugin(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new NativePluginDecorator(cls, config));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    return {
        setters: [],
        execute: function () {
            NativePluginDecorator = function NativePluginDecorator(cls, config) {
                var _this = this;

                _classCallCheck(this, NativePluginDecorator);

                this.cls = cls;
                this.config = config;
                cls.ifPlugin = function (check, cb) {
                    var returnType = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

                    // Convert to boolean the plugin param
                    var exists = !!check;
                    if (typeof check === 'function') {
                        exists = check();
                    }
                    if (exists) {
                        return cb();
                    }
                    cls.pluginWarn();
                    return typeof returnType === 'function' ? returnType() : returnType;
                };
                cls.pluginWarn = function () {
                    var platformString = [];
                    for (var k in _this.config.platforms) {
                        platformString.push('\t' + k + ': ' + _this.config.platforms[k]);
                    }
                    console.warn('Plugin for ' + _this.config.name + ' not installed. For native functionality, please install the correct plugin for your platform:\n' + platformString.join('\n'));
                };
            };

            _export('NativePluginDecorator', NativePluginDecorator);
        }
    };
});
System.register('ionic/native/plugins', ['./plugin', './battery/battery', './camera/camera', './contacts/contacts', './device/device', './device-motion/device-motion', './device-orientation/device-orientation', './geolocation/geolocation', './vibration/vibration'], function (_export) {
  'use strict';

  return {
    setters: [function (_plugin) {
      for (var _key in _plugin) {
        if (_key !== 'default') _export(_key, _plugin[_key]);
      }
    }, function (_batteryBattery) {
      for (var _key2 in _batteryBattery) {
        if (_key2 !== 'default') _export(_key2, _batteryBattery[_key2]);
      }
    }, function (_cameraCamera) {
      for (var _key3 in _cameraCamera) {
        if (_key3 !== 'default') _export(_key3, _cameraCamera[_key3]);
      }
    }, function (_contactsContacts) {
      for (var _key4 in _contactsContacts) {
        if (_key4 !== 'default') _export(_key4, _contactsContacts[_key4]);
      }
    }, function (_deviceDevice) {
      for (var _key5 in _deviceDevice) {
        if (_key5 !== 'default') _export(_key5, _deviceDevice[_key5]);
      }
    }, function (_deviceMotionDeviceMotion) {
      for (var _key6 in _deviceMotionDeviceMotion) {
        if (_key6 !== 'default') _export(_key6, _deviceMotionDeviceMotion[_key6]);
      }
    }, function (_deviceOrientationDeviceOrientation) {
      for (var _key7 in _deviceOrientationDeviceOrientation) {
        if (_key7 !== 'default') _export(_key7, _deviceOrientationDeviceOrientation[_key7]);
      }
    }, function (_geolocationGeolocation) {
      for (var _key8 in _geolocationGeolocation) {
        if (_key8 !== 'default') _export(_key8, _geolocationGeolocation[_key8]);
      }
    }, function (_vibrationVibration) {
      for (var _key9 in _vibrationVibration) {
        if (_key9 !== 'default') _export(_key9, _vibrationVibration[_key9]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/net/http', ['ionic/util'], function (_export) {
    //TODO(mlynch): surely, there must be another way, sir?
    'use strict';

    var util, Http;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            window._jsonpcallbacks = {
                counter: 0
            };
            /**
             * The Http class makes it easy to send GET/POST/PUT/DELETE/PATCH requests
             * and send/receive JSON (or anything else) through a simple API.
             *
             * Http uses the `fetch()` API underneath, or a polyfill if it's not natively supported.
             */

            Http = (function () {
                function Http() {
                    _classCallCheck(this, Http);
                }

                _createClass(Http, null, [{
                    key: 'fetch',

                    /**
                     * The raw fetch() operation.
                     *
                     * Generally, you want to use one of get()/post()/put()/delete() but
                     * this is useful if you want to do something crazy.
                     *
                     * @param url the URL to pass to fetch
                     * @param options the options to configure the fetch
                     * @return es6 promise from the fetch.
                     */
                    value: function fetch(url, options) {
                        return window.fetch(url, options).then(function (response) {
                            // status "0" to handle local files fetching (e.g. Cordova/Phonegap etc.)
                            if (response.status === 200 || response.status === 0) {
                                // We have a good response, let's check the response headers and return
                                // deserialized JSON or return the text from the response.
                                if (response.headers.get('Content-Type') === 'application/json') {
                                    return response.json();
                                }
                                return response.text();
                            } else {
                                return Promise.reject(response, new Error(response.statusText));
                            }
                        })['catch'](function (err) {
                            return Promise.reject(err);
                        });
                    }
                }, {
                    key: 'jsonp',
                    value: function jsonp(url, callbackId, options) {
                        return new Promise(function (resolve, reject) {
                            var script = document.createElement('script');
                            script.src = url;
                            script.async = true;
                            script.type = 'text/javascript';
                            var callback = function callback(event) {
                                script.removeEventListener('load', callback);
                                script.removeEventListener('error', callback);
                                document.body.removeChild(script);
                                var text = undefined,
                                    status = undefined;
                                if (event) {
                                    if (event.type === "load" && !window._jsonpcallbacks[callbackId].called) {
                                        event = { type: "error" };
                                    }
                                    text = event.type;
                                    status = event.type === "error" ? 404 : 200;
                                    resolve(window._jsonpcallbacks[callbackId].data, status, text);
                                } else {
                                    reject();
                                }
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                            };
                            script.addEventListener('load', callback);
                            script.addEventListener('error', callback);
                            document.body.appendChild(script);
                            return callback;
                        });
                    }
                }, {
                    key: '_method',
                    value: function _method(method, url, data, options, sendsJson) {
                        options = util.defaults(options, {
                            method: method,
                            headers: {
                                'Accept': 'application/json,text/plain,*/*'
                            }
                        });
                        if (options.body) {
                            options.body = typeof data === 'string' ? data : JSON.stringify(data);
                        }
                        if (sendsJson) {
                            options.headers['Content-Type'] = 'application/json';
                        }
                        if (options.method == 'jsonp') {
                            var callbackId;

                            var _ret = (function () {
                                // Adopted from Angular 1
                                var callbacks = window._jsonpcallbacks;
                                callbackId = '_' + (callbacks.counter++).toString(36);

                                callbacks[callbackId] = function (data) {
                                    callbacks[callbackId].data = data;
                                    callbacks[callbackId].called = true;
                                };
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                                url = url.replace('JSON_CALLBACK', '_jsonpcallbacks.' + callbackId);
                                return {
                                    v: Http.jsonp(url, callbackId, options)
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        } else {
                            return Http.fetch(url, options);
                        }
                    }

                    /**
                     * Send a GET request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'get',
                    value: function get(url) {
                        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        return Http._method('get', url, {}, options);
                    }

                    /**
                     * Send a POST request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'post',
                    value: function post(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('post', url, data, options, true);
                    }

                    /**
                     * Send a PUT request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PUT to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'put',
                    value: function put(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('put', url, data, options, true);
                    }

                    /**
                     * Send a DELETE request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to DELETE to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'delete',
                    value: function _delete(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('delete', url, data, options, true);
                    }

                    /**
                     * Send a PATH request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PATH to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                }, {
                    key: 'patch',
                    value: function patch(url) {
                        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('patch', url, data, options, true);
                    }
                }]);

                return Http;
            })();

            _export('Http', Http);
        }
    };
});
System.register('ionic/platform/platform', ['../util/util', '../util/dom'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var util, dom, PlatformCtrl, PlatformNode, Platform;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertSuperset(platformNode) {
        var supersetPlaformName = platformNode.superset();
        if (supersetPlaformName) {
            // add a platform in between two exist platforms
            // so we can build the correct hierarchy of active platforms
            var supersetPlatform = new PlatformNode(supersetPlaformName);
            supersetPlatform.parent(platformNode.parent());
            supersetPlatform.child(platformNode);
            if (supersetPlatform.parent()) {
                supersetPlatform.parent().child(supersetPlatform);
            }
            platformNode.parent(supersetPlatform);
        }
    }
    return {
        setters: [function (_utilUtil) {
            util = _utilUtil;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            PlatformCtrl = (function () {
                function PlatformCtrl() {
                    var _this = this;

                    _classCallCheck(this, PlatformCtrl);

                    this._settings = {};
                    this._platforms = [];
                    this._versions = {};
                    this._registry = {};
                    this._default = null;
                    this._onResizes = [];
                    this._readyPromise = new Promise(function (res) {
                        _this._readyResolve = res;
                    });
                }

                // Methods
                // **********************************************
                /**
                 * TODO
                 * @param {TODO} platformName  TODO
                 * @returns {TODO} TODO
                 */

                _createClass(PlatformCtrl, [{
                    key: 'is',
                    value: function is(platformName) {
                        return this._platforms.indexOf(platformName) > -1;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'platforms',
                    value: function platforms() {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        return this._platforms;
                    }

                    /**
                     * TODO
                     * @param {TODO} platformName  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'versions',
                    value: function versions(platformName) {
                        if (arguments.length) {
                            // get a specific platform's version
                            return this._versions[platformName];
                        }
                        // get all the platforms that have a valid parsed version
                        return this._versions;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'ready',
                    value: function ready() {
                        return this._readyPromise;
                    }

                    /**
                     * TODO
                     * @param {TODO} config  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'prepareReady',
                    value: function prepareReady(config) {
                        var self = this;
                        function resolve() {
                            self._readyResolve(config);
                        }
                        if (this._engineReady) {
                            // the engine provide a ready promise, use this instead
                            this._engineReady(resolve);
                        } else {
                            // there is no custom ready method from the engine
                            // use the default dom ready
                            dom.ready(resolve);
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'domReady',
                    value: function domReady() {
                        // convenience method so its easy to access on Platform
                        return dom.ready.apply(this, arguments);
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'windowLoad',
                    value: function windowLoad() {
                        // convenience method so its easy to access on Platform
                        return dom.windowLoad.apply(this, arguments);
                    }

                    // Methods meant to be overridden by the engine
                    // **********************************************
                    // Provided NOOP methods so they do not error when
                    // called by engines (the browser) doesn't provide them
                }, {
                    key: 'on',
                    value: function on() {}
                }, {
                    key: 'onHardwareBackButton',
                    value: function onHardwareBackButton() {}
                }, {
                    key: 'registerBackButtonAction',
                    value: function registerBackButtonAction() {}
                }, {
                    key: 'exitApp',
                    value: function exitApp() {}
                }, {
                    key: 'fullScreen',
                    value: function fullScreen() {}
                }, {
                    key: 'showStatusBar',
                    value: function showStatusBar() {}

                    // Getter/Setter Methods
                    // **********************************************
                }, {
                    key: 'url',
                    value: function url(val) {
                        if (arguments.length) {
                            this._url = val;
                            this._qs = util.getQuerystring(val);
                        }
                        return this._url;
                    }
                }, {
                    key: 'query',
                    value: function query(key) {
                        return (this._qs || {})[key];
                    }
                }, {
                    key: 'userAgent',
                    value: function userAgent(val) {
                        if (arguments.length) {
                            this._ua = val;
                        }
                        return this._ua;
                    }
                }, {
                    key: 'navigatorPlatform',
                    value: function navigatorPlatform(val) {
                        if (arguments.length) {
                            this._bPlt = val;
                        }
                        return this._bPlt || '';
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        if (!this._w) {
                            this._w = window.innerWidth;
                            this._h = window.innerHeight;
                        }
                        return this._w;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        if (!this._h) {
                            this._w = window.innerWidth;
                            this._h = window.innerHeight;
                        }
                        return this._h;
                    }
                }, {
                    key: 'isPortrait',
                    value: function isPortrait() {
                        return this.width() < this.height();
                    }
                }, {
                    key: 'isLandscape',
                    value: function isLandscape() {
                        return !this.isPortrait();
                    }
                }, {
                    key: 'winResize',
                    value: function winResize() {
                        Platform._w = Platform._h = 0;
                        clearTimeout(Platform._resizeTimer);
                        Platform._resizeTimer = setTimeout(function () {
                            for (var i = 0; i < Platform._onResizes.length; i++) {
                                try {
                                    Platform._onResizes[i]();
                                } catch (e) {
                                    console.error(e);
                                }
                            }
                        }, 500);
                    }
                }, {
                    key: 'onResize',
                    value: function onResize(cb) {
                        // TODO: Make more good
                        this._onResizes.push(cb);
                    }

                    // Registry
                    // **********************************************
                    /**
                     * TODO
                     * @param {TODO} platformConfig  TODO
                     */
                }, {
                    key: 'register',
                    value: function register(platformConfig) {
                        this._registry[platformConfig.name] = platformConfig;
                    }
                }, {
                    key: 'registry',
                    value: function registry() {
                        return this._registry;
                    }
                }, {
                    key: 'setDefault',
                    value: function setDefault(platformName) {
                        this._default = platformName;
                    }

                    /**
                     * TODO
                     * @param {TODO} queryValue  TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'testQuery',
                    value: function testQuery(queryValue) {
                        var val = this.query('ionicplatform');
                        if (val) {
                            var valueSplit = val.toLowerCase().split(';');
                            for (var i = 0; i < valueSplit.length; i++) {
                                if (valueSplit[i] == queryValue) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }

                    /**
                     * TODO
                     * @param {TODO} userAgentExpression  TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'testUserAgent',
                    value: function testUserAgent(userAgentExpression) {
                        var rx = new RegExp(userAgentExpression, 'i');
                        return rx.test(this._ua);
                    }

                    /**
                     * TODO
                     * @param {TODO} userAgentExpression  TODO
                     * @returns {Object} TODO
                     */
                }, {
                    key: 'matchUserAgentVersion',
                    value: function matchUserAgentVersion(userAgentExpression) {
                        var val = this._ua.match(userAgentExpression);
                        if (val) {
                            return {
                                major: val[1],
                                minor: val[2]
                            };
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} queryValue  TODO
                     * @param {TODO} userAgentExpression  TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'isPlatform',
                    value: function isPlatform(queryValue, userAgentExpression) {
                        if (!userAgentExpression) {
                            userAgentExpression = queryValue;
                        }
                        return this.testQuery(queryValue) || this.testUserAgent(userAgentExpression);
                    }

                    /**
                     * TODO
                     * @param {TODO} config  TODO
                     */
                }, {
                    key: 'load',
                    value: function load(config) {
                        var rootPlatformNode = null;
                        var engineNode = null;
                        var self = this;
                        this.platformOverride = config.setting('platform');
                        // figure out the most specific platform and active engine
                        var tmpPlatform = null;
                        for (var platformName in this._registry) {
                            tmpPlatform = this.matchPlatform(platformName);
                            if (tmpPlatform) {
                                // we found a platform match!
                                // check if its more specific than the one we already have
                                if (tmpPlatform.isEngine) {
                                    // because it matched then this should be the active engine
                                    // you cannot have more than one active engine
                                    engineNode = tmpPlatform;
                                } else if (!rootPlatformNode || tmpPlatform.depth > rootPlatformNode.depth) {
                                    // only find the root node for platforms that are not engines
                                    // set this node as the root since we either don't already
                                    // have one, or this one is more specific that the current one
                                    rootPlatformNode = tmpPlatform;
                                }
                            }
                        }
                        if (!rootPlatformNode) {
                            rootPlatformNode = new PlatformNode(this._default);
                        }
                        // build a Platform instance filled with the
                        // hierarchy of active platforms and settings
                        if (rootPlatformNode) {
                            // check if we found an engine node (cordova/node-webkit/etc)
                            if (engineNode) {
                                // add the engine to the first in the platform hierarchy
                                // the original rootPlatformNode now becomes a child
                                // of the engineNode, which is not the new root
                                engineNode.child(rootPlatformNode);
                                rootPlatformNode.parent(engineNode);
                                rootPlatformNode = engineNode;
                                // add any events which the engine would provide
                                // for example, Cordova provides its own ready event
                                var engineMethods = engineNode.methods();
                                engineMethods._engineReady = engineMethods.ready;
                                delete engineMethods.ready;
                                util.extend(this, engineMethods);
                            }
                            var platformNode = rootPlatformNode;
                            while (platformNode) {
                                insertSuperset(platformNode);
                                platformNode = platformNode.child();
                            }
                            // make sure the root noot is actually the root
                            // incase a node was inserted before the root
                            platformNode = rootPlatformNode.parent();
                            while (platformNode) {
                                rootPlatformNode = platformNode;
                                platformNode = platformNode.parent();
                            }
                            platformNode = rootPlatformNode;
                            while (platformNode) {
                                // set the array of active platforms with
                                // the last one in the array the most important
                                this._platforms.push(platformNode.name());
                                // copy default platform settings into this platform settings obj
                                this._settings[platformNode.name()] = util.extend({}, platformNode.settings());
                                // get the platforms version if a version parser was provided
                                this._versions[platformNode.name()] = platformNode.version(this);
                                // go to the next platform child
                                platformNode = platformNode.child();
                            }
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} platformName  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'matchPlatform',
                    value: function matchPlatform(platformName) {
                        // build a PlatformNode and assign config data to it
                        // use it's getRoot method to build up its hierarchy
                        // depending on which platforms match
                        var platformNode = new PlatformNode(platformName);
                        var rootNode = platformNode.getRoot(this, 0);
                        if (rootNode) {
                            rootNode.depth = 0;
                            var childPlatform = rootNode.child();
                            while (childPlatform) {
                                rootNode.depth++;
                                childPlatform = childPlatform.child();
                            }
                        }
                        return rootNode;
                    }
                }, {
                    key: 'settings',
                    value: function settings(val) {
                        if (arguments.length) {
                            this._settings = val;
                        }
                        return this._settings;
                    }

                    /**
                     * TODO
                     * @param {TODO} platformName  TODO
                     * @returns {string} TODO
                     */
                }, {
                    key: 'get',
                    value: function get(platformName) {
                        return this._registry[platformName] || {};
                    }
                }]);

                return PlatformCtrl;
            })();

            _export('PlatformCtrl', PlatformCtrl);

            PlatformNode = (function () {
                function PlatformNode(platformName) {
                    _classCallCheck(this, PlatformNode);

                    this.c = Platform.get(platformName);
                    this.isEngine = this.c.isEngine;
                }

                _createClass(PlatformNode, [{
                    key: 'name',
                    value: function name() {
                        return this.c.name;
                    }
                }, {
                    key: 'settings',
                    value: function settings() {
                        return this.c.settings || {};
                    }
                }, {
                    key: 'superset',
                    value: function superset() {
                        return this.c.superset;
                    }
                }, {
                    key: 'methods',
                    value: function methods() {
                        return this.c.methods || {};
                    }
                }, {
                    key: 'parent',
                    value: function parent(val) {
                        if (arguments.length) {
                            this._parent = val;
                        }
                        return this._parent;
                    }
                }, {
                    key: 'child',
                    value: function child(val) {
                        if (arguments.length) {
                            this._child = val;
                        }
                        return this._child;
                    }
                }, {
                    key: 'isMatch',
                    value: function isMatch(p) {
                        if (typeof this.c.isMatched !== 'boolean') {
                            if (p.platformOverride && !this.isEngine) {
                                this.c.isMatched = p.platformOverride === this.c.name;
                            } else if (!this.c.isMatch) {
                                this.c.isMatched = false;
                            } else {
                                this.c.isMatched = this.c.isMatch(p);
                            }
                        }
                        return this.c.isMatched;
                    }
                }, {
                    key: 'version',
                    value: function version(p) {
                        if (this.c.versionParser) {
                            var v = this.c.versionParser(p);
                            if (v) {
                                var str = v.major + '.' + v.minor;
                                return {
                                    str: str,
                                    num: parseFloat(str),
                                    major: parseInt(v.major, 10),
                                    minor: parseInt(v.minor, 10)
                                };
                            }
                        }
                    }
                }, {
                    key: 'getRoot',
                    value: function getRoot(p) {
                        if (this.isMatch(p)) {
                            var parents = this.getSubsetParents(this.name());
                            if (!parents.length) {
                                return this;
                            }
                            var platform = null;
                            var rootPlatform = null;
                            for (var i = 0; i < parents.length; i++) {
                                platform = new PlatformNode(parents[i]);
                                platform.child(this);
                                rootPlatform = platform.getRoot(p);
                                if (rootPlatform) {
                                    this.parent(platform);
                                    return rootPlatform;
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getSubsetParents',
                    value: function getSubsetParents(subsetPlatformName) {
                        var registry = Platform.registry();
                        var parentPlatformNames = [];
                        var platform = null;
                        for (var platformName in registry) {
                            platform = registry[platformName];
                            if (platform.subsets && platform.subsets.indexOf(subsetPlatformName) > -1) {
                                parentPlatformNames.push(platformName);
                            }
                        }
                        return parentPlatformNames;
                    }
                }]);

                return PlatformNode;
            })();

            Platform = new PlatformCtrl();

            _export('Platform', Platform);
        }
    };
});
System.register('ionic/platform/registry', ['./platform'], function (_export) {
    'use strict';

    var Platform;
    return {
        setters: [function (_platform) {
            Platform = _platform.Platform;
        }],
        execute: function () {
            Platform.register({
                name: 'core',
                settings: {
                    mode: 'ios',
                    keyboardHeight: 290
                }
            });
            Platform.setDefault('core');
            Platform.register({
                name: 'mobile'
            });
            Platform.register({
                name: 'phablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    return smallest > 390 && smallest < 520 && (largest > 620 && largest < 800);
                }
            });
            Platform.register({
                name: 'tablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    return smallest > 460 && smallest < 820 && (largest > 780 && largest < 1400);
                }
            });
            Platform.register({
                name: 'android',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'md',
                    keyboardHeight: 290,
                    keyboardScrollAssist: true
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('android', 'android|silk');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Android (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'ios',
                superset: 'mobile',
                subsets: ['ipad', 'iphone'],
                settings: {
                    mode: 'ios',
                    tapPolyfill: function tapPolyfill() {
                        return (/iphone|ipad|ipod/i.test(Platform.navigatorPlatform())
                        );
                    },
                    keyboardScrollAssist: function keyboardScrollAssist() {
                        return (/iphone|ipad|ipod/i.test(Platform.navigatorPlatform())
                        );
                    },
                    keyboardHeight: 290
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ios', 'iphone|ipad|ipod');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
                }
            });
            Platform.register({
                name: 'ipad',
                superset: 'tablet',
                settings: {
                    keyboardHeight: 500
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ipad');
                }
            });
            Platform.register({
                name: 'iphone',
                subsets: ['phablet'],
                isMatch: function isMatch(p) {
                    return p.isPlatform('iphone');
                }
            });
            Platform.register({
                name: 'windowsphone',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'wp'
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('windowsphone', 'windows phone');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'cordova',
                isEngine: true,
                methods: {
                    ready: function ready(resolve) {
                        Platform.windowLoad(function () {
                            document.addEventListener("deviceready", resolve);
                        });
                    }
                },
                isMatch: function isMatch(p) {
                    return !!(window.cordova || window.PhoneGap || window.phonegap);
                }
            });
        }
    };
});
System.register('ionic/storage/local-storage', ['./storage'], function (_export) {
    /**
     * The LocalStorage storage engine uses the browser's local storage system for
     * storing key/value pairs.
     *
     * Note: LocalStorage should ONLY be used for temporary data that you can afford to lose.
     * Given disk space constraints on a mobile device, local storage might be "cleaned up"
     * by the operating system (iOS).
     *
     * For guaranteed, long-term storage, use the SqlStorage engine which stores data in a file.
     */
    'use strict';

    var StorageEngine, LocalStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }],
        execute: function () {
            LocalStorage = (function (_StorageEngine) {
                _inherits(LocalStorage, _StorageEngine);

                function LocalStorage() {
                    _classCallCheck(this, LocalStorage);

                    _get(Object.getPrototypeOf(LocalStorage.prototype), 'constructor', this).call(this);
                }

                _createClass(LocalStorage, [{
                    key: 'get',
                    value: function get(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                var value = window.localStorage.getItem(key);
                                resolve(value);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.setItem(key, value);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return new Promise(function (resolve, reject) {
                            try {
                                window.localStorage.removeItem(key);
                                resolve();
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return LocalStorage;
            })(StorageEngine);

            _export('LocalStorage', LocalStorage);
        }
    };
});
System.register('ionic/storage/sql', ['./storage', 'ionic/util'], function (_export) {
    'use strict';

    var StorageEngine, util, DB_NAME, SqlStorage;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_storage) {
            StorageEngine = _storage.StorageEngine;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            DB_NAME = '__ionicstorage';

            SqlStorage = (function (_StorageEngine) {
                _inherits(SqlStorage, _StorageEngine);

                function SqlStorage(options) {
                    _classCallCheck(this, SqlStorage);

                    _get(Object.getPrototypeOf(SqlStorage.prototype), 'constructor', this).call(this);
                    var dbOptions = util.defaults({
                        name: DB_NAME,
                        backupFlag: SqlStorage.BACKUP_NONE,
                        existingDatabase: false
                    }, options);
                    if (window.sqlitePlugin) {
                        var _location = this._getBackupLocation(dbOptions);
                        this._db = window.sqlitePlugin.openDatabase(util.extend({
                            name: dbOptions.name,
                            location: _location,
                            createFromLocation: dbOptions.existingDatabase ? 1 : 0
                        }, dbOptions));
                    } else {
                        console.warn('Storage: SQLite plugin not installed, falling back to WebSQL. Make sure to install cordova-sqlite-storage in production!');
                        this._db = window.openDatabase(dbOptions.name, '1.0', 'database', 5 * 1024 * 1024);
                    }
                    this._tryInit();
                }

                _createClass(SqlStorage, [{
                    key: '_getBackupLocation',
                    value: function _getBackupLocation(dbFlag) {
                        switch (dbFlag) {
                            case SqlStorage.BACKUP_LOCAL:
                                return 2;
                            case SqlStorage.BACKUP_LIBRARY:
                                return 1;
                            case SqlStorage.BACKUP_DOCUMENTS:
                                return 0;
                            default:
                                throw Error('Invalid backup flag: ' + dbFlag);
                        }
                    }

                    // Initialize the DB with our required tables
                }, {
                    key: '_tryInit',
                    value: function _tryInit() {
                        this._db.transaction(function (tx) {
                            tx.executeSql('CREATE TABLE IF NOT EXISTS kv (key text primary key, value text)', [], function (tx, res) {}, function (tx, err) {
                                console.error('Storage: Unable to create initial storage tables', tx, err);
                            });
                        });
                    }

                    /**
                     * Perform an arbitrary SQL operation on the database. Use this method
                     * to have full control over the underlying database through SQL operations
                     * like SELECT, INSERT, and UPDATE.
                     *
                     * @param {string} query the query to run
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'query',
                    value: function query(_query) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            _this._db.transaction(function (tx) {
                                ts.executeSql(_query, [], function (tx, res) {
                                    resolve({
                                        tx: tx,
                                        res: res
                                    });
                                }, function (tx, err) {
                                    reject({
                                        tx: tx,
                                        err: err
                                    });
                                });
                            });
                        });
                    }

                    /**
                     * Get the value in the database identified by the given key.
                     * @param {string} key the key
                     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                     */
                }, {
                    key: 'get',
                    value: function get(key) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this2._db.transaction(function (tx) {
                                    tx.executeSql("select key, value from kv where key = ? limit 1", [key], function (tx, res) {
                                        if (res.rows.length > 0) {
                                            var item = res.rows.item(0);
                                            resolve(item.value);
                                        }
                                        resolve(null);
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Set the value in the database for the given key. Existing values will be overwritten.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        var _this3 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this3._db.transaction(function (tx) {
                                    tx.executeSql('insert or replace into kv(key, value) values (?, ?)', [key, value], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }

                    /**
                    * Remove the value in the database for the given key.
                    * @param {string} key the key
                    * @param {string} value The value (as a string)
                    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
                    */
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        var _this4 = this;

                        return new Promise(function (resolve, reject) {
                            try {
                                _this4._db.transaction(function (tx) {
                                    tx.executeSql('delete from kv where key = ?', [key], function (tx, res) {
                                        resolve();
                                    }, function (tx, err) {
                                        reject({
                                            tx: tx,
                                            err: err
                                        });
                                    });
                                }, function (err) {
                                    reject(err);
                                });
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                }]);

                return SqlStorage;
            })(StorageEngine);

            _export('SqlStorage', SqlStorage);

            SqlStorage.BACKUP_LOCAL = 2;
            SqlStorage.BACKUP_LIBRARY = 1;
            SqlStorage.BACKUP_DOCUMENTS = 0;
        }
    };
});
System.register('ionic/storage/storage', [], function (_export) {
    /**
     * Storage is an easy way to store key/value pairs and other complicated
     * data in a way that uses a variety of storage engines underneath.
     *
     * For most cases, we recommend the SqlStorage system as it will store
     * data in a file in the app's sandbox. LocalStorage should ONLY be used
     * for temporary data as it may be "cleaned up" by the operation system
     * during low disk space situations.
     */
    'use strict';

    var Storage, StorageEngine;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            Storage = (function () {
                function Storage(strategyCls) {
                    _classCallCheck(this, Storage);

                    this._strategy = new strategyCls();
                }

                _createClass(Storage, [{
                    key: 'get',
                    value: function get(key) {
                        return this._strategy.get(key);
                    }
                }, {
                    key: 'getJson',
                    value: function getJson(key) {
                        try {
                            return JSON.parse(this._strategy.get(key));
                        } catch (e) {
                            console.warn('Storage getJson(): unable to parse value for key', key, ' as JSON');
                            return null;
                        }
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        return this._strategy.set(key, value);
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        return this._strategy.remove(key);
                    }
                }, {
                    key: 'query',
                    value: function query(_query) {
                        return this._strategy.query(key);
                    }
                }]);

                return Storage;
            })();

            _export('Storage', Storage);

            StorageEngine = (function () {
                function StorageEngine() {
                    _classCallCheck(this, StorageEngine);
                }

                _createClass(StorageEngine, [{
                    key: 'get',
                    value: function get(key, value) {
                        throw Error("get() not implemented for this storage engine");
                    }
                }, {
                    key: 'set',
                    value: function set(key, value) {
                        throw Error("set() not implemented for this storage engine");
                    }
                }, {
                    key: 'remove',
                    value: function remove(key) {
                        throw Error("remove() not implemented for this storage engine");
                    }
                }, {
                    key: 'query',
                    value: function query(_query2) {
                        throw Error("query() not implemented for this storage engine");
                    }
                }]);

                return StorageEngine;
            })();

            _export('StorageEngine', StorageEngine);
        }
    };
});
System.register('ionic/transitions/ios-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, OPACITY, TRANSLATEX, OFF_RIGHT, OFF_LEFT, CENTER, OFF_OPACITY, IOSTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 600;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            OPACITY = 'opacity';
            TRANSLATEX = 'translateX';
            OFF_RIGHT = '100%';
            OFF_LEFT = '-33%';
            CENTER = '0%';
            OFF_OPACITY = 0.8;

            IOSTransition = (function (_Transition) {
                _inherits(IOSTransition, _Transition);

                function IOSTransition(nav, opts) {
                    _classCallCheck(this, IOSTransition);

                    _get(Object.getPrototypeOf(IOSTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves to center
                    this.enteringView.to(TRANSLATEX, CENTER).to(OPACITY, 1).before.setStyles({ zIndex: this.entering.index });
                    this.enteringTitle.fadeIn().to(TRANSLATEX, CENTER);
                    // leaving view moves off screen
                    this.leavingView.from(TRANSLATEX, CENTER).from(OPACITY, 1).before.setStyles({ zIndex: this.leaving.index });
                    this.leavingTitle.from(TRANSLATEX, CENTER).from(OPACITY, 1);
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEX, OFF_LEFT).from(OPACITY, OFF_OPACITY).to(OPACITY, 1);
                        this.enteringTitle.from(TRANSLATEX, OFF_LEFT);
                        this.leavingNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.leavingView.to(TRANSLATEX, OFF_RIGHT).to(OPACITY, 1);
                        this.leavingTitle.to(TRANSLATEX, OFF_RIGHT).to(OPACITY, 0);
                        if (this.leaving.enableBack() && this.viewWidth() > 200) {
                            var leavingBackButtonText = new Animation(this.leaving.backButtonTextElement());
                            leavingBackButtonText.fromTo(TRANSLATEX, CENTER, this.viewWidth() / 2 + 'px');
                            this.leavingNavbar.add(leavingBackButtonText);
                        }
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEX, OFF_RIGHT).from(OPACITY, 1);
                        this.enteringNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.enteringTitle.from(TRANSLATEX, OFF_RIGHT);
                        this.leavingView.to(TRANSLATEX, OFF_LEFT).to(OPACITY, OFF_OPACITY);
                        this.leavingTitle.to(TRANSLATEX, OFF_LEFT).to(OPACITY, 0);
                        if (this.entering.enableBack() && this.viewWidth() > 200) {
                            var enteringBackButtonText = new Animation(this.entering.backButtonTextElement());
                            enteringBackButtonText.fromTo(TRANSLATEX, this.viewWidth() / 2 + 'px', CENTER);
                            this.enteringNavbar.add(enteringBackButtonText);
                        }
                    }
                }

                return IOSTransition;
            })(Transition);

            Transition.register('ios', IOSTransition);
        }
    };
});
System.register('ionic/transitions/md-transition', ['./transition'], function (_export) {
    'use strict';

    var Transition, DURATION, EASING, TRANSLATEY, OFF_BOTTOM, CENTER, MaterialTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }],
        execute: function () {
            DURATION = 300;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            TRANSLATEY = 'translateY';
            OFF_BOTTOM = '40px';
            CENTER = '0px';

            MaterialTransition = (function (_Transition) {
                _inherits(MaterialTransition, _Transition);

                function MaterialTransition(nav, opts) {
                    _classCallCheck(this, MaterialTransition);

                    _get(Object.getPrototypeOf(MaterialTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves in bottom to center
                    this.enteringView.to(TRANSLATEY, CENTER).before.setStyles({ zIndex: this.entering.index });
                    // entering item moves in bottom to center
                    this.enteringNavbar.to(TRANSLATEY, CENTER).before.setStyles({ zIndex: this.entering.index + 10 });
                    // leaving view stays put
                    this.leavingView.before.setStyles({ zIndex: this.leaving.index });
                    this.leavingNavbar.before.setStyles({ zIndex: this.leaving.index + 10 });
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEY, CENTER);
                        this.enteringNavbar.from(TRANSLATEY, CENTER);
                        // leaving view goes center to bottom
                        this.leavingView.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut();
                        this.leavingNavbar.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut();
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEY, OFF_BOTTOM).fadeIn();
                        this.enteringNavbar.from(TRANSLATEY, OFF_BOTTOM).fadeIn();
                    }
                }

                return MaterialTransition;
            })(Transition);

            Transition.register('md', MaterialTransition);
        }
    };
});
System.register('ionic/transitions/transition', ['../animations/animation'], function (_export) {
    'use strict';

    var Animation, SHOW_NAVBAR_CSS, SHOW_VIEW_CSS, SHOW_BACK_BUTTON, TransitionRegistry, Transition;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            SHOW_NAVBAR_CSS = 'show-navbar';
            SHOW_VIEW_CSS = 'show-view';
            SHOW_BACK_BUTTON = 'show-back-button';
            TransitionRegistry = {};

            Transition = (function (_Animation) {
                _inherits(Transition, _Animation);

                function Transition(nav, opts) {
                    _classCallCheck(this, Transition);

                    _get(Object.getPrototypeOf(Transition.prototype), 'constructor', this).call(this);
                    // get the entering and leaving items
                    var enteringItem = this.entering = nav.getStagedEnteringItem();
                    var leavingItem = this.leaving = nav.getStagedLeavingItem();
                    // create animation for the entering item's "ion-view" element
                    this.enteringView = new Animation(enteringItem.viewElementRef());
                    this.enteringView.before.addClass(SHOW_VIEW_CSS);
                    this.enteringView.onPlay(function () {
                        enteringItem.postRender();
                    });
                    this.add(this.enteringView);
                    if (opts.navbar !== false) {
                        var enteringNavbar = this.enteringNavbar = new Animation(enteringItem.navbarElement());
                        enteringNavbar.before.addClass(SHOW_NAVBAR_CSS);
                        if (enteringItem.enableBack()) {
                            // only animate in the back button if the entering view has it enabled
                            var enteringBackButton = this.enteringBackButton = new Animation(enteringItem.backButtonElement());
                            enteringBackButton.before.addClass(SHOW_BACK_BUTTON).fadeIn();
                            enteringNavbar.add(enteringBackButton);
                        }
                        this.enteringTitle = new Animation(enteringItem.titleElement());
                        enteringNavbar.add(this.enteringTitle);
                        this.add(enteringNavbar);
                        this.enteringNavbarItems = new Animation(enteringItem.navbarItemElements());
                        this.enteringNavbarItems.fadeIn();
                        enteringNavbar.add(this.enteringNavbarItems);
                    }
                    if (leavingItem) {
                        // setup the leaving item if one exists (initial viewing wouldn't have a leaving item)
                        this.leavingView = new Animation(leavingItem.viewElementRef());
                        this.leavingView.after.removeClass(SHOW_VIEW_CSS);
                        var leavingNavbar = this.leavingNavbar = new Animation(leavingItem.navbarElement());
                        leavingNavbar.after.removeClass(SHOW_NAVBAR_CSS);
                        var leavingBackButton = this.leavingBackButton = new Animation(leavingItem.backButtonElement());
                        leavingBackButton.after.removeClass(SHOW_BACK_BUTTON).fadeOut();
                        leavingNavbar.add(leavingBackButton);
                        this.leavingTitle = new Animation(leavingItem.titleElement());
                        leavingNavbar.add(this.leavingTitle);
                        this.leavingNavbarItems = new Animation(leavingItem.navbarItemElements());
                        this.leavingNavbarItems.fadeOut();
                        leavingNavbar.add(this.leavingNavbarItems);
                        this.add(this.leavingView, leavingNavbar);
                    }
                }

                _createClass(Transition, [{
                    key: 'viewWidth',
                    value: function viewWidth() {
                        // TODO: MAKE MORE BETTER
                        return this._w || (this._w = this.leaving && this.leaving.viewElementRef().nativeElement.offsetWidth);
                    }

                    /*
                     STATIC CLASSES
                     */
                }], [{
                    key: 'create',
                    value: function create(nav) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var name = opts.animation || 'ios';
                        var TransitionClass = TransitionRegistry[name];
                        if (!TransitionClass) {
                            // transition wasn't found, default to a 'none' transition
                            // which doesn't animate anything, just shows and hides
                            TransitionClass = Transition;
                        }
                        return new TransitionClass(nav, opts);
                    }
                }, {
                    key: 'register',
                    value: function register(name, TransitionClass) {
                        TransitionRegistry[name] = TransitionClass;
                    }
                }]);

                return Transition;
            })(Animation);

            _export('Transition', Transition);
        }
    };
});
System.register('ionic/util/activator', ['./dom'], function (_export) {
    'use strict';

    var raf, pointerCoord, hasPointerMoved, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_dom) {
            raf = _dom.raf;
            pointerCoord = _dom.pointerCoord;
            hasPointerMoved = _dom.hasPointerMoved;
        }],
        execute: function () {
            Activator = (function () {
                function Activator(app, config, window, document) {
                    _classCallCheck(this, Activator);

                    var self = this;
                    self.app = app;
                    self.config = config;
                    self.win = window;
                    self.doc = document;
                    self.id = 0;
                    self.queue = {};
                    self.active = {};
                    self.activatedClass = 'activated';
                    self.deactivateTimeout = 180;
                    this.deactivateAttempt = 0;
                    self.pointerTolerance = 4;
                    self.isTouch = false;
                    self.disableClick = 0;
                    self.disableClickLimit = 2500;
                    self.tapPolyfill = config.setting('tapPolyfill');
                    function bindDom(type, listener, useCapture) {
                        document.addEventListener(type, listener, useCapture);
                    }
                    bindDom('click', function (ev) {
                        self.click(ev);
                    }, true);
                    bindDom('touchstart', function (ev) {
                        self.isTouch = true;
                        self.pointerStart(ev);
                    });
                    bindDom('touchend', function (ev) {
                        self.isTouch = true;
                        self.touchEnd(ev);
                    });
                    bindDom('touchcancel', function (ev) {
                        self.isTouch = true;
                        self.touchCancel(ev);
                    });
                    bindDom('mousedown', function (ev) {
                        self.mouseDown(ev);
                    }, true);
                    bindDom('mouseup', function (ev) {
                        self.mouseUp(ev);
                    }, true);
                    self.pointerMove = function (ev) {
                        var moveCoord = pointerCoord(ev);
                        console.log('pointerMove', moveCoord, self.start);
                        if (hasPointerMoved(10, self.start, moveCoord)) {
                            self.pointerCancel();
                        }
                    };
                    self.moveListeners = function (shouldAdd) {
                        document.removeEventListener('touchmove', self.pointerMove);
                        document.removeEventListener('mousemove', self.pointerMove);
                        if (shouldAdd) {
                            bindDom('touchmove', self.pointerMove);
                            bindDom('mousemove', self.pointerMove);
                        }
                    };
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(Activator, [{
                    key: 'touchEnd',
                    value: function touchEnd(ev) {
                        var self = this;
                        if (self.tapPolyfill && self.start) {
                            var endCoord = pointerCoord(ev);
                            if (!hasPointerMoved(self.pointerTolerance, self.start, endCoord)) {
                                console.debug('create click');
                                self.disableClick = Date.now();
                                var clickEvent = self.doc.createEvent('MouseEvents');
                                clickEvent.initMouseEvent('click', true, true, self.win, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                clickEvent.isIonicTap = true;
                                ev.target.dispatchEvent(clickEvent);
                            }
                        }
                        self.pointerEnd(ev);
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseDown',
                    value: function mouseDown(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseDown prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else if (!self.isTouch) {
                            this.pointerStart(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'mouseUp',
                    value: function mouseUp(ev) {
                        if (this.isDisabledClick()) {
                            console.debug('mouseUp prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        if (!self.isTouch) {
                            this.pointerEnd(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: 'pointerStart',
                    value: function pointerStart(ev) {
                        var targetEle = this.getActivatableTarget(ev.target);
                        if (targetEle) {
                            this.start = pointerCoord(ev);
                            this.queueActivate(targetEle);
                            this.moveListeners(true);
                        } else {
                            this.start = null;
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerEnd',
                    value: function pointerEnd(ev) {
                        this.queueDeactivate();
                        this.moveListeners(false);
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'pointerCancel',
                    value: function pointerCancel() {
                        console.debug('pointerCancel');
                        this.deactivate();
                        this.moveListeners(false);
                        this.disableClick = Date.now();
                    }
                }, {
                    key: 'isDisabledClick',
                    value: function isDisabledClick() {
                        return this.disableClick + this.disableClickLimit > Date.now();
                    }

                    /**
                     * Whether the supplied click event should be allowed or not.
                     * @param {MouseEvent} ev  The click event.
                     * @return {boolean} True if click event should be allowed, otherwise false.
                     */
                }, {
                    key: 'allowClick',
                    value: function allowClick(ev) {
                        if (!ev.isIonicTap) {
                            if (this.isDisabledClick()) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * TODO
                     * @param {MouseEvent} ev  TODO
                     */
                }, {
                    key: 'click',
                    value: function click(ev) {
                        if (!this.allowClick(ev)) {
                            console.debug('click prevent');
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        this.isTouch = false;
                    }
                }, {
                    key: 'getActivatableTarget',
                    value: function getActivatableTarget(ele) {
                        var targetEle = ele;
                        for (var x = 0; x < 4; x++) {
                            if (!targetEle) break;
                            if (this.isActivatable(targetEle)) return targetEle;
                            targetEle = targetEle.parentElement;
                        }
                        return null;
                    }
                }, {
                    key: 'isActivatable',
                    value: function isActivatable(ele) {
                        if (/^(A|BUTTON)$/.test(ele.tagName)) {
                            return true;
                        }
                        var attributes = ele.attributes;
                        for (var i = 0, l = attributes.length; i < l; i++) {
                            if (/click|tappable/.test(attributes[i].name)) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'queueActivate',
                    value: function queueActivate(ele) {
                        var self = this;
                        self.queue[++self.id] = ele;
                        if (self.id > 19) self.id = 0;
                        raf(function () {
                            // activate all elements in the queue
                            for (var key in self.queue) {
                                if (self.queue[key]) {
                                    self.queue[key].classList.add(self.activatedClass);
                                    self.active[key] = self.queue[key];
                                }
                            }
                            self.queue = {};
                        });
                    }
                }, {
                    key: 'queueDeactivate',
                    value: function queueDeactivate() {
                        var self = this;
                        setTimeout(function () {
                            self.deactivate();
                        }, this.deactivateTimeout);
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        var self = this;
                        if (this.app.isTransitioning() && this.deactivateAttempt < 10) {
                            // the app is actively transitioning, don't bother deactivating
                            // anything this makes it easier on the GPU so it doesn't
                            // have to redraw any buttons during a transition
                            // retry
                            ++this.deactivateAttempt;
                            this.queueDeactivate();
                        } else {
                            // not actively transitioning, good to deactivate any elements
                            // clear out any elements that are queued to be set to active
                            self.queue = {};
                            // in the next frame, remove the active class from all active elements
                            raf(function () {
                                for (var key in self.active) {
                                    if (self.active[key]) {
                                        self.active[key].classList.remove(self.activatedClass);
                                    }
                                    delete self.active[key];
                                }
                            });
                            this.deactivateAttempt = 0;
                        }
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register('ionic/util/click-block', [], function (_export) {
    'use strict';

    var CSS_CLICK_BLOCK, DEFAULT_EXPIRE, cbEle, fallbackTimerId, isShowing, ClickBlock;

    function disableInput(ev) {
        ev.preventDefault();
        ev.stopPropagation();
    }
    function show(expire) {
        clearTimeout(fallbackTimerId);
        fallbackTimerId = setTimeout(hide, expire || DEFAULT_EXPIRE);
        if (!isShowing) {
            isShowing = true;
            if (cbEle) {
                cbEle.classList.add(CSS_CLICK_BLOCK);
            } else {
                cbEle = document.createElement('div');
                cbEle.className = 'click-block ' + CSS_CLICK_BLOCK;
                document.body.appendChild(cbEle);
            }
            cbEle.addEventListener('touchmove', disableInput);
        }
    }
    function hide() {
        clearTimeout(fallbackTimerId);
        if (isShowing) {
            cbEle.classList.remove(CSS_CLICK_BLOCK);
            isShowing = false;
            cbEle.removeEventListener('touchmove', disableInput);
        }
    }
    return {
        setters: [],
        execute: function () {
            CSS_CLICK_BLOCK = 'click-block-active';
            DEFAULT_EXPIRE = 330;
            cbEle = undefined;
            fallbackTimerId = undefined;
            isShowing = false;

            ClickBlock = function ClickBlock(shouldShow, expire) {
                (shouldShow ? show : hide)(expire);
            };

            _export('ClickBlock', ClickBlock);
        }
    };
});
System.register('ionic/util/dom', [], function (_export) {
    'use strict';

    var nativeRaf, nativeCancelRaf, raf, rafCancel, CSS;

    _export('rafPromise', rafPromise);

    _export('transitionEnd', transitionEnd);

    _export('animationStart', animationStart);

    _export('animationEnd', animationEnd);

    _export('ready', ready);

    _export('windowLoad', windowLoad);

    _export('pointerCoord', pointerCoord);

    _export('hasPointerMoved', hasPointerMoved);

    _export('hasFocus', hasFocus);

    _export('isTextInput', isTextInput);

    _export('hasFocusedTextInput', hasFocusedTextInput);

    _export('closest', closest);

    function rafPromise() {
        return new Promise(function (resolve) {
            return raf(resolve);
        });
    }

    function transitionEnd(el) {
        return cssPromise(el, CSS.transitionEnd);
    }

    function animationStart(el, animationName) {
        return cssPromise(el, CSS.animationStart, animationName);
    }

    function animationEnd(el, animationName) {
        return cssPromise(el, CSS.animationEnd, animationName);
    }

    function cssPromise(el, eventNames, animationName) {
        return new Promise(function (resolve) {
            eventNames.split(' ').forEach(function (eventName) {
                el.addEventListener(eventName, onEvent);
            });
            function onEvent(ev) {
                if (ev.animationName && animationName) {
                    // do not resolve if a bubbled up ev.animationName
                    // is not the same as the passed in animationName arg
                    if (ev.animationName !== animationName) {
                        return;
                    }
                } else if (ev.target !== el) {
                    // do not resolve if the event's target element is not
                    // the same as the element the listener was added to
                    return;
                }
                ev.stopPropagation();
                eventNames.split(' ').forEach(function (eventName) {
                    el.removeEventListener(eventName, onEvent);
                });
                resolve(ev);
            }
        });
    }

    function ready(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    document.removeEventListener('DOMContentLoaded', completed, false);
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function windowLoad(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function pointerCoord(ev) {
        // get coordinates for either a mouse click
        // or a touch depending on the given event
        var c = { x: 0, y: 0 };
        if (ev) {
            var touches = ev.touches && ev.touches.length ? ev.touches : [ev];
            var e = ev.changedTouches && ev.changedTouches[0] || touches[0];
            if (e) {
                c.x = e.clientX || e.pageX || 0;
                c.y = e.clientY || e.pageY || 0;
            }
        }
        return c;
    }

    function hasPointerMoved(threshold, startCoord, endCoord) {
        return startCoord && endCoord && (Math.abs(startCoord.x - endCoord.x) > threshold || Math.abs(startCoord.y - endCoord.y) > threshold);
    }

    function hasFocus(ele) {
        return !!(ele && (document.activeElement === ele.nativeElement || document.activeElement === ele));
    }

    function isTextInput(ele) {
        return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || ele.tagName == 'INPUT' && !/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i.test(ele.type));
    }

    function hasFocusedTextInput() {
        var ele = document.activeElement;
        if (isTextInput(ele)) {
            return ele.parentElement.querySelector(':focus') === ele;
        }
        return false;
    }

    function closest(el, selector) {
        var matchesFn;
        // find vendor prefix
        ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'].some(function (fn) {
            if (typeof document.body[fn] == 'function') {
                matchesFn = fn;
                return true;
            }
            return false;
        });
        // traverse parents
        while (el !== null) {
            parent = el.parentElement;
            if (parent !== null && parent[matchesFn](selector)) {
                return parent;
            }
            el = parent;
        }
        return null;
    }

    return {
        setters: [],
        execute: function () {
            nativeRaf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
            nativeCancelRaf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;

            raf = nativeRaf || function (callback) {
                var timeCurrent = new Date().getTime(),
                    timeDelta = undefined;
                /* Dynamically set delay on a per-tick basis to match 60fps. */
                /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
                timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
                timeLast = timeCurrent + timeDelta;
                return setTimeout(function () {
                    callback(timeCurrent + timeDelta);
                }, timeDelta);
            };

            _export('raf', raf);

            rafCancel = nativeRaf ? nativeCancelRaf : function (id) {
                return window.cancelTimeout(id);
            };

            _export('rafCancel', rafCancel);

            CSS = {};

            _export('CSS', CSS);

            (function () {
                // transform
                var i,
                    keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transform = keys[i];
                        break;
                    }
                }
                // transition
                keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transition = keys[i];
                        break;
                    }
                }
                // The only prefix we care about is webkit for transitions.
                var isWebkit = CSS.transition.indexOf('webkit') > -1;
                CSS.prefix = isWebkit ? '-webkit-' : '';
                // transition duration
                CSS.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
                // To be sure transitionend works everywhere, include *both* the webkit and non-webkit events
                CSS.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
            })();
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS.animation = 'WebkitAnimation';
                CSS.animationStart = 'webkitAnimationStart animationstart';
                CSS.animationEnd = 'webkitAnimationEnd animationend';
            } else {
                CSS.animation = 'animation';
                CSS.animationStart = 'animationstart';
                CSS.animationEnd = 'animationend';
            }
        }
    };
});
System.register('ionic/util/focus', ['./dom'], function (_export) {
    /* Focus Outline
     * --------------------------------------------------
     * When a keydown event happens, from a tab key, then the
     * 'key-input' class is added to the body element so focusable
     * elements have an outline. On a mousedown or touchstart
     * event then the 'key-input' class is removed.
     */
    'use strict';

    var raf, ready, isKeyInputEnabled;

    function keyDown(ev) {
        if (!isKeyInputEnabled && ev.keyCode == 9) {
            isKeyInputEnabled = true;
            raf(enableKeyInput);
        }
    }
    function enableKeyInput() {
        document.body.classList[isKeyInputEnabled ? 'add' : 'remove']('key-input');
        if (isKeyInputEnabled) {
            document.addEventListener('mousedown', pointerDown);
            document.addEventListener('touchstart', pointerDown);
        } else {
            document.removeEventListener('mousedown', pointerDown);
            document.removeEventListener('touchstart', pointerDown);
        }
    }
    function pointerDown() {
        isKeyInputEnabled = false;
        raf(enableKeyInput);
    }
    return {
        setters: [function (_dom) {
            raf = _dom.raf;
            ready = _dom.ready;
        }],
        execute: function () {
            isKeyInputEnabled = false;
            ready().then(function () {
                document.addEventListener('keydown', keyDown);
            });
        }
    };
});
System.register('ionic/util/util', [], function (_export) {
    // Simple noop function
    'use strict';

    var isBoolean, isString, isNumber, isFunction, isDefined, isUndefined, isBlank, isObject, isArray, isTrueProperty, uid, Log, array;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export('noop', noop);

    /**
     * Extend the destination with an arbitrary number of other objects.
     * @param dst the destination
     * @param ... the param objects
     */

    _export('clamp', clamp);

    /**
     * Do a deep extend (merge).
     * @param dst the destination
     * @param ... the param objects
     */

    _export('extend', extend);

    _export('merge', merge);

    /**
     * Apply default arguments if they don't exist in
     * the first object.
     * @param the destination to apply defaults to.
     */

    _export('debounce', debounce);

    _export('defaults', defaults);

    _export('pascalCaseToDashCase', pascalCaseToDashCase);

    /**
     * A simple logger class.
     */

    _export('nextUid', nextUid);

    _export('getQuerystring', getQuerystring);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function noop() {}

    /**
     * Given a min and max, restrict the given number
     * to the range.
     * @param min the minimum
     * @param n the value
     * @param max the maximum
     */

    function clamp(min, n, max) {
        return Math.max(min, Math.min(n, max));
    }

    function extend(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), false);
    }

    function merge(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), true);
    }

    function _baseExtend(dst, objs, deep) {
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!obj || !isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                    _baseExtend(dst[key], [src], true);
                } else {
                    dst[key] = src;
                }
            }
        }
        return dst;
    }

    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function () {
            context = this;
            args = arguments;
            timestamp = new Date();
            var later = function later() {
                var last = new Date() - timestamp;
                if (last < wait) {
                    timeout = setTimeout(later, wait - last);
                } else {
                    timeout = null;
                    if (!immediate) result = func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) result = func.apply(context, args);
            return result;
        };
    }

    function defaults(dest) {
        for (var i = arguments.length - 1; i >= 1; i--) {
            var source = arguments[i] || {};
            for (var key in source) {
                if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
        return dest;
    }

    /**
     * Convert a string in the format thisIsAString to a slug format this-is-a-string
     */

    function pascalCaseToDashCase() {
        var str = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

        return str.charAt(0).toLowerCase() + str.substring(1).replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
        });
    }

    function nextUid() {
        return ++uid;
    }

    /**
     * Grab the query string param value for the given key.
     * @param key the key to look for
     */

    function getQuerystring(url, key) {
        var queryParams = {};
        if (url) {
            var startIndex = url.indexOf('?');
            if (startIndex !== -1) {
                var queries = url.slice(startIndex + 1).split('&');
                if (queries.length) {
                    queries.forEach(function (param) {
                        var split = param.split('=');
                        queryParams[split[0]] = split[1].split('#')[0];
                    });
                }
            }
            if (key) {
                return queryParams[key] || '';
            }
        }
        return queryParams;
    }

    return {
        setters: [],
        execute: function () {
            ;
            isBoolean = function isBoolean(val) {
                return typeof val === 'boolean';
            };

            _export('isBoolean', isBoolean);

            isString = function isString(val) {
                return typeof val === 'string';
            };

            _export('isString', isString);

            isNumber = function isNumber(val) {
                return typeof val === 'number';
            };

            _export('isNumber', isNumber);

            isFunction = function isFunction(val) {
                return typeof val === 'function';
            };

            _export('isFunction', isFunction);

            isDefined = function isDefined(val) {
                return typeof val !== 'undefined';
            };

            _export('isDefined', isDefined);

            isUndefined = function isUndefined(val) {
                return typeof val === 'undefined';
            };

            _export('isUndefined', isUndefined);

            isBlank = function isBlank(val) {
                return val === undefined || val === null;
            };

            _export('isBlank', isBlank);

            isObject = function isObject(val) {
                return typeof val === 'object';
            };

            _export('isObject', isObject);

            isArray = Array.isArray;

            _export('isArray', isArray);

            isTrueProperty = function isTrueProperty(val) {
                return typeof val !== 'undefined' && val !== "false";
            };

            _export('isTrueProperty', isTrueProperty);

            uid = 0;

            Log = (function () {
                function Log() {
                    _classCallCheck(this, Log);
                }

                _createClass(Log, null, [{
                    key: 'log',
                    value: function log() {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        console.log.apply(console, args);
                    }
                }, {
                    key: 'info',
                    value: function info() {
                        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }

                        console.info.apply(console, args);
                    }
                }, {
                    key: 'warn',
                    value: function warn() {
                        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                            args[_key3] = arguments[_key3];
                        }

                        console.warn.apply(console, args);
                    }
                }, {
                    key: 'error',
                    value: function error() {
                        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                            args[_key4] = arguments[_key4];
                        }

                        console.error.apply(console, args);
                    }
                }]);

                return Log;
            })();

            _export('Log', Log);

            array = {
                find: function find(arr, cb) {
                    for (var i = 0, ii = arr.length; i < ii; i++) {
                        if (cb(arr[i], i)) return arr[i];
                    }
                },
                remove: function remove(arr, itemOrIndex) {
                    var index = -1;
                    if (isNumber(itemOrIndex)) {
                        index = itemOrIndex;
                    } else {
                        index = arr.indexOf(itemOrIndex);
                    }
                    if (index < 0) {
                        return false;
                    }
                    arr.splice(index, 1);
                    return true;
                }
            };

            _export('array', array);
        }
    };
});
System.register("ionic/components/action-menu/action-menu", ["angular2/angular2", "../icon/icon", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
    * @ngdoc service
    * @name ActionMenu
    * @module ionic
    * @description
    * The ActionMenu is a modal menu with options to select based on an action.
    */

    /**
     * @name ActionMenu
     * @description
     * The Action Menu is a slide-up pane that lets the user choose from a set of options. Dangerous options are made obvious.
     *
     * There are easy ways to cancel out of the action sheet, such as tapping the backdrop or even hitting escape on the keyboard for desktop testing.
     *
     * @usage
     * ```ts
     * openMenu() {
     *
     *   this.actionMenu.open({
     *     buttons: [
     *       { text: 'Share This' },
     *       { text: 'Move' }
     *     ],
     *     destructiveText: 'Delete',
     *     titleText: 'Modify your album',
     *     cancelText: 'Cancel',
     *     cancel: function() {
     *       console.log('Canceled');
     *     },
     *     destructiveButtonClicked: () => {
     *       console.log('Destructive clicked');
     *     },
     *     buttonClicked: function(index) {
     *       console.log('Button clicked', index);
     *       if(index == 1) { return false; }
     *       return true;
     *     }
     *
     *   }).then(actionMenuRef => {
     *     this.actionMenuRef = actionMenuRef;
     *   });
     *
     * }
     * ```
     */
    "use strict";

    var View, Injectable, NgFor, NgIf, Icon, Overlay, Animation, util, __decorate, __metadata, ActionMenuDirective, ActionMenu, OVERLAY_TYPE, ActionMenuAnimation, ActionMenuSlideIn, ActionMenuSlideOut, ActionMenuMdSlideIn, ActionMenuMdSlideOut;

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgFor = _angular2Angular2.NgFor;
            NgIf = _angular2Angular2.NgIf;
        }, function (_iconIcon) {
            Icon = _iconIcon.Icon;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ActionMenuDirective = (function () {
                function ActionMenuDirective() {
                    _classCallCheck(this, ActionMenuDirective);
                }

                _createClass(ActionMenuDirective, [{
                    key: "_cancel",
                    value: function _cancel() {
                        this.cancel && this.cancel();
                        return this.overlayRef.close();
                    }
                }, {
                    key: "_destructive",
                    value: function _destructive() {
                        var shouldClose = this.destructiveButtonClicked();
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_buttonClicked",
                    value: function _buttonClicked(index) {
                        var shouldClose = this.buttonClicked(index);
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return ActionMenuDirective;
            })();

            ActionMenuDirective = __decorate([View({
                template: '<backdrop (click)="_cancel()" tappable></backdrop>' + '<action-menu-wrapper>' + '<div class="action-menu-container">' + '<div class="action-menu-group action-menu-options">' + '<div class="action-menu-title" *ng-if="titleText">{{titleText}}</div>' + '<button (^click)="_buttonClicked(index)" *ng-for="#b of buttons; #index = index" class="action-menu-option">' + '<icon [name]="b.icon" *ng-if="b.icon"></icon> ' + '{{b.text}}' + '</button>' + '<button *ng-if="destructiveText" (click)="_destructive()" class="destructive action-menu-destructive">' + '<icon [name]="destructiveIcon" *ng-if="destructiveIcon"></icon> ' + '{{destructiveText}}</button>' + '</div>' + '<div class="action-menu-group action-menu-cancel" *ng-if="cancelText">' + '<button (click)="_cancel()">' + '<icon [name]="cancelIcon"></icon> ' + '{{cancelText}}</button>' + '</div>' + '</div>' + '</action-menu-wrapper>',
                directives: [NgFor, NgIf, Icon]
            }), __metadata('design:paramtypes', [])], ActionMenuDirective);

            ActionMenu = (function (_Overlay) {
                _inherits(ActionMenu, _Overlay);

                function ActionMenu() {
                    _classCallCheck(this, ActionMenu);

                    _get(Object.getPrototypeOf(ActionMenu.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(ActionMenu, [{
                    key: "open",

                    /**
                     * Create and open a new Action Menu. This is the
                     * public API, and most often you will only use ActionMenu.open()
                     *
                     * @param {Object} [opts={}]  TODO
                     * @return {Promise} Promise that resolves when the action menu is open.
                     */
                    value: function open() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        var config = this.config;
                        var defaults = {
                            enterAnimation: config.setting('actionMenuEnter'),
                            leaveAnimation: config.setting('actionMenuLeave'),
                            cancelIcon: config.setting('actionMenuCancelIcon'),
                            destructiveIcon: config.setting('actionMenuDestructiveIcon')
                        };
                        var context = util.extend(defaults, opts);
                        return this.create(OVERLAY_TYPE, ActionMenuDirective, context, context);
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get() {
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return ActionMenu;
            })(Overlay);

            _export("ActionMenu", ActionMenu);

            _export("ActionMenu", ActionMenu = __decorate([Injectable(), __metadata('design:paramtypes', [])], ActionMenu));
            OVERLAY_TYPE = 'action-menu';

            /**
             * Animations for action sheet
             */

            ActionMenuAnimation = (function (_Animation) {
                _inherits(ActionMenuAnimation, _Animation);

                function ActionMenuAnimation(element) {
                    _classCallCheck(this, ActionMenuAnimation);

                    _get(Object.getPrototypeOf(ActionMenuAnimation.prototype), "constructor", this).call(this, element);
                    this.easing('cubic-bezier(.36, .66, .04, 1)').duration(450);
                    this.backdrop = new Animation(element.querySelector('backdrop'));
                    this.wrapper = new Animation(element.querySelector('action-menu-wrapper'));
                    this.add(this.backdrop, this.wrapper);
                }

                return ActionMenuAnimation;
            })(Animation);

            ActionMenuSlideIn = (function (_ActionMenuAnimation) {
                _inherits(ActionMenuSlideIn, _ActionMenuAnimation);

                function ActionMenuSlideIn(element) {
                    _classCallCheck(this, ActionMenuSlideIn);

                    _get(Object.getPrototypeOf(ActionMenuSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.01, 0.4);
                    this.wrapper.fromTo('translateY', '100%', '0%');
                }

                return ActionMenuSlideIn;
            })(ActionMenuAnimation);

            Animation.register('action-menu-slide-in', ActionMenuSlideIn);

            ActionMenuSlideOut = (function (_ActionMenuAnimation2) {
                _inherits(ActionMenuSlideOut, _ActionMenuAnimation2);

                function ActionMenuSlideOut(element) {
                    _classCallCheck(this, ActionMenuSlideOut);

                    _get(Object.getPrototypeOf(ActionMenuSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.4, 0.01);
                    this.wrapper.fromTo('translateY', '0%', '100%');
                }

                return ActionMenuSlideOut;
            })(ActionMenuAnimation);

            Animation.register('action-menu-slide-out', ActionMenuSlideOut);

            ActionMenuMdSlideIn = (function (_ActionMenuSlideIn) {
                _inherits(ActionMenuMdSlideIn, _ActionMenuSlideIn);

                function ActionMenuMdSlideIn(element) {
                    _classCallCheck(this, ActionMenuMdSlideIn);

                    _get(Object.getPrototypeOf(ActionMenuMdSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.01, 0.26);
                }

                return ActionMenuMdSlideIn;
            })(ActionMenuSlideIn);

            Animation.register('action-menu-md-slide-in', ActionMenuMdSlideIn);

            ActionMenuMdSlideOut = (function (_ActionMenuSlideOut) {
                _inherits(ActionMenuMdSlideOut, _ActionMenuSlideOut);

                function ActionMenuMdSlideOut(element) {
                    _classCallCheck(this, ActionMenuMdSlideOut);

                    _get(Object.getPrototypeOf(ActionMenuMdSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo('opacity', 0.26, 0.01);
                }

                return ActionMenuMdSlideOut;
            })(ActionMenuSlideOut);

            Animation.register('action-menu-md-slide-out', ActionMenuMdSlideOut);
        }
    };
});
System.register("ionic/components/app/app", ["angular2/angular2", "angular2/router", "../../config/config", "../../platform/platform", "../../util/activator", "../action-menu/action-menu", "../modal/modal", "../popup/popup", "../form/focus-holder"], function (_export) {
    /**
     * @name IonicApp
     * @description
     * The base Ionic class that your app inherits from. By inheriting from this class, you will have access to the Ionic API.
     *
     * @usage
     * ```js
     *  @App({
     *    templateUrl: '/app/app.html',
     *  })
     *  class MyApp {
     *
     *    constructor(app: IonicApp) {
     *      this.app = app;
     *    }
     *  }
     *  ```
     * Note: Ionic sets `ion-app` as the selector for the app. Setting a custom selector will override this and cause CSS problems.
     *
     */
    "use strict";

    var Component, View, bootstrap, ElementRef, NgZone, bind, DynamicComponentLoader, Injector, ROUTER_BINDINGS, HashLocationStrategy, LocationStrategy, IonicConfig, Platform, Activator, ActionMenu, Modal, Popup, FocusHolder, __decorate, __metadata, IonicApp, RootAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export("ionicBootstrap", ionicBootstrap);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function initApp(window, document, config) {
        // create the base IonicApp
        var app = new IonicApp();
        app.isRTL(document.documentElement.getAttribute('dir') == 'rtl');
        // load all platform data
        // Platform is a global singleton
        Platform.url(window.location.href);
        Platform.userAgent(window.navigator.userAgent);
        Platform.navigatorPlatform(window.navigator.platform);
        Platform.load(config);
        setTimeout(function () {
            // start listening for resizes XXms after the app starts
            window.addEventListener('resize', Platform.winResize);
        }, 2500);
        return app;
    }

    /**
     * TODO
     *
     * @param {TODO} rootComponentType  TODO
     * @param {TODO} config  TODO
     * @return {Promise} TODO
     */

    function ionicBootstrap(rootComponentType, config) {
        return new Promise(function (resolve) {
            try {
                (function () {
                    // get the user config, or create one if wasn't passed in
                    if (typeof config !== IonicConfig) {
                        config = new IonicConfig(config);
                    }
                    // create the base IonicApp
                    var app = initApp(window, document, config);
                    // copy default platform settings into the user config platform settings
                    // user config platform settings should override default platform settings
                    config.setPlatform(Platform);
                    // config and platform settings have been figured out
                    // apply the correct CSS to the app
                    app.applyBodyCss(document.body, Platform, config);
                    // prepare the ready promise to fire....when ready
                    Platform.prepareReady(config);
                    // TODO: probs need a better way to inject global injectables
                    var activator = new Activator(app, config, window, document);
                    var actionMenu = new ActionMenu(app, config);
                    var modal = new Modal(app, config);
                    var popup = new Popup(app, config);
                    // add injectables that will be available to all child components
                    var appBindings = Injector.resolve([bind(IonicApp).toValue(app), bind(IonicConfig).toValue(config), bind(Activator).toValue(activator), bind(ActionMenu).toValue(actionMenu), bind(Modal).toValue(modal), bind(Popup).toValue(popup), ROUTER_BINDINGS, bind(LocationStrategy).toClass(HashLocationStrategy)]);
                    bootstrap(rootComponentType, appBindings).then(function (appRef) {
                        app.load(appRef);
                        // Adding a anchor to add overlays off of...huh??
                        var elementRefs = appRef._hostComponent.hostView._view.elementRefs;
                        var lastElementRef = elementRefs[1];
                        var injector = lastElementRef.parentView._view.rootElementInjectors[0]._injector;
                        var loader = injector.get(DynamicComponentLoader);
                        loader.loadNextToLocation(RootAnchor, lastElementRef).then(function () {
                            // append the focus holder if its needed
                            if (config.setting('keyboardScrollAssist')) {
                                app.appendComponent(FocusHolder).then(function (ref) {
                                    app.focusHolder(ref.instance);
                                });
                            }
                        })["catch"](function (err) {
                            console.error(err);
                        });
                        resolve(app);
                    })["catch"](function (err) {
                        console.error('ionicBootstrap', err);
                    });
                })();
            } catch (err) {
                console.error(err);
            }
        });
    }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            bootstrap = _angular2Angular2.bootstrap;
            ElementRef = _angular2Angular2.ElementRef;
            NgZone = _angular2Angular2.NgZone;
            bind = _angular2Angular2.bind;
            DynamicComponentLoader = _angular2Angular2.DynamicComponentLoader;
            Injector = _angular2Angular2.Injector;
        }, function (_angular2Router) {
            ROUTER_BINDINGS = _angular2Router.ROUTER_BINDINGS;
            HashLocationStrategy = _angular2Router.HashLocationStrategy;
            LocationStrategy = _angular2Router.LocationStrategy;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_utilActivator) {
            Activator = _utilActivator.Activator;
        }, function (_actionMenuActionMenu) {
            ActionMenu = _actionMenuActionMenu.ActionMenu;
        }, function (_modalModal) {
            Modal = _modalModal.Modal;
        }, function (_popupPopup) {
            Popup = _popupPopup.Popup;
        }, function (_formFocusHolder) {
            FocusHolder = _formFocusHolder.FocusHolder;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IonicApp = (function () {
                /**
                 * TODO
                 */

                function IonicApp() {
                    _classCallCheck(this, IonicApp);

                    this.overlays = [];
                    this._isTransitioning = false;
                    // Our component registry map
                    this.components = {};
                }

                /**
                 * TODO
                 * @param {Object} appRef  TODO
                 */

                _createClass(IonicApp, [{
                    key: "load",
                    value: function load(appRef) {
                        this.ref(appRef);
                        this._zone = appRef.injector.get(NgZone);
                    }

                    /**
                     * TODO
                     * @param {TODO=} val  TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "focusHolder",
                    value: function focusHolder(val) {
                        if (arguments.length) {
                            this._focusHolder = val;
                        }
                        return this._focusHolder;
                    }

                    /**
                     * Sets the document title.
                     * @param {string} val  Value to set the document title to.
                     */
                }, {
                    key: "title",
                    value: function title(val) {
                        // TODO: User angular service
                        document.title = val;
                    }

                    /**
                     * Sets if the app is currently transitioning or not. For example
                     * this is set to `true` while views transition, a modal slides up, an action-menu
                     * slides up, etc. After the transition completes it is set back to `false`.
                     * @param {bool} isTransitioning
                     */
                }, {
                    key: "setTransitioning",
                    value: function setTransitioning(isTransitioning) {
                        this._isTransitioning = !!isTransitioning;
                    }

                    /**
                     * Boolean if the app is actively transitioning or not.
                     * @return {bool}
                     */
                }, {
                    key: "isTransitioning",
                    value: function isTransitioning() {
                        return this._isTransitioning;
                    }

                    /**
                     * TODO
                     * @param {TODO=} val  TODO
                     * @return TODO
                     */
                }, {
                    key: "ref",
                    value: function ref(val) {
                        if (arguments.length) {
                            this._ref = val;
                        }
                        return this._ref;
                    }

                    /**
                     * TODO
                     * @return TODO
                     */
                }, {
                    key: "zoneRun",

                    /**
                     * TODO
                     * @param {Function} fn  TODO
                     */
                    value: function zoneRun(fn) {
                        this._zone.run(fn);
                    }

                    /**
                     * TODO
                     * @param {Function} fn  TODO
                     */
                }, {
                    key: "zoneRunOutside",
                    value: function zoneRunOutside(fn) {
                        this._zone.runOutsideAngular(fn);
                    }

                    /**
                     * Register a known component with a key, for easy lookups later.
                     * @param {TODO} key  The key to use to register the component
                     * @param {TODO} component  The component to register
                     */
                }, {
                    key: "register",
                    value: function register(key, component) {
                        this.components[key] = component;
                    }

                    /**
                     * Unregister a known component with a key.
                     * @param {TODO} key  The key to use to unregister
                     */
                }, {
                    key: "unregister",
                    value: function unregister(key) {
                        delete this.components[key];
                    }

                    /**
                     * Get a registered component with the given type (returns the first)
                     * @param {Object} cls the type to search for
                     * @return the matching component, or undefined if none was found
                     */
                }, {
                    key: "getRegisteredComponent",
                    value: function getRegisteredComponent(cls) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var component = _step.value;

                                if (component instanceof cls) {
                                    return component;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }

                    /**
                     * Get the component for the given key.
                     * @param {TODO} key  TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "getComponent",
                    value: function getComponent(key) {
                        return this.components[key];
                    }

                    /**
                     * Create and append the given component into the root
                     * element of the app.
                     *
                     * @param {TODO} componentType the component to create and insert
                     * @return {Promise} Promise that resolves with the ContainerRef created
                     */
                }, {
                    key: "appendComponent",
                    value: function appendComponent(componentType) {
                        return this.rootAnchor.append(componentType);
                    }

                    /**
                     * TODO
                     *
                     * @param {Element} bodyEle  the body element
                     * @param {TODO} platform  TODO
                     * @param {TODO} config  TODO
                     */
                }, {
                    key: "applyBodyCss",
                    value: function applyBodyCss(bodyEle, platform, config) {
                        var versions = platform.versions();
                        platform.platforms().forEach(function (platformName) {
                            // platform-ios
                            var platformClass = 'platform-' + platformName;
                            bodyEle.classList.add(platformClass);
                            var platformVersion = versions[platformName];
                            if (platformVersion) {
                                // platform-ios9
                                platformClass += platformVersion.major;
                                bodyEle.classList.add(platformClass);
                                // platform-ios9_3
                                bodyEle.classList.add(platformClass + '_' + platformVersion.minor);
                            }
                        });
                        bodyEle.classList.add(config.setting('mode'));
                        /**
                        * Hairline Shim
                        * Add the "hairline" CSS class name to the body tag
                        * if the browser supports subpixels.
                        */
                        if (window.devicePixelRatio >= 2) {
                            var hairlineEle = document.createElement('div');
                            hairlineEle.style.border = '.5px solid transparent';
                            bodyEle.appendChild(hairlineEle);
                            if (hairlineEle.offsetHeight === 1) {
                                bodyEle.classList.add('hairlines');
                            }
                            bodyEle.removeChild(hairlineEle);
                        }
                    }

                    /**
                     * If val is defined, specifies whether app text is RTL.  If val is undefined
                     * returns whether app text is RTL.
                     *
                     * @param {boolean=} val  Boolean specifying whether text is RTL or not.
                     * @returns {boolean} true if app text is RTL, false if otherwise.
                     */
                }, {
                    key: "isRTL",
                    value: function isRTL(val) {
                        if (arguments.length) {
                            this._rtl = val;
                        }
                        return this._rtl;
                    }
                }, {
                    key: "injector",
                    get: function get() {
                        return this._ref.injector;
                    }
                }]);

                return IonicApp;
            })();

            _export("IonicApp", IonicApp);

            RootAnchor = (function () {
                function RootAnchor(app, elementRef, loader) {
                    _classCallCheck(this, RootAnchor);

                    this.elementRef = elementRef;
                    this.loader = loader;
                    app.rootAnchor = this;
                }

                _createClass(RootAnchor, [{
                    key: "append",
                    value: function append(componentType) {
                        return this.loader.loadNextToLocation(componentType, this.elementRef)["catch"](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return RootAnchor;
            })();

            RootAnchor = __decorate([Component({
                selector: 'root-anchor'
            }), View({
                template: ''
            }), __metadata('design:paramtypes', [IonicApp, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof DynamicComponentLoader !== 'undefined' && DynamicComponentLoader || Object])], RootAnchor);
        }
    };
});
System.register("ionic/components/app/id", ["angular2/angular2", "./app"], function (_export) {
    /**
     * IdRef is an easy way to identify unique components in an app and access them
     * no matter where in the UI heirarchy you are. For example, this makes toggling
     * a global side menu feasible from any place in the application.
     */
    "use strict";

    var AppViewManager, ElementRef, Directive, IonicApp, __decorate, __metadata, IdRef;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            AppViewManager = _angular2Angular2.AppViewManager;
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_app) {
            IonicApp = _app.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IdRef = (function () {
                function IdRef(app, elementRef, appViewManager) {
                    _classCallCheck(this, IdRef);

                    this.app = app;
                    this.elementRef = elementRef;
                    this.appViewManager = appViewManager;
                    // Grab the component this directive is attached to
                    this.component = appViewManager.getComponent(elementRef);
                }

                _createClass(IdRef, [{
                    key: "onInit",
                    value: function onInit() {
                        this.app.register(this.id, this.component);
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.app.unregister(this.id);
                    }
                }]);

                return IdRef;
            })();

            _export("IdRef", IdRef);

            _export("IdRef", IdRef = __decorate([Directive({
                selector: '[id]',
                properties: ['id']
            }), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof AppViewManager !== 'undefined' && AppViewManager || Object])], IdRef));
        }
    };
});
System.register("ionic/components/aside/aside-toggle", ["angular2/angular2", "../app/app"], function (_export) {
    /**
    * TODO
    */
    "use strict";

    var Directive, IonicApp, __decorate, __metadata, AsideToggle;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            AsideToggle = (function () {
                /**
                * TODO
                * @param {IonicApp} app  TODO
                */

                function AsideToggle(app) {
                    _classCallCheck(this, AsideToggle);

                    this.app = app;
                }

                _createClass(AsideToggle, [{
                    key: "onInit",
                    value: function onInit() {
                        var toggleTarget = this.asideToggle;
                        // Get the component with this toggleTarget tag, or use "menu" if none
                        this.aside = this.app.getComponent(toggleTarget || 'menu');
                    }

                    /**
                    * TODO
                    * @param {TODO} event  TODO
                    */
                }, {
                    key: "toggle",
                    value: function toggle(event) {
                        this.aside && this.aside.toggle();
                        console.log('Aside toggle');
                    }
                }]);

                return AsideToggle;
            })();

            _export("AsideToggle", AsideToggle);

            _export("AsideToggle", AsideToggle = __decorate([Directive({
                selector: '[aside-toggle]',
                properties: ['asideToggle'],
                host: {
                    '(^click)': 'toggle($event)'
                }
            }), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object])], AsideToggle));
        }
    };
});
System.register("ionic/components/aside/aside", ["angular2/angular2", "../ion", "../app/app", "../../config/config", "../../config/annotations", "./extensions/types", "./extensions/gestures", "ionic/util/util", "ionic/util"], function (_export) {
    /**
     * Aside is a side-menu navigation that can be dragged out or toggled to show. Aside supports two
     * display styles currently: overlay, and reveal. Overlay is the tradtional Android drawer style, and Reveal
     * is the traditional iOS style. By default, Aside will adjust to the correct style for the platform.
     */
    "use strict";

    var forwardRef, Component, Host, View, EventEmitter, ElementRef, Ion, IonicApp, IonicConfig, IonicComponent, types, gestures, util, dom, __decorate, __metadata, __param, Aside, AsideBackdrop;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            forwardRef = _angular2Angular2.forwardRef;
            Component = _angular2Angular2.Component;
            Host = _angular2Angular2.Host;
            View = _angular2Angular2.View;
            EventEmitter = _angular2Angular2.EventEmitter;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_extensionsTypes) {
            types = _extensionsTypes;
        }, function (_extensionsGestures) {
            gestures = _extensionsGestures;
        }, function (_ionicUtilUtil) {
            util = _ionicUtilUtil;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Aside = (function (_Ion) {
                _inherits(Aside, _Ion);

                /**
                * TODO
                * @param {IonicApp} app  TODO
                * @param {ElementRef} elementRef  Reference to the element.
                */

                function Aside(app, elementRef, config) {
                    var _this = this;

                    _classCallCheck(this, Aside);

                    _get(Object.getPrototypeOf(Aside.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    this.opening = new EventEmitter('opening');
                    //this.animation = new Animation(element.querySelector('backdrop'));
                    this.contentClickFn = function (e) {
                        if (!_this.isOpen || _this.isChanging) {
                            return;
                        }
                        _this.close();
                    };
                    this.finishChanging = util.debounce(function () {
                        _this.setChanging(false);
                    });
                    // TODO: Use Animation Class
                    this.getNativeElement().addEventListener('transitionend', function (ev) {
                        //this.setChanging(false)
                        clearTimeout(_this.setChangeTimeout);
                        _this.setChangeTimeout = setInterval(_this.finishChanging, 400);
                    });
                }

                /**
                 * TODO
                 */

                _createClass(Aside, [{
                    key: "onDestroy",
                    value: function onDestroy() {
                        app.unregister(this);
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        _get(Object.getPrototypeOf(Aside.prototype), "onInit", this).call(this);
                        this.contentElement = this.content instanceof Node ? this.content : this.content.getNativeElement();
                        if (!this.id) {
                            // Auto register
                            this.app.register('menu', this);
                        }
                        if (this.contentElement) {
                            this.contentElement.addEventListener('transitionend', function (ev) {
                                //this.setChanging(false)
                                clearTimeout(_this2.setChangeTimeout);
                                _this2.setChangeTimeout = setInterval(_this2.finishChanging, 400);
                            });
                            this.contentElement.addEventListener('click', this.contentClickFn);
                        } else {
                            console.error('Aside: must have a [content] element to listen for drag events on. Supply one like this:\n\n<ion-aside [content]="content"></ion-aside>\n\n<ion-content #content>');
                        }
                        this.gestureDelegate = this.getDelegate('gesture');
                        this.typeDelegate = this.getDelegate('type');
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.contentElement.removeEventListener('click', this.contentClickFn);
                    }

                    /**
                     * TODO
                     * @return {Element} The Aside's content element.
                     */
                }, {
                    key: "getContentElement",
                    value: function getContentElement() {
                        return this.contentElement;
                    }

                    /**
                     * TODO
                     * @param {TODO} v  TODO
                     */
                }, {
                    key: "setOpenAmt",
                    value: function setOpenAmt(v) {
                        this.opening.next(v);
                    }

                    /**
                     * TODO
                     * @param {boolean} willOpen  TODO
                     */
                }, {
                    key: "setDoneTransforming",
                    value: function setDoneTransforming(willOpen) {
                        this.typeDelegate.setDoneTransforming(willOpen);
                    }

                    /**
                     * TODO
                     * @param {TODO} transform  TODO
                     */
                }, {
                    key: "setTransform",
                    value: function setTransform(transform) {
                        this.typeDelegate.setTransform(transform);
                    }

                    /**
                     * TODO
                     * @param {boolean} isSliding  TODO
                     */
                }, {
                    key: "setSliding",
                    value: function setSliding(isSliding) {
                        if (isSliding !== this.isSliding) {
                            this.typeDelegate.setSliding(isSliding);
                        }
                    }

                    /**
                     * TODO
                     * @param {boolean} isChanging  TODO
                     */
                }, {
                    key: "setChanging",
                    value: function setChanging(isChanging) {
                        // Stop any last changing end operations
                        clearTimeout(this.setChangeTimeout);
                        if (isChanging !== this.isChanging) {
                            this.isChanging = isChanging;
                            this.getNativeElement().classList[isChanging ? 'add' : 'remove']('changing');
                        }
                    }

                    /**
                     * Sets the state of the Aside to open or not.
                     * @param {boolean} isOpen  If the Aside is open or not.
                     * @return {Promise} TODO
                     */
                }, {
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this3 = this;

                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            this.setChanging(true);
                            // Set full or closed amount
                            this.setOpenAmt(isOpen ? 1 : 0);
                            return dom.rafPromise().then(function () {
                                _this3.typeDelegate.setOpen(isOpen);
                            });
                        }
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "open",
                    value: function open() {
                        return this.setOpen(true);
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "close",
                    value: function close() {
                        return this.setOpen(false);
                    }

                    /**
                     * TODO
                     * @return {TODO} TODO
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        return this.setOpen(!this.isOpen);
                    }
                }]);

                return Aside;
            })(Ion);

            _export("Aside", Aside);

            _export("Aside", Aside = __decorate([IonicComponent({
                selector: 'ion-aside',
                properties: ['content', 'dragThreshold', 'id'],
                defaultProperties: {
                    'side': 'left',
                    'type': 'reveal'
                },
                delegates: {
                    gesture: [
                    //[instance => instance.side == 'top', gestures.TopAsideGesture],
                    //[instance => instance.side == 'bottom', gestures.BottomAsideGesture],
                    [function (instance) {
                        return instance.side == 'right';
                    }, gestures.RightAsideGesture], [function (instance) {
                        return instance.side == 'left';
                    }, gestures.LeftAsideGesture]],
                    type: [[function (instance) {
                        return instance.type == 'overlay';
                    }, types.AsideTypeOverlay], [function (instance) {
                        return instance.type == 'reveal';
                    }, types.AsideTypeReveal]]
                },
                events: ['opening']
            }), View({
                template: '<ng-content></ng-content><ion-aside-backdrop></ion-aside-backdrop>',
                directives: [forwardRef(function () {
                    return AsideBackdrop;
                })]
            }), __metadata('design:paramtypes', [typeof IonicApp !== 'undefined' && IonicApp || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Aside));
            /**
             * TODO
             */

            AsideBackdrop = (function (_Ion2) {
                _inherits(AsideBackdrop, _Ion2);

                /**
                 * TODO
                 * @param {ElementReg} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {Aside} aside  TODO
                 */

                function AsideBackdrop(elementRef, config, aside) {
                    _classCallCheck(this, AsideBackdrop);

                    _get(Object.getPrototypeOf(AsideBackdrop.prototype), "constructor", this).call(this, elementRef, config);
                    aside.backdrop = this;
                    this.aside = aside;
                    this.opacity = 0;
                }

                /**
                 * TODO
                 */

                _createClass(AsideBackdrop, [{
                    key: "onInit",
                    value: function onInit() {
                        var ww = window.innerWidth;
                        var wh = window.innerHeight;
                        this.width = ww + 'px';
                        this.height = wh + 'px';
                    }

                    /**
                     * TODO
                     * @param {TODO} event  TODO
                     */
                }, {
                    key: "clicked",
                    value: function clicked(event) {
                        this.aside.close();
                    }
                }]);

                return AsideBackdrop;
            })(Ion);

            _export("AsideBackdrop", AsideBackdrop);

            _export("AsideBackdrop", AsideBackdrop = __decorate([Component({
                selector: 'ion-aside-backdrop',
                host: {
                    '[style.width]': 'width',
                    '[style.height]': 'height',
                    '[style.opacity]': 'opacity',
                    '(click)': 'clicked($event)'
                }
            }), View({
                template: ''
            }), __param(2, Host()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, Aside])], AsideBackdrop));
        }
    };
});
System.register("ionic/components/button/button", ["angular2/angular2"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, __decorate, __metadata, Button;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Button = (function () {
                function Button() {
                    _classCallCheck(this, Button);

                    this.iconLeft = this.iconRight = this.iconOnly = false;
                }

                /**
                 * TODO
                 * @param {TODO} icon  TODO
                 */

                _createClass(Button, [{
                    key: "registerIcon",
                    value: function registerIcon(icon) {
                        this.iconLeft = icon.iconLeft;
                        this.iconRight = icon.iconRight;
                        this.iconOnly = icon.iconOnly;
                    }
                }]);

                return Button;
            })();

            _export("Button", Button);

            _export("Button", Button = __decorate([Directive({
                selector: 'button,[button]',
                host: {
                    '[class.icon-left]': 'iconLeft',
                    '[class.icon-right]': 'iconRight',
                    '[class.icon-only]': 'iconOnly'
                }
            }), __metadata('design:paramtypes', [])], Button));
        }
    };
});
System.register("ionic/components/card/card", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicDirective, __decorate, __metadata, Card;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Card = (function (_Ion) {
                _inherits(Card, _Ion);

                /**
                 * TODO
                 * @param {ElementeRef} elementRef  TODO
                 * @param {IonicConfig} ionicConfig  TODO
                 */

                function Card(elementRef, ionicConfig) {
                    _classCallCheck(this, Card);

                    _get(Object.getPrototypeOf(Card.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                }

                return Card;
            })(Ion);

            _export("Card", Card);

            _export("Card", Card = __decorate([IonicDirective({
                selector: 'ion-card'
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Card));
        }
    };
});
System.register("ionic/components/checkbox/checkbox", ["angular2/angular2", "../ion", "../form/input", "../../config/config", "../../config/annotations"], function (_export) {
    /**
     * @name ionCheckbox
     * @description
     * The checkbox is no different than the HTML checkbox input, except it's styled differently
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
     *
     * @usage
     * ```html
     * <ion-checkbox checked="true" value="isChecked" ng-control="htmlCtrl">
     *   HTML5
     * </ion-checkbox>
     * ```
     */
    "use strict";

    var ElementRef, Optional, NgControl, Ion, IonInput, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, __param, Checkbox;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_formInput) {
            IonInput = _formInput.IonInput;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Checkbox = (function (_Ion) {
                _inherits(Checkbox, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} ionicConfig  TODO
                 * @param {NgControl=} ngControl  TODO
                 */

                function Checkbox(elementRef, config, ngControl) {
                    _classCallCheck(this, Checkbox);

                    _get(Object.getPrototypeOf(Checkbox.prototype), "constructor", this).call(this, elementRef, config);
                    this.tabIndex = 0;
                    this.id = IonInput.nextId();
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.ngControl = ngControl;
                    if (ngControl) ngControl.valueAccessor = this;
                }

                /**
                 * TODO
                 */

                _createClass(Checkbox, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Checkbox.prototype), "onInit", this).call(this);
                        this.labelId = 'label-' + this.id;
                    }

                    /**
                     * Toggle the checked state of the checkbox. Calls onChange to pass the
                     * updated checked state to the model (Control).
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.checked = !this.checked;
                        this.onChange(this.checked);
                    }

                    /**
                     * Click event handler to toggle the checkbox checked state.
                     * @param {MouseEvent} ev  The click event.
                     */
                }, {
                    key: "click",
                    value: function click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.toggle();
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the model (Control) on change to update
                     * the checked value.
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.checked = value;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the view (NgControl) to register the
                     * onChange event handler that updates the model (Control).
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L27
                     * @param {Function} fn  the onChange event handler.
                     */
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the the view (NgControl) to register
                     * the onTouched event handler that marks model (Control) as touched.
                     * @param {Function} fn  onTouched event handler.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return Checkbox;
            })(Ion);

            _export("Checkbox", Checkbox);

            _export("Checkbox", Checkbox = __decorate([IonicComponent({
                selector: 'ion-checkbox',
                properties: ['value', 'checked', 'disabled', 'id'],
                host: {
                    'class': 'item',
                    'role': 'checkbox',
                    'tappable': 'true',
                    '[attr.tab-index]': 'tabIndex',
                    '[attr.aria-checked]': 'checked',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'labelId',
                    '(^click)': 'click($event)'
                }
            }), IonicView({
                template: '<div item-left class="item-media media-checkbox">' + '<div class="checkbox-icon"></div>' + '</div>' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>'
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof NgControl !== 'undefined' && NgControl || Object])], Checkbox));
        }
    };
});
System.register("ionic/components/content/content", ["angular2/angular2", "../ion", "../../config/config", "../../animations/scroll-to", "../../util/dom"], function (_export) {
    /**
     * @name ionContent
     * @description
     * The ionContent component provides an easy to use content area that can be configured to use Ionic's custom Scroll View, or the built in overflow scrolling of the browser.
     *
     * While we recommend using the custom Scroll features in Ionic in most cases, sometimes (for performance reasons) only the browser's native overflow scrolling will suffice, and so we've made it easy to toggle between the Ionic scroll implementation and overflow scrolling.
     *
     * You can implement pull-to-refresh with the ionRefresher component.
     *
     * @usage
     * ```html
     * <ion-content>
     *   Add your content here!
     * </ion-content>
     * ```
     *
     */
    "use strict";

    var Component, View, ElementRef, Ion, IonicConfig, ScrollTo, hasFocusedTextInput, __decorate, __metadata, Content;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_animationsScrollTo) {
            ScrollTo = _animationsScrollTo.ScrollTo;
        }, function (_utilDom) {
            hasFocusedTextInput = _utilDom.hasFocusedTextInput;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Content = (function (_Ion) {
                _inherits(Content, _Ion);

                /**
                 * @param {ElementRef} elementRef  A reference to the component's DOM element.
                 * @param {IonicConfig} config  The config object to change content's default settings.
                 */

                function Content(elementRef, config) {
                    _classCallCheck(this, Content);

                    _get(Object.getPrototypeOf(Content.prototype), "constructor", this).call(this, elementRef, config);
                    this.scrollPadding = 0;
                }

                /**
                 * TODO
                 * @private
                 */

                _createClass(Content, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Content.prototype), "onInit", this).call(this);
                        this.scrollElement = this.getNativeElement().children[0];
                    }

                    /**
                     * Adds the specified scroll handler to the content' scroll element.
                     * @param {Function} handler  The scroll event handler.
                     * @returns {Function} A function that removes the scroll handler.
                     */
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        // ensure we're not creating duplicates
                        this.scrollElement.removeEventListener('scroll', handler);
                        this.scrollElement.addEventListener('scroll', handler);
                        return function () {
                            _this.scrollElement.removeEventListener('scroll', handler);
                        };
                    }

                    /**
                     * Adds the specified touchmove handler to the content's scroll element.
                     * @param {Function} handler  The touchmove handler.
                     * @returns {Function} A function that removes the touchmove handler.
                     */
                }, {
                    key: "addTouchMoveListener",
                    value: function addTouchMoveListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        // ensure we're not creating duplicates
                        this.scrollElement.removeEventListener('touchmove', handler);
                        this.scrollElement.addEventListener('touchmove', handler);
                        return function () {
                            _this2.scrollElement.removeEventListener('touchmove', handler);
                        };
                    }

                    /**
                     * Scroll to the specified position.
                     * @param {TODO} x  The x-value to scroll to.
                     * @param {TODO} y  The y-value to scroll to.
                     * @param {Number} duration  Duration of the scroll animation.
                     * @param {TODO} tolerance  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "scrollTo",
                    value: function scrollTo(x, y, duration, tolerance) {
                        if (this._scrollTo) {
                            this._scrollTo.dispose();
                        }
                        this._scrollTo = new ScrollTo(this.scrollElement);
                        return this._scrollTo.start(x, y, duration, tolerance);
                    }

                    /**
                     * Returns the content and scroll elements' dimensions.
                     * @returns {Object} dimensions  The content and scroll elements' dimensions
                     * {Number} dimensions.contentHeight  content offsetHeight
                     * {Number} dimensions.contentTop  content offsetTop
                     * {Number} dimensions.contentBottom  content offsetTop+offsetHeight
                     * {Number} dimensions.contentWidth  content offsetWidth
                     * {Number} dimensions.contentLeft  content offsetLeft
                     * {Number} dimensions.contentRight  content offsetLeft + offsetWidth
                     * {Number} dimensions.scrollHeight  scroll scrollHeight
                     * {Number} dimensions.scrollTop  scroll scrollTop
                     * {Number} dimensions.scrollBottom  scroll scrollTop + scrollHeight
                     * {Number} dimensions.scrollWidth  scroll scrollWidth
                     * {Number} dimensions.scrollLeft  scroll scrollLeft
                     * {Number} dimensions.scrollRight  scroll scrollLeft + scrollWidth
                     * TODO: figure out how to get this to work
                     */
                }, {
                    key: "getDimensions",
                    value: function getDimensions() {
                        var scrollElement = this.scrollElement;
                        var parentElement = scrollElement.parentElement;
                        return {
                            contentHeight: parentElement.offsetHeight,
                            contentTop: parentElement.offsetTop,
                            contentBottom: parentElement.offsetTop + parentElement.offsetHeight,
                            contentWidth: parentElement.offsetWidth,
                            contentLeft: parentElement.offsetLeft,
                            contentRight: parentElement.offsetLeft + parentElement.offsetWidth,
                            scrollHeight: scrollElement.scrollHeight,
                            scrollTop: scrollElement.scrollTop,
                            scrollBottom: scrollElement.scrollTop + scrollElement.scrollHeight,
                            scrollWidth: scrollElement.scrollWidth,
                            scrollLeft: scrollElement.scrollLeft,
                            scrollRight: scrollElement.scrollLeft + scrollElement.scrollWidth
                        };
                    }

                    /**
                     * @private
                     * Adds padding to the bottom of the scroll element when the keyboard is open
                     * so content below the keyboard can be scrolled into view.
                     */
                }, {
                    key: "addKeyboardPadding",
                    value: function addKeyboardPadding(addPadding) {
                        if (addPadding > this.scrollPadding) {
                            this.scrollPadding = addPadding;
                            this.scrollElement.style.paddingBottom = addPadding + 'px';
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "pollFocus",
                    value: function pollFocus() {
                        var _this3 = this;

                        if (hasFocusedTextInput()) {
                            this.isPollingFocus = true;
                            setTimeout(function () {
                                _this3.pollFocus();
                            }, 500);
                        } else {
                            this.isPollingFocus = false;
                            if (this.scrollPadding) {
                                this.scrollPadding = 0;
                                this.scrollElement.style.paddingBottom = '';
                            }
                        }
                    }
                }]);

                return Content;
            })(Ion);

            _export("Content", Content);

            _export("Content", Content = __decorate([Component({
                selector: 'ion-content',
                properties: ['parallax']
            }), View({
                template: '<scroll-content><ng-content></ng-content></scroll-content>'
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Content));
        }
    };
});
System.register("ionic/components/form/focus-holder", ["angular2/angular2", "./input"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Component, Directive, View, Host, Attribute, ElementRef, forwardRef, IonInput, __decorate, __metadata, __param, FocusHolder, FocusInput;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Host = _angular2Angular2.Host;
            Attribute = _angular2Angular2.Attribute;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_input) {
            IonInput = _input.IonInput;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            FocusHolder = (function () {
                /**
                 * TODO
                 */

                function FocusHolder() {
                    _classCallCheck(this, FocusHolder);

                    this.i = [];
                }

                /**
                 * TODO
                 * @param {TODO} inputType  TODO
                 */

                _createClass(FocusHolder, [{
                    key: "setFocusHolder",
                    value: function setFocusHolder(inputType) {
                        this.i[2].type = inputType;
                        this.i[2].setFocus();
                    }

                    /**
                     * TODO
                     * @param {TODO} tabIndex  TODO
                     */
                }, {
                    key: "receivedFocus",
                    value: function receivedFocus(tabIndex) {
                        if (tabIndex === '999') {
                            // focus on the previous input
                            IonInput.focusPrevious();
                        } else if (tabIndex === '1001') {
                            // focus on the next input
                            IonInput.focusNext();
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} input  TODO
                     */
                }, {
                    key: "register",
                    value: function register(input) {
                        this.i.push(input);
                    }
                }]);

                return FocusHolder;
            })();

            _export("FocusHolder", FocusHolder);

            _export("FocusHolder", FocusHolder = __decorate([Component({
                selector: 'focus-holder'
            }), View({
                template: '<input tabindex="999"><input tabindex="1001"><input tabindex="1002">',
                directives: [forwardRef(function () {
                    return FocusInput;
                })]
            }), __metadata('design:paramtypes', [])], FocusHolder));

            FocusInput = (function () {
                function FocusInput(elementRef, holder, tabindex) {
                    _classCallCheck(this, FocusInput);

                    this.elementRef = elementRef;
                    this.holder = holder;
                    this.tabindex = tabindex;
                    this.holder.register(this);
                }

                _createClass(FocusInput, [{
                    key: "setFocus",
                    value: function setFocus() {
                        this.elementRef.nativeElement.focus();
                    }
                }, {
                    key: "keydown",
                    value: function keydown(ev) {
                        // prevent any keyboard typing when a holder has focus
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }, {
                    key: "type",
                    get: function get() {
                        // default to text type if unknown
                        return this._t || 'text';
                    },
                    set: function set(val) {
                        this._t = val;
                    }
                }]);

                return FocusInput;
            })();

            FocusInput = __decorate([Directive({
                selector: 'input',
                host: {
                    '[type]': 'type',
                    '(focus)': 'holder.receivedFocus(tabindex)',
                    '(keydown)': 'keydown($event)'
                }
            }), __param(1, Host()), __param(2, Attribute('tabindex')), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, FocusHolder, String])], FocusInput);
        }
    };
});
System.register('ionic/components/form/input', ['../ion'], function (_export) {
    'use strict';

    var Ion, inputRegistry, inputItemIds, activeInput, lastInput, IonInput;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ion) {
            Ion = _ion.Ion;
        }],
        execute: function () {
            inputRegistry = [];
            inputItemIds = -1;
            activeInput = null;
            lastInput = null;

            /**
             * @name ionInput
             * @description
             * The ionInput component is used to focus text input elements.
             *
             * The `focusNext()` and  `focusPrevious()` methods make it easy to focus input elements across all devices.
             *
             * @usage
             * ```html
             * <ion-input>
             *   <ion-label>Name</ion-label>
             *   <input value="Name" type="text">
             * </ion-input>
             * ```
             */

            IonInput = (function (_Ion) {
                _inherits(IonInput, _Ion);

                function IonInput() {
                    _classCallCheck(this, IonInput);

                    _get(Object.getPrototypeOf(IonInput.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(IonInput, null, [{
                    key: 'registerInput',

                    /**
                     * @param {TODO} input  TODO
                     */
                    value: function registerInput(input) {
                        inputRegistry.push(input);
                    }

                    /**
                     * TODO
                     * @param {TODO} input  TODO
                     */
                }, {
                    key: 'setAsLastInput',
                    value: function setAsLastInput(input) {
                        lastInput = input;
                    }

                    /**
                     * Focuses the previous input element, if it exists.
                     */
                }, {
                    key: 'focusPrevious',
                    value: function focusPrevious() {
                        this.focusMove(-1);
                    }

                    /**
                     * Focuses the next input element, if it exists.
                     */
                }, {
                    key: 'focusNext',
                    value: function focusNext() {
                        this.focusMove(1);
                    }

                    /**
                     * @param {Number} inc TODO
                     */
                }, {
                    key: 'focusMove',
                    value: function focusMove(inc) {
                        var input = activeInput || lastInput;
                        if (input) {
                            var index = inputRegistry.indexOf(input);
                            if (index > -1 && index + inc < inputRegistry.length) {
                                var siblingInput = inputRegistry[index + inc];
                                siblingInput && siblingInput.initFocus();
                            }
                        }
                    }

                    /**
                     * @returns {Number} The ID of the next input element.
                     */
                }, {
                    key: 'nextId',
                    value: function nextId() {
                        return ++inputItemIds;
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'clearTabIndexes',
                    value: function clearTabIndexes() {
                        for (var i = 0; i < inputRegistry.length; i++) {
                            inputRegistry[i].tabIndex = -1;
                        }
                    }
                }]);

                return IonInput;
            })(Ion);

            _export('IonInput', IonInput);
        }
    };
});
System.register("ionic/components/icon/icon", ["angular2/angular2", "../../config/config", "../button/button"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, Optional, Host, Renderer, IonicConfig, Button, __decorate, __metadata, __param, Icon;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Host = _angular2Angular2.Host;
            Renderer = _angular2Angular2.Renderer;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Icon = (function () {
                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {Button} hostButton  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {Renderer} renderer  TODO
                 */

                function Icon(elementRef, hostButton, config, renderer) {
                    _classCallCheck(this, Icon);

                    this.elementRef = elementRef;
                    this.renderer = renderer;
                    this.eleRef = elementRef;
                    this.hostButton = hostButton;
                    this.config = config;
                    this.mode = config.setting('iconMode');
                    this.iconLeft = this.iconRight = this.iconOnly = false;
                    this.ariaHidden = true;
                }

                /**
                 * TODO
                 */

                _createClass(Icon, [{
                    key: "onInit",
                    value: function onInit() {
                        var ele = this.eleRef.nativeElement;
                        if (ele.hasAttribute('forward')) {
                            this.name = this.config.setting('forwardIcon');
                        } else if (this.mode == 'ios' && this.ios) {
                            this.name = this.ios;
                        } else if (this.mode == 'md' && this.md) {
                            this.name = this.md;
                        } else if (!this.name) {
                            // looping through native dom attributes, eww
                            // https://github.com/angular/angular/issues/3961
                            for (var i = 0, l = ele.attributes.length; i < l; i++) {
                                if (ele.attributes[i].value === '' && /_|item-|is-active|large|small|class/.test(ele.attributes[i].name) !== true) {
                                    this.name = ele.attributes[i].name;
                                    break;
                                }
                            }
                        }
                        if (!this.name) return;
                        if (!/^ion-/.test(this.name)) {
                            // not an exact icon being used
                            // add mode specific prefix
                            this.name = 'ion-' + this.mode + '-' + this.name;
                        }
                        if (this.hostButton) {
                            // check if there is a sibling element (that's not aria hidden)
                            var hasPreviousSiblingElement = !!ele.previousElementSibling;
                            var hasNextSiblingElement = ele.nextElementSibling && ele.nextElementSibling.getAttribute('aria-hidden') !== 'true';
                            if (!hasPreviousSiblingElement && !hasNextSiblingElement) {
                                // this icon is within a button, and doesn't have a sibling element
                                // check for text nodes to the right and left of this icon element
                                this.iconLeft = (ele.nextSibling && ele.nextSibling.textContent || '').trim() !== '';
                                this.iconRight = (ele.previousSibling && ele.previousSibling.textContent || '').trim() !== '';
                                this.iconOnly = !this.iconLeft && !this.iconRight;
                            }
                            // tell the button there's a child icon
                            // the button will set the correct css classes on itself
                            this.hostButton.registerIcon(this);
                        }
                        // hide the icon when it's within a button
                        // and the button isn't an icon only button
                        this.ariaHidden = this.hostButton && !this.iconOnly;
                        this.update();
                    }
                }, {
                    key: "update",
                    value: function update() {
                        if (this.name && this.mode == 'ios') {
                            if (this.isActive) {
                                if (/-outline/.test(this.name)) {
                                    this.name = this.name.replace('-outline', '');
                                }
                            } else if (!/-outline/.test(this.name)) {
                                this.name += '-outline';
                            }
                        }
                        if (this._name !== this.name) {
                            if (this._name) {
                                this.renderer.setElementClass(this.elementRef, this._name, false);
                            }
                            this._name = this.name;
                            this.renderer.setElementClass(this.elementRef, this.name, true);
                            if (!this.ariaHidden) {
                                // the icon is either not within a button
                                // or the icon is within a button, and its an icon only button
                                this.label = this.name.replace('ion-', '').replace('ios-', '').replace('md-', '').replace('-', ' ');
                            }
                        }
                    }
                }, {
                    key: "isActive",
                    get: function get() {
                        return this._isActive === undefined || this._isActive === true || this._isActive === 'true';
                    },
                    set: function set(val) {
                        this._isActive = val;
                        this.update();
                    }
                }]);

                return Icon;
            })();

            _export("Icon", Icon);

            _export("Icon", Icon = __decorate([Directive({
                selector: 'icon',
                properties: ['name', 'ios', 'md', 'isActive'],
                host: {
                    '[attr.aria-label]': 'label',
                    '[attr.aria-hidden]': 'ariaHidden',
                    'role': 'img'
                }
            }), __param(1, Optional()), __param(1, Host()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof Button !== 'undefined' && Button || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof Renderer !== 'undefined' && Renderer || Object])], Icon));
        }
    };
});
System.register("ionic/components/item/item-group", ["angular2/angular2"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, __decorate, __metadata, ItemGroup, ItemGroupTitle;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ItemGroup =
            /**
             * TODO
             * @param {ElementRef} elementRef  TODO
             */
            function ItemGroup(elementRef) {
                _classCallCheck(this, ItemGroup);

                this.ele = elementRef.nativeElement;
            };

            _export("ItemGroup", ItemGroup);

            _export("ItemGroup", ItemGroup = __decorate([Directive({
                selector: 'ion-item-group',
                host: {
                    'class': 'item-group'
                }
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object])], ItemGroup));
            /**
             * TODO
             */

            ItemGroupTitle =
            /**
             * TODO
             * @param {ElementRef} elementRef  TODO
             */
            function ItemGroupTitle(elementRef) {
                _classCallCheck(this, ItemGroupTitle);

                this.isSticky = true;
                this.ele = elementRef.nativeElement;
            };

            _export("ItemGroupTitle", ItemGroupTitle);

            _export("ItemGroupTitle", ItemGroupTitle = __decorate([Directive({
                selector: 'ion-item-group-title',
                host: {
                    'class': 'item-group-title',
                    '[class.sticky]': 'isSticky'
                }
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object])], ItemGroupTitle));
        }
    };
});
System.register("ionic/components/item/item-options", [], function (_export) {
    "use strict";

    var __decorate, __metadata, ItemPrimaryOptions, ItemSecondaryOptions;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * TODO
             */

            ItemPrimaryOptions = function ItemPrimaryOptions() {
                _classCallCheck(this, ItemPrimaryOptions);
            };

            _export("ItemPrimaryOptions", ItemPrimaryOptions);

            _export("ItemPrimaryOptions", ItemPrimaryOptions = __decorate([Decorator({
                selector: 'ion-primary-options'
            }), __metadata('design:paramtypes', [])], ItemPrimaryOptions));
            /**
             * TODO
             */

            ItemSecondaryOptions = function ItemSecondaryOptions() {
                _classCallCheck(this, ItemSecondaryOptions);
            };

            _export("ItemSecondaryOptions", ItemSecondaryOptions);

            _export("ItemSecondaryOptions", ItemSecondaryOptions = __decorate([Decorator({
                selector: 'ion-secondary-options'
            }), __metadata('design:paramtypes', [])], ItemSecondaryOptions));
        }
    };
});
System.register("ionic/components/item/item-swipe-buttons", ["angular2/angular2", "ionic/components/item/item", "ionic/gestures/slide-gesture"], function (_export) {
    /**
     * @name ionPrimarySwipeButtons
     * @description
     * Creates a swipeable button inside a list item, that is visible when the item is swiped to the left by the user. Swiped open buttons can be hidden with `setOpen(false)`.
     *
     * @usage
     * TODO
     */
    "use strict";

    var ElementRef, Host, Directive, Item, SlideGesture, __decorate, __metadata, __param, ItemPrimarySwipeButtons, ItemSecondarySwipeButtons, ItemSlideGesture;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Directive = _angular2Angular2.Directive;
        }, function (_ionicComponentsItemItem) {
            Item = _ionicComponentsItemItem.Item;
        }, function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ItemPrimarySwipeButtons = (function () {
                /**
                 * @param {ElementRef} elementRef  A reference to the component's DOM element.
                 * @param {Item} item  The list item containing the swipeable buttons.
                 */

                function ItemPrimarySwipeButtons(elementRef, item) {
                    _classCallCheck(this, ItemPrimarySwipeButtons);

                    item.primarySwipeButtons = this;
                    this.ele = elementRef.nativeElement;
                    this.item = item;
                    this.gesture = new ItemSlideGesture(this);
                    this.gesture.listen();
                }

                /**
                 * @param {boolean} isOpen  Whether or not the button should be set to open/visible.
                 */

                _createClass(ItemPrimarySwipeButtons, [{
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this = this;

                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            requestAnimationFrame(function () {
                                _this.ele.classList[isOpen ? 'add' : 'remove'](isOpen);
                            });
                        }
                    }
                }]);

                return ItemPrimarySwipeButtons;
            })();

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons);

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons = __decorate([Directive({
                selector: 'ion-primary-swipe-buttons'
            }), __param(1, Host()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof Item !== 'undefined' && Item || Object])], ItemPrimarySwipeButtons));
            /**
             * TODO
             */

            ItemSecondarySwipeButtons = function ItemSecondarySwipeButtons() {
                _classCallCheck(this, ItemSecondarySwipeButtons);
            };

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons);

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons = __decorate([Directive({
                selector: 'ion-secondary-swipe-buttons'
            }), __metadata('design:paramtypes', [])], ItemSecondarySwipeButtons));

            ItemSlideGesture = (function (_SlideGesture) {
                _inherits(ItemSlideGesture, _SlideGesture);

                function ItemSlideGesture(buttons) {
                    _classCallCheck(this, ItemSlideGesture);

                    _get(Object.getPrototypeOf(ItemSlideGesture.prototype), "constructor", this).call(this, buttons.item.ele);
                    this.buttons = buttons;
                }

                _createClass(ItemSlideGesture, [{
                    key: "getSlideBoundaries",
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.buttons.ele.offsetWidth,
                            max: 0
                        };
                    }
                }, {
                    key: "getElementStartPos",
                    value: function getElementStartPos(slide, ev) {
                        return this.buttons.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: "onSlideBeforeStart",
                    value: function onSlideBeforeStart() {
                        this.buttons.ele.classList.add('changing');
                        this.buttons.ele.classList.add('no-transition');
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: "onSlide",
                    value: function onSlide(slide, ev) {
                        this.buttons.ele.style.transform = 'translate3d(' + slide.distance + 'px,0,0)';
                    }
                }, {
                    key: "onSlideEnd",
                    value: function onSlideEnd(slide, ev) {
                        this.buttons.ele.style.transform = '';
                        this.buttons.ele.classList.remove('no-transition');
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.buttons.setOpen(!this.buttons.isOpen);
                        }
                    }
                }]);

                return ItemSlideGesture;
            })(SlideGesture);
        }
    };
});
System.register("ionic/components/item/item", ["angular2/angular2", "ionic/util"], function (_export) {
    /**
     * @name ionItem
     * @description
     * Creates a list-item that can easily be swiped,
     * deleted, reordered, edited, and more.
     *
     * @usage
     * ```html
     * <ion-list>
     *   <ion-item *ng-for="#item of items" (^click)="itemTapped($event, item)">
     *     {{item.title}}
     *     <div class="item-note" item-right>
     *       {{item.note}}
     *     </div>
     *   </ion-item>
     * </ion-list>
     *  ```
     */
    "use strict";

    var Component, View, ElementRef, NgIf, dom, __decorate, __metadata, Item, Slideable, ItemSlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            NgIf = _angular2Angular2.NgIf;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Item =
            /**
             * TODO
             * @param {ElementRef} elementRef  A reference to the component's DOM element.
             */
            function Item(elementRef) {
                _classCallCheck(this, Item);

                this._isOpen = false;
                this._isSlideActive = false;
                this._isTransitioning = false;
                this._transform = '';
                this.ele = elementRef.nativeElement;
                this.swipeButtons = {};
                this.optionButtons = {};
            };

            _export("Item", Item);

            _export("Item", Item = __decorate([Component({
                selector: 'ion-item,[ion-item]',
                host: {
                    'class': 'item'
                }
            }), View({
                template: '<ng-content select="[item-left]"></ng-content>' + '<ion-item-content>' + '<ng-content></ng-content>' + '</ion-item-content>' + '<ng-content select="[item-right]"></ng-content>',
                directives: [NgIf]
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object])], Item));

            Slideable = (function () {
                function Slideable(slideElement) {
                    _classCallCheck(this, Slideable);
                }

                // override

                _createClass(Slideable, [{
                    key: "onTransform",
                    value: function onTransform(str) {}

                    // override
                }, {
                    key: "onTransitionActive",
                    value: function onTransitionActive(active) {}

                    //override
                }, {
                    key: "onSlideActive",
                    value: function onSlideActive(active) {}
                }, {
                    key: "transform",
                    value: function transform(str) {
                        if (arguments.length && str !== this._transform) {
                            this.onTransform();
                        }
                    }
                }, {
                    key: "isTransitionActive",
                    value: function isTransitionActive(active) {
                        if (arguments.length && active !== this._isTransitionActive) {
                            this._isTransitionActive = active;
                            this.onSetTransitionActive(active);
                        }
                        return this._isTransitioning;
                    }
                }, {
                    key: "isSlideActive",
                    value: function isSlideActive(active) {
                        if (arguments.length && active !== this._isSlideActive) {
                            this._isSlideActive = active;
                            this.onSetDragActive(active);
                        }
                        return this._isSlideActive;
                    }
                }, {
                    key: "isOpen",
                    value: (function (_isOpen) {
                        function isOpen(_x) {
                            return _isOpen.apply(this, arguments);
                        }

                        isOpen.toString = function () {
                            return _isOpen.toString();
                        };

                        return isOpen;
                    })(function (open) {
                        var _this = this;

                        if (arguments.length && open !== this._isOpen) {
                            this.isTransitionActive(true);
                            dom.raf(function () {
                                _this.isOpen = isOpen;
                                _this.onSetIsOpen(open);
                            });
                        }
                    })
                }]);

                return Slideable;
            })();

            ItemSlideGesture = function ItemSlideGesture() {
                _classCallCheck(this, ItemSlideGesture);
            };
        }
    };
});
System.register("ionic/components/list/list", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations", "./virtual", "ionic/util"], function (_export) {
    /**
     * @name ionList
     * @description
     * The List is a widely used interface element in almost any mobile app, and can include
     * content ranging from basic text all the way to buttons, toggles, icons, and thumbnails.
     *
     * Both the list, which contains items, and the list items themselves can be any HTML
     * element.
     *
     * Using the ionList and ionItem components make it easy to support various
     * interaction modes such as swipe to edit, drag to reorder, and removing items.
     *
     */
    "use strict";

    var Directive, ElementRef, Ion, IonicConfig, IonicDirective, ListVirtualScroll, util, __decorate, __metadata, List, ListHeader;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_virtual) {
            ListVirtualScroll = _virtual.ListVirtualScroll;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            List = (function (_Ion) {
                _inherits(List, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function List(elementRef, config) {
                    _classCallCheck(this, List);

                    _get(Object.getPrototypeOf(List.prototype), "constructor", this).call(this, elementRef, config);
                    this.ele = elementRef.nativeElement;
                }

                /**
                 * TODO
                 */

                _createClass(List, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(List.prototype), "onInit", this).call(this);
                        if (util.isDefined(this.virtual)) {
                            console.log('Content', this.content);
                            console.log('Virtual?', this.virtual);
                            console.log('Items?', this.items.length, 'of \'em');
                            this._initVirtualScrolling();
                        }
                    }

                    /**
                     * @private
                     * TODO
                     */
                }, {
                    key: "_initVirtualScrolling",
                    value: function _initVirtualScrolling() {
                        if (!this.content) {
                            return;
                        }
                        this._virtualScrollingManager = new ListVirtualScroll(this);
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     */
                }, {
                    key: "setItemTemplate",
                    value: function setItemTemplate(item) {
                        this.itemTemplate = item;
                    }
                }]);

                return List;
            })(Ion);

            _export("List", List);

            _export("List", List = __decorate([IonicDirective({
                selector: 'ion-list',
                properties: ['items', 'virtual', 'content']
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], List));
            /**
             * TODO
             */

            ListHeader = function ListHeader() {
                _classCallCheck(this, ListHeader);
            };

            _export("ListHeader", ListHeader);

            _export("ListHeader", ListHeader = __decorate([Directive({
                selector: 'ion-header',
                properties: ['id'],
                host: {
                    '[attr.id]': 'id'
                }
            }), __metadata('design:paramtypes', [])], ListHeader));
        }
    };
});
System.register('ionic/components/list/virtual', [], function (_export) {
    'use strict';

    var ListVirtualScroll, VirtualItemRef;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            ListVirtualScroll = (function () {
                function ListVirtualScroll(list) {
                    var _this = this;

                    _classCallCheck(this, ListVirtualScroll);

                    this.list = list;
                    this.content = this.list.content;
                    this.viewportHeight = this.content.height();
                    this.viewContainer = this.list.itemTemplate.viewContainer;
                    this.itemHeight = 60;
                    this.shownItems = {};
                    this.enteringItems = [];
                    this.leavingItems = [];
                    // Compute the initial sizes
                    setTimeout(function () {
                        _this.resize();
                        // Simulate the first event to start layout
                        _this._handleVirtualScroll({
                            target: _this.content.scrollElement
                        });
                    });
                    this.content.addScrollEventListener(function (event) {
                        _this._handleVirtualScroll(event);
                    });
                }

                _createClass(ListVirtualScroll, [{
                    key: 'resize',
                    value: function resize() {
                        this.viewportHeight = this.content.height();
                        this.viewportScrollHeight = this.content.scrollElement.scrollHeight;
                        this.virtualHeight = this.list.items.length * this.itemHeight;
                        this.itemsPerScreen = this.viewportHeight / this.itemHeight;
                        console.log('VIRTUAL: resize(viewportHeight:', this.viewportHeight, 'viewportScrollHeight:', this.viewportScrollHeight, 'virtualHeight:', this.virtualHeight, ', itemsPerScreen:', this.itemsPerScreen, ')');
                    }
                }, {
                    key: '_handleVirtualScroll',
                    value: function _handleVirtualScroll(event) {
                        var item = undefined;
                        var shownItemRef = undefined;
                        var st = event.target.scrollTop;
                        var sh = event.target.scrollHeight;
                        var topIndex = Math.floor(st / this.itemHeight);
                        var bottomIndex = Math.floor(st / this.itemHeight + this.itemsPerScreen);
                        var items = this.list.items;
                        // Key iterate the shown items map
                        // and compare the index to our index range,
                        // pushing the items to remove to our leaving
                        // list if they're ouside this range.
                        for (var i in this.shownItems) {
                            if (i < topIndex || i > bottomIndex) {
                                this.leavingItems.push(this.shownItems[i]);
                                delete this.shownItems[i];
                            }
                        }
                        var realIndex = 0;
                        // Iterate the set of items that will be rendered, using the
                        // index from the actual items list as the map for the
                        // virtual items we draw
                        for (var i = topIndex, _realIndex = 0; i < bottomIndex && i < items.length; i++, _realIndex++) {
                            item = items[i];
                            console.log('Drawing item', i, item.title);
                            shownItemRef = this.shownItems[i];
                            // Is this a new item?
                            if (!shownItemRef) {
                                var itemView = this.viewContainer.create(this.list.itemTemplate.protoViewRef, _realIndex);
                                itemView.setLocal('\$implicit', item);
                                itemView.setLocal('\$item', item);
                                shownItemRef = new VirtualItemRef(item, i, _realIndex, itemView);
                                this.shownItems[i] = shownItemRef;
                                this.enteringItems.push(shownItemRef);
                            }
                        }
                        while (this.leavingItems.length) {
                            var itemRef = this.leavingItems.pop();
                            console.log('Removing item', itemRef.item, itemRef.realIndex);
                            this.viewContainer.remove(itemRef.realIndex);
                        }
                        console.log('VIRTUAL SCROLL: scroll(scrollTop:', st, 'topIndex:', topIndex, 'bottomIndex:', bottomIndex, ')');
                        console.log('Container has', this.list.getNativeElement().children.length, 'children');
                    }
                }, {
                    key: 'cellAtIndex',
                    value: function cellAtIndex(index) {}
                }]);

                return ListVirtualScroll;
            })();

            _export('ListVirtualScroll', ListVirtualScroll);

            VirtualItemRef = function VirtualItemRef(item, index, realIndex, view) {
                _classCallCheck(this, VirtualItemRef);

                this.item = item;
                this.index = index;
                this.realIndex = realIndex;
                this.view = view;
            };
        }
    };
});
System.register("ionic/components/material/button", ["angular2/angular2", "../../config/config"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Directive, IonicConfig, __decorate, __metadata, MaterialButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            MaterialButton = (function () {
                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function MaterialButton(elementRef, config) {
                    _classCallCheck(this, MaterialButton);

                    this.elementRef = elementRef;
                    this.config = config;
                }

                _createClass(MaterialButton, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.config.setting('mdRipple')) {}
                    }
                }]);

                return MaterialButton;
            })();

            _export("MaterialButton", MaterialButton);

            _export("MaterialButton", MaterialButton = __decorate([Directive({
                selector: 'button,[button]'
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], MaterialButton));
        }
    };
});
System.register('ionic/components/material/ripple', [], function (_export) {
    /**
     * Lovingly Adapted from Material Design Lite
     * Copyright Google, 2015, Licensed under the Apache 2 license.
     * https://github.com/google/material-design-lite
     */
    /**
     * TODO
     */
    'use strict';

    var MaterialRippleEffect;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            MaterialRippleEffect = (function () {
                /**
                 * TODO
                 * @param {MaterialButton} button  TODO
                 */

                function MaterialRippleEffect(button) {
                    _classCallCheck(this, MaterialRippleEffect);

                    this.elementRef = button.elementRef;
                    this.element = this.elementRef.nativeElement;
                    var rippleContainer = document.createElement('span');
                    rippleContainer.classList.add('md-ripple-container');
                    rippleContainer.setAttribute('aria-hidden', 'true');
                    this.rippleElement = document.createElement('span');
                    this.rippleElement.classList.add('md-ripple');
                    rippleContainer.appendChild(this.rippleElement);
                    this.recentering = false; //this.element.classList.contains(this.CssClasses_.RIPPLE_CENTER);
                    this.INITIAL_SCALE = 'scale(0.0001, 0.0001)';
                    this.INITIAL_SIZE = '1px';
                    this.INITIAL_OPACITY = '0.4';
                    this.FINAL_OPACITY = '0';
                    this.FINAL_SCALE = '';
                    //this.boundRippleBlurHandler = this.blurHandler.bind(this);
                    //this.rippleElement_.addEventListener('mouseup', this.boundRippleBlurHandler);
                    this.elementRef.nativeElement.appendChild(rippleContainer);
                    this._initRipple();
                }

                /**
                 * @private
                 * TODO
                 */

                _createClass(MaterialRippleEffect, [{
                    key: '_initRipple',
                    value: function _initRipple() {
                        this.frameCount = 0;
                        this.rippleSize = 0;
                        this.x = 0;
                        this.y = 0;
                        // Touch start produces a compat mouse down event, which would cause a
                        // second ripples. To avoid that, we use this property to ignore the first
                        // mouse down after a touch start.
                        this.ignoringMouseDown = false;
                        this.boundDownHandler = this.downHandler.bind(this);
                        this.element.addEventListener('mousedown', this.boundDownHandler);
                        this.element.addEventListener('touchstart', this.boundDownHandler);
                        this.boundUpHandler = this.upHandler.bind(this);
                        this.element.addEventListener('mouseup', this.boundUpHandler);
                        this.element.addEventListener('mouseleave', this.boundUpHandler);
                        this.element.addEventListener('touchend', this.boundUpHandler);
                        this.element.addEventListener('blur', this.boundUpHandler);
                    }

                    /**
                     * Handle mouse / finger down on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                }, {
                    key: 'downHandler',
                    value: function downHandler(event) {
                        'use strict';
                        if (!this.rippleElement.style.width && !this.rippleElement.style.height) {
                            var rect = this.element.getBoundingClientRect();
                            this.boundHeight = rect.height;
                            this.boundWidth = rect.width;
                            this.rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
                            this.rippleElement.style.width = this.rippleSize + 'px';
                            this.rippleElement.style.height = this.rippleSize + 'px';
                        }
                        this.rippleElement.classList.add('is-visible');
                        if (event.type === 'mousedown' && this.ignoringMouseDown) {
                            this.ignoringMouseDown = false;
                        } else {
                            if (event.type === 'touchstart') {
                                this.ignoringMouseDown = true;
                            }
                            var frameCount = this.getFrameCount();
                            if (frameCount > 0) {
                                return;
                            }
                            this.setFrameCount(1);
                            var bound = event.currentTarget.getBoundingClientRect();
                            var x;
                            var y;
                            // Check if we are handling a keyboard click.
                            if (event.clientX === 0 && event.clientY === 0) {
                                x = Math.round(bound.width / 2);
                                y = Math.round(bound.height / 2);
                            } else {
                                var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                                var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                                x = Math.round(clientX - bound.left);
                                y = Math.round(clientY - bound.top);
                            }
                            this.setRippleXY(x, y);
                            this.setRippleStyles(true);
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        }
                    }

                    /**
                     * Handle mouse / finger up on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                }, {
                    key: 'upHandler',
                    value: function upHandler(event) {
                        'use strict';
                        // Don't fire for the artificial "mouseup" generated by a double-click.
                        if (event && event.detail !== 2) {
                            setTimeout((function () {
                                this.rippleElement.classList.remove('is-visible');
                            }).bind(this), 150);
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getFrameCount',
                    value: function getFrameCount() {
                        return this.frameCount;
                    }

                    /**
                     * TODO
                     * @param {TODO} fC TODO
                     */
                }, {
                    key: 'setFrameCount',
                    value: function setFrameCount(fC) {
                        this.frameCount = fC;
                    }

                    /**
                     * TODO
                     * @return {Element} TODO
                     */
                }, {
                    key: 'getRippleElement',
                    value: function getRippleElement() {
                        return this.rippleElement;
                    }

                    /**
                     * TODO
                     * @param {number} newX  TODO
                     * @param {number} newY  TODO
                     */
                }, {
                    key: 'setRippleXY',
                    value: function setRippleXY(newX, newY) {
                        this.x = newX;
                        this.y = newY;
                    }

                    /**
                     * TODO
                     * @param {TODO} start  TODO
                     */
                }, {
                    key: 'setRippleStyles',
                    value: function setRippleStyles(start) {
                        if (this.rippleElement !== null) {
                            var transformString;
                            var scale;
                            var size;
                            var offset = 'translate(' + this.x + 'px, ' + this.y + 'px)';
                            if (start) {
                                scale = this.INITIAL_SCALE;
                                size = this.INITIAL_SIZE;
                            } else {
                                scale = this.FINAL_SCALE;
                                size = this.rippleSize + 'px';
                                if (this.recentering) {
                                    offset = 'translate(' + this.boundWidth / 2 + 'px, ' + this.boundHeight / 2 + 'px)';
                                }
                            }
                            transformString = 'translate(-50%, -50%) ' + offset + scale;
                            this.rippleElement.style.webkitTransform = transformString;
                            this.rippleElement.style.msTransform = transformString;
                            this.rippleElement.style.transform = transformString;
                            if (start) {
                                this.rippleElement.classList.remove('md-ripple-animating');
                            } else {
                                this.rippleElement.classList.add('md-ripple-animating');
                            }
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'animFrameHandler',
                    value: function animFrameHandler() {
                        if (this.frameCount-- > 0) {
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        } else {
                            this.setRippleStyles(false);
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'elementClicked',
                    value: function elementClicked(event) {}
                }]);

                return MaterialRippleEffect;
            })();

            _export('MaterialRippleEffect', MaterialRippleEffect);
        }
    };
});
System.register("ionic/components/modal/modal", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
     * @name ionModal
     * @description
     * The Modal is a content pane that can go over the user's main view temporarily. Usually used for making a choice or editing an item.
     *
     * @usage
     * ```ts
     * class MyApp {
     *
     *  constructor(modal: Modal, app: IonicApp, ionicConfig: IonicConfig) {
     *    this.modal = modal;
     *  }
     *
     *  openModal() {
     *    this.modal.open(ContactModal, {
     *      enterAnimation: 'my-fade-in',
     *      leaveAnimation: 'my-fade-out',
     *      handle: 'my-modal'
     *    });
     *  }
     * }
     * ```
     */
    "use strict";

    var Injectable, Overlay, Animation, util, __decorate, __metadata, Modal, OVERLAY_TYPE, ModalSlideIn, ModalSlideOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Injectable = _angular2Angular2.Injectable;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Modal = (function (_Overlay) {
                _inherits(Modal, _Overlay);

                function Modal() {
                    _classCallCheck(this, Modal);

                    _get(Object.getPrototypeOf(Modal.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(Modal, [{
                    key: "open",

                    /**
                     * TODO
                     * @param {Type} ComponentType  TODO
                     * @param {Object} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                    value: function open(ComponentType) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var defaults = {
                            enterAnimation: 'modal-slide-in',
                            leaveAnimation: 'modal-slide-out'
                        };
                        return this.create(OVERLAY_TYPE, ComponentType, util.extend(defaults, opts));
                    }

                    /**
                     * TODO
                     * @param {TODO} handle  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return Modal;
            })(Overlay);

            _export("Modal", Modal);

            _export("Modal", Modal = __decorate([Injectable(), __metadata('design:paramtypes', [])], Modal));
            OVERLAY_TYPE = 'modal';

            /**
             * Animations for modals
             */

            ModalSlideIn = (function (_Animation) {
                _inherits(ModalSlideIn, _Animation);

                function ModalSlideIn(element) {
                    _classCallCheck(this, ModalSlideIn);

                    _get(Object.getPrototypeOf(ModalSlideIn.prototype), "constructor", this).call(this, element);
                    this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                return ModalSlideIn;
            })(Animation);

            Animation.register('modal-slide-in', ModalSlideIn);

            ModalSlideOut = (function (_Animation2) {
                _inherits(ModalSlideOut, _Animation2);

                function ModalSlideOut(element) {
                    _classCallCheck(this, ModalSlideOut);

                    _get(Object.getPrototypeOf(ModalSlideOut.prototype), "constructor", this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                return ModalSlideOut;
            })(Animation);

            Animation.register('modal-slide-out', ModalSlideOut);
        }
    };
});
System.register("ionic/components/nav/anchors", ["angular2/angular2", "angular2/src/core/compiler/view_container_ref", "./pane", "../view/view-controller"], function (_export) {
    "use strict";

    var Component, View, Directive, Host, ElementRef, forwardRef, Inject, ViewContainerRef, Pane, ViewController, __decorate, __metadata, __param, PaneAnchor, PaneContentAnchor, NavBarAnchor, NavBarContainer;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Inject = _angular2Angular2.Inject;
        }, function (_angular2SrcCoreCompilerView_container_ref) {
            ViewContainerRef = _angular2SrcCoreCompilerView_container_ref.ViewContainerRef;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneAnchor = function PaneAnchor(pane, elementRef) {
                _classCallCheck(this, PaneAnchor);

                pane.sectionAnchorElementRef = elementRef;
            };

            _export("PaneAnchor", PaneAnchor);

            _export("PaneAnchor", PaneAnchor = __decorate([Directive({ selector: 'template[pane-anchor]' }), __param(0, Host()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata('design:paramtypes', [typeof Pane !== 'undefined' && Pane || Object, typeof ElementRef !== 'undefined' && ElementRef || Object])], PaneAnchor));

            PaneContentAnchor = function PaneContentAnchor(pane, viewContainerRef) {
                _classCallCheck(this, PaneContentAnchor);

                pane.contentContainerRef = viewContainerRef;
            };

            _export("PaneContentAnchor", PaneContentAnchor);

            _export("PaneContentAnchor", PaneContentAnchor = __decorate([Directive({ selector: 'template[content-anchor]' }), __param(0, Host()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata('design:paramtypes', [typeof Pane !== 'undefined' && Pane || Object, typeof ViewContainerRef !== 'undefined' && ViewContainerRef || Object])], PaneContentAnchor));

            NavBarAnchor = function NavBarAnchor(viewCtrl, viewContainerRef) {
                _classCallCheck(this, NavBarAnchor);

                viewCtrl.navbarViewContainer(viewContainerRef);
            };

            NavBarAnchor = __decorate([Directive({
                selector: 'template[navbar-anchor]'
            }), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __metadata('design:paramtypes', [typeof ViewController !== 'undefined' && ViewController || Object, typeof ViewContainerRef !== 'undefined' && ViewContainerRef || Object])], NavBarAnchor);

            NavBarContainer = function NavBarContainer() {
                _classCallCheck(this, NavBarContainer);
            };

            _export("NavBarContainer", NavBarContainer);

            _export("NavBarContainer", NavBarContainer = __decorate([Component({
                selector: 'section',
                host: {
                    'class': 'navbar-container'
                }
            }), View({
                template: '<template navbar-anchor></template>',
                directives: [NavBarAnchor]
            }), __metadata('design:paramtypes', [])], NavBarContainer));
        }
    };
});
System.register("ionic/components/nav/nav-controller", [], function (_export) {
  /**
   * TODO
   */
  "use strict";

  var NavController, NavParams;

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  return {
    setters: [],
    execute: function () {
      NavController = (function () {
        /**
         * TODO
         * @param {TODO} nav  TODO
         */

        function NavController(nav) {
          _classCallCheck(this, NavController);

          this._nav = nav;
        }

        /**
         * TODO
         */

        /**
         * Set the history stack to match the list of component items.
         * @param {TODO} items  TODO
         * @return {TODO} TODO
         */

        _createClass(NavController, [{
          key: "setItems",
          value: function setItems(items) {
            return this._nav.setItems(items);
          }

          /**
           * Clear the history stack.
           * @return {TODO} TODO
           */
        }, {
          key: "clear",
          value: function clear() {
            return this._nav.clear();
          }

          /**
           * Push a new component onto the history stack.
           * @return {TODO} TODO
           */
        }, {
          key: "push",
          value: function push() {
            return this._nav.push.apply(this._nav, arguments);
          }

          /**
           * Pop the top most (visible) component off the history stack.
           * @return {TODO} TODO
           */
        }, {
          key: "pop",
          value: function pop() {
            return this._nav.pop.apply(this._nav, arguments);
          }
        }]);

        return NavController;
      })();

      _export("NavController", NavController);

      NavParams = (function () {
        /**
         * TODO
         * @param {TODO} data  TODO
         */

        function NavParams(data) {
          _classCallCheck(this, NavParams);

          this.data = data || {};
        }

        /**
         * TODO
         * @param {TODO} param  TODO
         */

        _createClass(NavParams, [{
          key: "get",
          value: function get(param) {
            return this.data[param];
          }
        }]);

        return NavParams;
      })();

      _export("NavParams", NavParams);
    }
  };
});
System.register("ionic/components/nav/nav-push", ["angular2/angular2", "./nav-controller"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, NavController, __decorate, __metadata, NavPush, NavPop;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_navController) {
            NavController = _navController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            NavPush = (function () {
                /**
                 * TODO
                 * @param {NavController} nav  TODO
                 */

                function NavPush(nav) {
                    _classCallCheck(this, NavPush);

                    this.nav = nav;
                }

                _createClass(NavPush, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.push(this.navPush, this.pushData);
                    }
                }]);

                return NavPush;
            })();

            _export("NavPush", NavPush);

            _export("NavPush", NavPush = __decorate([Directive({
                selector: '[nav-push]',
                properties: ['navPush', 'pushData'],
                host: {
                    '(^click)': 'onClick($event)',
                    'role': 'link'
                }
            }), __metadata('design:paramtypes', [typeof NavController !== 'undefined' && NavController || Object])], NavPush));
            /**
             * TODO
             */

            NavPop = (function () {
                /**
                 * TODO
                 * @param {NavController} nav  TODO
                 */

                function NavPop(nav) {
                    _classCallCheck(this, NavPop);

                    this.nav = nav;
                }

                _createClass(NavPop, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.pop();
                    }
                }]);

                return NavPop;
            })();

            _export("NavPop", NavPop);

            _export("NavPop", NavPop = __decorate([Directive({
                selector: '[nav-pop]',
                host: {
                    '(^click)': 'onClick($event)',
                    'role': 'link'
                }
            }), __metadata('design:paramtypes', [typeof NavController !== 'undefined' && NavController || Object])], NavPop));
        }
    };
});
System.register("ionic/components/nav/nav-router", ["angular2/angular2", "angular2/router", "./nav"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, ElementRef, DynamicComponentLoader, Attribute, RouterOutlet, Router, Instruction, Nav, __decorate, __metadata, __param, NavRouter;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            DynamicComponentLoader = _angular2Angular2.DynamicComponentLoader;
            Attribute = _angular2Angular2.Attribute;
        }, function (_angular2Router) {
            RouterOutlet = _angular2Router.RouterOutlet;
            Router = _angular2Router.Router;
            Instruction = _angular2Router.Instruction;
        }, function (_nav) {
            Nav = _nav.Nav;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            NavRouter = (function (_RouterOutlet) {
                _inherits(NavRouter, _RouterOutlet);

                /**
                 * TODO
                 * @param {ElementRef} _elementRef  TODO
                 * @param {DynamicComponentLoader} _loader  TODO
                 * @param {Router} _parentRouter  TODO
                 * @param {string} nameAttr  Value of the element's 'name' attribute
                 * @param {Nav} nav  TODO
                 */

                function NavRouter(_elementRef, _loader, _parentRouter, nameAttr, nav) {
                    _classCallCheck(this, NavRouter);

                    _get(Object.getPrototypeOf(NavRouter.prototype), "constructor", this).call(this, _elementRef, _loader, _parentRouter, nameAttr);
                    // Nav is Ionic's ViewController, which we injected into this class
                    this.nav = nav;
                    // register this router with Ionic's ViewController
                    // Ionic's ViewController will call this NavRouter's "stateChange"
                    // method when the ViewController has...changed its state
                    nav.registerRouter(this);
                }

                /**
                 * @private
                 * TODO
                 * @param {ComponentInstruction} instruction  TODO
                 */

                _createClass(NavRouter, [{
                    key: "_activate",
                    value: function _activate(instruction) {
                        var previousInstruction = this._currentInstruction;
                        this._currentInstruction = instruction;
                        var componentType = instruction.componentType;
                        this.childRouter = this._parentRouter.childRouter(componentType);
                        // tell the ViewController which componentType, and it's params, to navigate to
                        this.nav.push(componentType, instruction.params);
                    }

                    /**
                     * TODO
                     * @param {TODO} type  TODO
                     * @param {TODO} viewItem  TODO
                     */
                }, {
                    key: "stateChange",
                    value: function stateChange(type, viewItem) {
                        // stateChange is called by Ionic's ViewController
                        // type could be "push" or "pop"
                        // viewItem is Ionic's ViewItem class, which has the properties "componentType" and "params"
                        // only do an update if there's an actual view change
                        if (!viewItem || this._activeViewId === viewItem.id) return;
                        this._activeViewId = viewItem.id;
                        // get the best PathRecognizer for this view's componentType
                        var pathRecognizer = this.getPathRecognizerByComponent(viewItem.componentType);
                        if (pathRecognizer) {
                            // generate a componentInstruction from the view's PathRecognizer and params
                            var componentInstruction = pathRecognizer.generate(viewItem.params.data);
                            // create an Instruction from the componentInstruction
                            var instruction = new Instruction(componentInstruction, null);
                            // update the browser's URL
                            this._parentRouter.navigateInstruction(instruction);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} componentType  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "getPathRecognizerByComponent",
                    value: function getPathRecognizerByComponent(componentType) {
                        // given a componentType, figure out the best PathRecognizer to use
                        var rules = this._parentRouter.registry._rules;
                        var pathRecognizer = null;
                        rules.forEach(function (rule) {
                            pathRecognizer = rule.matchers.find(function (matcherPathRecognizer) {
                                return matcherPathRecognizer.handler.componentType === componentType;
                            });
                        });
                        return pathRecognizer;
                    }
                }]);

                return NavRouter;
            })(RouterOutlet);

            _export("NavRouter", NavRouter);

            _export("NavRouter", NavRouter = __decorate([Directive({
                selector: 'ion-nav'
            }), __param(3, Attribute('name')), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof DynamicComponentLoader !== 'undefined' && DynamicComponentLoader || Object, typeof Router !== 'undefined' && Router || Object, String, typeof Nav !== 'undefined' && Nav || Object])], NavRouter));
        }
    };
});
System.register("ionic/components/nav/nav", ["angular2/angular2", "../../config/annotations", "../view/view-controller"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, View, ElementRef, Host, Optional, forwardRef, Injector, NgZone, IonicComponent, ViewController, __decorate, __metadata, __param, Nav, NavPaneAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            NgZone = _angular2Angular2.NgZone;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Nav = (function (_ViewController) {
                _inherits(Nav, _ViewController);

                /**
                 * TODO
                 * @param {ViewController} hostViewCtrl  TODO
                 * @param {Injector} injector  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {NgZone} zone  TODO
                 */

                function Nav(hostViewCtrl, injector, elementRef, zone) {
                    _classCallCheck(this, Nav);

                    _get(Object.getPrototypeOf(Nav.prototype), "constructor", this).call(this, hostViewCtrl, injector, elementRef, zone);
                }

                /**
                 * TODO
                 */

                _createClass(Nav, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Nav.prototype), "onInit", this).call(this);
                        if (this.root) {
                            this.push(this.root);
                        }
                        // default the swipe back to be enabled
                        var isSwipeBackEnabled = (this.swipeBackEnabled || '').toString() !== 'false';
                        this.isSwipeBackEnabled(isSwipeBackEnabled);
                    }
                }]);

                return Nav;
            })(ViewController);

            _export("Nav", Nav);

            _export("Nav", Nav = __decorate([IonicComponent({
                selector: 'ion-nav',
                properties: ['root'],
                defaultProperties: {
                    'swipeBackEnabled': true
                }
            }), View({
                template: '<template pane-anchor></template>',
                directives: [forwardRef(function () {
                    return NavPaneAnchor;
                })]
            }), __param(0, Optional()), __metadata('design:paramtypes', [typeof ViewController !== 'undefined' && ViewController || Object, typeof Injector !== 'undefined' && Injector || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof NgZone !== 'undefined' && NgZone || Object])], Nav));

            NavPaneAnchor = function NavPaneAnchor(nav, elementRef) {
                _classCallCheck(this, NavPaneAnchor);

                nav.anchorElementRef(elementRef);
            };

            NavPaneAnchor = __decorate([Directive({ selector: 'template[pane-anchor]' }), __param(0, Host()), __metadata('design:paramtypes', [Nav, typeof ElementRef !== 'undefined' && ElementRef || Object])], NavPaneAnchor);
        }
    };
});
System.register("ionic/components/nav/pane", ["angular2/angular2", "../ion", "../../config/config", "../view/view-controller", "./swipe-handle", "../../config/annotations", "./anchors"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var View, ElementRef, Inject, forwardRef, Injector, bind, Ion, IonicConfig, ViewController, SwipeHandle, IonicComponent, PaneAnchor, PaneContentAnchor, NavBarContainer, __decorate, __metadata, __param, PaneController, Pane;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_swipeHandle) {
            SwipeHandle = _swipeHandle.SwipeHandle;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_anchors) {
            PaneAnchor = _anchors.PaneAnchor;
            PaneContentAnchor = _anchors.PaneContentAnchor;
            NavBarContainer = _anchors.NavBarContainer;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneController = (function () {
                /**
                 * TODO
                 * @param {ViewController} viewCtrl  TODO
                 */

                function PaneController(viewCtrl) {
                    _classCallCheck(this, PaneController);

                    this.panes = [];
                    this.viewCtrl = viewCtrl;
                    this.bindings = Injector.resolve([bind(ViewController).toValue(viewCtrl)]);
                }

                /**
                 * TODO
                 * @param {TODO} nav  TODO
                 * @param {Function} nav  TODO
                 */

                _createClass(PaneController, [{
                    key: "get",
                    value: function get(itemStructure, callback) {
                        var _this = this;

                        // this gets or creates the Pane which similar nav items live in
                        // Nav items with just a navbar/content would all use the same Pane
                        // Tabs and view's without a navbar would get a different Panes
                        var key = itemStructure.key;
                        var viewCtrl = this.viewCtrl;
                        var pane = this.panes[this.panes.length - 1];
                        if (pane && pane.key === key) {
                            // the last pane's structure is the same as the one the item needs to go in
                            callback(pane);
                        } else {
                            // create a new nav pane
                            viewCtrl.loader.loadNextToLocation(Pane, viewCtrl.anchorElementRef(), this.bindings).then(function (componentRef) {
                                // get the pane reference
                                pane = _this.newPane;
                                _this.newPane = null;
                                var sectionAnchorElementRef = pane && pane.sectionAnchorElementRef;
                                if (!sectionAnchorElementRef) {
                                    return callback();
                                }
                                pane.key = key;
                                pane.dispose = function () {
                                    componentRef.dispose();
                                    _this.panes.splice(_this.panes.indexOf(pane), 1);
                                };
                                _this.panes.push(pane);
                                var promises = [];
                                var sectionsToAdd = [];
                                // decide which sections should be added to this Pane, ie: nav bars, footers, etc.
                                // add only the sections it needs
                                if (itemStructure.navbar) {
                                    sectionsToAdd.push(NavBarContainer);
                                }
                                // add the sections which this type of Pane requires
                                sectionsToAdd.forEach(function (SectionClass) {
                                    // as each section is compiled and added to the Pane
                                    // the section will add a reference to itself in the Pane's sections object
                                    promises.push(viewCtrl.loader.loadNextToLocation(SectionClass, sectionAnchorElementRef));
                                });
                                // wait for all of the sections to resolve
                                Promise.all(promises).then(function () {
                                    callback(pane);
                                }, function (err) {
                                    console.error(err);
                                });
                            }, function (loaderErr) {
                                console.error(loaderErr);
                            })["catch"](function (err) {
                                console.error(err);
                            });
                        }
                    }
                }, {
                    key: "add",
                    value: function add(pane) {
                        this.newPane = pane;
                    }
                }]);

                return PaneController;
            })();

            _export("PaneController", PaneController);

            Pane = (function (_Ion) {
                _inherits(Pane, _Ion);

                function Pane(viewCtrl, elementRef, ionicConfig) {
                    _classCallCheck(this, Pane);

                    _get(Object.getPrototypeOf(Pane.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    viewCtrl.panes.add(this);
                    this.totalItems = 0;
                    this.zIndex = ++viewCtrl.zIndexes;
                }

                return Pane;
            })(Ion);

            _export("Pane", Pane);

            _export("Pane", Pane = __decorate([IonicComponent({
                selector: 'ion-pane',
                classId: 'nav',
                host: {
                    '[style.z-index]': 'zIndex'
                }
            }), View({
                template: "\n    <template pane-anchor></template>\n    <section class=\"content-container\">\n      <template content-anchor></template>\n      <div class=\"swipe-handle\"></div>\n    </section>\n  ",
                directives: [PaneAnchor, PaneContentAnchor, SwipeHandle]
            }), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __metadata('design:paramtypes', [typeof ViewController !== 'undefined' && ViewController || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Pane));
        }
    };
});
System.register("ionic/components/nav/swipe-handle", ["angular2/angular2", "../view/view-controller", "./pane", "ionic/gestures/gesture"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Directive, Host, Optional, Inject, forwardRef, NgZone, ViewController, Pane, Gesture, __decorate, __metadata, __param, SwipeHandle;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            NgZone = _angular2Angular2.NgZone;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SwipeHandle = (function () {
                /**
                 * TODO
                 * @param {ViewController=} viewCtrl  TODO
                 * @param {Pane} pane  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {NgZone} ngZone  TODO
                 */

                function SwipeHandle(viewCtrl, pane, elementRef, ngZone) {
                    _classCallCheck(this, SwipeHandle);

                    if (!viewCtrl || !viewCtrl.isSwipeBackEnabled() || !pane) return;
                    var self = this;
                    self.pane = pane;
                    self.viewCtrl = viewCtrl;
                    self.zone = ngZone;
                    this.zone.runOutsideAngular(function () {
                        var gesture = self.gesture = new Gesture(elementRef.nativeElement);
                        gesture.listen();
                        function dragHorizontal(ev) {
                            self.onDragHorizontal(ev);
                        }
                        gesture.on('panend', function (gestureEv) {
                            self.onDragEnd(gestureEv.gesture);
                        });
                        gesture.on('panleft', dragHorizontal);
                        gesture.on('panright', dragHorizontal);
                    });
                    self.startX = null;
                    self.width = null;
                }

                _createClass(SwipeHandle, [{
                    key: "onDragEnd",
                    value: function onDragEnd(gesture) {
                        var _this = this;

                        gesture.srcEvent.preventDefault();
                        gesture.srcEvent.stopPropagation();
                        // TODO: POLISH THESE NUMBERS WITH GOOD MATHIFICATION
                        var progress = (gesture.center.x - this.startX) / this.width;
                        var completeSwipeBack = progress > 0.5;
                        var playbackRate = 4;
                        if (completeSwipeBack) {
                            // complete swipe back
                            if (progress > 0.9) {
                                playbackRate = 1;
                            } else if (progress > 0.8) {
                                playbackRate = 2;
                            } else if (progress > 0.7) {
                                playbackRate = 3;
                            }
                        } else {
                            // cancel swipe back
                            if (progress < 0.1) {
                                playbackRate = 1;
                            } else if (progress < 0.2) {
                                playbackRate = 2;
                            } else if (progress < 0.3) {
                                playbackRate = 3;
                            }
                        }
                        this.zone.run(function () {
                            _this.viewCtrl.swipeBackEnd(completeSwipeBack, progress, playbackRate);
                        });
                        this.startX = null;
                    }
                }, {
                    key: "onDragHorizontal",
                    value: function onDragHorizontal(gestureEv) {
                        var _this2 = this;

                        this.zone.run(function () {
                            var gesture = gestureEv.gesture;
                            if (_this2.startX === null) {
                                // starting drag
                                gesture.srcEvent.preventDefault();
                                gesture.srcEvent.stopPropagation();
                                _this2.startX = gesture.center.x;
                                _this2.width = _this2.pane.width() - _this2.startX;
                                _this2.viewCtrl.swipeBackStart();
                            }
                            _this2.viewCtrl.swipeBackProgress((gesture.center.x - _this2.startX) / _this2.width);
                        });
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.gesture && this.gesture.destroy();
                    }
                }, {
                    key: "showHandle",
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.canSwipeBack() : false;
                    }
                }]);

                return SwipeHandle;
            })();

            _export("SwipeHandle", SwipeHandle);

            _export("SwipeHandle", SwipeHandle = __decorate([Directive({
                selector: '.swipe-handle',
                host: {
                    '[class.show-handle]': 'showHandle'
                }
            }), __param(0, Optional()), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __param(1, Host()), __param(1, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata('design:paramtypes', [typeof ViewController !== 'undefined' && ViewController || Object, typeof Pane !== 'undefined' && Pane || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof NgZone !== 'undefined' && NgZone || Object])], SwipeHandle));
        }
    };
});
System.register("ionic/components/nav-bar/nav-bar", ["angular2/angular2", "../toolbar/toolbar", "../../config/config", "../../config/annotations", "../app/app", "../view/view-item"], function (_export) {
    "use strict";

    var Directive, Host, Optional, ElementRef, forwardRef, TemplateRef, ToolbarBase, IonicConfig, IonicComponent, IonicView, IonicApp, ViewItem, __decorate, __metadata, __param, Navbar, BackButton, BackButtonText, Title, NavbarItem, NavbarTemplate;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            TemplateRef = _angular2Angular2.TemplateRef;
        }, function (_toolbarToolbar) {
            ToolbarBase = _toolbarToolbar.ToolbarBase;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Navbar = (function (_ToolbarBase) {
                _inherits(Navbar, _ToolbarBase);

                function Navbar(elementRef, config, app, item) {
                    _classCallCheck(this, Navbar);

                    _get(Object.getPrototypeOf(Navbar.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    item && item.navbarView(this);
                    this.bbClass = config.setting('backButtonIcon');
                    this.bbDefault = config.setting('backButtonText');
                    this.bbText = '';
                }

                _createClass(Navbar, [{
                    key: "backButtonElement",
                    value: function backButtonElement(eleRef) {
                        if (arguments.length) {
                            this._bbEle = eleRef;
                        }
                        return this._bbEle;
                    }
                }, {
                    key: "backButtonTextElement",
                    value: function backButtonTextElement(eleRef) {
                        if (arguments.length) {
                            this._bbTxEle = eleRef;
                        }
                        return this._bbTxEle;
                    }
                }, {
                    key: "didEnter",
                    value: function didEnter() {
                        var titleEle = this._ttEle || (this._ttEle = this.getNativeElement().querySelector('ion-title'));
                        titleEle && this.app.title(titleEle.textContent);
                    }
                }]);

                return Navbar;
            })(ToolbarBase);

            _export("Navbar", Navbar);

            _export("Navbar", Navbar = __decorate([IonicComponent({
                selector: 'ion-navbar',
                host: {
                    'class': 'toolbar'
                }
            }), IonicView({
                template: "\n    <div class=\"toolbar-inner\">\n      <button class=\"back-button\">\n        <icon class=\"back-button-icon\" [name]=\"bbClass\"></icon>\n        <span class=\"back-button-text\">\n          <span class=\"back-default\" [text-content]=\"bbDefault\"></span>\n          <span class=\"back-title\" [text-content]=\"bbText\"></span>\n        </span>\n      </button>\n      <ng-content select=\"[aside-toggle]\"></ng-content>\n      <div class=\"toolbar-title\">\n        <div class=\"toolbar-inner-title\">\n          <ng-content select=\"ion-title\"></ng-content>\n        </div>\n      </div>\n      <div class=\"toolbar-item toolbar-primary-item\">\n        <ng-content select=\"[primary]\"></ng-content>\n      </div>\n      <div class=\"toolbar-item toolbar-secondary-item\">\n        <ng-content select=\"[secondary]\"></ng-content>\n      </div>\n    </div>\n  ",
                directives: [forwardRef(function () {
                    return BackButton;
                }), forwardRef(function () {
                    return BackButtonText;
                }), forwardRef(function () {
                    return Title;
                }), forwardRef(function () {
                    return NavbarItem;
                })]
            }), __param(3, Optional()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof IonicApp !== 'undefined' && IonicApp || Object, typeof ViewItem !== 'undefined' && ViewItem || Object])], Navbar));

            BackButton = (function () {
                function BackButton(navbar, item, elementRef) {
                    _classCallCheck(this, BackButton);

                    this.item = item;
                    navbar.backButtonElement(elementRef);
                }

                _createClass(BackButton, [{
                    key: "goBack",
                    value: function goBack(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.item && this.item.viewCtrl.pop();
                    }
                }]);

                return BackButton;
            })();

            BackButton = __decorate([Directive({
                selector: '.back-button',
                host: {
                    '(^click)': 'goBack($event)'
                }
            }), __param(0, Host()), __param(1, Optional()), __metadata('design:paramtypes', [Navbar, typeof ViewItem !== 'undefined' && ViewItem || Object, typeof ElementRef !== 'undefined' && ElementRef || Object])], BackButton);

            BackButtonText = function BackButtonText(navbar, elementRef) {
                _classCallCheck(this, BackButtonText);

                navbar.backButtonTextElement(elementRef);
            };

            BackButtonText = __decorate([Directive({
                selector: '.back-button-text'
            }), __param(0, Host()), __metadata('design:paramtypes', [Navbar, typeof ElementRef !== 'undefined' && ElementRef || Object])], BackButtonText);

            Title = function Title(toolbar, elementRef) {
                _classCallCheck(this, Title);

                toolbar.titleElement(elementRef);
            };

            Title = __decorate([Directive({
                selector: '.toolbar-title'
            }), __param(0, Host()), __metadata('design:paramtypes', [Navbar, typeof ElementRef !== 'undefined' && ElementRef || Object])], Title);

            NavbarItem = function NavbarItem(toolbar, elementRef) {
                _classCallCheck(this, NavbarItem);

                toolbar.itemElements(elementRef);
            };

            NavbarItem = __decorate([Directive({
                selector: '.toolbar-item'
            }), __param(0, Host()), __metadata('design:paramtypes', [Navbar, typeof ElementRef !== 'undefined' && ElementRef || Object])], NavbarItem);
            /*
              Used to find and register headers in a view, and this directive's
              content will be moved up to the common navbar location, and created
              using the same context as the view's content area.
            */

            NavbarTemplate = function NavbarTemplate(item, templateRef) {
                _classCallCheck(this, NavbarTemplate);

                item && item.addTemplateRef('navbar', templateRef);
            };

            _export("NavbarTemplate", NavbarTemplate);

            _export("NavbarTemplate", NavbarTemplate = __decorate([Directive({
                selector: 'template[navbar]'
            }), __param(0, Optional()), __param(1, Optional()), __metadata('design:paramtypes', [typeof ViewItem !== 'undefined' && ViewItem || Object, typeof TemplateRef !== 'undefined' && TemplateRef || Object])], NavbarTemplate));
        }
    };
});
System.register('ionic/components/overlay/overlay', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../../animations/animation', '../../util/click-block', 'ionic/util'], function (_export) {
    'use strict';

    var Component, DirectiveBinding, Animation, ClickBlock, util, Overlay, OverlayRef, ROOT_Z_INDEX;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            Overlay = (function () {
                function Overlay(app, config) {
                    _classCallCheck(this, Overlay);

                    this.app = app;
                    this.config = config;
                    this.mode = config.setting('mode');
                }

                _createClass(Overlay, [{
                    key: 'create',
                    value: function create(overlayType, componentType) {
                        var _this = this;

                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                        var context = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

                        return new Promise(function (resolve, reject) {
                            var app = _this.app;
                            var annotation = new Component({
                                selector: 'ion-' + overlayType,
                                host: {
                                    '[style.z-index]': 'zIndex',
                                    'mode': _this.mode,
                                    'class': overlayType
                                }
                            });
                            var overlayComponentType = DirectiveBinding.createFromType(componentType, annotation);
                            // create a unique token that works as a cache key
                            overlayComponentType.token = overlayType + componentType.name;
                            app.appendComponent(overlayComponentType).then(function (ref) {
                                var overlayRef = new OverlayRef(app, overlayType, opts, ref, context);
                                overlayRef._open(opts).then(function () {
                                    resolve(overlayRef);
                                });
                            })['catch'](function (err) {
                                console.error('Overlay appendComponent:', err);
                                reject(err);
                            });
                        })['catch'](function (err) {
                            console.error('Overlay create:', err);
                        });
                    }
                }, {
                    key: 'getByType',
                    value: function getByType(overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByHandle',
                    value: function getByHandle(handle, overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (handle === this.app.overlays[i]._handle && overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }]);

                return Overlay;
            })();

            _export('Overlay', Overlay);

            OverlayRef = (function () {
                function OverlayRef(app, overlayType, opts, ref, context) {
                    var _this2 = this;

                    _classCallCheck(this, OverlayRef);

                    this.app = app;
                    var overlayInstance = ref && ref.instance;
                    if (!overlayInstance) return;
                    if (context) {
                        util.extend(ref.instance, context);
                    }
                    this._instance = overlayInstance;
                    overlayInstance.viewLoaded && overlayInstance.viewLoaded();
                    this.zIndex = ROOT_Z_INDEX;
                    for (var i = 0; i < app.overlays.length; i++) {
                        if (app.overlays[i].zIndex >= this.zIndex) {
                            this.zIndex = app.overlays[i].zIndex + 1;
                        }
                    }
                    overlayInstance.zIndex = this.zIndex;
                    overlayInstance.overlayRef = this;
                    overlayInstance.close = function (instanceOpts) {
                        _this2.close(instanceOpts);
                    };
                    this._elementRef = ref.location;
                    this._type = overlayType;
                    this._opts = opts;
                    this._handle = opts.handle || this.zIndex;
                    this._dispose = function () {
                        _this2._instance = null;
                        ref.dispose && ref.dispose();
                        util.array.remove(app.overlays, _this2);
                    };
                    app.overlays.push(this);
                }

                _createClass(OverlayRef, [{
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this._elementRef;
                    }
                }, {
                    key: '_open',
                    value: function _open() {
                        var _this3 = this;

                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this3._instance || {};
                            instance.viewWillEnter && instance.viewWillEnter();
                            var animationName = opts && opts.animation || _this3._opts.enterAnimation;
                            var animation = Animation.create(_this3._elementRef.nativeElement, animationName);
                            animation.before.addClass('show-overlay');
                            ClickBlock(true, animation.duration() + 200);
                            _this3.app.setTransitioning(true);
                            _this3.app.zoneRunOutside(function () {
                                animation.play().then(function () {
                                    _this3.app.zoneRun(function () {
                                        ClickBlock(false);
                                        _this3.app.setTransitioning(false);
                                        animation.dispose();
                                        instance.viewDidEnter && instance.viewDidEnter();
                                        resolve();
                                    });
                                });
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }, {
                    key: 'close',
                    value: function close() {
                        var _this4 = this;

                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this4._instance || {};
                            instance.viewWillLeave && instance.viewWillLeave();
                            instance.viewWillUnload && instance.viewWillUnload();
                            var animationName = opts && opts.animation || _this4._opts.leaveAnimation;
                            var animation = Animation.create(_this4._elementRef.nativeElement, animationName);
                            animation.after.removeClass('show-overlay');
                            ClickBlock(true, animation.duration() + 200);
                            _this4.app.setTransitioning(true);
                            animation.play().then(function () {
                                instance.viewDidLeave && instance.viewDidLeave();
                                instance.viewDidUnload && instance.viewDidUnload();
                                _this4._dispose();
                                ClickBlock(false);
                                _this4.app.setTransitioning(false);
                                animation.dispose();
                                resolve();
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return OverlayRef;
            })();

            _export('OverlayRef', OverlayRef);

            ROOT_Z_INDEX = 1000;
        }
    };
});
System.register("ionic/components/popup/popup", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
     * @name ionPopup
     * @description
     * The Ionic Popup service allows programmatically creating and showing popup windows that require the user to respond in order to continue.
     *
     * The popup system has support for more flexible versions of the built in `alert()`, `prompt()`, and `confirm()` functions that users are used to, in addition to allowing popups with completely custom content and look.
     *
     * @usage
     * ```ts
     * class myApp {
     *
     *   constructor(popup: Popup) {
     *     this.popup = popup;
     *   }
     *
     *   doAlert() {
     *     this.popup.alert('Alert').then(() => {
     *       console.log('Alert closed');
     *     });
     *   }
     *
     *   doPrompt() {
     *     this.popup.prompt('What is your name?').then((name) => {
     *       console.log('Name entered:', name);
     *     }, () => {
     *       console.error('Prompt closed');
     *     });
     *   }
     *
     *   doConfirm() {
     *     this.popup.confirm('Are you sure?').then((result, ev) => {
     *       console.log('Confirmed!', result);
     *     }, () => {
     *       console.error('Not confirmed!');
     *     });
     *   }
     * }
     * ```
     */
    "use strict";

    var FORM_DIRECTIVES, Component, View, Injectable, NgClass, NgIf, NgFor, Overlay, Animation, util, __decorate, __metadata, Popup, OVERLAY_TYPE, StandardPopup, PopupAnimation, PopupPopIn, PopupPopOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x8, _x9, _x10) { var _again = true; _function: while (_again) { var object = _x8, property = _x9, receiver = _x10; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x8 = parent; _x9 = property; _x10 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            FORM_DIRECTIVES = _angular2Angular2.FORM_DIRECTIVES;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgClass = _angular2Angular2.NgClass;
            NgIf = _angular2Angular2.NgIf;
            NgFor = _angular2Angular2.NgFor;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Popup = (function (_Overlay) {
                _inherits(Popup, _Overlay);

                function Popup() {
                    _classCallCheck(this, Popup);

                    _get(Object.getPrototypeOf(Popup.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(Popup, [{
                    key: "popup",

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                    value: function popup(context) {
                        var _this = this;

                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        return new Promise(function (resolve, reject) {
                            var defaults = {
                                enterAnimation: 'popup-pop-in',
                                leaveAnimation: 'popup-pop-out'
                            };
                            context.promiseResolve = resolve;
                            context.promiseReject = reject;
                            return _this.create(OVERLAY_TYPE, StandardPopup, util.extend(defaults, opts), context);
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "alert",
                    value: function alert() {
                        var context = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === 'string') {
                            context = {
                                title: context
                            };
                        }
                        var button = {
                            text: 'OK',
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                                //resolve();
                            }
                        };
                        context = util.extend({
                            cancel: function cancel() {
                                //reject();
                            },
                            buttons: [button]
                        }, context);
                        return this.popup(context, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "confirm",
                    value: function confirm() {
                        var context = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === 'string') {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: 'OK',
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        var cancelButton = {
                            text: 'Cancel',
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        context = util.extend({
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} [context={}]  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "prompt",
                    value: function prompt() {
                        var context = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === 'string') {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: 'Ok',
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        var cancelButton = {
                            text: 'Cancel',
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {
                                // Allow it to close
                            }
                        };
                        context = util.extend({
                            showPrompt: true,
                            promptPlaceholder: '',
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} context  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return Popup;
            })(Overlay);

            _export("Popup", Popup);

            _export("Popup", Popup = __decorate([Injectable(), __metadata('design:paramtypes', [])], Popup));
            OVERLAY_TYPE = 'popup';

            StandardPopup = (function () {
                function StandardPopup(popup) {
                    _classCallCheck(this, StandardPopup);

                    this.popup = popup;
                }

                _createClass(StandardPopup, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        setTimeout(function () {
                            _this2.element = _this2.overlayRef.getElementRef().nativeElement;
                            _this2.promptInput = _this2.element.querySelector('input');
                            if (_this2.promptInput) {
                                _this2.promptInput.value = '';
                            }
                        });
                    }
                }, {
                    key: "buttonTapped",
                    value: function buttonTapped(button, event) {
                        var promptValue = this.promptInput && this.promptInput.value;
                        var retVal = button.onTap && button.onTap(event, this, {
                            promptValue: promptValue
                        });
                        // If the event.preventDefault() wasn't called, close
                        if (!event.defaultPrevented) {
                            // If this is a cancel button, reject the promise
                            if (button.isCancel) {
                                this.promiseReject();
                            } else {
                                // Resolve with the prompt value
                                this.promiseResolve(promptValue);
                            }
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_cancel",
                    value: function _cancel(event) {
                        this.cancel && this.cancel(event);
                        if (!event.defaultPrevented) {
                            this.promiseReject();
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return StandardPopup;
            })();

            StandardPopup = __decorate([Component({
                selector: 'ion-popup-default'
            }), View({
                template: '<backdrop (click)="_cancel($event)" tappable></backdrop>' + '<popup-wrapper>' + '<div class="popup-head">' + '<h3 class="popup-title" [inner-html]="title"></h3>' + '<h5 class="popup-sub-title" [inner-html]="subTitle" *ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '<input type="text" *ng-if="showPrompt" placeholder="{{promptPlaceholder}}">' + '</div>' + '<div class="popup-buttons" *ng-if="buttons.length">' + '<button *ng-for="#button of buttons" (click)="buttonTapped(button, $event)" [ng-class]="button.type || \'button-default\'" [inner-html]="button.text"></button>' + '</div>' + '</popup-wrapper>',
                directives: [FORM_DIRECTIVES, NgClass, NgIf, NgFor]
            }), __metadata('design:paramtypes', [Popup])], StandardPopup);

            PopupAnimation = (function (_Animation) {
                _inherits(PopupAnimation, _Animation);

                function PopupAnimation(element) {
                    _classCallCheck(this, PopupAnimation);

                    _get(Object.getPrototypeOf(PopupAnimation.prototype), "constructor", this).call(this, element);
                    this.easing('ease-in-out').duration(200);
                    this.backdrop = new Animation(element.querySelector('backdrop'));
                    this.wrapper = new Animation(element.querySelector('popup-wrapper'));
                    this.add(this.backdrop, this.wrapper);
                }

                /**
                 * Animations for modals
                 */
                return PopupAnimation;
            })(Animation);

            PopupPopIn = (function (_PopupAnimation) {
                _inherits(PopupPopIn, _PopupAnimation);

                function PopupPopIn(element) {
                    _classCallCheck(this, PopupPopIn);

                    _get(Object.getPrototypeOf(PopupPopIn.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo('opacity', '0', '1');
                    this.wrapper.fromTo('scale', '1.1', '1');
                    this.backdrop.fromTo('opacity', '0', '0.3');
                }

                return PopupPopIn;
            })(PopupAnimation);

            Animation.register('popup-pop-in', PopupPopIn);

            PopupPopOut = (function (_PopupAnimation2) {
                _inherits(PopupPopOut, _PopupAnimation2);

                function PopupPopOut(element) {
                    _classCallCheck(this, PopupPopOut);

                    _get(Object.getPrototypeOf(PopupPopOut.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo('opacity', '1', '0');
                    this.wrapper.fromTo('scale', '1', '0.9');
                    this.backdrop.fromTo('opacity', '0.3', '0');
                }

                return PopupPopOut;
            })(PopupAnimation);

            Animation.register('popup-pop-out', PopupPopOut);
        }
    };
});
System.register("ionic/components/radio/radio", ["angular2/angular2", "../../config/annotations", "../../config/config", "../ion", "../list/list"], function (_export) {
    /**
     * @name ionRadioGroup
     * @description
     * A radio group is a group of radio components.
     *
     * Selecting a radio button in the group unselects all others in the group.
     *
     * New radios can be registered dynamically.
     *
     * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
     *
     * @usage
     * ```html
     * <ion-radio-group ng-control="clientside">
     *
     *   <ion-header>
     *     Clientside
     *   </ion-header>
     *
     *   <ion-radio value="ember">
     *     Ember
     *   </ion-radio>
     *
     *   <ion-radio value="angular1">
     *     Angular 1
     *   </ion-radio>
     *
     *   <ion-radio value="angular2" checked="true">
     *     Angular 2
     *   </ion-radio>
     *
     *   <ion-radio value="react">
     *     React
     *   </ion-radio>
     *
     * </ion-radio-group>
     * ```
    */
    "use strict";

    var ElementRef, Host, Optional, NgControl, Query, QueryList, IonicDirective, IonicComponent, IonicView, IonicConfig, Ion, ListHeader, __decorate, __metadata, __param, RadioGroup, RadioButton, radioGroupIds;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
            Query = _angular2Angular2.Query;
            QueryList = _angular2Angular2.QueryList;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_listList) {
            ListHeader = _listList.ListHeader;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            RadioGroup = (function (_Ion) {
                _inherits(RadioGroup, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {NgControl=} ngControl  TODO
                 * @param {QueryList<ListHeader>} headerQuery  TODO
                 */

                function RadioGroup(elementRef, config, ngControl, headerQuery) {
                    _classCallCheck(this, RadioGroup);

                    _get(Object.getPrototypeOf(RadioGroup.prototype), "constructor", this).call(this, elementRef, config);
                    this.headerQuery = headerQuery;
                    this.radios = [];
                    this.id = ++radioGroupIds;
                    this.radioIds = -1;
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    if (ngControl) ngControl.valueAccessor = this;
                }

                _createClass(RadioGroup, [{
                    key: "onInit",
                    value: function onInit() {
                        var header = this.headerQuery.first;
                        if (header) {
                            if (!header.id) {
                                header.id = 'radio-header-' + this.id;
                            }
                            this.describedById = header.id;
                        }
                    }

                    /**
                     * Register the specified radio button with the radio group.
                     * @param {RadioButton} radio  The radio button to register.
                     */
                }, {
                    key: "registerRadio",
                    value: function registerRadio(radio) {
                        radio.id = radio.id || 'radio-' + this.id + '-' + ++this.radioIds;
                        this.radios.push(radio);
                        if (radio.checked) {
                            this.value = radio.value;
                            this.activeId = radio.id;
                        }
                    }

                    /**
                     * Update which radio button in the group is checked, unchecking all others.
                     * @param {RadioButton} checkedRadio  The radio button to check.
                     */
                }, {
                    key: "update",
                    value: function update(checkedRadio) {
                        this.value = checkedRadio.value;
                        this.activeId = checkedRadio.id;
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.radios[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var radio = _step.value;

                                radio.checked = radio === checkedRadio;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        this.onChange(this.value);
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the model (Control) on change to update
                     * the checked value.
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
                     */
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = value;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.radios[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var radio = _step2.value;

                                radio.checked = radio.value == value;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the view (NgControl) to register the
                     * onChange event handler that updates the model (Control).
                     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L27
                     * @param {Function} fn  the onChange event handler.
                     */
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }

                    /**
                     * @private
                     * Angular2 Forms API method called by the the view (NgControl) to register
                     * the onTouched event handler that marks the model (Control) as touched.
                     * @param {Function} fn  onTouched event handler.
                     */
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return RadioGroup;
            })(Ion);

            _export("RadioGroup", RadioGroup);

            _export("RadioGroup", RadioGroup = __decorate([IonicDirective({
                selector: 'ion-radio-group',
                host: {
                    'class': 'list',
                    'role': 'radiogroup',
                    '[attr.aria-activedescendant]': 'activeId',
                    '[attr.aria-describedby]': 'describedById'
                }
            }), __param(2, Optional()), __param(3, Query(ListHeader)), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof NgControl !== 'undefined' && NgControl || Object, typeof QueryList !== 'undefined' && QueryList || Object])], RadioGroup));
            /**
             * @name ionRadio
             * @description
             * A single radio component.
             *
             * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
             *
             * @usage
             * ```html
             * <ion-radio value="isChecked" checked="true">
             *   Radio Label
             * </ion-radio>
             * ```
             *
             */

            RadioButton = (function (_Ion2) {
                _inherits(RadioButton, _Ion2);

                /**
                 * Radio button constructor.
                 * @param {RadioGroup=} group  The parent radio group, if any.
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function RadioButton(group, elementRef, config) {
                    _classCallCheck(this, RadioButton);

                    _get(Object.getPrototypeOf(RadioButton.prototype), "constructor", this).call(this, elementRef, config);
                    this.group = group;
                    this.tabIndex = 0;
                }

                _createClass(RadioButton, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(RadioButton.prototype), "onInit", this).call(this);
                        this.group.registerRadio(this);
                        this.labelId = 'label-' + this.id;
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.check();
                    }

                    /**
                     * Update the checked state of this radio button.
                     * TODO: Call this toggle? Since unchecks as well
                     */
                }, {
                    key: "check",
                    value: function check() {
                        this.checked = !this.checked;
                        this.group.update(this);
                    }
                }]);

                return RadioButton;
            })(Ion);

            _export("RadioButton", RadioButton);

            _export("RadioButton", RadioButton = __decorate([IonicComponent({
                selector: 'ion-radio',
                properties: ['value', 'checked', 'disabled', 'id'],
                host: {
                    'class': 'item',
                    'role': 'radio',
                    'tappable': 'true',
                    '[attr.id]': 'id',
                    '[attr.tab-index]': 'tabIndex',
                    '[attr.aria-checked]': 'checked',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'labelId',
                    '(^click)': 'click($event)'
                }
            }), IonicView({
                template: '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '<div item-right class="item-media media-radio">' + '<div class="radio-icon"></div>' + '</div>'
            }), __param(0, Host()), __param(0, Optional()), __metadata('design:paramtypes', [RadioGroup, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], RadioButton));
            radioGroupIds = -1;
        }
    };
});
System.register("ionic/components/scroll/pull-to-refresh", ["angular2/angular2", "../content/content", "ionic/util", "ionic/util/dom"], function (_export) {
    /**
     * @name ionRefresher
     * @description
     * Allows you to add pull-to-refresh to an ionContent component.
     *
     * Place it as the first child of your ionContent or ionScroll element.
     *
     * When refreshing is complete, call `refresher.complete()` from your controller.
     *
     *  @usage
     *  ```ts
     *  <ion-refresher (starting)="doStarting()" (refresh)="doRefresh($event, refresher)" (pulling)="doPulling($event, amt)">
     *
     *
     *  doRefresh(refresher) {
     *    console.log('Refreshing!', refresher);
     *
     *    setTimeout(() => {
     *      console.log('Pull to refresh complete!', refresher);
     *      refresher.complete();
     *    })
     *  }
     *
     *  doStarting() {
     *    console.log('Pull started!');
     *  }
     *
     *  doPulling(amt) {
     *    console.log('You have pulled', amt);
     *  }
     *  ```
     */
    "use strict";

    var Component, View, NgIf, NgClass, ElementRef, EventEmitter, Host, Content, util, raf, CSS, __decorate, __metadata, __param, Refresher;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            NgIf = _angular2Angular2.NgIf;
            NgClass = _angular2Angular2.NgClass;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Host = _angular2Angular2.Host;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicUtilDom) {
            raf = _ionicUtilDom.raf;
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Refresher = (function () {
                /**
                 * TODO
                 * @param {Content} content  TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function Refresher(content, element) {
                    _classCallCheck(this, Refresher);

                    this.ele = element.nativeElement;
                    this.ele.classList.add('content');
                    this.content = content;
                    this.refresh = new EventEmitter('refresh');
                    this.starting = new EventEmitter('starting');
                    this.pulling = new EventEmitter('pulling');
                }

                _createClass(Refresher, [{
                    key: "onInit",
                    value: function onInit() {
                        this.initEvents();
                    }

                    /**
                     * Initialize touch and scroll event listeners.
                     */
                }, {
                    key: "initEvents",
                    value: function initEvents() {
                        var sp = this.content.getNativeElement();
                        var sc = this.content.scrollElement;
                        this.isDragging = false;
                        this.isOverscrolling = false;
                        this.dragOffset = 0;
                        this.lastOverscroll = 0;
                        this.ptrThreshold = 60;
                        this.activated = false;
                        this.scrollTime = 500;
                        this.startY = null;
                        this.deltaY = null;
                        this.canOverscroll = true;
                        this.scrollHost = sp;
                        this.scrollChild = sc;
                        util.defaults(this, {
                            pullingIcon: 'ion-android-arrow-down',
                            refreshingIcon: 'ion-ionic'
                        });
                        this.showSpinner = !util.isDefined(this.refreshingIcon) && this.spinner != 'none';
                        this.showIcon = util.isDefined(this.refreshingIcon);
                        this._touchMoveListener = this._handleTouchMov.bind(this);
                        this._touchEndListener = this._handleTouchEnd.bind(this);
                        this._handleScrollListener = this._handleScroll.bind(this);
                        sc.addEventListener('touchmove', this._touchMoveListener);
                        sc.addEventListener('touchend', this._touchEndListener);
                        sc.addEventListener('scroll', this._handleScrollListener);
                    }
                }, {
                    key: "onDehydrate",
                    value: function onDehydrate() {
                        console.log('DEHYDRATION');
                        var sc = this.content.scrollElement;
                        sc.removeEventListener('touchmove', this._touchMoveListener);
                        sc.removeEventListener('touchend', this._touchEndListener);
                        sc.removeEventListener('scroll', this._handleScrollListener);
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     */
                }, {
                    key: "overscroll",
                    value: function overscroll(val) {
                        this.scrollChild.style[CSS.transform] = 'translateY(' + val + 'px)';
                        this.lastOverscroll = val;
                    }

                    /**
                     * TODO
                     * @param {TODO} target  TODO
                     * @param {TODO} newScrollTop  TODO
                     */
                }, {
                    key: "nativescroll",
                    value: function nativescroll(target, newScrollTop) {
                        // creates a scroll event that bubbles, can be cancelled, and with its view
                        // and detail property initialized to window and 1, respectively
                        target.scrollTop = newScrollTop;
                        var e = document.createEvent("UIEvents");
                        e.initUIEvent("scroll", true, true, window, 1);
                        target.dispatchEvent(e);
                    }

                    /**
                     * TODO
                     * @param {TODO} enabled  TODO
                     */
                }, {
                    key: "setScrollLock",
                    value: function setScrollLock(enabled) {
                        var _this = this;

                        // set the scrollbar to be position:fixed in preparation to overscroll
                        // or remove it so the app can be natively scrolled
                        if (enabled) {
                            raf(function () {
                                _this.scrollChild.classList.add('overscroll');
                                _this.show();
                            });
                        } else {
                            raf(function () {
                                _this.scrollChild.classList.remove('overscroll');
                                _this.hide();
                                _this.deactivate();
                            });
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "activate",
                    value: function activate() {
                        //this.ele.classList.add('active');
                        this.isActive = true;
                        //this.starting.next();
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "deactivate",
                    value: function deactivate() {
                        var _this2 = this;

                        // give tail 150ms to finish
                        setTimeout(function () {
                            _this2.isActive = false;
                            _this2.isRefreshing = false;
                            _this2.isRefreshingTail = false;
                            // deactivateCallback
                            if (_this2.activated) _this2.activated = false;
                        }, 150);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        // startCallback
                        this.isRefreshing = true;
                        this.refresh.next(this);
                        //$scope.$onRefresh();
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "show",
                    value: function show() {
                        // showCallback
                        this.ele.classList.remove('invisible');
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "hide",
                    value: function hide() {
                        // showCallback
                        this.ele.classList.add('invisible');
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "tail",
                    value: function tail() {
                        // tailCallback
                        this.ele.classList.add('refreshing-tail');
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "complete",
                    value: function complete() {
                        var _this3 = this;

                        setTimeout(function () {
                            raf(_this3.tail.bind(_this3));
                            // scroll back to home during tail animation
                            _this3.scrollTo(0, _this3.scrollTime, _this3.deactivate.bind(_this3));
                            // return to native scrolling after tail animation has time to finish
                            setTimeout(function () {
                                if (_this3.isOverscrolling) {
                                    _this3.isOverscrolling = false;
                                    _this3.setScrollLock(false);
                                }
                            }, _this3.scrollTime);
                        }, this.scrollTime);
                    }

                    /**
                     * TODO
                     * @param {TODO} Y  TODO
                     * @param {TODO} duration  TODO
                     * @param {Function} callback  TODO
                     */
                }, {
                    key: "scrollTo",
                    value: function scrollTo(Y, duration, callback) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var start = Date.now(),
                            from = this.lastOverscroll;
                        if (from === Y) {
                            callback();
                            return; /* Prevent scrolling to the Y point if already there */
                        }
                        // decelerating to zero velocity
                        function easeOutCubic(t) {
                            return --t * t * t + 1;
                        }
                        // scroll loop
                        function scroll() {
                            var currentTime = Date.now(),
                                time = Math.min(1, (currentTime - start) / duration),

                            // where .5 would be 50% of time on a linear scale easedT gives a
                            // fraction based on the easing method
                            easedT = easeOutCubic(time);
                            this.overscroll(parseInt(easedT * (Y - from) + from, 10));
                            if (time < 1) {
                                raf(scroll.bind(this));
                            } else {
                                if (Y < 5 && Y > -5) {
                                    this.isOverscrolling = false;
                                    this.setScrollLock(false);
                                }
                                callback && callback();
                            }
                        }
                        // start scroll loop
                        raf(scroll.bind(this));
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleTouchMove",
                    value: function _handleTouchMove(e) {
                        //console.log('TOUCHMOVE', e);
                        // if multitouch or regular scroll event, get out immediately
                        if (!this.canOverscroll || e.touches.length > 1) {
                            return;
                        }
                        //if this is a new drag, keep track of where we start
                        if (this.startY === null) {
                            this.startY = parseInt(e.touches[0].screenY, 10);
                        }
                        // kitkat fix for touchcancel events http://updates.html5rocks.com/2014/05/A-More-Compatible-Smoother-Touch
                        /*
                        if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && scrollHost.scrollTop === 0) {
                          isDragging = true;
                          e.preventDefault();
                        }
                        */
                        // how far have we dragged so far?
                        this.deltaY = parseInt(e.touches[0].screenY, 10) - this.startY;
                        // if we've dragged up and back down in to native scroll territory
                        if (this.deltaY - this.dragOffset <= 0 || this.scrollHost.scrollTop !== 0) {
                            if (this.isOverscrolling) {
                                this.isOverscrolling = false;
                                this.setScrollLock(false);
                            }
                            if (this.isDragging) {
                                this.nativescroll(this.scrollHost, parseInt(this.deltaY - this.dragOffset, 10) * -1);
                            }
                            // if we're not at overscroll 0 yet, 0 out
                            if (this.lastOverscroll !== 0) {
                                this.overscroll(0);
                            }
                            return;
                        } else if (this.deltaY > 0 && this.scrollHost.scrollTop === 0 && !this.isOverscrolling) {
                            // starting overscroll, but drag started below scrollTop 0, so we need to offset the position
                            this.dragOffset = this.deltaY;
                        }
                        // prevent native scroll events while overscrolling
                        e.preventDefault();
                        // if not overscrolling yet, initiate overscrolling
                        if (!this.isOverscrolling) {
                            this.isOverscrolling = true;
                            this.setScrollLock(true);
                        }
                        this.isDragging = true;
                        // overscroll according to the user's drag so far
                        this.overscroll(parseInt((this.deltaY - this.dragOffset) / 3, 10));
                        // Pass an incremental pull amount to the EventEmitter
                        this.pulling.next(this.lastOverscroll);
                        // update the icon accordingly
                        if (!this.activated && this.lastOverscroll > this.ptrThreshold) {
                            this.activated = true;
                            raf(this.activate.bind(this));
                        } else if (this.activated && this.lastOverscroll < this.ptrThreshold) {
                            this.activated = false;
                            raf(this.deactivate.bind(this));
                        }
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleTouchEnd",
                    value: function _handleTouchEnd(e) {
                        console.log('TOUCHEND', e);
                        // if this wasn't an overscroll, get out immediately
                        if (!this.canOverscroll && !this.isDragging) {
                            return;
                        }
                        // reset Y
                        this.startY = null;
                        // the user has overscrolled but went back to native scrolling
                        if (!this.isDragging) {
                            this.dragOffset = 0;
                            this.isOverscrolling = false;
                            this.setScrollLock(false);
                        } else {
                            this.isDragging = false;
                            this.dragOffset = 0;
                            // the user has scroll far enough to trigger a refresh
                            if (this.lastOverscroll > this.ptrThreshold) {
                                this.start();
                                this.scrollTo(this.ptrThreshold, this.scrollTime);
                            } else {
                                this.scrollTo(0, this.scrollTime, this.deactivate.bind(this));
                                this.isOverscrolling = false;
                            }
                        }
                    }

                    /**
                     * @private
                     * TODO
                     * @param {Event} e  TODO
                     */
                }, {
                    key: "_handleScroll",
                    value: function _handleScroll(e) {
                        console.log('SCROLL', e.target.scrollTop);
                    }
                }]);

                return Refresher;
            })();

            _export("Refresher", Refresher);

            _export("Refresher", Refresher = __decorate([Component({
                selector: 'ion-refresher',
                events: ['refresh', 'starting', 'pulling'],
                properties: ['pullingIcon', 'pullingText', 'refreshingIcon', 'refreshingText', 'spinner', 'disablePullingRotation'],
                host: {
                    '[class.active]': 'isActive',
                    '[class.refreshing]': 'isRefreshing',
                    '[class.refreshingTail]': 'isRefreshingTail'
                }
            }), View({
                template: "<div class=\"refresher-content\" [class.refresher-with-text]=\"pullingText || refreshingText\">\n      <div class=\"icon-pulling\">\n        <i class=\"icon\" [ng-class]=\"pullingIcon\"></i>\n      </div>\n      <div class=\"text-pulling\" [inner-html]=\"pullingText\" *ng-if=\"pullingText\"></div>\n      <div class=\"icon-refreshing\">\n        <!--<ion-spinner ng-if=\"showSpinner\" icon=\"{{spinner}}\"></ion-spinner>-->\n        <i class=\"icon\" [ng-class]=\"refreshingIcon\"></i>\n      </div>\n      <div class=\"text-refreshing\" [inner-html]=\"refreshingText\" *ng-if=\"refreshingText\"></div>\n    </div>",
                directives: [NgIf, NgClass]
            }), __param(0, Host()), __metadata('design:paramtypes', [typeof Content !== 'undefined' && Content || Object, typeof ElementRef !== 'undefined' && ElementRef || Object])], Refresher));
        }
    };
});
System.register("ionic/components/scroll/scroll", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    /**
     * ion-scroll is a non-flexboxed scroll area that can
     * scroll horizontally or vertically.
     */
    "use strict";

    var View, ElementRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, Scroll;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Scroll = (function (_Ion) {
                _inherits(Scroll, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function Scroll(elementRef, ionicConfig) {
                    _classCallCheck(this, Scroll);

                    _get(Object.getPrototypeOf(Scroll.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.maxScale = 3;
                    this.zoomDuration = 250;
                }

                _createClass(Scroll, [{
                    key: "onInit",
                    value: function onInit() {
                        this.scrollElement = this.getNativeElement().children[0];
                    }

                    /**
                     * Add a scroll event handler to the scroll element if it exists.
                     * @param {Function} handler  The scroll handler to add to the scroll element.
                     * @returns {?Function} a function to remove the specified handler, otherwise
                     * undefined if the scroll element doesn't exist.
                     */
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener('scroll', handler);
                        return function () {
                            _this.scrollElement.removeEventListener('scroll', handler);
                        };
                    }
                }]);

                return Scroll;
            })(Ion);

            _export("Scroll", Scroll);

            _export("Scroll", Scroll = __decorate([IonicComponent({
                selector: 'ion-scroll',
                properties: ['scrollX', 'scrollY', 'zoom', 'maxZoom'],
                host: {
                    '[class.scroll-x]': 'scrollX',
                    '[class.scroll-y]': 'scrollY'
                }
            }), View({
                template: '<scroll-content><div class="scroll-zoom-wrapper"><ng-content></ng-content></div></scroll-content>'
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Scroll));
        }
    };
});
System.register("ionic/components/search-bar/search-bar", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, SearchBar;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            SearchBar = (function (_Ion) {
                _inherits(SearchBar, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function SearchBar(elementRef, config //,
                ) {
                    _classCallCheck(this, SearchBar);

                    _get(Object.getPrototypeOf(SearchBar.prototype), "constructor", this).call(this, elementRef, config);
                    // this.controlDirective = cd;
                    // cd.valueAccessor = this; //ControlDirective should inject CheckboxControlDirective
                    this.query = '';
                }

                /**
                 * Much like ngModel, this is called from our valueAccessor for the attached
                 * ControlDirective to update the value internally.
                 */

                _createClass(SearchBar, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.value = value;
                    }
                }, {
                    key: "inputChanged",
                    value: function inputChanged(event) {
                        this.value = event.target.value;
                        console.log('Search changed', this.value);
                        // TODO: Better way to do this?
                        this.controlDirective._control().updateValue(event.target.value);
                    }
                }, {
                    key: "inputFocused",
                    value: function inputFocused() {
                        this.isFocused = true;
                        this.shouldLeftAlign = true;
                    }
                }, {
                    key: "inputBlurred",
                    value: function inputBlurred() {
                        this.isFocused = false;
                        this.shouldLeftAlign = this.value.trim() != '';
                    }
                }]);

                return SearchBar;
            })(Ion);

            _export("SearchBar", SearchBar);

            _export("SearchBar", SearchBar = __decorate([IonicComponent({
                selector: 'ion-search-bar',
                properties: ['list', 'query'],
                defaultProperties: {
                    'cancelText': 'Cancel',
                    'placeholder': 'Search'
                }
            }), IonicView({
                template: "\n  <div class=\"search-bar-input-container\" [class.left-align]=\"shouldLeftAlign\">\n    <div class=\"search-bar-icon\"></div>\n    <input (focus)=\"inputFocused()\" (blur)=\"inputBlurred()\"\n    (input)=\"inputChanged($event)\" class=\"search-bar-input\" type=\"search\" [attr.placeholder]=\"placeholder\">\n  </div>\n  <button class=\"search-bar-cancel\">{{cancelText}}</button>"
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], SearchBar));
            /*
            export class SearchPipe extends Pipe {
              constructor() {
                super();
                this.state = 0;
              }
            
              supports(newValue) {
                return true;
              }
            
              transform(value, ...args) {
                console.log('Transforming', value, args);
                return value;
                //return `${value} state:${this.state ++}`;
              }
            
              create(cdRef) {
                console.log('REF', cdRef);
                return new SearchPipe(cdRef);
              }
            }
            */
        }
    };
});
System.register("ionic/components/segment/segment", ["angular2/angular2", "angular2/forms", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var View, Renderer, ElementRef, EventEmitter, Host, forwardRef, NgControl, Ion, IonicConfig, IonicDirective, IonicComponent, __decorate, __metadata, __param, Segment, SegmentControlValueAccessor, SegmentButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Renderer = _angular2Angular2.Renderer;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Host = _angular2Angular2.Host;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_angular2Forms) {
            NgControl = _angular2Forms.NgControl;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Segment = (function (_Ion) {
                _inherits(Segment, _Ion);

                /**
                 * TODO
                 * @param {NgControl} ngControl  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {Renderer} renderer  TODO
                 */

                function Segment(ngControl, elementRef, ionicConfig, renderer) {
                    _classCallCheck(this, Segment);

                    _get(Object.getPrototypeOf(Segment.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.ele = elementRef.nativeElement;
                    this.elementRef = elementRef;
                    this.renderer = renderer;
                    this.change = new EventEmitter('change');
                    this.input = new EventEmitter('input');
                    this.ngControl = ngControl;
                    this.buttons = [];
                }

                /**
                 * Called by child SegmentButtons to bind themselves to
                 * the Segment.
                 * @param {SegmentButton} segmentButton  The child SegmentButton to register.
                 */

                _createClass(Segment, [{
                    key: "register",
                    value: function register(segmentButton) {
                        this.buttons.push(segmentButton);
                        // If this button is registered and matches our value,
                        // make sure to select it
                        if (this.value == segmentButton.value) {
                            this.selected(segmentButton);
                        }
                    }

                    /**
                     * Select the button with the given value.
                     * @param {string} value  Value of the button to select.
                     */
                }, {
                    key: "selectFromValue",
                    value: function selectFromValue(value) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var button = _step.value;

                                if (button.value === value) {
                                    button.isActive = true;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }

                    /**
                     * Indicate a button should be selected.
                     * @param {SegmentButton} segmentButton  The button to select.
                     */
                }, {
                    key: "selected",
                    value: function selected(segmentButton) {
                        var _this = this;

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.isActive = false;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        segmentButton.isActive = true;
                        //this.onChange();
                        setTimeout(function () {
                            _this.value = segmentButton.value;
                            _this.ngControl.valueAccessor.writeValue(segmentButton.value);
                            _this.selectFromValue(segmentButton.value);
                            _this.ngControl.control.updateValue(segmentButton.value);
                            // Trigger on change
                            _this.change.next();
                        });
                        //this.ngControl.control().updateValue(this.value);
                        // TODO: Better way to do this?
                        //this.controlDirective._control().updateValue(this.value);
                    }
                }]);

                return Segment;
            })(Ion);

            _export("Segment", Segment);

            _export("Segment", Segment = __decorate([IonicComponent({
                selector: 'ion-segment',
                appInjector: [NgControl],
                properties: ['value'],
                host: {
                    '(click)': 'buttonClicked($event)',
                    '(change)': 'onChange($event)'
                }
            }), View({
                template: '<div class="ion-segment"><ng-content></ng-content></div>',
                directives: [forwardRef(function () {
                    return SegmentButton;
                })]
            }), __metadata('design:paramtypes', [typeof NgControl !== 'undefined' && NgControl || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof Renderer !== 'undefined' && Renderer || Object])], Segment));
            /**
             * TODO
             */

            SegmentControlValueAccessor = (function () {
                /**
                 * TODO
                 * @param {NgControl} ngControl  TODO
                 * @param {Renderer} renderer  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {Segment} segment  TODO
                 */

                function SegmentControlValueAccessor(ngControl, renderer, elementRef, segment) {
                    _classCallCheck(this, SegmentControlValueAccessor);

                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.ngControl = ngControl;
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    this.segment = segment;
                    ngControl.valueAccessor = this;
                }

                _createClass(SegmentControlValueAccessor, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        // both this.value and setProperty are required at the moment
                        // remove when a proper imperative API is provided
                        this.value = !value ? '' : value;
                        this.renderer.setElementProperty(this.elementRef, 'value', this.value);
                        this.segment.value = this.value;
                        this.segment.selectFromValue(value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return SegmentControlValueAccessor;
            })();

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor);

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor = __decorate([IonicDirective({
                selector: 'ion-segment',
                //properties: ['value'],
                host: {
                    '(change)': 'onChange($event.target.value)',
                    '(input)': 'onChange($event.target.value)',
                    '(blur)': 'onTouched()'
                }
            }), __metadata('design:paramtypes', [typeof NgControl !== 'undefined' && NgControl || Object, typeof Renderer !== 'undefined' && Renderer || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, Segment])], SegmentControlValueAccessor));
            /**
             * TODO
             */

            SegmentButton = (function () {
                /**
                 * TODO
                 * @param {Segment} segment  TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function SegmentButton(segment, elementRef) {
                    _classCallCheck(this, SegmentButton);

                    this.ele = elementRef.ele;
                    this.segment = segment;
                }

                _createClass(SegmentButton, [{
                    key: "onInit",
                    value: function onInit() {
                        this.segment.register(this);
                    }
                }, {
                    key: "buttonClicked",
                    value: function buttonClicked(event) {
                        this.segment.selected(this, event);
                        event.preventDefault();
                    }
                }]);

                return SegmentButton;
            })();

            _export("SegmentButton", SegmentButton);

            _export("SegmentButton", SegmentButton = __decorate([IonicDirective({
                selector: 'ion-segment-button',
                properties: ['value'],
                host: {
                    '(click)': 'buttonClicked($event)',
                    '[class.active]': 'isActive'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Segment, typeof ElementRef !== 'undefined' && ElementRef || Object])], SegmentButton));
        }
    };
});
System.register("ionic/components/show-hide-when/show-hide-when", ["angular2/angular2", "../../platform/platform"], function (_export) {
    "use strict";

    var Directive, Attribute, NgZone, Platform, __decorate, __metadata, __param, DisplayWhen, ShowWhen, HideWhen;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Attribute = _angular2Angular2.Attribute;
            NgZone = _angular2Angular2.NgZone;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            DisplayWhen = (function () {
                function DisplayWhen(conditions, ngZone) {
                    var _this = this;

                    _classCallCheck(this, DisplayWhen);

                    this.isMatch = false;
                    if (!conditions) return;
                    this.conditions = conditions.split(',');
                    // check if its one of the matching platforms first
                    // a platform does not change during the life of an app
                    for (var i = 0; i < this.conditions.length; i++) {
                        if (this.conditions[i] && Platform.is(this.conditions[i])) {
                            this.isMatch = true;
                            return;
                        }
                    }
                    if (this.orientation()) {
                        // add window resize listener
                        Platform.onResize(function () {
                            ngZone.run(function () {
                                _this.orientation();
                            });
                        });
                        return;
                    }
                }

                /**
                 * TODO
                 */

                _createClass(DisplayWhen, [{
                    key: "orientation",
                    value: function orientation() {
                        for (var i = 0; i < this.conditions.length; i++) {
                            var condition = this.conditions[i];
                            if (condition == 'portrait') {
                                this.isMatch = Platform.isPortrait();
                                return true;
                            }
                            if (condition == 'landscape') {
                                this.isMatch = Platform.isLandscape();
                                return true;
                            }
                        }
                    }
                }]);

                return DisplayWhen;
            })();

            ShowWhen = (function (_DisplayWhen) {
                _inherits(ShowWhen, _DisplayWhen);

                /**
                 * TODO
                 * @param {string} showWhen  The value of the element's 'show-when' attribute
                 * @param {NgZone} ngZone  TODO
                 */

                function ShowWhen(showWhen, ngZone) {
                    _classCallCheck(this, ShowWhen);

                    _get(Object.getPrototypeOf(ShowWhen.prototype), "constructor", this).call(this, showWhen, ngZone);
                }

                _createClass(ShowWhen, [{
                    key: "hidden",
                    get: function get() {
                        return !this.isMatch;
                    }
                }]);

                return ShowWhen;
            })(DisplayWhen);

            _export("ShowWhen", ShowWhen);

            _export("ShowWhen", ShowWhen = __decorate([Directive({
                selector: '[show-when]',
                host: {
                    '[hidden]': 'hidden'
                }
            }), __param(0, Attribute('show-when')), __metadata('design:paramtypes', [String, typeof NgZone !== 'undefined' && NgZone || Object])], ShowWhen));
            /**
             * TODO
             */

            HideWhen = (function (_DisplayWhen2) {
                _inherits(HideWhen, _DisplayWhen2);

                /**
                 * TODO
                 * @param {string} showWhen  The value of the element's 'hide-when' attribute
                 * @param {NgZone} ngZone  TODO
                 */

                function HideWhen(hideWhen, ngZone) {
                    _classCallCheck(this, HideWhen);

                    _get(Object.getPrototypeOf(HideWhen.prototype), "constructor", this).call(this, hideWhen, ngZone);
                }

                _createClass(HideWhen, [{
                    key: "hidden",
                    get: function get() {
                        return this.isMatch;
                    }
                }]);

                return HideWhen;
            })(DisplayWhen);

            _export("HideWhen", HideWhen);

            _export("HideWhen", HideWhen = __decorate([Directive({
                selector: '[hide-when]',
                host: {
                    '[hidden]': 'hidden'
                }
            }), __param(0, Attribute('hide-when')), __metadata('design:paramtypes', [String, typeof NgZone !== 'undefined' && NgZone || Object])], HideWhen));
        }
    };
});
System.register("ionic/components/slides/slides", ["angular2/angular2", "../ion", "ionic/animations/animation", "ionic/gestures/gesture", "../../config/annotations", "../../config/config", "ionic/util", "../../util/dom", "./swiper-widget"], function (_export) {
    /**
     * Slides is a slide box implementation based on Swiper.js
     *
     * Swiper.js:
     * The most modern mobile touch slider and framework with hardware accelerated transitions
     *
     * http://www.idangero.us/swiper/
     *
     * Copyright 2015, Vladimir Kharlampidi
     * The iDangero.us
     * http://www.idangero.us/
     *
     * Licensed under MIT
     *
     */
    "use strict";

    var View, ElementRef, Host, NgIf, NgClass, Ion, Animation, Gesture, IonicComponent, IonicDirective, IonicConfig, dom, util, CSS, Swiper, __decorate, __metadata, __param, Slides, Slide, SlideLazy;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            NgIf = _angular2Angular2.NgIf;
            NgClass = _angular2Angular2.NgClass;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_ionicAnimationsAnimation) {
            Animation = _ionicAnimationsAnimation.Animation;
        }, function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
            util = _ionicUtil;
        }, function (_utilDom) {
            CSS = _utilDom.CSS;
        }, function (_swiperWidget) {
            Swiper = _swiperWidget.Swiper;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Slides = (function (_Ion) {
                _inherits(Slides, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 */

                function Slides(elementRef, config) {
                    var _this = this;

                    _classCallCheck(this, Slides);

                    _get(Object.getPrototypeOf(Slides.prototype), "constructor", this).call(this, elementRef, config);
                    this.rapidUpdate = util.debounce(function () {
                        _this.update();
                    }, 10);
                }

                _createClass(Slides, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        if (!this.options) {
                            this.options = {};
                        }
                        this.showPager = util.isTrueProperty(this.pager);
                        var options = util.defaults({
                            pagination: '.swiper-pagination',
                            paginationClickable: true,
                            lazyLoading: true,
                            preloadImages: false
                        }, this.options);
                        options.onTap = function (swiper, e) {
                            _this2.onTap(swiper, e);
                            return _this2.options.onTap && _this2.options.onTap(swiper, e);
                        };
                        options.onClick = function (swiper, e) {
                            _this2.onClick(swiper, e);
                            return _this2.options.onClick && _this2.options.onClick(swiper, e);
                        };
                        options.onDoubleTap = function (swiper, e) {
                            _this2.onDoubleTap(swiper, e);
                            return _this2.options.onDoubleTap && _this2.options.onDoubleTap(swiper, e);
                        };
                        options.onTransitionStart = function (swiper, e) {
                            _this2.onTransitionStart(swiper, e);
                            return _this2.options.onTransitionStart && _this2.options.onTransitionStart(swiper, e);
                        };
                        options.onTransitionEnd = function (swiper, e) {
                            _this2.onTransitionEnd(swiper, e);
                            return _this2.options.onTransitionEnd && _this2.options.onTransitionEnd(swiper, e);
                        };
                        options.onSlideChangeStart = function (swiper) {
                            return _this2.options.onSlideChangeStart && _this2.options.onSlideChangeStart(swiper);
                        };
                        options.onSlideChangeEnd = function (swiper) {
                            return _this2.options.onSlideChangeEnd && _this2.options.onSlideChangeEnd(swiper);
                        };
                        options.onLazyImageLoad = function (swiper, slide, img) {
                            return _this2.options.onLazyImageLoad && _this2.options.onLazyImageLoad(swiper, slide, img);
                        };
                        options.onLazyImageReady = function (swiper, slide, img) {
                            return _this2.options.onLazyImageReady && _this2.options.onLazyImageReady(swiper, slide, img);
                        };
                        var swiper = new Swiper(this.getNativeElement().children[0], options);
                        this.slider = swiper;
                        /*
                        * TODO: Finish this
                        if(util.isTrueProperty(this.zoom)) {
                          this.enableZoom = true;
                          setTimeout(() => {
                            this.initZoom();
                          })
                        }
                        */
                    }
                }, {
                    key: "onTap",
                    value: function onTap(swiper, e) {}
                }, {
                    key: "onClick",
                    value: function onClick(swiper, e) {}
                }, {
                    key: "onDoubleTap",
                    value: function onDoubleTap(swiper, e) {
                        this.toggleZoom(swiper, e);
                    }
                }, {
                    key: "onLazyImageLoad",
                    value: function onLazyImageLoad(swiper, slide, img) {}
                }, {
                    key: "onLazyImageReady",
                    value: function onLazyImageReady(swiper, slide, img) {}

                    /*
                    nextButton(swiper, e) {
                    }
                    prevButton() {
                    }
                    indexButton() {
                    }
                    */
                }, {
                    key: "initZoom",
                    value: function initZoom() {
                        var _this3 = this;

                        this.zoomDuration = this.zoomDuration || 230;
                        this.maxScale = this.zoomMax || 3;
                        this.zoomElement = this.getNativeElement().children[0].children[0];
                        this.zoomElement && this.zoomElement.classList.add('ion-scroll-zoom');
                        this.zoomGesture = new Gesture(this.zoomElement);
                        this.zoomGesture.listen();
                        this.scale = 1;
                        this.zoomLastPosX = 0;
                        this.zoomLastPosY = 0;
                        var last_scale = undefined,
                            startX = undefined,
                            startY = undefined,
                            posX = 0,
                            posY = 0,
                            zoomRect = undefined;
                        this.viewportWidth = this.getNativeElement().offsetWidth;
                        this.viewportHeight = this.getNativeElement().offsetHeight;
                        this.zoomElement.addEventListener('touchstart', function (e) {
                            _this3.onTouchStart(e);
                        });
                        this.zoomElement.addEventListener('touchmove', function (e) {
                            _this3.onTouchMove(e);
                        });
                        this.zoomElement.addEventListener('touchend', function (e) {
                            _this3.onTouchEnd(e);
                        });
                        this.zoomGesture.on('pinchstart', function (e) {
                            last_scale = _this3.scale;
                            console.log('Last scale', e.scale);
                        });
                        this.zoomGesture.on('pinch', function (e) {
                            _this3.scale = Math.max(1, Math.min(last_scale * e.scale, 10));
                            console.log('Scaling', _this3.scale);
                            _this3.zoomElement.style[CSS.transform] = 'scale(' + _this3.scale + ')';
                            zoomRect = _this3.zoomElement.getBoundingClientRect();
                        });
                        this.zoomGesture.on('pinchend', function (e) {
                            //last_scale = Math.max(1, Math.min(last_scale * e.scale, 10));
                            if (_this3.scale > _this3.maxScale) {
                                var za = new Animation(_this3.zoomElement).duration(_this3.zoomDuration).easing('linear').from('scale', _this3.scale).to('scale', _this3.maxScale);
                                za.play();
                                _this3.scale = _this3.maxScale;
                            }
                        });
                    }
                }, {
                    key: "resetZoom",
                    value: function resetZoom() {
                        if (this.zoomElement) {
                            this.zoomElement.parentElement.style[CSS.transform] = '';
                            this.zoomElement.style[CSS.transform] = 'scale(1)';
                        }
                        this.scale = 1;
                        this.zoomLastPosX = 0;
                        this.zoomLastPosY = 0;
                    }
                }, {
                    key: "toggleZoom",
                    value: function toggleZoom(swiper, e) {
                        console.log('Try toggle zoom');
                        if (!this.enableZoom) {
                            return;
                        }
                        console.log('Toggling zoom', e);
                        /*
                        let x = e.pointers[0].clientX;
                        let y = e.pointers[0].clientY;
                             let mx = this.viewportWidth / 2;
                        let my = this.viewportHeight / 2;
                             let tx, ty;
                             if(x > mx) {
                          // Greater than half
                          tx = -x;
                        } else {
                          // Less than or equal to half
                          tx = (this.viewportWidth - x);
                        }
                        if(y > my) {
                          ty = -y;
                        } else {
                          ty = y-my;
                        }
                             console.log(y);
                        */
                        var zi = new Animation(this.touch.target.children[0]).duration(this.zoomDuration).easing('linear').fill('none');
                        var zw = new Animation(this.touch.target.children[0]).duration(this.zoomDuration).easing('linear');
                        var za = new Animation();
                        za.fill('none');
                        za.add(zi); //, zw);
                        if (this.scale > 1) {
                            // Zoom out
                            //zw.fromTo('translateX', posX + 'px', '0px');
                            //zw.fromTo('translateY', posY + 'px', '0px');
                            zi.from('scale', this.scale);
                            zi.to('scale', 1);
                            za.play();
                            //posX = 0;
                            //posY = 0;
                            this.scale = 1;
                        } else {
                            // Zoom in
                            //zw.fromTo('translateX', posX + 'px', tx + 'px');
                            //zw.fromTo('translateY', posY + 'px', ty + 'px');
                            zi.from('scale', this.scale);
                            zi.to('scale', this.maxScale);
                            za.play();
                            //posX = tx;
                            //posY = ty;
                            this.scale = this.maxScale;
                        }
                    }
                }, {
                    key: "onTransitionStart",
                    value: function onTransitionStart(swiper) {}
                }, {
                    key: "onTransitionEnd",
                    value: function onTransitionEnd(swiper) {}
                }, {
                    key: "onTouchStart",
                    value: function onTouchStart(e) {
                        console.log('Touch start', e);
                        //TODO: Support mice as well
                        var target = dom.closest(e.target, '.slide').children[0].children[0];
                        this.touch = {
                            startX: e.touches[0].clientX,
                            startY: e.touches[0].clientY,
                            deltaX: 0,
                            deltaY: 0,
                            lastX: 0,
                            lastY: 0,
                            target: target.parentElement,
                            zoomable: target,
                            zoomableWidth: target.offsetWidth,
                            zoomableHeight: target.offsetHeight
                        };
                        console.log('Target', this.touch.target);
                        //TODO: android prevent default
                    }
                }, {
                    key: "onTouchMove",
                    value: function onTouchMove(e) {
                        this.touch.deltaX = e.touches[0].clientX - this.touch.startX;
                        this.touch.deltaY = e.touches[0].clientY - this.touch.startY;
                        // TODO: Make sure we need to transform (image is bigger than viewport)
                        var zoomableScaledWidth = this.touch.zoomableWidth * this.scale;
                        var zoomableScaledHeight = this.touch.zoomableHeight * this.scale;
                        var x1 = Math.min(this.viewportWidth / 2 - zoomableScaledWidth / 2, 0);
                        var x2 = -x1;
                        var y1 = Math.min(this.viewportHeight / 2 - zoomableScaledHeight / 2, 0);
                        var y2 = -y1;
                        console.log('BOUNDS', x1, x2, y1, y2);
                        if (this.scale <= 1) {
                            return;
                        }
                        console.log('PAN', e);
                        // Move image
                        this.touch.x = this.touch.deltaX + this.touch.lastX;
                        this.touch.y = this.touch.deltaY + this.touch.lastY;
                        console.log(this.touch.x, this.touch.y);
                        if (this.touch.x < x1) {
                            console.log('OUT ON LEFT');
                        }
                        if (this.touch.x > x2) {
                            console.log('OUT ON RIGHT');
                        }
                        if (this.touch.x > this.viewportWidth) {} else if (-this.touch.x > this.viewportWidth) {} else {
                            console.log('TRANSFORM', this.touch.x, this.touch.y, this.touch.target);
                            //this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
                            this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    }
                }, {
                    key: "onTouchEnd",
                    value: function onTouchEnd(e) {
                        console.log('PANEND', e);
                        if (this.scale > 1) {
                            if (Math.abs(this.touch.x) > this.viewportWidth) {
                                posX = posX > 0 ? this.viewportWidth - 1 : -(this.viewportWidth - 1);
                                console.log('Setting on posx', this.touch.x);
                            }
                            /*
                            if(posY > this.viewportHeight/2) {
                              let z = new Animation(this.zoomElement.parentElement);
                              z.fromTo('translateY', posY + 'px', Math.min(this.viewportHeight/2 + 30, posY));
                              z.play();
                            } else {
                              let z = new Animation(this.zoomElement.parentElement);
                              z.fromTo('translateY', posY + 'px', Math.max(this.viewportHeight/2 - 30, posY));
                              z.play();
                            }
                            */
                            this.touch.lastX = this.touch.x;
                            this.touch.lastY = this.touch.y;
                        }
                    }

                    /**
                     * Update the underlying slider implementation. Call this if you've added or removed
                     * child slides.
                     */
                }, {
                    key: "update",
                    value: function update() {
                        var _this4 = this;

                        setTimeout(function () {
                            _this4.slider.update();
                            // Don't allow pager to show with > 10 slides
                            if (_this4.slider.slides.length > 10) {
                                _this4.showPager = false;
                            }
                        });
                    }
                }, {
                    key: "next",
                    value: function next() {
                        this.slider.slideNext();
                    }
                }, {
                    key: "prev",
                    value: function prev() {
                        this.slider.slidePrev();
                    }
                }, {
                    key: "getIndex",
                    value: function getIndex() {
                        return this.slider.activeIndex;
                    }
                }, {
                    key: "getNumSlides",
                    value: function getNumSlides() {
                        return this.slider.slides.length;
                    }
                }, {
                    key: "isAtEnd",
                    value: function isAtEnd() {
                        return this.slider.isEnd;
                    }
                }, {
                    key: "isAtBeginning",
                    value: function isAtBeginning() {
                        return this.slider.isBeginning;
                    }
                }, {
                    key: "getSliderWidget",
                    value: function getSliderWidget() {
                        return this.slider;
                    }
                }]);

                return Slides;
            })(Ion);

            _export("Slides", Slides);

            _export("Slides", Slides = __decorate([IonicComponent({
                selector: 'ion-slides',
                properties: ['loop', 'index', 'bounce', 'pager', 'options', 'zoom', 'zoomDuration', 'zoomMax']
            }), View({
                template: "<div class=\"swiper-container\">\n    <div class=\"swiper-wrapper\">\n      <ng-content></ng-content>\n    </div>\n    <div [class.hide]=\"!showPager\" class=\"swiper-pagination\"></div>\n  </div>",
                directives: [NgIf, NgClass]
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Slides));
            /**
             * TODO
             */

            Slide =
            /**
             * TODO
             * @param {Slides} slides  The containing slidebox.
             * @param {ElementRef} elementRef  TODO
             */
            function Slide(elementRef, slides) {
                _classCallCheck(this, Slide);

                this.ele = elementRef.nativeElement;
                this.ele.classList.add('swiper-slide');
                slides.rapidUpdate();
            };

            _export("Slide", Slide);

            _export("Slide", Slide = __decorate([IonicComponent({
                selector: 'ion-slide',
                properties: ['zoom']
            }), View({
                template: "<div class=\"slide-zoom\"><ng-content></ng-content></div>"
            }), __param(1, Host()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, Slides])], Slide));

            SlideLazy = function SlideLazy(elementRef) {
                _classCallCheck(this, SlideLazy);

                elementRef.getNativeElement().classList.add('swiper-lazy');
            };

            _export("SlideLazy", SlideLazy);

            _export("SlideLazy", SlideLazy = __decorate([IonicDirective({
                selector: 'slide-lazy'
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object])], SlideLazy));
        }
    };
});
System.register('ionic/components/slides/swiper-widget',[],function(_export){ /**
 * Swiper 3.1.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 *
 * http://www.idangero.us/swiper/
 *
 * Copyright 2015, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: August 22, 2015
 */'use strict';var $,Dom7,swiperDomPlugins,i,domLib;_export('Swiper',Swiper); /*===========================
Swiper
===========================*/function Swiper(container,params){if(!(this instanceof Swiper))return new Swiper(container,params);var defaults={direction:'horizontal',touchEventsTarget:'container',initialSlide:0,speed:300, // autoplay
autoplay:false,autoplayDisableOnInteraction:true, // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
iOSEdgeSwipeDetection:false,iOSEdgeSwipeThreshold:20, // Free mode
freeMode:false,freeModeMomentum:true,freeModeMomentumRatio:1,freeModeMomentumBounce:true,freeModeMomentumBounceRatio:1,freeModeSticky:false, // Set wrapper width
setWrapperSize:false, // Virtual Translate
virtualTranslate:false, // Effects
effect:'slide',coverflow:{rotate:50,stretch:0,depth:100,modifier:1,slideShadows:true},cube:{slideShadows:true,shadow:true,shadowOffset:20,shadowScale:0.94},fade:{crossFade:false}, // Parallax
parallax:false, // Scrollbar
scrollbar:null,scrollbarHide:true, // Keyboard Mousewheel
keyboardControl:false,mousewheelControl:false,mousewheelReleaseOnEdges:false,mousewheelInvert:false,mousewheelForceToAxis:false,mousewheelSensitivity:1, // Hash Navigation
hashnav:false, // Slides grid
spaceBetween:0,slidesPerView:1,slidesPerColumn:1,slidesPerColumnFill:'column',slidesPerGroup:1,centeredSlides:false,slidesOffsetBefore:0,slidesOffsetAfter:0, // Round length
roundLengths:false, // Touches
touchRatio:1,touchAngle:45,simulateTouch:true,shortSwipes:true,longSwipes:true,longSwipesRatio:0.5,longSwipesMs:300,followFinger:true,onlyExternal:false,threshold:0,touchMoveStopPropagation:true, // Pagination
pagination:null,paginationElement:'span',paginationClickable:false,paginationHide:false,paginationBulletRender:null, // Resistance
resistance:true,resistanceRatio:0.85, // Next/prev buttons
nextButton:null,prevButton:null, // Progress
watchSlidesProgress:false,watchSlidesVisibility:false, // Cursor
grabCursor:false, // Clicks
preventClicks:true,preventClicksPropagation:true,slideToClickedSlide:false, // Lazy Loading
lazyLoading:false,lazyLoadingInPrevNext:false,lazyLoadingOnTransitionStart:false, // Images
preloadImages:true,updateOnImagesReady:true, // loop
loop:false,loopAdditionalSlides:0,loopedSlides:null, // Control
control:undefined,controlInverse:false,controlBy:'slide', // Swiping/no swiping
allowSwipeToPrev:true,allowSwipeToNext:true,swipeHandler:null,noSwiping:true,noSwipingClass:'swiper-no-swiping', // NS
slideClass:'swiper-slide',slideActiveClass:'swiper-slide-active',slideVisibleClass:'swiper-slide-visible',slideDuplicateClass:'swiper-slide-duplicate',slideNextClass:'swiper-slide-next',slidePrevClass:'swiper-slide-prev',wrapperClass:'swiper-wrapper',bulletClass:'swiper-pagination-bullet',bulletActiveClass:'swiper-pagination-bullet-active',buttonDisabledClass:'swiper-button-disabled',paginationHiddenClass:'swiper-pagination-hidden', // Observer
observer:false,observeParents:false, // Accessibility
a11y:false,prevSlideMessage:'Previous slide',nextSlideMessage:'Next slide',firstSlideMessage:'This is the first slide',lastSlideMessage:'This is the last slide',paginationBulletMessage:'Go to slide {{index}}', // Callbacks
runCallbacksOnInit:true};var initialVirtualTranslate=params && params.virtualTranslate;params = params || {};for(var def in defaults) {if(typeof params[def] === 'undefined'){params[def] = defaults[def];}else if(typeof params[def] === 'object'){for(var deepDef in defaults[def]) {if(typeof params[def][deepDef] === 'undefined'){params[def][deepDef] = defaults[def][deepDef];}}}} // Swiper
var s=this; // Version
s.version = '3.1.0'; // Params
s.params = params; // Classname
s.classNames = []; /*=========================
      Dom Library and plugins
      ===========================*/if(typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){$ = Dom7;}if(typeof $ === 'undefined'){if(typeof Dom7 === 'undefined'){$ = window.Dom7 || window.Zepto || window.jQuery;}else {$ = Dom7;}if(!$)return;} // Export it to Swiper instance
s.$ = $; /*=========================
      Preparation - Define Container, Wrapper and Pagination
      ===========================*/s.container = $(container);if(s.container.length === 0)return;if(s.container.length > 1){s.container.each(function(){new Swiper(this,params);});return;} // Save instance in container HTML Element and in data
s.container[0].swiper = s;s.container.data('swiper',s);s.classNames.push('swiper-container-' + s.params.direction);if(s.params.freeMode){s.classNames.push('swiper-container-free-mode');}if(!s.support.flexbox){s.classNames.push('swiper-container-no-flexbox');s.params.slidesPerColumn = 1;} // Enable slides progress when required
if(s.params.parallax || s.params.watchSlidesVisibility){s.params.watchSlidesProgress = true;} // Coverflow / 3D
if(['cube','coverflow'].indexOf(s.params.effect) >= 0){if(s.support.transforms3d){s.params.watchSlidesProgress = true;s.classNames.push('swiper-container-3d');}else {s.params.effect = 'slide';}}if(s.params.effect !== 'slide'){s.classNames.push('swiper-container-' + s.params.effect);}if(s.params.effect === 'cube'){s.params.resistanceRatio = 0;s.params.slidesPerView = 1;s.params.slidesPerColumn = 1;s.params.slidesPerGroup = 1;s.params.centeredSlides = false;s.params.spaceBetween = 0;s.params.virtualTranslate = true;s.params.setWrapperSize = false;}if(s.params.effect === 'fade'){s.params.slidesPerView = 1;s.params.slidesPerColumn = 1;s.params.slidesPerGroup = 1;s.params.watchSlidesProgress = true;s.params.spaceBetween = 0;if(typeof initialVirtualTranslate === 'undefined'){s.params.virtualTranslate = true;}} // Grab Cursor
if(s.params.grabCursor && s.support.touch){s.params.grabCursor = false;} // Wrapper
s.wrapper = s.container.children('.' + s.params.wrapperClass); // Pagination
if(s.params.pagination){s.paginationContainer = $(s.params.pagination);if(s.params.paginationClickable){s.paginationContainer.addClass('swiper-pagination-clickable');}} // Is Horizontal
function isH(){return s.params.direction === 'horizontal';} // RTL
s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');if(s.rtl){s.classNames.push('swiper-container-rtl');} // Wrong RTL support
if(s.rtl){s.wrongRTL = s.wrapper.css('display') === '-webkit-box';} // Columns
if(s.params.slidesPerColumn > 1){s.classNames.push('swiper-container-multirow');} // Check for Android
if(s.device.android){s.classNames.push('swiper-container-android');} // Add classes
s.container.addClass(s.classNames.join(' ')); // Translate
s.translate = 0; // Progress
s.progress = 0; // Velocity
s.velocity = 0; /*=========================
      Locks, unlocks
      ===========================*/s.lockSwipeToNext = function(){s.params.allowSwipeToNext = false;};s.lockSwipeToPrev = function(){s.params.allowSwipeToPrev = false;};s.lockSwipes = function(){s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;};s.unlockSwipeToNext = function(){s.params.allowSwipeToNext = true;};s.unlockSwipeToPrev = function(){s.params.allowSwipeToPrev = true;};s.unlockSwipes = function(){s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;}; /*=========================
      Round helper
      ===========================*/function round(a){return Math.floor(a);} /*=========================
      Set grab cursor
      ===========================*/if(s.params.grabCursor){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grab';s.container[0].style.cursor = '-moz-grab';s.container[0].style.cursor = 'grab';} /*=========================
      Update on Images Ready
      ===========================*/s.imagesToLoad = [];s.imagesLoaded = 0;s.loadImage = function(imgElement,src,checkForComplete,callback){var image;function onReady(){if(callback)callback();}if(!imgElement.complete || !checkForComplete){if(src){image = new window.Image();image.onload = onReady;image.onerror = onReady;image.src = src;}else {onReady();}}else {onReady();}};s.preloadImages = function(){s.imagesToLoad = s.container.find('img');function _onReady(){if(typeof s === 'undefined' || s === null)return;if(s.imagesLoaded !== undefined)s.imagesLoaded++;if(s.imagesLoaded === s.imagesToLoad.length){if(s.params.updateOnImagesReady)s.update();s.emit('onImagesReady',s);}}for(var i=0;i < s.imagesToLoad.length;i++) {s.loadImage(s.imagesToLoad[i],s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src'),true,_onReady);}}; /*=========================
      Autoplay
      ===========================*/s.autoplayTimeoutId = undefined;s.autoplaying = false;s.autoplayPaused = false;function autoplay(){s.autoplayTimeoutId = setTimeout(function(){if(s.params.loop){s.fixLoop();s._slideNext();}else {if(!s.isEnd){s._slideNext();}else {if(!params.autoplayStopOnLast){s._slideTo(0);}else {s.stopAutoplay();}}}},s.params.autoplay);}s.startAutoplay = function(){if(typeof s.autoplayTimeoutId !== 'undefined')return false;if(!s.params.autoplay)return false;if(s.autoplaying)return false;s.autoplaying = true;s.emit('onAutoplayStart',s);autoplay();};s.stopAutoplay = function(internal){if(!s.autoplayTimeoutId)return;if(s.autoplayTimeoutId)clearTimeout(s.autoplayTimeoutId);s.autoplaying = false;s.autoplayTimeoutId = undefined;s.emit('onAutoplayStop',s);};s.pauseAutoplay = function(speed){if(s.autoplayPaused)return;if(s.autoplayTimeoutId)clearTimeout(s.autoplayTimeoutId);s.autoplayPaused = true;if(speed === 0){s.autoplayPaused = false;autoplay();}else {s.wrapper.transitionEnd(function(){if(!s)return;s.autoplayPaused = false;if(!s.autoplaying){s.stopAutoplay();}else {autoplay();}});}}; /*=========================
      Min/Max Translate
      ===========================*/s.minTranslate = function(){return -s.snapGrid[0];};s.maxTranslate = function(){return -s.snapGrid[s.snapGrid.length - 1];}; /*=========================
      Slider/slides sizes
      ===========================*/s.updateContainerSize = function(){var width,height;if(typeof s.params.width !== 'undefined'){width = s.params.width;}else {width = s.container[0].clientWidth;}if(typeof s.params.height !== 'undefined'){height = s.params.height;}else {height = s.container[0].clientHeight;}if(width === 0 && isH() || height === 0 && !isH()){return;} //Subtract paddings
width = width - parseInt(s.container.css('padding-left'),10) - parseInt(s.container.css('padding-right'),10);height = height - parseInt(s.container.css('padding-top'),10) - parseInt(s.container.css('padding-bottom'),10); // Store values
s.width = width;s.height = height;s.size = isH()?s.width:s.height;};s.updateSlidesSize = function(){s.slides = s.wrapper.children('.' + s.params.slideClass);s.snapGrid = [];s.slidesGrid = [];s.slidesSizesGrid = [];var spaceBetween=s.params.spaceBetween,slidePosition=-s.params.slidesOffsetBefore,i,prevSlideSize=0,index=0;if(typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0){spaceBetween = parseFloat(spaceBetween.replace('%','')) / 100 * s.size;}s.virtualSize = -spaceBetween; // reset margins
if(s.rtl)s.slides.css({marginLeft:'',marginTop:''});else s.slides.css({marginRight:'',marginBottom:''});var slidesNumberEvenToRows;if(s.params.slidesPerColumn > 1){if(Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn){slidesNumberEvenToRows = s.slides.length;}else {slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;}} // Calc slides
var slideSize;var slidesPerColumn=s.params.slidesPerColumn;var slidesPerRow=slidesNumberEvenToRows / slidesPerColumn;var numFullColumns=slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);for(i = 0;i < s.slides.length;i++) {slideSize = 0;var slide=s.slides.eq(i);if(s.params.slidesPerColumn > 1){ // Set slides order
var newSlideOrderIndex;var column,row;if(s.params.slidesPerColumnFill === 'column'){column = Math.floor(i / slidesPerColumn);row = i - column * slidesPerColumn;if(column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1){if(++row >= slidesPerColumn){row = 0;column++;}}newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;slide.css({'-webkit-box-ordinal-group':newSlideOrderIndex,'-moz-box-ordinal-group':newSlideOrderIndex,'-ms-flex-order':newSlideOrderIndex,'-webkit-order':newSlideOrderIndex,'order':newSlideOrderIndex});}else {row = Math.floor(i / slidesPerRow);column = i - row * slidesPerRow;}slide.css({'margin-top':row !== 0 && s.params.spaceBetween && s.params.spaceBetween + 'px'}).attr('data-swiper-column',column).attr('data-swiper-row',row);}if(slide.css('display') === 'none')continue;if(s.params.slidesPerView === 'auto'){slideSize = isH()?slide.outerWidth(true):slide.outerHeight(true);if(s.params.roundLengths)slideSize = round(slideSize);}else {slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;if(s.params.roundLengths)slideSize = round(slideSize);if(isH()){s.slides[i].style.width = slideSize + 'px';}else {s.slides[i].style.height = slideSize + 'px';}}s.slides[i].swiperSlideSize = slideSize;s.slidesSizesGrid.push(slideSize);if(s.params.centeredSlides){slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;if(i === 0)slidePosition = slidePosition - s.size / 2 - spaceBetween;if(Math.abs(slidePosition) < 1 / 1000)slidePosition = 0;if(index % s.params.slidesPerGroup === 0)s.snapGrid.push(slidePosition);s.slidesGrid.push(slidePosition);}else {if(index % s.params.slidesPerGroup === 0)s.snapGrid.push(slidePosition);s.slidesGrid.push(slidePosition);slidePosition = slidePosition + slideSize + spaceBetween;}s.virtualSize += slideSize + spaceBetween;prevSlideSize = slideSize;index++;}s.virtualSize = Math.max(s.virtualSize,s.size) + s.params.slidesOffsetAfter;var newSlidesGrid;if(s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')){s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});}if(!s.support.flexbox || s.params.setWrapperSize){if(isH())s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});else s.wrapper.css({height:s.virtualSize + s.params.spaceBetween + 'px'});}if(s.params.slidesPerColumn > 1){s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;s.wrapper.css({width:s.virtualSize + s.params.spaceBetween + 'px'});if(s.params.centeredSlides){newSlidesGrid = [];for(i = 0;i < s.snapGrid.length;i++) {if(s.snapGrid[i] < s.virtualSize + s.snapGrid[0])newSlidesGrid.push(s.snapGrid[i]);}s.snapGrid = newSlidesGrid;}} // Remove last grid elements depending on width
if(!s.params.centeredSlides){newSlidesGrid = [];for(i = 0;i < s.snapGrid.length;i++) {if(s.snapGrid[i] <= s.virtualSize - s.size){newSlidesGrid.push(s.snapGrid[i]);}}s.snapGrid = newSlidesGrid;if(Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])){s.snapGrid.push(s.virtualSize - s.size);}}if(s.snapGrid.length === 0)s.snapGrid = [0];if(s.params.spaceBetween !== 0){if(isH()){if(s.rtl)s.slides.css({marginLeft:spaceBetween + 'px'});else s.slides.css({marginRight:spaceBetween + 'px'});}else s.slides.css({marginBottom:spaceBetween + 'px'});}if(s.params.watchSlidesProgress){s.updateSlidesOffset();}};s.updateSlidesOffset = function(){for(var i=0;i < s.slides.length;i++) {s.slides[i].swiperSlideOffset = isH()?s.slides[i].offsetLeft:s.slides[i].offsetTop;}}; /*=========================
      Slider/slides progress
      ===========================*/s.updateSlidesProgress = function(translate){if(typeof translate === 'undefined'){translate = s.translate || 0;}if(s.slides.length === 0)return;if(typeof s.slides[0].swiperSlideOffset === 'undefined')s.updateSlidesOffset();var offsetCenter=-translate;if(s.rtl)offsetCenter = translate; // Visible Slides
var containerBox=s.container[0].getBoundingClientRect();var sideBefore=isH()?'left':'top';var sideAfter=isH()?'right':'bottom';s.slides.removeClass(s.params.slideVisibleClass);for(var i=0;i < s.slides.length;i++) {var slide=s.slides[i];var slideProgress=(offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);if(s.params.watchSlidesVisibility){var slideBefore=-(offsetCenter - slide.swiperSlideOffset);var slideAfter=slideBefore + s.slidesSizesGrid[i];var isVisible=slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || slideBefore <= 0 && slideAfter >= s.size;if(isVisible){s.slides.eq(i).addClass(s.params.slideVisibleClass);}}slide.progress = s.rtl?-slideProgress:slideProgress;}};s.updateProgress = function(translate){if(typeof translate === 'undefined'){translate = s.translate || 0;}var translatesDiff=s.maxTranslate() - s.minTranslate();if(translatesDiff === 0){s.progress = 0;s.isBeginning = s.isEnd = true;}else {s.progress = (translate - s.minTranslate()) / translatesDiff;s.isBeginning = s.progress <= 0;s.isEnd = s.progress >= 1;}if(s.isBeginning)s.emit('onReachBeginning',s);if(s.isEnd)s.emit('onReachEnd',s);if(s.params.watchSlidesProgress)s.updateSlidesProgress(translate);s.emit('onProgress',s,s.progress);};s.updateActiveIndex = function(){var translate=s.rtl?s.translate:-s.translate;var newActiveIndex,i,snapIndex;for(i = 0;i < s.slidesGrid.length;i++) {if(typeof s.slidesGrid[i + 1] !== 'undefined'){if(translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2){newActiveIndex = i;}else if(translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]){newActiveIndex = i + 1;}}else {if(translate >= s.slidesGrid[i]){newActiveIndex = i;}}} // Normalize slideIndex
if(newActiveIndex < 0 || typeof newActiveIndex === 'undefined')newActiveIndex = 0; // for (i = 0; i < s.slidesGrid.length; i++) {
// if (- translate >= s.slidesGrid[i]) {
// newActiveIndex = i;
// }
// }
snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);if(snapIndex >= s.snapGrid.length)snapIndex = s.snapGrid.length - 1;if(newActiveIndex === s.activeIndex){return;}s.snapIndex = snapIndex;s.previousIndex = s.activeIndex;s.activeIndex = newActiveIndex;s.updateClasses();}; /*=========================
      Classes
      ===========================*/s.updateClasses = function(){s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);var activeSlide=s.slides.eq(s.activeIndex); // Active classes
activeSlide.addClass(s.params.slideActiveClass);activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass); // Pagination
if(s.bullets && s.bullets.length > 0){s.bullets.removeClass(s.params.bulletActiveClass);var bulletIndex;if(s.params.loop){bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup;if(bulletIndex > s.slides.length - 1 - s.loopedSlides * 2){bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);}if(bulletIndex > s.bullets.length - 1)bulletIndex = bulletIndex - s.bullets.length;}else {if(typeof s.snapIndex !== 'undefined'){bulletIndex = s.snapIndex;}else {bulletIndex = s.activeIndex || 0;}}if(s.paginationContainer.length > 1){s.bullets.each(function(){if($(this).index() === bulletIndex)$(this).addClass(s.params.bulletActiveClass);});}else {s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);}} // Next/active buttons
if(!s.params.loop){if(s.params.prevButton){if(s.isBeginning){$(s.params.prevButton).addClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.disable($(s.params.prevButton));}else {$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.enable($(s.params.prevButton));}}if(s.params.nextButton){if(s.isEnd){$(s.params.nextButton).addClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.disable($(s.params.nextButton));}else {$(s.params.nextButton).removeClass(s.params.buttonDisabledClass);if(s.params.a11y && s.a11y)s.a11y.enable($(s.params.nextButton));}}}}; /*=========================
      Pagination
      ===========================*/s.updatePagination = function(){if(!s.params.pagination)return;if(s.paginationContainer && s.paginationContainer.length > 0){var bulletsHTML='';var numberOfBullets=s.params.loop?Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup):s.snapGrid.length;for(var i=0;i < numberOfBullets;i++) {if(s.params.paginationBulletRender){bulletsHTML += s.params.paginationBulletRender(i,s.params.bulletClass);}else {bulletsHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';}}s.paginationContainer.html(bulletsHTML);s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);if(s.params.paginationClickable && s.params.a11y && s.a11y){s.a11y.initPagination();}}}; /*=========================
      Common update method
      ===========================*/s.update = function(updateTranslate){s.updateContainerSize();s.updateSlidesSize();s.updateProgress();s.updatePagination();s.updateClasses();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}function forceSetTranslate(){newTranslate = Math.min(Math.max(s.translate,s.maxTranslate()),s.minTranslate());s.setWrapperTranslate(newTranslate);s.updateActiveIndex();s.updateClasses();}if(updateTranslate){var translated,newTranslate;if(s.controller && s.controller.spline){s.controller.spline = undefined;}if(s.params.freeMode){forceSetTranslate();}else {if((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides){translated = s.slideTo(s.slides.length - 1,0,false,true);}else {translated = s.slideTo(s.activeIndex,0,false,true);}if(!translated){forceSetTranslate();}}}}; /*=========================
      Resize Handler
      ===========================*/s.onResize = function(forceUpdatePagination){ // Disable locks on resize
var allowSwipeToPrev=s.params.allowSwipeToPrev;var allowSwipeToNext=s.params.allowSwipeToNext;s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;s.updateContainerSize();s.updateSlidesSize();if(s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination)s.updatePagination();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}if(s.controller && s.controller.spline){s.controller.spline = undefined;}if(s.params.freeMode){var newTranslate=Math.min(Math.max(s.translate,s.maxTranslate()),s.minTranslate());s.setWrapperTranslate(newTranslate);s.updateActiveIndex();s.updateClasses();}else {s.updateClasses();if((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides){s.slideTo(s.slides.length - 1,0,false,true);}else {s.slideTo(s.activeIndex,0,false,true);}} // Return locks after resize
s.params.allowSwipeToPrev = allowSwipeToPrev;s.params.allowSwipeToNext = allowSwipeToNext;}; /*=========================
      Events
      ===========================*/ //Define Touch Events
var desktopEvents=['mousedown','mousemove','mouseup'];if(window.navigator.pointerEnabled)desktopEvents = ['pointerdown','pointermove','pointerup'];else if(window.navigator.msPointerEnabled)desktopEvents = ['MSPointerDown','MSPointerMove','MSPointerUp'];s.touchEvents = {start:s.support.touch || !s.params.simulateTouch?'touchstart':desktopEvents[0],move:s.support.touch || !s.params.simulateTouch?'touchmove':desktopEvents[1],end:s.support.touch || !s.params.simulateTouch?'touchend':desktopEvents[2]}; // WP8 Touch Events Fix
if(window.navigator.pointerEnabled || window.navigator.msPointerEnabled){(s.params.touchEventsTarget === 'container'?s.container:s.wrapper).addClass('swiper-wp8-' + s.params.direction);} // Attach/detach events
s.initEvents = function(detach){var actionDom=detach?'off':'on';var action=detach?'removeEventListener':'addEventListener';var touchEventsTarget=s.params.touchEventsTarget === 'container'?s.container[0]:s.wrapper[0];var target=s.support.touch?touchEventsTarget:document;var moveCapture=s.params.nested?true:false; //Touch Events
if(s.browser.ie){touchEventsTarget[action](s.touchEvents.start,s.onTouchStart,false);target[action](s.touchEvents.move,s.onTouchMove,moveCapture);target[action](s.touchEvents.end,s.onTouchEnd,false);}else {if(s.support.touch){touchEventsTarget[action](s.touchEvents.start,s.onTouchStart,false);touchEventsTarget[action](s.touchEvents.move,s.onTouchMove,moveCapture);touchEventsTarget[action](s.touchEvents.end,s.onTouchEnd,false);}if(params.simulateTouch && !s.device.ios && !s.device.android){touchEventsTarget[action]('mousedown',s.onTouchStart,false);document[action]('mousemove',s.onTouchMove,moveCapture);document[action]('mouseup',s.onTouchEnd,false);}}window[action]('resize',s.onResize); // Next, Prev, Index
if(s.params.nextButton){$(s.params.nextButton)[actionDom]('click',s.onClickNext);if(s.params.a11y && s.a11y)$(s.params.nextButton)[actionDom]('keydown',s.a11y.onEnterKey);}if(s.params.prevButton){$(s.params.prevButton)[actionDom]('click',s.onClickPrev);if(s.params.a11y && s.a11y)$(s.params.prevButton)[actionDom]('keydown',s.a11y.onEnterKey);}if(s.params.pagination && s.params.paginationClickable){$(s.paginationContainer)[actionDom]('click','.' + s.params.bulletClass,s.onClickIndex);if(s.params.a11y && s.a11y)$(s.paginationContainer)[actionDom]('keydown','.' + s.params.bulletClass,s.a11y.onEnterKey);} // Prevent Links Clicks
if(s.params.preventClicks || s.params.preventClicksPropagation)touchEventsTarget[action]('click',s.preventClicks,true);};s.attachEvents = function(detach){s.initEvents();};s.detachEvents = function(){s.initEvents(true);}; /*=========================
      Handle Clicks
      ===========================*/ // Prevent Clicks
s.allowClick = true;s.preventClicks = function(e){if(!s.allowClick){if(s.params.preventClicks)e.preventDefault();if(s.params.preventClicksPropagation && s.animating){e.stopPropagation();e.stopImmediatePropagation();}}}; // Clicks
s.onClickNext = function(e){e.preventDefault();if(s.isEnd && !s.params.loop)return;s.slideNext();};s.onClickPrev = function(e){e.preventDefault();if(s.isBeginning && !s.params.loop)return;s.slidePrev();};s.onClickIndex = function(e){e.preventDefault();var index=$(this).index() * s.params.slidesPerGroup;if(s.params.loop)index = index + s.loopedSlides;s.slideTo(index);}; /*=========================
      Handle Touches
      ===========================*/function findElementInEvent(e,selector){var el=$(e.target);if(!el.is(selector)){if(typeof selector === 'string'){el = el.parents(selector);}else if(selector.nodeType){var found;el.parents().each(function(index,_el){if(_el === selector)found = selector;});if(!found)return undefined;else return selector;}}if(el.length === 0){return undefined;}return el[0];}s.updateClickedSlide = function(e){var slide=findElementInEvent(e,'.' + s.params.slideClass);var slideFound=false;if(slide){for(var i=0;i < s.slides.length;i++) {if(s.slides[i] === slide)slideFound = true;}}if(slide && slideFound){s.clickedSlide = slide;s.clickedIndex = $(slide).index();}else {s.clickedSlide = undefined;s.clickedIndex = undefined;return;}if(s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex){var slideToIndex=s.clickedIndex,realIndex;if(s.params.loop){realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');if(slideToIndex > s.slides.length - s.params.slidesPerView){s.fixLoop();slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]').eq(0).index();setTimeout(function(){s.slideTo(slideToIndex);},0);}else if(slideToIndex < s.params.slidesPerView - 1){s.fixLoop();var duplicatedSlides=s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]');slideToIndex = duplicatedSlides.eq(duplicatedSlides.length - 1).index();setTimeout(function(){s.slideTo(slideToIndex);},0);}else {s.slideTo(slideToIndex);}}else {s.slideTo(slideToIndex);}}};var isTouched,isMoved,touchStartTime,isScrolling,currentTranslate,startTranslate,allowThresholdMove, // Form elements to match
formElements='input, select, textarea, button', // Last click time
lastClickTime=Date.now(),clickTimeout, //Velocities
velocities=[],allowMomentumBounce; // Animating Flag
s.animating = false; // Touches information
s.touches = {startX:0,startY:0,currentX:0,currentY:0,diff:0}; // Touch handlers
var isTouchEvent,startMoving;s.onTouchStart = function(e){if(e.originalEvent)e = e.originalEvent;isTouchEvent = e.type === 'touchstart';if(!isTouchEvent && 'which' in e && e.which === 3)return;if(s.params.noSwiping && findElementInEvent(e,'.' + s.params.noSwipingClass)){s.allowClick = true;return;}if(s.params.swipeHandler){if(!findElementInEvent(e,s.params.swipeHandler))return;}var startX=s.touches.currentX = e.type === 'touchstart'?e.targetTouches[0].pageX:e.pageX;var startY=s.touches.currentY = e.type === 'touchstart'?e.targetTouches[0].pageY:e.pageY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold){return;}isTouched = true;isMoved = false;isScrolling = undefined;startMoving = undefined;s.touches.startX = startX;s.touches.startY = startY;touchStartTime = Date.now();s.allowClick = true;s.updateContainerSize();s.swipeDirection = undefined;if(s.params.threshold > 0)allowThresholdMove = false;if(e.type !== 'touchstart'){var preventDefault=true;if($(e.target).is(formElements))preventDefault = false;if(document.activeElement && $(document.activeElement).is(formElements)){document.activeElement.blur();}if(preventDefault){e.preventDefault();}}s.emit('onTouchStart',s,e);};s.onTouchMove = function(e){if(e.originalEvent)e = e.originalEvent;if(isTouchEvent && e.type === 'mousemove')return;if(e.preventedByNestedSwiper)return;if(s.params.onlyExternal){ // isMoved = true;
s.allowClick = false;if(isTouched){s.touches.startX = s.touches.currentX = e.type === 'touchmove'?e.targetTouches[0].pageX:e.pageX;s.touches.startY = s.touches.currentY = e.type === 'touchmove'?e.targetTouches[0].pageY:e.pageY;touchStartTime = Date.now();}return;}if(isTouchEvent && document.activeElement){if(e.target === document.activeElement && $(e.target).is(formElements)){isMoved = true;s.allowClick = false;return;}}s.emit('onTouchMove',s,e);if(e.targetTouches && e.targetTouches.length > 1)return;s.touches.currentX = e.type === 'touchmove'?e.targetTouches[0].pageX:e.pageX;s.touches.currentY = e.type === 'touchmove'?e.targetTouches[0].pageY:e.pageY;if(typeof isScrolling === 'undefined'){var touchAngle=Math.atan2(Math.abs(s.touches.currentY - s.touches.startY),Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;isScrolling = isH()?touchAngle > s.params.touchAngle:90 - touchAngle > s.params.touchAngle;}if(isScrolling){s.emit('onTouchMoveOpposite',s,e);}if(typeof startMoving === 'undefined' && s.browser.ieTouch){if(s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY){startMoving = true;}}if(!isTouched)return;if(isScrolling){isTouched = false;return;}if(!startMoving && s.browser.ieTouch){return;}s.allowClick = false;s.emit('onSliderMove',s,e);e.preventDefault();if(s.params.touchMoveStopPropagation && !s.params.nested){e.stopPropagation();}if(!isMoved){if(params.loop){s.fixLoop();}startTranslate = s.getWrapperTranslate();s.setWrapperTransition(0);if(s.animating){s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');}if(s.params.autoplay && s.autoplaying){if(s.params.autoplayDisableOnInteraction){s.stopAutoplay();}else {s.pauseAutoplay();}}allowMomentumBounce = false; //Grab Cursor
if(s.params.grabCursor){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grabbing';s.container[0].style.cursor = '-moz-grabbin';s.container[0].style.cursor = 'grabbing';}}isMoved = true;var diff=s.touches.diff = isH()?s.touches.currentX - s.touches.startX:s.touches.currentY - s.touches.startY;diff = diff * s.params.touchRatio;if(s.rtl)diff = -diff;s.swipeDirection = diff > 0?'prev':'next';currentTranslate = diff + startTranslate;var disableParentSwiper=true;if(diff > 0 && currentTranslate > s.minTranslate()){disableParentSwiper = false;if(s.params.resistance)currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff,s.params.resistanceRatio);}else if(diff < 0 && currentTranslate < s.maxTranslate()){disableParentSwiper = false;if(s.params.resistance)currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff,s.params.resistanceRatio);}if(disableParentSwiper){e.preventedByNestedSwiper = true;} // Directions locks
if(!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate){currentTranslate = startTranslate;}if(!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate){currentTranslate = startTranslate;}if(!s.params.followFinger)return; // Threshold
if(s.params.threshold > 0){if(Math.abs(diff) > s.params.threshold || allowThresholdMove){if(!allowThresholdMove){allowThresholdMove = true;s.touches.startX = s.touches.currentX;s.touches.startY = s.touches.currentY;currentTranslate = startTranslate;s.touches.diff = isH()?s.touches.currentX - s.touches.startX:s.touches.currentY - s.touches.startY;return;}}else {currentTranslate = startTranslate;return;}} // Update active index in free mode
if(s.params.freeMode || s.params.watchSlidesProgress){s.updateActiveIndex();}if(s.params.freeMode){ //Velocity
if(velocities.length === 0){velocities.push({position:s.touches[isH()?'startX':'startY'],time:touchStartTime});}velocities.push({position:s.touches[isH()?'currentX':'currentY'],time:new window.Date().getTime()});} // Update progress
s.updateProgress(currentTranslate); // Update translate
s.setWrapperTranslate(currentTranslate);};s.onTouchEnd = function(e){if(e.originalEvent)e = e.originalEvent;s.emit('onTouchEnd',s,e);if(!isTouched)return; //Return Grab Cursor
if(s.params.grabCursor && isMoved && isTouched){s.container[0].style.cursor = 'move';s.container[0].style.cursor = '-webkit-grab';s.container[0].style.cursor = '-moz-grab';s.container[0].style.cursor = 'grab';} // Time diff
var touchEndTime=Date.now();var timeDiff=touchEndTime - touchStartTime; // Tap, doubleTap, Click
if(s.allowClick){s.updateClickedSlide(e);s.emit('onTap',s,e);if(timeDiff < 300 && touchEndTime - lastClickTime > 300){if(clickTimeout)clearTimeout(clickTimeout);clickTimeout = setTimeout(function(){if(!s)return;if(s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)){s.paginationContainer.toggleClass(s.params.paginationHiddenClass);}s.emit('onClick',s,e);},300);}if(timeDiff < 300 && touchEndTime - lastClickTime < 300){if(clickTimeout)clearTimeout(clickTimeout);s.emit('onDoubleTap',s,e);}}lastClickTime = Date.now();setTimeout(function(){if(s)s.allowClick = true;},0);if(!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate){isTouched = isMoved = false;return;}isTouched = isMoved = false;var currentPos;if(s.params.followFinger){currentPos = s.rtl?s.translate:-s.translate;}else {currentPos = -currentTranslate;}if(s.params.freeMode){if(currentPos < -s.minTranslate()){s.slideTo(s.activeIndex);return;}else if(currentPos > -s.maxTranslate()){if(s.slides.length < s.snapGrid.length){s.slideTo(s.snapGrid.length - 1);}else {s.slideTo(s.slides.length - 1);}return;}if(s.params.freeModeMomentum){if(velocities.length > 1){var lastMoveEvent=velocities.pop(),velocityEvent=velocities.pop();var distance=lastMoveEvent.position - velocityEvent.position;var time=lastMoveEvent.time - velocityEvent.time;s.velocity = distance / time;s.velocity = s.velocity / 2;if(Math.abs(s.velocity) < 0.02){s.velocity = 0;} // this implies that the user stopped moving a finger then released.
// There would be no events with distance zero, so the last event is stale.
if(time > 150 || new window.Date().getTime() - lastMoveEvent.time > 300){s.velocity = 0;}}else {s.velocity = 0;}velocities.length = 0;var momentumDuration=1000 * s.params.freeModeMomentumRatio;var momentumDistance=s.velocity * momentumDuration;var newPosition=s.translate + momentumDistance;if(s.rtl)newPosition = -newPosition;var doBounce=false;var afterBouncePosition;var bounceAmount=Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;if(newPosition < s.maxTranslate()){if(s.params.freeModeMomentumBounce){if(newPosition + s.maxTranslate() < -bounceAmount){newPosition = s.maxTranslate() - bounceAmount;}afterBouncePosition = s.maxTranslate();doBounce = true;allowMomentumBounce = true;}else {newPosition = s.maxTranslate();}}else if(newPosition > s.minTranslate()){if(s.params.freeModeMomentumBounce){if(newPosition - s.minTranslate() > bounceAmount){newPosition = s.minTranslate() + bounceAmount;}afterBouncePosition = s.minTranslate();doBounce = true;allowMomentumBounce = true;}else {newPosition = s.minTranslate();}}else if(s.params.freeModeSticky){var j=0,nextSlide;for(j = 0;j < s.snapGrid.length;j += 1) {if(s.snapGrid[j] > -newPosition){nextSlide = j;break;}}if(Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next'){newPosition = s.snapGrid[nextSlide];}else {newPosition = s.snapGrid[nextSlide - 1];}if(!s.rtl)newPosition = -newPosition;} //Fix duration
if(s.velocity !== 0){if(s.rtl){momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);}else {momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);}}else if(s.params.freeModeSticky){s.slideReset();return;}if(s.params.freeModeMomentumBounce && doBounce){s.updateProgress(afterBouncePosition);s.setWrapperTransition(momentumDuration);s.setWrapperTranslate(newPosition);s.onTransitionStart();s.animating = true;s.wrapper.transitionEnd(function(){if(!s || !allowMomentumBounce)return;s.emit('onMomentumBounce',s);s.setWrapperTransition(s.params.speed);s.setWrapperTranslate(afterBouncePosition);s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd();});});}else if(s.velocity){s.updateProgress(newPosition);s.setWrapperTransition(momentumDuration);s.setWrapperTranslate(newPosition);s.onTransitionStart();if(!s.animating){s.animating = true;s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd();});}}else {s.updateProgress(newPosition);}s.updateActiveIndex();}if(!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs){s.updateProgress();s.updateActiveIndex();}return;} // Find current slide
var i,stopIndex=0,groupSize=s.slidesSizesGrid[0];for(i = 0;i < s.slidesGrid.length;i += s.params.slidesPerGroup) {if(typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined'){if(currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]){stopIndex = i;groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];}}else {if(currentPos >= s.slidesGrid[i]){stopIndex = i;groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];}}} // Find current slide size
var ratio=(currentPos - s.slidesGrid[stopIndex]) / groupSize;if(timeDiff > s.params.longSwipesMs){ // Long touches
if(!s.params.longSwipes){s.slideTo(s.activeIndex);return;}if(s.swipeDirection === 'next'){if(ratio >= s.params.longSwipesRatio)s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);}if(s.swipeDirection === 'prev'){if(ratio > 1 - s.params.longSwipesRatio)s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);}}else { // Short swipes
if(!s.params.shortSwipes){s.slideTo(s.activeIndex);return;}if(s.swipeDirection === 'next'){s.slideTo(stopIndex + s.params.slidesPerGroup);}if(s.swipeDirection === 'prev'){s.slideTo(stopIndex);}}}; /*=========================
      Transitions
      ===========================*/s._slideTo = function(slideIndex,speed){return s.slideTo(slideIndex,speed,true,true);};s.slideTo = function(slideIndex,speed,runCallbacks,internal){if(typeof runCallbacks === 'undefined')runCallbacks = true;if(typeof slideIndex === 'undefined')slideIndex = 0;if(slideIndex < 0)slideIndex = 0;s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);if(s.snapIndex >= s.snapGrid.length)s.snapIndex = s.snapGrid.length - 1;var translate=-s.snapGrid[s.snapIndex]; // Stop autoplay
if(s.params.autoplay && s.autoplaying){if(internal || !s.params.autoplayDisableOnInteraction){s.pauseAutoplay(speed);}else {s.stopAutoplay();}} // Update progress
s.updateProgress(translate); // Normalize slideIndex
for(var i=0;i < s.slidesGrid.length;i++) {if(-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)){slideIndex = i;}} // Directions locks
if(!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()){return false;}if(!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()){if((s.activeIndex || 0) !== slideIndex)return false;} // Update Index
if(typeof speed === 'undefined')speed = s.params.speed;s.previousIndex = s.activeIndex || 0;s.activeIndex = slideIndex;if(translate === s.translate){s.updateClasses();return false;}s.updateClasses();s.onTransitionStart(runCallbacks);var translateX=isH()?translate:0,translateY=isH()?0:translate;if(speed === 0){s.setWrapperTransition(0);s.setWrapperTranslate(translate);s.onTransitionEnd(runCallbacks);}else {s.setWrapperTransition(speed);s.setWrapperTranslate(translate);if(!s.animating){s.animating = true;s.wrapper.transitionEnd(function(){if(!s)return;s.onTransitionEnd(runCallbacks);});}}return true;};s.onTransitionStart = function(runCallbacks){if(typeof runCallbacks === 'undefined')runCallbacks = true;if(s.lazy)s.lazy.onTransitionStart();if(runCallbacks){s.emit('onTransitionStart',s);if(s.activeIndex !== s.previousIndex){s.emit('onSlideChangeStart',s);}}};s.onTransitionEnd = function(runCallbacks){s.animating = false;s.setWrapperTransition(0);if(typeof runCallbacks === 'undefined')runCallbacks = true;if(s.lazy)s.lazy.onTransitionEnd();if(runCallbacks){s.emit('onTransitionEnd',s);if(s.activeIndex !== s.previousIndex){s.emit('onSlideChangeEnd',s);}}if(s.params.hashnav && s.hashnav){s.hashnav.setHash();}};s.slideNext = function(runCallbacks,speed,internal){if(s.params.loop){if(s.animating)return false;s.fixLoop();var clientLeft=s.container[0].clientLeft;return s.slideTo(s.activeIndex + s.params.slidesPerGroup,speed,runCallbacks,internal);}else return s.slideTo(s.activeIndex + s.params.slidesPerGroup,speed,runCallbacks,internal);};s._slideNext = function(speed){return s.slideNext(true,speed,true);};s.slidePrev = function(runCallbacks,speed,internal){if(s.params.loop){if(s.animating)return false;s.fixLoop();var clientLeft=s.container[0].clientLeft;return s.slideTo(s.activeIndex - 1,speed,runCallbacks,internal);}else return s.slideTo(s.activeIndex - 1,speed,runCallbacks,internal);};s._slidePrev = function(speed){return s.slidePrev(true,speed,true);};s.slideReset = function(runCallbacks,speed,internal){return s.slideTo(s.activeIndex,speed,runCallbacks);}; /*=========================
      Translate/transition helpers
      ===========================*/s.setWrapperTransition = function(duration,byController){s.wrapper.transition(duration);if(s.params.effect !== 'slide' && s.effects[s.params.effect]){s.effects[s.params.effect].setTransition(duration);}if(s.params.parallax && s.parallax){s.parallax.setTransition(duration);}if(s.params.scrollbar && s.scrollbar){s.scrollbar.setTransition(duration);}if(s.params.control && s.controller){s.controller.setTransition(duration,byController);}s.emit('onSetTransition',s,duration);};s.setWrapperTranslate = function(translate,updateActiveIndex,byController){var x=0,y=0,z=0;if(isH()){x = s.rtl?-translate:translate;}else {y = translate;}if(!s.params.virtualTranslate){if(s.support.transforms3d)s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');}s.translate = isH()?x:y;if(updateActiveIndex)s.updateActiveIndex();if(s.params.effect !== 'slide' && s.effects[s.params.effect]){s.effects[s.params.effect].setTranslate(s.translate);}if(s.params.parallax && s.parallax){s.parallax.setTranslate(s.translate);}if(s.params.scrollbar && s.scrollbar){s.scrollbar.setTranslate(s.translate);}if(s.params.control && s.controller){s.controller.setTranslate(s.translate,byController);}s.emit('onSetTranslate',s,s.translate);};s.getTranslate = function(el,axis){var matrix,curTransform,curStyle,transformMatrix; // automatic axis detection
if(typeof axis === 'undefined'){axis = 'x';}if(s.params.virtualTranslate){return s.rtl?-s.translate:s.translate;}curStyle = window.getComputedStyle(el,null);if(window.WebKitCSSMatrix){ // Some old versions of Webkit choke when 'none' is passed; pass
// empty string instead in this case
transformMatrix = new window.WebKitCSSMatrix(curStyle.webkitTransform === 'none'?'':curStyle.webkitTransform);}else {transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(','matrix(1, 0, 0, 1,');matrix = transformMatrix.toString().split(',');}if(axis === 'x'){ //Latest Chrome and webkits Fix
if(window.WebKitCSSMatrix)curTransform = transformMatrix.m41;else if(matrix.length === 16)curTransform = parseFloat(matrix[12]);else curTransform = parseFloat(matrix[4]);}if(axis === 'y'){ //Latest Chrome and webkits Fix
if(window.WebKitCSSMatrix)curTransform = transformMatrix.m42;else if(matrix.length === 16)curTransform = parseFloat(matrix[13]);else curTransform = parseFloat(matrix[5]);}if(s.rtl && curTransform)curTransform = -curTransform;return curTransform || 0;};s.getWrapperTranslate = function(axis){if(typeof axis === 'undefined'){axis = isH()?'x':'y';}return s.getTranslate(s.wrapper[0],axis);}; /*=========================
      Observer
      ===========================*/s.observers = [];function initObserver(target,options){options = options || {}; // create an observer instance
var ObserverFunc=window.MutationObserver || window.WebkitMutationObserver;var observer=new ObserverFunc(function(mutations){mutations.forEach(function(mutation){s.onResize(true);s.emit('onObserverUpdate',s,mutation);});});observer.observe(target,{attributes:typeof options.attributes === 'undefined'?true:options.attributes,childList:typeof options.childList === 'undefined'?true:options.childList,characterData:typeof options.characterData === 'undefined'?true:options.characterData});s.observers.push(observer);}s.initObservers = function(){if(s.params.observeParents){var containerParents=s.container.parents();for(var i=0;i < containerParents.length;i++) {initObserver(containerParents[i]);}} // Observe container
initObserver(s.container[0],{childList:false}); // Observe wrapper
initObserver(s.wrapper[0],{attributes:false});};s.disconnectObservers = function(){for(var i=0;i < s.observers.length;i++) {s.observers[i].disconnect();}s.observers = [];}; /*=========================
      Loop
      ===========================*/ // Create looped slides
s.createLoop = function(){ // Remove duplicated slides
s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();var slides=s.wrapper.children('.' + s.params.slideClass);if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides)s.params.loopedSlides = slides.length;s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView,10);s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;if(s.loopedSlides > slides.length){s.loopedSlides = slides.length;}var prependSlides=[],appendSlides=[],i;slides.each(function(index,el){var slide=$(this);if(index < s.loopedSlides)appendSlides.push(el);if(index < slides.length && index >= slides.length - s.loopedSlides)prependSlides.push(el);slide.attr('data-swiper-slide-index',index);});for(i = 0;i < appendSlides.length;i++) {s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));}for(i = prependSlides.length - 1;i >= 0;i--) {s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));}};s.destroyLoop = function(){s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();s.slides.removeAttr('data-swiper-slide-index');};s.fixLoop = function(){var newIndex; //Fix For Negative Oversliding
if(s.activeIndex < s.loopedSlides){newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;newIndex = newIndex + s.loopedSlides;s.slideTo(newIndex,0,false,true);}else if(s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2 || s.activeIndex > s.slides.length - s.params.slidesPerView * 2){newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;newIndex = newIndex + s.loopedSlides;s.slideTo(newIndex,0,false,true);}}; /*=========================
      Append/Prepend/Remove Slides
      ===========================*/s.appendSlide = function(slides){if(s.params.loop){s.destroyLoop();}if(typeof slides === 'object' && slides.length){for(var i=0;i < slides.length;i++) {if(slides[i])s.wrapper.append(slides[i]);}}else {s.wrapper.append(slides);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}};s.prependSlide = function(slides){if(s.params.loop){s.destroyLoop();}var newActiveIndex=s.activeIndex + 1;if(typeof slides === 'object' && slides.length){for(var i=0;i < slides.length;i++) {if(slides[i])s.wrapper.prepend(slides[i]);}newActiveIndex = s.activeIndex + slides.length;}else {s.wrapper.prepend(slides);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}s.slideTo(newActiveIndex,0,false);};s.removeSlide = function(slidesIndexes){if(s.params.loop){s.destroyLoop();s.slides = s.wrapper.children('.' + s.params.slideClass);}var newActiveIndex=s.activeIndex,indexToRemove;if(typeof slidesIndexes === 'object' && slidesIndexes.length){for(var i=0;i < slidesIndexes.length;i++) {indexToRemove = slidesIndexes[i];if(s.slides[indexToRemove])s.slides.eq(indexToRemove).remove();if(indexToRemove < newActiveIndex)newActiveIndex--;}newActiveIndex = Math.max(newActiveIndex,0);}else {indexToRemove = slidesIndexes;if(s.slides[indexToRemove])s.slides.eq(indexToRemove).remove();if(indexToRemove < newActiveIndex)newActiveIndex--;newActiveIndex = Math.max(newActiveIndex,0);}if(s.params.loop){s.createLoop();}if(!(s.params.observer && s.support.observer)){s.update(true);}if(s.params.loop){s.slideTo(newActiveIndex + s.loopedSlides,0,false);}else {s.slideTo(newActiveIndex,0,false);}};s.removeAllSlides = function(){var slidesIndexes=[];for(var i=0;i < s.slides.length;i++) {slidesIndexes.push(i);}s.removeSlide(slidesIndexes);}; /*=========================
      Effects
      ===========================*/s.effects = {fade:{setTranslate:function setTranslate(){for(var i=0;i < s.slides.length;i++) {var slide=s.slides.eq(i);var offset=slide[0].swiperSlideOffset;var tx=-offset;if(!s.params.virtualTranslate)tx = tx - s.translate;var ty=0;if(!isH()){ty = tx;tx = 0;}var slideOpacity=s.params.fade.crossFade?Math.max(1 - Math.abs(slide[0].progress),0):1 + Math.min(Math.max(slide[0].progress,-1),0);slide.css({opacity:slideOpacity}).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');}},setTransition:function setTransition(duration){s.slides.transition(duration);if(s.params.virtualTranslate && duration !== 0){var eventTriggered=false;s.slides.transitionEnd(function(){if(eventTriggered)return;if(!s)return;eventTriggered = true;s.animating = false;var triggerEvents=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'];for(var i=0;i < triggerEvents.length;i++) {s.wrapper.trigger(triggerEvents[i]);}});}}},cube:{setTranslate:function setTranslate(){var wrapperRotate=0,cubeShadow;if(s.params.cube.shadow){if(isH()){cubeShadow = s.wrapper.find('.swiper-cube-shadow');if(cubeShadow.length === 0){cubeShadow = $('<div class="swiper-cube-shadow"></div>');s.wrapper.append(cubeShadow);}cubeShadow.css({height:s.width + 'px'});}else {cubeShadow = s.container.find('.swiper-cube-shadow');if(cubeShadow.length === 0){cubeShadow = $('<div class="swiper-cube-shadow"></div>');s.container.append(cubeShadow);}}}for(var i=0;i < s.slides.length;i++) {var slide=s.slides.eq(i);var slideAngle=i * 90;var round=Math.floor(slideAngle / 360);if(s.rtl){slideAngle = -slideAngle;round = Math.floor(-slideAngle / 360);}var progress=Math.max(Math.min(slide[0].progress,1),-1);var tx=0,ty=0,tz=0;if(i % 4 === 0){tx = -round * 4 * s.size;tz = 0;}else if((i - 1) % 4 === 0){tx = 0;tz = -round * 4 * s.size;}else if((i - 2) % 4 === 0){tx = s.size + round * 4 * s.size;tz = s.size;}else if((i - 3) % 4 === 0){tx = -s.size;tz = 3 * s.size + s.size * 4 * round;}if(s.rtl){tx = -tx;}if(!isH()){ty = tx;tx = 0;}var transform='rotateX(' + (isH()?0:-slideAngle) + 'deg) rotateY(' + (isH()?slideAngle:0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';if(progress <= 1 && progress > -1){wrapperRotate = i * 90 + progress * 90;if(s.rtl)wrapperRotate = -i * 90 - progress * 90;}slide.transform(transform);if(s.params.cube.slideShadows){ //Set shadows
var shadowBefore=isH()?slide.find('.swiper-slide-shadow-left'):slide.find('.swiper-slide-shadow-top');var shadowAfter=isH()?slide.find('.swiper-slide-shadow-right'):slide.find('.swiper-slide-shadow-bottom');if(shadowBefore.length === 0){shadowBefore = $('<div class="swiper-slide-shadow-' + (isH()?'left':'top') + '"></div>');slide.append(shadowBefore);}if(shadowAfter.length === 0){shadowAfter = $('<div class="swiper-slide-shadow-' + (isH()?'right':'bottom') + '"></div>');slide.append(shadowAfter);}var shadowOpacity=slide[0].progress;if(shadowBefore.length)shadowBefore[0].style.opacity = -slide[0].progress;if(shadowAfter.length)shadowAfter[0].style.opacity = slide[0].progress;}}s.wrapper.css({'-webkit-transform-origin':'50% 50% -' + s.size / 2 + 'px','-moz-transform-origin':'50% 50% -' + s.size / 2 + 'px','-ms-transform-origin':'50% 50% -' + s.size / 2 + 'px','transform-origin':'50% 50% -' + s.size / 2 + 'px'});if(s.params.cube.shadow){if(isH()){cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + -s.width / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + s.params.cube.shadowScale + ')');}else {var shadowAngle=Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;var multiplier=1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);var scale1=s.params.cube.shadowScale,scale2=s.params.cube.shadowScale / multiplier,offset=s.params.cube.shadowOffset;cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + -s.height / 2 / scale2 + 'px) rotateX(-90deg)');}}var zFactor=s.isSafari || s.isUiWebView?-s.size / 2:0;s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH()?0:wrapperRotate) + 'deg) rotateY(' + (isH()?-wrapperRotate:0) + 'deg)');},setTransition:function setTransition(duration){s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);if(s.params.cube.shadow && !isH()){s.container.find('.swiper-cube-shadow').transition(duration);}}},coverflow:{setTranslate:function setTranslate(){var transform=s.translate;var center=isH()?-transform + s.width / 2:-transform + s.height / 2;var rotate=isH()?s.params.coverflow.rotate:-s.params.coverflow.rotate;var translate=s.params.coverflow.depth; //Each slide offset from center
for(var i=0,length=s.slides.length;i < length;i++) {var slide=s.slides.eq(i);var slideSize=s.slidesSizesGrid[i];var slideOffset=slide[0].swiperSlideOffset;var offsetMultiplier=(center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;var rotateY=isH()?rotate * offsetMultiplier:0;var rotateX=isH()?0:rotate * offsetMultiplier; // var rotateZ = 0
var translateZ=-translate * Math.abs(offsetMultiplier);var translateY=isH()?0:s.params.coverflow.stretch * offsetMultiplier;var translateX=isH()?s.params.coverflow.stretch * offsetMultiplier:0; //Fix for ultra small values
if(Math.abs(translateX) < 0.001)translateX = 0;if(Math.abs(translateY) < 0.001)translateY = 0;if(Math.abs(translateZ) < 0.001)translateZ = 0;if(Math.abs(rotateY) < 0.001)rotateY = 0;if(Math.abs(rotateX) < 0.001)rotateX = 0;var slideTransform='translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';slide.transform(slideTransform);slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;if(s.params.coverflow.slideShadows){ //Set shadows
var shadowBefore=isH()?slide.find('.swiper-slide-shadow-left'):slide.find('.swiper-slide-shadow-top');var shadowAfter=isH()?slide.find('.swiper-slide-shadow-right'):slide.find('.swiper-slide-shadow-bottom');if(shadowBefore.length === 0){shadowBefore = $('<div class="swiper-slide-shadow-' + (isH()?'left':'top') + '"></div>');slide.append(shadowBefore);}if(shadowAfter.length === 0){shadowAfter = $('<div class="swiper-slide-shadow-' + (isH()?'right':'bottom') + '"></div>');slide.append(shadowAfter);}if(shadowBefore.length)shadowBefore[0].style.opacity = offsetMultiplier > 0?offsetMultiplier:0;if(shadowAfter.length)shadowAfter[0].style.opacity = -offsetMultiplier > 0?-offsetMultiplier:0;}} //Set correct perspective for IE10
if(s.browser.ie){var ws=s.wrapper[0].style;ws.perspectiveOrigin = center + 'px 50%';}},setTransition:function setTransition(duration){s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);}}}; /*=========================
      Images Lazy Loading
      ===========================*/s.lazy = {initialImageLoaded:false,loadImageInSlide:function loadImageInSlide(index,loadInDuplicate){if(typeof index === 'undefined')return;if(typeof loadInDuplicate === 'undefined')loadInDuplicate = true;if(s.slides.length === 0)return;var slide=s.slides.eq(index);var img=slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');if(slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')){img.add(slide[0]);}if(img.length === 0)return;img.each(function(){var _img=$(this);_img.addClass('swiper-lazy-loading');var background=_img.attr('data-background');var src=_img.attr('data-src');s.loadImage(_img[0],src || background,false,function(){if(background){_img.css('background-image','url(' + background + ')');_img.removeAttr('data-background');}else {_img.attr('src',src);_img.removeAttr('data-src');}_img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');slide.find('.swiper-lazy-preloader, .preloader').remove();if(s.params.loop && loadInDuplicate){var slideOriginalIndex=slide.attr('data-swiper-slide-index');if(slide.hasClass(s.params.slideDuplicateClass)){var originalSlide=s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');s.lazy.loadImageInSlide(originalSlide.index(),false);}else {var duplicatedSlide=s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');s.lazy.loadImageInSlide(duplicatedSlide.index(),false);}}s.emit('onLazyImageReady',s,slide[0],_img[0]);});s.emit('onLazyImageLoad',s,slide[0],_img[0]);});},load:function load(){var i;if(s.params.watchSlidesVisibility){s.wrapper.children('.' + s.params.slideVisibleClass).each(function(){s.lazy.loadImageInSlide($(this).index());});}else {if(s.params.slidesPerView > 1){for(i = s.activeIndex;i < s.activeIndex + s.params.slidesPerView;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);}}else {s.lazy.loadImageInSlide(s.activeIndex);}}if(s.params.lazyLoadingInPrevNext){if(s.params.slidesPerView > 1){ // Next Slides
for(i = s.activeIndex + s.params.slidesPerView;i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);} // Prev Slides
for(i = s.activeIndex - s.params.slidesPerView;i < s.activeIndex;i++) {if(s.slides[i])s.lazy.loadImageInSlide(i);}}else {var nextSlide=s.wrapper.children('.' + s.params.slideNextClass);if(nextSlide.length > 0)s.lazy.loadImageInSlide(nextSlide.index());var prevSlide=s.wrapper.children('.' + s.params.slidePrevClass);if(prevSlide.length > 0)s.lazy.loadImageInSlide(prevSlide.index());}}},onTransitionStart:function onTransitionStart(){if(s.params.lazyLoading){if(s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded){s.lazy.load();}}},onTransitionEnd:function onTransitionEnd(){if(s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart){s.lazy.load();}}}; /*=========================
      Scrollbar
      ===========================*/s.scrollbar = {set:function set(){if(!s.params.scrollbar)return;var sb=s.scrollbar;sb.track = $(s.params.scrollbar);sb.drag = sb.track.find('.swiper-scrollbar-drag');if(sb.drag.length === 0){sb.drag = $('<div class="swiper-scrollbar-drag"></div>');sb.track.append(sb.drag);}sb.drag[0].style.width = '';sb.drag[0].style.height = '';sb.trackSize = isH()?sb.track[0].offsetWidth:sb.track[0].offsetHeight;sb.divider = s.size / s.virtualSize;sb.moveDivider = sb.divider * (sb.trackSize / s.size);sb.dragSize = sb.trackSize * sb.divider;if(isH()){sb.drag[0].style.width = sb.dragSize + 'px';}else {sb.drag[0].style.height = sb.dragSize + 'px';}if(sb.divider >= 1){sb.track[0].style.display = 'none';}else {sb.track[0].style.display = '';}if(s.params.scrollbarHide){sb.track[0].style.opacity = 0;}},setTranslate:function setTranslate(){if(!s.params.scrollbar)return;var diff;var sb=s.scrollbar;var translate=s.translate || 0;var newPos;var newSize=sb.dragSize;newPos = (sb.trackSize - sb.dragSize) * s.progress;if(s.rtl && isH()){newPos = -newPos;if(newPos > 0){newSize = sb.dragSize - newPos;newPos = 0;}else if(-newPos + sb.dragSize > sb.trackSize){newSize = sb.trackSize + newPos;}}else {if(newPos < 0){newSize = sb.dragSize + newPos;newPos = 0;}else if(newPos + sb.dragSize > sb.trackSize){newSize = sb.trackSize - newPos;}}if(isH()){if(s.support.transforms3d){sb.drag.transform('translate3d(' + newPos + 'px, 0, 0)');}else {sb.drag.transform('translateX(' + newPos + 'px)');}sb.drag[0].style.width = newSize + 'px';}else {if(s.support.transforms3d){sb.drag.transform('translate3d(0px, ' + newPos + 'px, 0)');}else {sb.drag.transform('translateY(' + newPos + 'px)');}sb.drag[0].style.height = newSize + 'px';}if(s.params.scrollbarHide){clearTimeout(sb.timeout);sb.track[0].style.opacity = 1;sb.timeout = setTimeout(function(){sb.track[0].style.opacity = 0;sb.track.transition(400);},1000);}},setTransition:function setTransition(duration){if(!s.params.scrollbar)return;s.scrollbar.drag.transition(duration);}}; /*=========================
      Controller
      ===========================*/s.controller = {LinearSpline:function LinearSpline(x,y){this.x = x;this.y = y;this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
// (x1,y1) is the known point before given value,
// (x3,y3) is the known point after given value.
var i1,i3;var l=this.x.length;this.interpolate = function(x2){if(!x2)return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):
i3 = binarySearch(this.x,x2);i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
// y2 := ((x2x1)  (y3y1))  (x3x1) + y1
return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];};var binarySearch=(function(){var maxIndex,minIndex,guess;return function(array,val){minIndex = -1;maxIndex = array.length;while(maxIndex - minIndex > 1) if(array[guess = maxIndex + minIndex >> 1] <= val){minIndex = guess;}else {maxIndex = guess;}return maxIndex;};})();}, //xxx: for now i will just save one spline function to to
getInterpolateFunction:function getInterpolateFunction(c){if(!s.controller.spline)s.controller.spline = s.params.loop?new s.controller.LinearSpline(s.slidesGrid,c.slidesGrid):new s.controller.LinearSpline(s.snapGrid,c.snapGrid);},setTranslate:function setTranslate(translate,byController){var controlled=s.params.control;var multiplier,controlledTranslate;function setControlledTranslate(c){ // this will create an Interpolate function based on the snapGrids
// x is the Grid of the scrolled scroller and y will be the controlled scroller
// it makes sense to create this only once and recall it for the interpolation
// the function does a lot of value caching for performance
translate = c.rtl && c.params.direction === 'horizontal'?-s.translate:s.translate;if(s.params.controlBy === 'slide'){s.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
// but it did not work out
controlledTranslate = -s.controller.spline.interpolate(-translate);}if(!controlledTranslate || s.params.controlBy === 'container'){multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();}if(s.params.controlInverse){controlledTranslate = c.maxTranslate() - controlledTranslate;}c.updateProgress(controlledTranslate);c.setWrapperTranslate(controlledTranslate,false,s);c.updateActiveIndex();}if(s.isArray(controlled)){for(var i=0;i < controlled.length;i++) {if(controlled[i] !== byController && controlled[i] instanceof Swiper){setControlledTranslate(controlled[i]);}}}else if(controlled instanceof Swiper && byController !== controlled){setControlledTranslate(controlled);}},setTransition:function setTransition(duration,byController){var controlled=s.params.control;var i;function setControlledTransition(c){c.setWrapperTransition(duration,s);if(duration !== 0){c.onTransitionStart();c.wrapper.transitionEnd(function(){if(!controlled)return;if(c.params.loop && s.params.controlBy === 'slide'){c.fixLoop();}c.onTransitionEnd();});}}if(s.isArray(controlled)){for(i = 0;i < controlled.length;i++) {if(controlled[i] !== byController && controlled[i] instanceof Swiper){setControlledTransition(controlled[i]);}}}else if(controlled instanceof Swiper && byController !== controlled){setControlledTransition(controlled);}}}; /*=========================
      Hash Navigation
      ===========================*/s.hashnav = {init:function init(){if(!s.params.hashnav)return;s.hashnav.initialized = true;var hash=document.location.hash.replace('#','');if(!hash)return;var speed=0;for(var i=0,length=s.slides.length;i < length;i++) {var slide=s.slides.eq(i);var slideHash=slide.attr('data-hash');if(slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)){var index=slide.index();s.slideTo(index,speed,s.params.runCallbacksOnInit,true);}}},setHash:function setHash(){if(!s.hashnav.initialized || !s.params.hashnav)return;document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';}}; /*=========================
      Keyboard Control
      ===========================*/function handleKeyboard(e){if(e.originalEvent)e = e.originalEvent; //jquery fix
var kc=e.keyCode || e.charCode; // Directions locks
if(!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)){return false;}if(!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)){return false;}if(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey){return;}if(document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')){return;}if(kc === 37 || kc === 39 || kc === 38 || kc === 40){var inView=false; //Check that swiper should be inside of visible area of window
if(s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0){return;}var windowScroll={left:window.pageXOffset,top:window.pageYOffset};var windowWidth=window.innerWidth;var windowHeight=window.innerHeight;var swiperOffset=s.container.offset();if(s.rtl)swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;var swiperCoord=[[swiperOffset.left,swiperOffset.top],[swiperOffset.left + s.width,swiperOffset.top],[swiperOffset.left,swiperOffset.top + s.height],[swiperOffset.left + s.width,swiperOffset.top + s.height]];for(var i=0;i < swiperCoord.length;i++) {var point=swiperCoord[i];if(point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight){inView = true;}}if(!inView)return;}if(isH()){if(kc === 37 || kc === 39){if(e.preventDefault)e.preventDefault();else e.returnValue = false;}if(kc === 39 && !s.rtl || kc === 37 && s.rtl)s.slideNext();if(kc === 37 && !s.rtl || kc === 39 && s.rtl)s.slidePrev();}else {if(kc === 38 || kc === 40){if(e.preventDefault)e.preventDefault();else e.returnValue = false;}if(kc === 40)s.slideNext();if(kc === 38)s.slidePrev();}}s.disableKeyboardControl = function(){$(document).off('keydown',handleKeyboard);};s.enableKeyboardControl = function(){$(document).on('keydown',handleKeyboard);}; /*=========================
      Mousewheel Control
      ===========================*/s.mousewheel = {event:false,lastScrollTime:new window.Date().getTime()};if(s.params.mousewheelControl){try{new window.WheelEvent('wheel');s.mousewheel.event = 'wheel';}catch(e) {}if(!s.mousewheel.event && document.onmousewheel !== undefined){s.mousewheel.event = 'mousewheel';}if(!s.mousewheel.event){s.mousewheel.event = 'DOMMouseScroll';}}function handleMousewheel(e){if(e.originalEvent)e = e.originalEvent; //jquery fix
var we=s.mousewheel.event;var delta=0; //Opera & IE
if(e.detail)delta = -e.detail;else if(we === 'mousewheel'){if(s.params.mousewheelForceToAxis){if(isH()){if(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))delta = e.wheelDeltaX;else return;}else {if(Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))delta = e.wheelDeltaY;else return;}}else {delta = e.wheelDelta;}}else if(we === 'DOMMouseScroll')delta = -e.detail;else if(we === 'wheel'){if(s.params.mousewheelForceToAxis){if(isH()){if(Math.abs(e.deltaX) > Math.abs(e.deltaY))delta = -e.deltaX;else return;}else {if(Math.abs(e.deltaY) > Math.abs(e.deltaX))delta = -e.deltaY;else return;}}else {delta = Math.abs(e.deltaX) > Math.abs(e.deltaY)?-e.deltaX:-e.deltaY;}}if(s.params.mousewheelInvert)delta = -delta;if(!s.params.freeMode){if(new window.Date().getTime() - s.mousewheel.lastScrollTime > 60){if(delta < 0){if((!s.isEnd || s.params.loop) && !s.animating)s.slideNext();else if(s.params.mousewheelReleaseOnEdges)return true;}else {if((!s.isBeginning || s.params.loop) && !s.animating)s.slidePrev();else if(s.params.mousewheelReleaseOnEdges)return true;}}s.mousewheel.lastScrollTime = new window.Date().getTime();}else { //Freemode or scrollContainer:
var position=s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;if(position > 0)position = 0;if(position < s.maxTranslate())position = s.maxTranslate();s.setWrapperTransition(0);s.setWrapperTranslate(position);s.updateProgress();s.updateActiveIndex();if(s.params.freeModeSticky){clearTimeout(s.mousewheel.timeout);s.mousewheel.timeout = setTimeout(function(){s.slideReset();},300);} // Return page scroll on edge positions
if(position === 0 || position === s.maxTranslate())return;}if(s.params.autoplay)s.stopAutoplay();if(e.preventDefault)e.preventDefault();else e.returnValue = false;return false;}s.disableMousewheelControl = function(){if(!s.mousewheel.event)return false;s.container.off(s.mousewheel.event,handleMousewheel);return true;};s.enableMousewheelControl = function(){if(!s.mousewheel.event)return false;s.container.on(s.mousewheel.event,handleMousewheel);return true;}; /*=========================
      Parallax
      ===========================*/function setParallaxTransform(el,progress){el = $(el);var p,pX,pY;p = el.attr('data-swiper-parallax') || '0';pX = el.attr('data-swiper-parallax-x');pY = el.attr('data-swiper-parallax-y');if(pX || pY){pX = pX || '0';pY = pY || '0';}else {if(isH()){pX = p;pY = '0';}else {pY = p;pX = '0';}}if(pX.indexOf('%') >= 0){pX = parseInt(pX,10) * progress + '%';}else {pX = pX * progress + 'px';}if(pY.indexOf('%') >= 0){pY = parseInt(pY,10) * progress + '%';}else {pY = pY * progress + 'px';}el.transform('translate3d(' + pX + ', ' + pY + ',0px)');}s.parallax = {setTranslate:function setTranslate(){s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){setParallaxTransform(this,s.progress);});s.slides.each(function(){var slide=$(this);slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){var progress=Math.min(Math.max(slide[0].progress,-1),1);setParallaxTransform(this,progress);});});},setTransition:function setTransition(duration){if(typeof duration === 'undefined')duration = s.params.speed;s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){var el=$(this);var parallaxDuration=parseInt(el.attr('data-swiper-parallax-duration'),10) || duration;if(duration === 0)parallaxDuration = 0;el.transition(parallaxDuration);});}}; /*=========================
      Plugins API. Collect all and init all plugins
      ===========================*/s._plugins = [];for(var plugin in s.plugins) {var p=s.plugins[plugin](s,s.params[plugin]);if(p)s._plugins.push(p);} // Method to call all plugins event/method
s.callPlugins = function(eventName){for(var i=0;i < s._plugins.length;i++) {if(eventName in s._plugins[i]){s._plugins[i][eventName](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}}}; /*=========================
      Events/Callbacks/Plugins Emitter
      ===========================*/function normalizeEventName(eventName){if(eventName.indexOf('on') !== 0){if(eventName[0] !== eventName[0].toUpperCase()){eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);}else {eventName = 'on' + eventName;}}return eventName;}s.emitterEventListeners = {};s.emit = function(eventName){ // Trigger callbacks
if(s.params[eventName]){s.params[eventName](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}var i; // Trigger events
if(s.emitterEventListeners[eventName]){for(i = 0;i < s.emitterEventListeners[eventName].length;i++) {s.emitterEventListeners[eventName][i](arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);}} // Trigger plugins
if(s.callPlugins)s.callPlugins(eventName,arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]);};s.on = function(eventName,handler){eventName = normalizeEventName(eventName);if(!s.emitterEventListeners[eventName])s.emitterEventListeners[eventName] = [];s.emitterEventListeners[eventName].push(handler);return s;};s.off = function(eventName,handler){var i;eventName = normalizeEventName(eventName);if(typeof handler === 'undefined'){ // Remove all handlers for such event
s.emitterEventListeners[eventName] = [];return s;}if(!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0)return;for(i = 0;i < s.emitterEventListeners[eventName].length;i++) {if(s.emitterEventListeners[eventName][i] === handler)s.emitterEventListeners[eventName].splice(i,1);}return s;};s.once = function(eventName,handler){eventName = normalizeEventName(eventName);var _handler=function _handler(){handler(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4]);s.off(eventName,_handler);};s.on(eventName,_handler);return s;}; // Accessibility tools
s.a11y = {makeFocusable:function makeFocusable($el){$el.attr('tabIndex','0');return $el;},addRole:function addRole($el,role){$el.attr('role',role);return $el;},addLabel:function addLabel($el,label){$el.attr('aria-label',label);return $el;},disable:function disable($el){$el.attr('aria-disabled',true);return $el;},enable:function enable($el){$el.attr('aria-disabled',false);return $el;},onEnterKey:function onEnterKey(event){if(event.keyCode !== 13)return;if($(event.target).is(s.params.nextButton)){s.onClickNext(event);if(s.isEnd){s.a11y.notify(s.params.lastSlideMessage);}else {s.a11y.notify(s.params.nextSlideMessage);}}else if($(event.target).is(s.params.prevButton)){s.onClickPrev(event);if(s.isBeginning){s.a11y.notify(s.params.firstSlideMessage);}else {s.a11y.notify(s.params.prevSlideMessage);}}if($(event.target).is('.' + s.params.bulletClass)){$(event.target)[0].click();}},liveRegion:$('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),notify:function notify(message){var notification=s.a11y.liveRegion;if(notification.length === 0)return;notification.html('');notification.html(message);},init:function init(){ // Setup accessibility
if(s.params.nextButton){var nextButton=$(s.params.nextButton);s.a11y.makeFocusable(nextButton);s.a11y.addRole(nextButton,'button');s.a11y.addLabel(nextButton,s.params.nextSlideMessage);}if(s.params.prevButton){var prevButton=$(s.params.prevButton);s.a11y.makeFocusable(prevButton);s.a11y.addRole(prevButton,'button');s.a11y.addLabel(prevButton,s.params.prevSlideMessage);}$(s.container).append(s.a11y.liveRegion);},initPagination:function initPagination(){if(s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length){s.bullets.each(function(){var bullet=$(this);s.a11y.makeFocusable(bullet);s.a11y.addRole(bullet,'button');s.a11y.addLabel(bullet,s.params.paginationBulletMessage.replace(/{{index}}/,bullet.index() + 1));});}},destroy:function destroy(){if(s.a11y.liveRegion && s.a11y.liveRegion.length > 0)s.a11y.liveRegion.remove();}}; /*=========================
      Init/Destroy
      ===========================*/s.init = function(){if(s.params.loop)s.createLoop();s.updateContainerSize();s.updateSlidesSize();s.updatePagination();if(s.params.scrollbar && s.scrollbar){s.scrollbar.set();}if(s.params.effect !== 'slide' && s.effects[s.params.effect]){if(!s.params.loop)s.updateProgress();s.effects[s.params.effect].setTranslate();}if(s.params.loop){s.slideTo(s.params.initialSlide + s.loopedSlides,0,s.params.runCallbacksOnInit);}else {s.slideTo(s.params.initialSlide,0,s.params.runCallbacksOnInit);if(s.params.initialSlide === 0){if(s.parallax && s.params.parallax)s.parallax.setTranslate();if(s.lazy && s.params.lazyLoading){s.lazy.load();s.lazy.initialImageLoaded = true;}}}s.attachEvents();if(s.params.observer && s.support.observer){s.initObservers();}if(s.params.preloadImages && !s.params.lazyLoading){s.preloadImages();}if(s.params.autoplay){s.startAutoplay();}if(s.params.keyboardControl){if(s.enableKeyboardControl)s.enableKeyboardControl();}if(s.params.mousewheelControl){if(s.enableMousewheelControl)s.enableMousewheelControl();}if(s.params.hashnav){if(s.hashnav)s.hashnav.init();}if(s.params.a11y && s.a11y)s.a11y.init();s.emit('onInit',s);}; // Cleanup dynamic styles
s.cleanupStyles = function(){ // Container
s.container.removeClass(s.classNames.join(' ')).removeAttr('style'); // Wrapper
s.wrapper.removeAttr('style'); // Slides
if(s.slides && s.slides.length){s.slides.removeClass([s.params.slideVisibleClass,s.params.slideActiveClass,s.params.slideNextClass,s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');} // Pagination/Bullets
if(s.paginationContainer && s.paginationContainer.length){s.paginationContainer.removeClass(s.params.paginationHiddenClass);}if(s.bullets && s.bullets.length){s.bullets.removeClass(s.params.bulletActiveClass);} // Buttons
if(s.params.prevButton)$(s.params.prevButton).removeClass(s.params.buttonDisabledClass);if(s.params.nextButton)$(s.params.nextButton).removeClass(s.params.buttonDisabledClass); // Scrollbar
if(s.params.scrollbar && s.scrollbar){if(s.scrollbar.track && s.scrollbar.track.length)s.scrollbar.track.removeAttr('style');if(s.scrollbar.drag && s.scrollbar.drag.length)s.scrollbar.drag.removeAttr('style');}}; // Destroy
s.destroy = function(deleteInstance,cleanupStyles){ // Detach evebts
s.detachEvents(); // Stop autoplay
s.stopAutoplay(); // Destroy loop
if(s.params.loop){s.destroyLoop();} // Cleanup styles
if(cleanupStyles){s.cleanupStyles();} // Disconnect observer
s.disconnectObservers(); // Disable keyboard/mousewheel
if(s.params.keyboardControl){if(s.disableKeyboardControl)s.disableKeyboardControl();}if(s.params.mousewheelControl){if(s.disableMousewheelControl)s.disableMousewheelControl();} // Disable a11y
if(s.params.a11y && s.a11y)s.a11y.destroy(); // Destroy callback
s.emit('onDestroy'); // Delete instance
if(deleteInstance !== false)s = null;};s.init(); // Return swiper instance
return s;} /*===========================
Add .swiper plugin from Dom libraries
===========================*/function addLibraryPlugin(lib){lib.fn.swiper = function(params){var firstInstance;lib(this).each(function(){var s=new Swiper(this,params);if(!firstInstance)firstInstance = s;});return firstInstance;};}return {setters:[],execute:function(){; /*==================================================
    Prototype
====================================================*/Swiper.prototype = {isSafari:(function(){var ua=navigator.userAgent.toLowerCase();return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;})(),isUiWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),isArray:function isArray(arr){return Object.prototype.toString.apply(arr) === '[object Array]';}, /*==================================================
    Browser
    ====================================================*/browser:{ie:window.navigator.pointerEnabled || window.navigator.msPointerEnabled,ieTouch:window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1}, /*==================================================
    Devices
    ====================================================*/device:(function(){var ua=navigator.userAgent;var android=ua.match(/(Android);?[\s\/]+([\d.]+)?/);var ipad=ua.match(/(iPad).*OS\s([\d_]+)/);var ipod=ua.match(/(iPod)(.*OS\s([\d_]+))?/);var iphone=!ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);return {ios:ipad || iphone || ipod,android:android};})(), /*==================================================
    Feature Detection
    ====================================================*/support:{touch:window.Modernizr && Modernizr.touch === true || (function(){return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);})(),transforms3d:window.Modernizr && Modernizr.csstransforms3d === true || (function(){var div=document.createElement('div').style;return 'webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div;})(),flexbox:(function(){var div=document.createElement('div').style;var styles='alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');for(var i=0;i < styles.length;i++) {if(styles[i] in div)return true;}})(),observer:(function(){return 'MutationObserver' in window || 'WebkitMutationObserver' in window;})()}, /*==================================================
    Plugins
    ====================================================*/plugins:{}}; /*===========================
Dom7 Library
===========================*/Dom7 = (function(){var Dom7=function Dom7(arr){var _this=this,i=0; // Create array-like object
for(i = 0;i < arr.length;i++) {_this[i] = arr[i];}_this.length = arr.length; // Return collection with methods
return this;};var $=function $(selector,context){var arr=[],i=0;if(selector && !context){if(selector instanceof Dom7){return selector;}}if(selector){ // String
if(typeof selector === 'string'){var els,tempParent,html=selector.trim();if(html.indexOf('<') >= 0 && html.indexOf('>') >= 0){var toCreate='div';if(html.indexOf('<li') === 0)toCreate = 'ul';if(html.indexOf('<tr') === 0)toCreate = 'tbody';if(html.indexOf('<td') === 0 || html.indexOf('<th') === 0)toCreate = 'tr';if(html.indexOf('<tbody') === 0)toCreate = 'table';if(html.indexOf('<option') === 0)toCreate = 'select';tempParent = document.createElement(toCreate);tempParent.innerHTML = selector;for(i = 0;i < tempParent.childNodes.length;i++) {arr.push(tempParent.childNodes[i]);}}else {if(!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)){ // Pure ID selector
els = [document.getElementById(selector.split('#')[1])];}else { // Other selectors
els = (context || document).querySelectorAll(selector);}for(i = 0;i < els.length;i++) {if(els[i])arr.push(els[i]);}}}else if(selector.nodeType || selector === window || selector === document){arr.push(selector);}else if(selector.length > 0 && selector[0].nodeType){for(i = 0;i < selector.length;i++) {arr.push(selector[i]);}}}return new Dom7(arr);};Dom7.prototype = { // Classes and attriutes
addClass:function addClass(className){if(typeof className === 'undefined'){return this;}var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.add(classes[i]);}}return this;},removeClass:function removeClass(className){var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.remove(classes[i]);}}return this;},hasClass:function hasClass(className){if(!this[0])return false;else return this[0].classList.contains(className);},toggleClass:function toggleClass(className){var classes=className.split(' ');for(var i=0;i < classes.length;i++) {for(var j=0;j < this.length;j++) {this[j].classList.toggle(classes[i]);}}return this;},attr:function attr(attrs,value){if(arguments.length === 1 && typeof attrs === 'string'){ // Get attr
if(this[0])return this[0].getAttribute(attrs);else return undefined;}else { // Set attrs
for(var i=0;i < this.length;i++) {if(arguments.length === 2){ // String
this[i].setAttribute(attrs,value);}else { // Object
for(var attrName in attrs) {this[i][attrName] = attrs[attrName];this[i].setAttribute(attrName,attrs[attrName]);}}}return this;}},removeAttr:function removeAttr(attr){for(var i=0;i < this.length;i++) {this[i].removeAttribute(attr);}return this;},data:function data(key,value){if(typeof value === 'undefined'){ // Get value
if(this[0]){var dataKey=this[0].getAttribute('data-' + key);if(dataKey)return dataKey;else if(this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage)return this[0].dom7ElementDataStorage[key];else return undefined;}else return undefined;}else { // Set value
for(var i=0;i < this.length;i++) {var el=this[i];if(!el.dom7ElementDataStorage)el.dom7ElementDataStorage = {};el.dom7ElementDataStorage[key] = value;}return this;}}, // Transforms
transform:function transform(_transform){for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = _transform;}return this;},transition:function transition(duration){if(typeof duration !== 'string'){duration = duration + 'ms';}for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;}return this;}, //Events
on:function on(eventName,targetSelector,listener,capture){function handleLiveEvent(e){var target=e.target;if($(target).is(targetSelector))listener.call(target,e);else {var parents=$(target).parents();for(var k=0;k < parents.length;k++) {if($(parents[k]).is(targetSelector))listener.call(parents[k],e);}}}var events=eventName.split(' ');var i,j;for(i = 0;i < this.length;i++) {if(typeof targetSelector === 'function' || targetSelector === false){ // Usual events
if(typeof targetSelector === 'function'){listener = arguments[1];capture = arguments[2] || false;}for(j = 0;j < events.length;j++) {this[i].addEventListener(events[j],listener,capture);}}else { //Live events
for(j = 0;j < events.length;j++) {if(!this[i].dom7LiveListeners)this[i].dom7LiveListeners = [];this[i].dom7LiveListeners.push({listener:listener,liveListener:handleLiveEvent});this[i].addEventListener(events[j],handleLiveEvent,capture);}}}return this;},off:function off(eventName,targetSelector,listener,capture){var events=eventName.split(' ');for(var i=0;i < events.length;i++) {for(var j=0;j < this.length;j++) {if(typeof targetSelector === 'function' || targetSelector === false){ // Usual events
if(typeof targetSelector === 'function'){listener = arguments[1];capture = arguments[2] || false;}this[j].removeEventListener(events[i],listener,capture);}else { // Live event
if(this[j].dom7LiveListeners){for(var k=0;k < this[j].dom7LiveListeners.length;k++) {if(this[j].dom7LiveListeners[k].listener === listener){this[j].removeEventListener(events[i],this[j].dom7LiveListeners[k].liveListener,capture);}}}}}}return this;},once:function once(eventName,targetSelector,listener,capture){var dom=this;if(typeof targetSelector === 'function'){targetSelector = false;listener = arguments[1];capture = arguments[2];}function proxy(e){listener(e);dom.off(eventName,targetSelector,proxy,capture);}dom.on(eventName,targetSelector,proxy,capture);},trigger:function trigger(eventName,eventData){for(var i=0;i < this.length;i++) {var evt;try{evt = new window.CustomEvent(eventName,{detail:eventData,bubbles:true,cancelable:true});}catch(e) {evt = document.createEvent('Event');evt.initEvent(eventName,true,true);evt.detail = eventData;}this[i].dispatchEvent(evt);}return this;},transitionEnd:function transitionEnd(callback){var events=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'],i,j,dom=this;function fireCallBack(e){ /*jshint validthis:true */if(e.target !== this)return;callback.call(this,e);for(i = 0;i < events.length;i++) {dom.off(events[i],fireCallBack);}}if(callback){for(i = 0;i < events.length;i++) {dom.on(events[i],fireCallBack);}}return this;}, // Sizing/Styles
width:function width(){if(this[0] === window){return window.innerWidth;}else {if(this.length > 0){return parseFloat(this.css('width'));}else {return null;}}},outerWidth:function outerWidth(includeMargins){if(this.length > 0){if(includeMargins)return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;}else return null;},height:function height(){if(this[0] === window){return window.innerHeight;}else {if(this.length > 0){return parseFloat(this.css('height'));}else {return null;}}},outerHeight:function outerHeight(includeMargins){if(this.length > 0){if(includeMargins)return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));else return this[0].offsetHeight;}else return null;},offset:function offset(){if(this.length > 0){var el=this[0];var box=el.getBoundingClientRect();var body=document.body;var clientTop=el.clientTop || body.clientTop || 0;var clientLeft=el.clientLeft || body.clientLeft || 0;var scrollTop=window.pageYOffset || el.scrollTop;var scrollLeft=window.pageXOffset || el.scrollLeft;return {top:box.top + scrollTop - clientTop,left:box.left + scrollLeft - clientLeft};}else {return null;}},css:function css(props,value){var i;if(arguments.length === 1){if(typeof props === 'string'){if(this[0])return window.getComputedStyle(this[0],null).getPropertyValue(props);}else {for(i = 0;i < this.length;i++) {for(var prop in props) {this[i].style[prop] = props[prop];}}return this;}}if(arguments.length === 2 && typeof props === 'string'){for(i = 0;i < this.length;i++) {this[i].style[props] = value;}return this;}return this;}, //Dom manipulation
each:function each(callback){for(var i=0;i < this.length;i++) {callback.call(this[i],i,this[i]);}return this;},html:function html(_html){if(typeof _html === 'undefined'){return this[0]?this[0].innerHTML:undefined;}else {for(var i=0;i < this.length;i++) {this[i].innerHTML = _html;}return this;}},is:function is(selector){if(!this[0])return false;var compareWith,i;if(typeof selector === 'string'){var el=this[0];if(el === document)return selector === document;if(el === window)return selector === window;if(el.matches)return el.matches(selector);else if(el.webkitMatchesSelector)return el.webkitMatchesSelector(selector);else if(el.mozMatchesSelector)return el.mozMatchesSelector(selector);else if(el.msMatchesSelector)return el.msMatchesSelector(selector);else {compareWith = $(selector);for(i = 0;i < compareWith.length;i++) {if(compareWith[i] === this[0])return true;}return false;}}else if(selector === document)return this[0] === document;else if(selector === window)return this[0] === window;else {if(selector.nodeType || selector instanceof Dom7){compareWith = selector.nodeType?[selector]:selector;for(i = 0;i < compareWith.length;i++) {if(compareWith[i] === this[0])return true;}return false;}return false;}},index:function index(){if(this[0]){var child=this[0];var i=0;while((child = child.previousSibling) !== null) {if(child.nodeType === 1)i++;}return i;}else return undefined;},eq:function eq(index){if(typeof index === 'undefined')return this;var length=this.length;var returnIndex;if(index > length - 1){return new Dom7([]);}if(index < 0){returnIndex = length + index;if(returnIndex < 0)return new Dom7([]);else return new Dom7([this[returnIndex]]);}return new Dom7([this[index]]);},append:function append(newChild){var i,j;for(i = 0;i < this.length;i++) {if(typeof newChild === 'string'){var tempDiv=document.createElement('div');tempDiv.innerHTML = newChild;while(tempDiv.firstChild) {this[i].appendChild(tempDiv.firstChild);}}else if(newChild instanceof Dom7){for(j = 0;j < newChild.length;j++) {this[i].appendChild(newChild[j]);}}else {this[i].appendChild(newChild);}}return this;},prepend:function prepend(newChild){var i,j;for(i = 0;i < this.length;i++) {if(typeof newChild === 'string'){var tempDiv=document.createElement('div');tempDiv.innerHTML = newChild;for(j = tempDiv.childNodes.length - 1;j >= 0;j--) {this[i].insertBefore(tempDiv.childNodes[j],this[i].childNodes[0]);}}else if(newChild instanceof Dom7){for(j = 0;j < newChild.length;j++) {this[i].insertBefore(newChild[j],this[i].childNodes[0]);}}else {this[i].insertBefore(newChild,this[i].childNodes[0]);}}return this;},insertBefore:function insertBefore(selector){var before=$(selector);for(var i=0;i < this.length;i++) {if(before.length === 1){before[0].parentNode.insertBefore(this[i],before[0]);}else if(before.length > 1){for(var j=0;j < before.length;j++) {before[j].parentNode.insertBefore(this[i].cloneNode(true),before[j]);}}}},insertAfter:function insertAfter(selector){var after=$(selector);for(var i=0;i < this.length;i++) {if(after.length === 1){after[0].parentNode.insertBefore(this[i],after[0].nextSibling);}else if(after.length > 1){for(var j=0;j < after.length;j++) {after[j].parentNode.insertBefore(this[i].cloneNode(true),after[j].nextSibling);}}}},next:function next(selector){if(this.length > 0){if(selector){if(this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector))return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);}else {if(this[0].nextElementSibling)return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);}}else return new Dom7([]);},nextAll:function nextAll(selector){var nextEls=[];var el=this[0];if(!el)return new Dom7([]);while(el.nextElementSibling) {var next=el.nextElementSibling;if(selector){if($(next).is(selector))nextEls.push(next);}else nextEls.push(next);el = next;}return new Dom7(nextEls);},prev:function prev(selector){if(this.length > 0){if(selector){if(this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector))return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);}else {if(this[0].previousElementSibling)return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);}}else return new Dom7([]);},prevAll:function prevAll(selector){var prevEls=[];var el=this[0];if(!el)return new Dom7([]);while(el.previousElementSibling) {var prev=el.previousElementSibling;if(selector){if($(prev).is(selector))prevEls.push(prev);}else prevEls.push(prev);el = prev;}return new Dom7(prevEls);},parent:function parent(selector){var parents=[];for(var i=0;i < this.length;i++) {if(selector){if($(this[i].parentNode).is(selector))parents.push(this[i].parentNode);}else {parents.push(this[i].parentNode);}}return $($.unique(parents));},parents:function parents(selector){var parents=[];for(var i=0;i < this.length;i++) {var parent=this[i].parentNode;while(parent) {if(selector){if($(parent).is(selector))parents.push(parent);}else {parents.push(parent);}parent = parent.parentNode;}}return $($.unique(parents));},find:function find(selector){var foundElements=[];for(var i=0;i < this.length;i++) {var found=this[i].querySelectorAll(selector);for(var j=0;j < found.length;j++) {foundElements.push(found[j]);}}return new Dom7(foundElements);},children:function children(selector){var children=[];for(var i=0;i < this.length;i++) {var childNodes=this[i].childNodes;for(var j=0;j < childNodes.length;j++) {if(!selector){if(childNodes[j].nodeType === 1)children.push(childNodes[j]);}else {if(childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector))children.push(childNodes[j]);}}}return new Dom7($.unique(children));},remove:function remove(){for(var i=0;i < this.length;i++) {if(this[i].parentNode)this[i].parentNode.removeChild(this[i]);}return this;},add:function add(){var dom=this;var i,j;for(i = 0;i < arguments.length;i++) {var toAdd=$(arguments[i]);for(j = 0;j < toAdd.length;j++) {dom[dom.length] = toAdd[j];dom.length++;}}return dom;}};$.fn = Dom7.prototype;$.unique = function(arr){var unique=[];for(var i=0;i < arr.length;i++) {if(unique.indexOf(arr[i]) === -1)unique.push(arr[i]);}return unique;};return $;})(); /*===========================
 Get Dom libraries
 ===========================*/swiperDomPlugins = ['jQuery','Zepto','Dom7'];for(i = 0;i < swiperDomPlugins.length;i++) {if(window[swiperDomPlugins[i]]){addLibraryPlugin(window[swiperDomPlugins[i]]);}} // Required DOM Plugins
if(typeof Dom7 === 'undefined'){domLib = window.Dom7 || window.Zepto || window.jQuery;}else {domLib = Dom7;}if(domLib){if(!('transitionEnd' in domLib.fn)){domLib.fn.transitionEnd = function(callback){var events=['webkitTransitionEnd','transitionend','oTransitionEnd','MSTransitionEnd','msTransitionEnd'],i,j,dom=this;function fireCallBack(e){ /*jshint validthis:true */if(e.target !== this)return;callback.call(this,e);for(i = 0;i < events.length;i++) {dom.off(events[i],fireCallBack);}}if(callback){for(i = 0;i < events.length;i++) {dom.on(events[i],fireCallBack);}}return this;};}if(!('transform' in domLib.fn)){domLib.fn.transform = function(transform){for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;}return this;};}if(!('transition' in domLib.fn)){domLib.fn.transition = function(duration){if(typeof duration !== 'string'){duration = duration + 'ms';}for(var i=0;i < this.length;i++) {var elStyle=this[i].style;elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;}return this;};}}}};});
System.register("ionic/components/switch/switch", ["angular2/angular2", "../ion", "../form/input", "../../config/config", "../../config/annotations", "../../util/dom"], function (_export) {
    /**
     * @name mediaSwitch
     * @private
     */
    "use strict";

    var Directive, ElementRef, Host, Optional, NgControl, Inject, forwardRef, Ion, IonInput, IonicConfig, IonicComponent, IonicView, pointerCoord, __decorate, __metadata, __param, MediaSwitch, Switch;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_formInput) {
            IonInput = _formInput.IonInput;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            MediaSwitch =
            /**
             * TODO
             * @param {Switch} swtch  TODO
             * @param {} elementRef  TODO
             * @param {IonicConfig} config  TODO
             */
            function MediaSwitch(swtch, elementRef) {
                _classCallCheck(this, MediaSwitch);

                swtch.switchEle = elementRef.nativeElement;
                this.swtch = swtch;
            };

            MediaSwitch = __decorate([Directive({
                selector: '.media-switch',
                host: {
                    'tappable': 'true',
                    '(^touchstart)': 'swtch.pointerDown($event)',
                    '(^mousedown)': 'swtch.pointerDown($event)',
                    '[class.activated]': 'swtch.isActivated'
                }
            }), __param(0, Host()), __param(0, Inject(forwardRef(function () {
                return Switch;
            }))), __metadata('design:paramtypes', [Switch, typeof ElementRef !== 'undefined' && ElementRef || Object])], MediaSwitch);
            /**
             * @name ionSwitch
             * @description
             * A switch technically is the same thing as an HTML checkbox input, except it looks different and is easier to use on a touch device. Ionic prefers to wrap the checkbox input with the <label> in order to make the entire toggle easy to tap or drag.
             *
             * Toggles can also have colors assigned to them, by adding the `toggle-assertive` attribute to assign the assertive color.
             *
             * See the [Angular 2 Docs](https://angular.io/docs/js/latest/api/forms/) for more info on forms and input.
             *
             * @usage
             * ```html
             * // Create a single switch
             *  <ion-switch checked="true">
             *    Pineapple
             *  </ion-switch>
             *
             * // Create a list of switches:
             *  <ion-list>
             *
             *    <ion-switch checked="true">
             *      Apple
             *    </ion-switch>
             *
             *     <ion-switch checked="false">
             *       Banana
             *     </ion-switch>
             *
             *     <ion-switch disabled="true">
             *       Cherry
             *     </ion-switch>
             *
             *  </ion-list>
             * ```
             *
             */

            Switch = (function (_Ion) {
                _inherits(Switch, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {NgControl=} ngControl  TODO
                 */

                function Switch(elementRef, config, ngControl) {
                    _classCallCheck(this, Switch);

                    _get(Object.getPrototypeOf(Switch.prototype), "constructor", this).call(this, elementRef, config);
                    this.ngControl = ngControl;
                    var self = this;
                    self.id = IonInput.nextId();
                    self.tabIndex = 0;
                    self.onChange = function (_) {};
                    self.onTouched = function (_) {};
                    if (ngControl) ngControl.valueAccessor = this;
                    function pointerMove(ev) {
                        var currentX = pointerCoord(ev).x;
                        if (self.checked) {
                            if (currentX + 15 < self.startX) {
                                self.toggle();
                                self.startX = currentX;
                            }
                        } else if (currentX - 15 > self.startX) {
                            self.toggle();
                            self.startX = currentX;
                        }
                    }
                    function pointerOut(ev) {
                        if (ev.currentTarget === ev.target) {
                            self.pointerUp(ev);
                        }
                    }
                    this.addMoveListener = function () {
                        this.switchEle.addEventListener('touchmove', pointerMove);
                        this.switchEle.addEventListener('mousemove', pointerMove);
                        elementRef.nativeElement.addEventListener('mouseout', pointerOut);
                    };
                    this.removeMoveListener = function () {
                        this.switchEle.removeEventListener('touchmove', pointerMove);
                        this.switchEle.removeEventListener('mousemove', pointerMove);
                        elementRef.nativeElement.removeEventListener('mouseout', pointerOut);
                    };
                }

                _createClass(Switch, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(Switch.prototype), "onInit", this).call(this);
                        this.labelId = 'label-' + this.id;
                    }

                    /**
                     * Set checked state of this switch.
                     * @param {boolean} value  Boolean to set this switch's checked state to.
                     */
                }, {
                    key: "check",
                    value: function check(value) {
                        this.checked = !!value;
                        this.onChange(this.checked);
                    }

                    /**
                     * Toggle the checked state of this switch.
                     */
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.check(!this.checked);
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        this.toggle();
                    }
                }, {
                    key: "writeValue",
                    value: function writeValue(value) {
                        this.checked = value;
                    }
                }, {
                    key: "pointerDown",
                    value: function pointerDown(ev) {
                        if (/touch/.test(ev.type)) {
                            this.isTouch = true;
                        }
                        if (this.isTouch && /mouse/.test(ev.type)) {
                            return;
                        }
                        this.startX = pointerCoord(ev).x;
                        this.removeMoveListener();
                        this.addMoveListener();
                        this.isActivated = true;
                    }
                }, {
                    key: "pointerUp",
                    value: function pointerUp(ev) {
                        if (this.isTouch && /mouse/.test(ev.type)) {
                            return;
                        }
                        var endX = pointerCoord(ev).x;
                        if (this.checked) {
                            if (this.startX + 4 > endX) {
                                this.toggle();
                            }
                        } else if (this.startX - 4 < endX) {
                            this.toggle();
                        }
                        this.removeMoveListener();
                        this.isActivated = false;
                        this.isTouch = false;
                    }

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.removeMoveListener();
                        this.switchEle = this.addMoveListener = this.removeMoveListener = null;
                    }
                }]);

                return Switch;
            })(Ion);

            _export("Switch", Switch);

            _export("Switch", Switch = __decorate([IonicComponent({
                selector: 'ion-switch',
                properties: ['value', 'checked', 'disabled', 'id'],
                host: {
                    'class': 'item',
                    'role': 'checkbox',
                    '[attr.tab-index]': 'tabIndex',
                    '[attr.aria-checked]': 'checked',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-labelledby]': 'labelId',
                    '(^touchend)': 'pointerUp($event)',
                    '(^mouseup)': 'pointerUp($event)'
                }
            }), IonicView({
                template: '<ng-content select="[item-left]"></ng-content>' + '<ion-item-content id="{{labelId}}">' + '<ng-content></ng-content>' + '</ion-item-content>' + '<div item-right class="item-media media-switch">' + '<div class="switch-icon"></div>' + '</div>',
                directives: [MediaSwitch]
            }), __param(2, Optional()), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof NgControl !== 'undefined' && NgControl || Object])], Switch));
        }
    };
});
System.register("ionic/components/tabs/tab", ["angular2/angular2", "../view/view-controller", "../view/view-item", "./tabs"], function (_export) {
    /**
     * @name ionTab
     * @requires ionTabs
     * @description
     * Contains a tab's content. The content only exists while the given tab is selected.
     *
     * @usage
     * ```html
     * <ion-tab tab-title="Heart" tab-icon="ion-ios-heart-outline" [root]="root1"></ion-tab>
     * ```
     */
    "use strict";

    var Directive, Component, View, Host, ElementRef, forwardRef, Injector, NgZone, ViewController, ViewItem, Tabs, __decorate, __metadata, __param, Tab, TabPaneAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Host = _angular2Angular2.Host;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            NgZone = _angular2Angular2.NgZone;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }, function (_tabs) {
            Tabs = _tabs.Tabs;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tab = (function (_ViewController) {
                _inherits(Tab, _ViewController);

                /**
                 * TODO
                 * @param {Tabs} tabs  TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {Injector} injector  TODO
                 * @param {NgZone} zone  TODO
                 */

                function Tab(tabs, elementRef, injector, zone) {
                    var _this = this;

                    _classCallCheck(this, Tab);

                    // A Tab is both a container of many views, and is a view itself.
                    // A Tab is one ViewItem within it's Host Tabs (which extends ViewController)
                    // A Tab is a ViewController for its child ViewItems
                    _get(Object.getPrototypeOf(Tab.prototype), "constructor", this).call(this, tabs, injector, elementRef, zone);
                    this.tabs = tabs;
                    this.childNavbar(true);
                    var item = this.item = new ViewItem(tabs.Host);
                    item.setInstance(this);
                    item.viewElementRef(elementRef);
                    tabs.addTab(this);
                    this.navbarView = item.navbarView = function () {
                        var activeItem = _this.getActive();
                        return activeItem && activeItem.navbarView();
                    };
                    item.enableBack = function () {
                        // override ViewItem's enableBack(), should use the
                        // active child nav item's enableBack() instead
                        var activeItem = _this.getActive();
                        return activeItem && activeItem.enableBack();
                    };
                    this.panelId = 'tab-panel-' + item.id;
                    this.labeledBy = 'tab-button-' + item.id;
                }

                _createClass(Tab, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        if (this._initialResolve) {
                            this.tabs.select(this).then(function () {
                                _this2._initialResolve();
                                _this2._initialResolve = null;
                            });
                        }
                    }

                    /**
                     * TODO
                     * @param {Function} callback  TODO
                     */
                }, {
                    key: "load",
                    value: function load(callback) {
                        if (!this._loaded && this.root) {
                            var opts = {
                                animate: false,
                                navbar: false
                            };
                            this.push(this.root, null, opts).then(function () {
                                callback && callback();
                            });
                            this._loaded = true;
                        } else {
                            callback && callback();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "queueInitial",
                    value: function queueInitial() {
                        var _this3 = this;

                        // this Tab will be used as the initial one for the first load of Tabs
                        return new Promise(function (res) {
                            _this3._initialResolve = res;
                        });
                    }
                }, {
                    key: "isSelected",
                    get: function get() {
                        return this.tabs.isActive(this.item);
                    }
                }, {
                    key: "isNotSelected",
                    get: function get() {
                        return !this.tabs.isActive(this.item);
                    }
                }]);

                return Tab;
            })(ViewController);

            _export("Tab", Tab);

            _export("Tab", Tab = __decorate([Component({
                selector: 'ion-tab',
                properties: ['root', 'tabTitle', 'tabIcon'],
                host: {
                    '[attr.id]': 'panelId',
                    '[attr.aria-labelledby]': 'labeledBy',
                    '[attr.aria-hidden]': 'isNotSelected',
                    '[class.tab-selected]': 'isSelected',
                    'role': 'tabpanel'
                }
            }), View({
                template: '<template pane-anchor></template><ng-content></ng-content>',
                directives: [forwardRef(function () {
                    return TabPaneAnchor;
                })]
            }), __param(0, Host()), __metadata('design:paramtypes', [typeof Tabs !== 'undefined' && Tabs || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof Injector !== 'undefined' && Injector || Object, typeof NgZone !== 'undefined' && NgZone || Object])], Tab));
            /**
             * TODO
             */

            TabPaneAnchor =
            /**
            * TODO
            * @param {Tab} tab  TODO
            * @param {ElementRef} elementRef  TODO
            */
            function TabPaneAnchor(tab, elementRef) {
                _classCallCheck(this, TabPaneAnchor);

                tab.anchorElementRef(elementRef);
            };

            TabPaneAnchor = __decorate([Directive({
                selector: 'template[pane-anchor]'
            }), __param(0, Host()), __metadata('design:paramtypes', [Tab, typeof ElementRef !== 'undefined' && ElementRef || Object])], TabPaneAnchor);
        }
    };
});
System.register("ionic/components/tabs/tabs", ["angular2/angular2", "../view/view-controller", "../view/view-item", "../../config/annotations"], function (_export) {
    /**
     * @name ionTabs
     * @description
     * Powers a multi-tabbed interface with a Tab Bar and a set of "pages" that can be tabbed through.
     *
     * Assign any tabs attribute to the element to define its look and feel.
     *
     * For iOS, tabs will appear at the bottom of the screen. For Android, tabs will be at the top of the screen, below the nav-bar. This follows each OS's design specification, but can be configured with the ionicConfig.
     *
     * See the ionTab component's documentation for more details on individual tabs.
     *
     * @usage
     * ```html
     * <ion-tabs>
     *   <ion-tab tab-title="Heart" tab-icon="ion-ios-heart-outline" [root]="root1"></ion-tab>
     *   <ion-tab tab-title="Star" tab-icon="ion-ios-star-outline" [root]="root2"></ion-tab>
     *   <ion-tab tab-title="Stopwatch" tab-icon="ion-ios-stopwatch-outline" [root]="root3"></ion-tab>
     * </ion-tabs>
     * ```
     *
     */
    "use strict";

    var Directive, Injector, ElementRef, Optional, Host, forwardRef, NgZone, ViewController, ViewItem, IonicComponent, IonicView, __decorate, __metadata, __param, Tabs, TabButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Injector = _angular2Angular2.Injector;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Host = _angular2Angular2.Host;
            forwardRef = _angular2Angular2.forwardRef;
            NgZone = _angular2Angular2.NgZone;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tabs = (function (_ViewController) {
                _inherits(Tabs, _ViewController);

                /**
                 * TODO
                 */

                function Tabs(hostViewCtrl, viewItem, injector, elementRef, zone) {
                    var _this = this;

                    _classCallCheck(this, Tabs);

                    _get(Object.getPrototypeOf(Tabs.prototype), "constructor", this).call(this, hostViewCtrl, injector, elementRef, zone);
                    // Tabs may also be an actual ViewItem which was navigated to
                    // if Tabs is static and not navigated to within a ViewController
                    // then skip this and don't treat it as it's own ViewItem
                    if (viewItem) {
                        this.item = viewItem;
                        // special overrides for the Tabs ViewItem
                        // the Tabs ViewItem does not have it's own navbar
                        // so find the navbar it should use within it's active Tab
                        viewItem.navbarView = function () {
                            var activeTab = _this.getActive();
                            if (activeTab && activeTab.instance) {
                                return activeTab.instance.navbarView();
                            }
                        };
                        // a Tabs ViewItem should not have a back button
                        // enableBack back button will later be determined
                        // by the active ViewItem that has a navbar
                        viewItem.enableBack = function () {
                            return false;
                        };
                    }
                }

                /**
                 * TODO
                 * @param {Tab} tab  TODO
                 */

                _createClass(Tabs, [{
                    key: "addTab",
                    value: function addTab(tab) {
                        // tab.item refers to the ViewItem of the individual Tab being added to Tabs (ViewController)
                        // this.item refers to the ViewItem instsance on Tabs
                        this.add(tab.item);
                        if (this.length() === 1) {
                            // this was the first tab added, queue this one to be loaded and selected
                            var promise = tab.queueInitial();
                            this.item && this.item.addPromise(promise);
                        }
                    }

                    /**
                     * TODO
                     * @param {Tab} tab  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "select",
                    value: function select(tab) {
                        var _this2 = this;

                        var enteringItem = null;
                        if (typeof tab === 'number') {
                            enteringItem = this.getByIndex(tab);
                        } else {
                            enteringItem = this.getByInstance(tab);
                        }
                        if (!enteringItem || !enteringItem.instance || this.isTransitioning()) {
                            return Promise.reject();
                        }
                        return new Promise(function (resolve) {
                            enteringItem.instance.load(function () {
                                var opts = {
                                    animate: false
                                };
                                var leavingItem = _this2.getActive() || new ViewItem();
                                leavingItem.shouldDestroy = false;
                                leavingItem.shouldCache = true;
                                _this2.transition(enteringItem, leavingItem, opts, function () {
                                    resolve();
                                });
                            });
                        });
                    }
                }, {
                    key: "tabs",
                    get: function get() {
                        return this.instances();
                    }
                }]);

                return Tabs;
            })(ViewController);

            _export("Tabs", Tabs);

            _export("Tabs", Tabs = __decorate([IonicComponent({
                selector: 'ion-tabs',
                defaultProperties: {
                    'tabBarPlacement': 'bottom',
                    'tabBarIcons': 'top'
                }
            }), IonicView({
                template: '' + '<nav class="tab-bar-container">' + '<div class="tab-bar" role="tablist">' + '<a *ng-for="#t of tabs" [tab]="t" class="tab-button" role="tab">' + '<icon [name]="t.tabIcon" [is-active]="t.isSelected" class="tab-button-icon"></icon>' + '<span class="tab-button-text">{{t.tabTitle}}</span>' + '</a>' + '</div>' + '</nav>' + '<section class="content-container">' + '<ng-content></ng-content>' + '</section>',
                directives: [forwardRef(function () {
                    return TabButton;
                })]
            }), __param(0, Optional()), __param(1, Optional()), __metadata('design:paramtypes', [typeof ViewController !== 'undefined' && ViewController || Object, typeof ViewItem !== 'undefined' && ViewItem || Object, typeof Injector !== 'undefined' && Injector || Object, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof NgZone !== 'undefined' && NgZone || Object])], Tabs));
            /**
             * TODO
             */

            TabButton = (function () {
                function TabButton(tabs) {
                    _classCallCheck(this, TabButton);

                    this.tabs = tabs;
                }

                _createClass(TabButton, [{
                    key: "onInit",
                    value: function onInit() {
                        var id = this.tab.item.id;
                        this.btnId = 'tab-button-' + id;
                        this.panelId = 'tab-panel-' + id;
                        this.hasTitle = !!this.tab.tabTitle;
                        this.hasIcon = !!this.tab.tabIcon;
                        this.hasTitleOnly = this.hasTitle && !this.hasIcon;
                        this.hasIconOnly = this.hasIcon && !this.hasTitle;
                    }
                }, {
                    key: "onClick",
                    value: function onClick(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.tabs.select(this.tab);
                    }
                }]);

                return TabButton;
            })();

            TabButton = __decorate([Directive({
                selector: '.tab-button',
                properties: ['tab'],
                host: {
                    '[attr.id]': 'btnId',
                    '[attr.aria-controls]': 'panelId',
                    '[attr.aria-selected]': 'tab.isSelected',
                    '[class.has-title]': 'hasTitle',
                    '[class.has-icon]': 'hasIcon',
                    '[class.has-title-only]': 'hasTitleOnly',
                    '[class.icon-only]': 'hasIconOnly',
                    '(^click)': 'onClick($event)'
                }
            }), __param(0, Host()), __metadata('design:paramtypes', [Tabs])], TabButton);
        }
    };
});
System.register("ionic/components/text-input/label", ["angular2/angular2", "../../config/config", "../../util/dom"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, IonicConfig, pointerCoord, hasPointerMoved, __decorate, __metadata, Label;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilDom) {
            pointerCoord = _utilDom.pointerCoord;
            hasPointerMoved = _utilDom.hasPointerMoved;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Label = (function () {
                /**
                 * TODO
                 * @param {IonicConfig} config
                 */

                function Label(config) {
                    _classCallCheck(this, Label);

                    this.scrollAssist = config.setting('keyboardScrollAssist');
                }

                /**
                 * TODO
                 * @param {TODO} ev  TODO
                 */

                _createClass(Label, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = pointerCoord(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} ev  TODO
                     */
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.container) {
                            // get where the touchend/mouseup ended
                            var endCoord = pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            if (!hasPointerMoved(20, this.startCoord, endCoord)) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.container.focus();
                            }
                            this.startCoord = null;
                        }
                    }
                }]);

                return Label;
            })();

            _export("Label", Label);

            _export("Label", Label = __decorate([Directive({
                selector: 'ion-label',
                properties: ['id'],
                host: {
                    '[attr.id]': 'id',
                    'class': 'input-label',
                    '(touchstart)': 'pointerStart($event)',
                    '(touchend)': 'pointerEnd($event)',
                    '(mousedown)': 'pointerStart($event)',
                    '(mouseup)': 'pointerEnd($event)'
                }
            }), __metadata('design:paramtypes', [typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Label));
        }
    };
});
System.register("ionic/components/text-input/text-input", ["angular2/angular2", "../../config/annotations", "../../config/config", "../form/input", "./label", "../ion", "../app/app", "../content/content", "../../util/click-block", "../../util/dom", "../../platform/platform"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, Host, Optional, ElementRef, Attribute, Query, QueryList, NgZone, IonicDirective, IonicConfig, IonInput, Label, Ion, IonicApp, Content, ClickBlock, dom, Platform, __decorate, __metadata, __param, TextInputElement, _TextInput, SCROLL_INTO_VIEW_DURATION;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Host = _angular2Angular2.Host;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            Attribute = _angular2Angular2.Attribute;
            Query = _angular2Angular2.Query;
            QueryList = _angular2Angular2.QueryList;
            NgZone = _angular2Angular2.NgZone;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_formInput) {
            IonInput = _formInput.IonInput;
        }, function (_label) {
            Label = _label.Label;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_utilDom) {
            dom = _utilDom;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            TextInputElement = (function () {
                /**
                 * TODO
                 * @param {string} type  The value of the underlying element's type attribute.
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 */

                function TextInputElement(type, elementRef, config) {
                    _classCallCheck(this, TextInputElement);

                    this.type = type;
                    this.elementRef = elementRef;
                    this.tabIndex = this.tabIndex || '';
                }

                /**
                 * Focus the input.
                 */

                _createClass(TextInputElement, [{
                    key: "setFocus",
                    value: function setFocus() {
                        this.elementRef.nativeElement.focus();
                    }

                    /**
                     * Whether the input has focus or not.
                     * @returns {boolean}  true if the input has focus, otherwise false.
                     */
                }, {
                    key: "hasFocus",
                    get: function get() {
                        return dom.hasFocus(this.elementRef);
                    }

                    /**
                     * Whether the input has a value.
                     * @returns {boolean}  true if the input has a value, otherwise false.
                     */
                }, {
                    key: "hasValue",
                    get: function get() {
                        return this.elementRef.nativeElement.value !== '';
                    }
                }]);

                return TextInputElement;
            })();

            _export("TextInputElement", TextInputElement);

            _export("TextInputElement", TextInputElement = __decorate([Directive({
                selector: 'textarea,input[type=text],input[type=password],input[type=number],input[type=search],input[type=email],input[type=url],input[type=tel]',
                property: ['tabIndex'],
                host: {
                    '[tabIndex]': 'tabIndex',
                    '[attr.aria-labelledby]': 'labelledBy',
                    'class': 'text-input input'
                }
            }), __param(0, Attribute('type')), __metadata('design:paramtypes', [String, typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], TextInputElement));
            /**
             * TODO
             */

            _TextInput = (function (_Ion) {
                _inherits(TextInput, _Ion);

                /**
                 * TODO
                 * @param {ElementRef} elementRef  TODO
                 * @param {IonicConfig} config  TODO
                 * @param {IonicApp} app  TODO
                 * @param {NgZone} ngZone  TODO
                 * @param {Content=} scrollView  The parent scroll view.
                 * @param {QueryList<TextInputElement>} inputQry  TODO
                 * @param {QueryList<Label>} labelQry  TODO
                 */

                function TextInput(elementRef, config, app, ngZone, scrollView, inputQry, labelQry) {
                    _classCallCheck(this, TextInput);

                    _get(Object.getPrototypeOf(TextInput.prototype), "constructor", this).call(this, elementRef, config);
                    this.scrollView = scrollView;
                    this.scrollAssist = config.setting('keyboardScrollAssist');
                    this.id = IonInput.nextId();
                    IonInput.registerInput(this);
                    this.app = app;
                    this.zone = ngZone;
                    this.inputQry = inputQry;
                    this.labelQry = labelQry;
                }

                /**
                 * TODO
                 */

                _createClass(TextInput, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(TextInput.prototype), "onInit", this).call(this);
                        var label = this.labelQry.first;
                        this.input = this.inputQry.first;
                        if (this.input) {
                            this.type = this.input.type;
                            this.input.tabIndex = -1;
                            if (label) {
                                label.id = label.id || 'label-' + this.id;
                                this.input.labelledBy = label.id;
                            }
                        }
                        var self = this;
                        self.scrollMove = function (ev) {
                            self.deregListeners();
                            if (self.inputHasFocus) {
                                self.tempFocusMove();
                            }
                        };
                    }

                    /**
                     * TODO
                     * @param {Event} ev  TODO
                     */
                }, {
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = dom.pointerCoord(ev);
                        }
                    }

                    /**
                     * TODO
                     * @param {Event} ev TODO
                     */
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        var _this = this;

                        if (this.scrollAssist && ev.type === 'touchend') {
                            // get where the touchend/mouseup ended
                            var endCoord = dom.pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            // and the input doesn't already have focus
                            if (!dom.hasPointerMoved(8, this.startCoord, endCoord) && !this.inputHasFocus) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.zone.runOutsideAngular(function () {
                                    _this.initFocus();
                                    // temporarily prevent mouseup's from focusing
                                    _this.preventMouse = true;
                                    clearTimeout(_this.mouseTimer);
                                    _this.mouseTimer = setTimeout(function () {
                                        _this.preventMouse = false;
                                    }, 500);
                                });
                            }
                        } else if (!this.preventMouse) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            this.zone.runOutsideAngular(function () {
                                _this.setFocus();
                            });
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                    //TODO inconsistent return value, sometimes undefined
                }, {
                    key: "initFocus",
                    value: function initFocus() {
                        var _this2 = this;

                        var scrollView = this.scrollView;
                        if (scrollView && this.scrollAssist) {
                            // this input is inside of a scroll view
                            // find out if text input should be manually scrolled into view
                            var ele = this.elementRef.nativeElement;
                            var keyboardHeight = this.config.setting('keyboardHeight');
                            var scrollData = _TextInput.getScollData(ele.offsetTop, ele.offsetHeight, scrollView.getDimensions(), keyboardHeight);
                            if (scrollData.noScroll) {
                                // the text input is in a safe position that doesn't require
                                // it to be scrolled into view, just set focus now
                                return this.setFocus();
                            }
                            // add padding to the bottom of the scroll view (if needed)
                            scrollView.addKeyboardPadding(scrollData.scrollPadding);
                            // manually scroll the text input to the top
                            // do not allow any clicks while it's scrolling
                            ClickBlock(true, SCROLL_INTO_VIEW_DURATION + 100);
                            this.app.setTransitioning(true);
                            // temporarily move the focus to the focus holder so the browser
                            // doesn't freak out while it's trying to get the input in place
                            // at this point the native text input still does not have focus
                            this.tempFocusMove();
                            // scroll the input into place
                            scrollView.scrollTo(0, scrollData.scrollTo, SCROLL_INTO_VIEW_DURATION, 6).then(function () {
                                // the scroll view is in the correct position now
                                // give the native text input focus
                                _this2.setFocus();
                                // all good, allow clicks again
                                ClickBlock(false);
                                _this2.app.setTransitioning(false);
                            });
                        } else {
                            // not inside of a scroll view, just focus it
                            this.setFocus();
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} inputOffsetTop  TODO
                     * @param {TODO} inputOffsetHeight  TODO
                     * @param {TODO} scrollViewDimensions  TODO
                     * @param {TODO} keyboardHeight  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "deregListeners",

                    /**
                     * TODO
                     */
                    value: function deregListeners() {
                        this.deregScroll && this.deregScroll();
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "setFocus",
                    value: function setFocus() {
                        var _this3 = this;

                        this.zone.run(function () {
                            // set focus on the input element
                            _this3.input && _this3.input.setFocus();
                            // ensure the body hasn't scrolled down
                            document.body.scrollTop = 0;
                            IonInput.setAsLastInput(_this3);
                        });
                        if (this.scrollAssist && this.scrollView) {
                            setTimeout(function () {
                                if (!_this3.scrollView.isPollingFocus) {
                                    _this3.scrollView.pollFocus();
                                }
                                _this3.deregListeners();
                                _this3.deregScroll = _this3.scrollView.addScrollEventListener(_this3.scrollMove);
                            }, 100);
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "tempFocusMove",
                    value: function tempFocusMove() {
                        var focusHolder = this.app.focusHolder();
                        focusHolder.setFocusHolder(this.type);
                    }
                }, {
                    key: "receivedFocus",

                    /**
                     * TODO
                     * @param {boolean} receivedFocus  TODO
                     */
                    value: function receivedFocus(_receivedFocus) {
                        var self = this;
                        if (_receivedFocus && !self.inputHasFocus) {
                            self.initFocus();
                        } else {
                            this.deregListeners();
                        }
                    }
                }, {
                    key: "inputHasFocus",
                    get: function get() {
                        return !!this.input && this.input.hasFocus;
                    }
                }, {
                    key: "inputHasValue",
                    get: function get() {
                        return !!this.input && this.input.hasValue;
                    }
                }, {
                    key: "activeTabIndex",
                    get: function get() {
                        this.input.tabIndex = this.inputHasFocus ? 1000 : -1;
                        return -1;
                    }
                }], [{
                    key: "getScollData",
                    value: function getScollData(inputOffsetTop, inputOffsetHeight, scrollViewDimensions, keyboardHeight) {
                        // compute input's Y values relative to the body
                        var inputTop = inputOffsetTop + scrollViewDimensions.contentTop - scrollViewDimensions.scrollTop;
                        var inputBottom = inputTop + inputOffsetHeight;
                        // compute the safe area which is the viewable content area when the soft keyboard is up
                        var safeAreaTop = scrollViewDimensions.contentTop;
                        var safeAreaHeight = Platform.height() - keyboardHeight - safeAreaTop;
                        safeAreaHeight /= 2;
                        var safeAreaBottom = safeAreaTop + safeAreaHeight;
                        var inputTopWithinSafeArea = inputTop >= safeAreaTop && inputTop <= safeAreaBottom;
                        var inputTopAboveSafeArea = inputTop < safeAreaTop;
                        var inputTopBelowSafeArea = inputTop > safeAreaBottom;
                        var inputBottomWithinSafeArea = inputBottom >= safeAreaTop && inputBottom <= safeAreaBottom;
                        var inputBottomBelowSafeArea = inputBottom > safeAreaBottom;
                        /*
                        Text Input Scroll To Scenarios
                        ---------------------------------------
                        1) Input top within safe area, bottom within safe area
                        2) Input top within safe area, bottom below safe area, room to scroll
                        3) Input top above safe area, bottom within safe area, room to scroll
                        4) Input top below safe area, no room to scroll, input smaller than safe area
                        5) Input top within safe area, bottom below safe area, no room to scroll, input smaller than safe area
                        6) Input top within safe area, bottom below safe area, no room to scroll, input larger than safe area
                        7) Input top below safe area, no room to scroll, input larger than safe area
                        */
                        if (inputTopWithinSafeArea && inputBottomWithinSafeArea) {
                            // Input top within safe area, bottom within safe area
                            // no need to scroll to a position, it's good as-is
                            return { noScroll: true };
                        }
                        // looks like we'll have to do some auto-scrolling
                        var scrollData = {
                            scrollAmount: 0,
                            scrollTo: 0,
                            scrollPadding: 0
                        };
                        if (inputTopBelowSafeArea || inputBottomBelowSafeArea) {
                            // Input top and bottom below safe area
                            // auto scroll the input up so at least the top of it shows
                            if (safeAreaHeight > inputOffsetHeight) {
                                // safe area height is taller than the input height, so we
                                // can bring it up the input just enough to show the input bottom
                                scrollData.scrollAmount = safeAreaBottom - inputBottom;
                            } else {
                                // safe area height is smaller than the input height, so we can
                                // only scroll it up so the input top is at the top of the safe area
                                // however the input bottom will be below the safe area
                                scrollData.scrollAmount = safeAreaTop - inputTop;
                            }
                        } else if (inputTopAboveSafeArea) {
                            // Input top above safe area
                            // auto scroll the input down so at least the top of it shows
                            scrollData.scrollAmount = safeAreaTop - inputTop;
                        }
                        // figure out where it should scroll to for the best position to the input
                        scrollData.scrollTo = scrollViewDimensions.scrollTop - scrollData.scrollAmount;
                        if (scrollData.scrollAmount < 0) {
                            // when auto-scrolling up, there also needs to be enough
                            // content padding at the bottom of the scroll view
                            // manually add it if there isn't enough scrollable area
                            // figure out how many scrollable area is left to scroll up
                            var availablePadding = scrollViewDimensions.scrollHeight - scrollViewDimensions.scrollTop - scrollViewDimensions.contentHeight;
                            var paddingSpace = availablePadding + scrollData.scrollAmount;
                            if (paddingSpace < 0) {
                                // there's not enough scrollable area at the bottom, so manually add more
                                scrollData.scrollPadding = scrollViewDimensions.contentHeight - safeAreaHeight;
                            }
                        }
                        // if (!window.safeAreaEle) {
                        //   window.safeAreaEle = document.createElement('div');
                        //   window.safeAreaEle.style.position = 'absolute';
                        //   window.safeAreaEle.style.background = 'rgba(0, 128, 0, 0.3)';
                        //   window.safeAreaEle.style.padding = '10px';
                        //   window.safeAreaEle.style.textShadow = '2px 2px white';
                        //   window.safeAreaEle.style.left = '0px';
                        //   window.safeAreaEle.style.right = '0px';
                        //   window.safeAreaEle.style.pointerEvents = 'none';
                        //   document.body.appendChild(window.safeAreaEle);
                        // }
                        // window.safeAreaEle.style.top = safeAreaTop + 'px';
                        // window.safeAreaEle.style.height = safeAreaHeight + 'px';
                        // window.safeAreaEle.innerHTML = `
                        //   <div>scrollTo: ${scrollData.scrollTo}</div>
                        //   <div>scrollAmount: ${scrollData.scrollAmount}</div>
                        //   <div>scrollPadding: ${scrollData.scrollPadding}</div>
                        //   <div>scrollHeight: ${scrollViewDimensions.scrollHeight}</div>
                        //   <div>scrollTop: ${scrollViewDimensions.scrollTop}</div>
                        //   <div>contentHeight: ${scrollViewDimensions.contentHeight}</div>
                        // `;
                        return scrollData;
                    }
                }]);

                return TextInput;
            })(Ion);

            _export("TextInput", _TextInput);

            _TextInput = __decorate([IonicDirective({
                selector: 'ion-input',
                classId: 'item-input',
                properties: ['tabIndex'],
                host: {
                    '(focus)': 'receivedFocus(true)',
                    '(blur)': 'receivedFocus(false)',
                    '(^touchstart)': 'pointerStart($event)',
                    '(^touchend)': 'pointerEnd($event)',
                    '(^mouseup)': 'pointerEnd($event)',
                    '[class.has-focus]': 'inputHasFocus',
                    '[class.has-value]': 'inputHasValue',
                    '[tabIndex]': 'activeTabIndex',
                    'class': 'item'
                }
            }), __param(4, Optional()), __param(4, Host()), __param(5, Query(TextInputElement)), __param(6, Query(Label)), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object, typeof IonicApp !== 'undefined' && IonicApp || Object, typeof NgZone !== 'undefined' && NgZone || Object, typeof Content !== 'undefined' && Content || Object, typeof QueryList !== 'undefined' && QueryList || Object, typeof QueryList !== 'undefined' && QueryList || Object])], _TextInput);
            SCROLL_INTO_VIEW_DURATION = 400;
        }
    };
});
System.register("ionic/components/toolbar/toolbar", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    /**
     * TODO
     */
    "use strict";

    var Directive, View, Host, ElementRef, forwardRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, __param, ToolbarBase, Toolbar, ToolbarTitle, ToolbarItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Host = _angular2Angular2.Host;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ToolbarBase = (function (_Ion) {
                _inherits(ToolbarBase, _Ion);

                function ToolbarBase(elementRef, config) {
                    _classCallCheck(this, ToolbarBase);

                    _get(Object.getPrototypeOf(ToolbarBase.prototype), "constructor", this).call(this, elementRef, config);
                    this.titleAlign = config.setting('navTitleAlign');
                    this.itemEles = [];
                }

                /**
                 * TODO
                 */

                /**
                 * TODO
                 * @param {TODO} eleRef  TODO
                 * @returns {TODO} TODO
                 */

                _createClass(ToolbarBase, [{
                    key: "titleElement",
                    value: function titleElement(eleRef) {
                        if (arguments.length) {
                            this._nbTlEle = eleRef;
                        }
                        return this._nbTlEle;
                    }

                    /**
                     * TODO
                     * @param {TODO} eleRef  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "itemElements",
                    value: function itemElements(eleRef) {
                        if (arguments.length) {
                            this.itemEles.push(eleRef);
                        }
                        return this.itemEles;
                    }

                    /**
                     * TODO
                     * @param {TODO} eleRef  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: "titleText",
                    value: function titleText(eleRef) {
                        if (arguments.length) {
                            this._ttTxt.push(eleRef);
                        }
                        return this._ttTxt;
                    }
                }, {
                    key: "onAllChangesDone",
                    value: function onAllChangesDone() {
                        if (this._queueAlign) {
                            this._queueAlign = false;
                            this._alignTitle();
                        }
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: "alignTitle",
                    value: function alignTitle() {
                        this._queueAlign = this.titleAlign === 'center';
                    }
                }, {
                    key: "_alignTitle",
                    value: function _alignTitle() {
                        // don't bother if we're not trying to center align the title
                        if (this.aligned) return;
                        // called after the navbar/title has had a moment to
                        // finish rendering in their correct locations
                        var toolbarEle = this.getNativeElement();
                        var titleEle = toolbarEle.querySelector('ion-title');
                        // don't bother if there's no title element
                        if (!titleEle) return;
                        // get all the dimensions
                        var titleOffsetLeft = titleEle.offsetLeft;
                        var titleOffsetRight = toolbarEle.offsetWidth - (titleOffsetLeft + titleEle.offsetWidth);
                        var marginLeft = 0;
                        var marginRight = 0;
                        if (titleOffsetLeft < titleOffsetRight) {
                            marginLeft = titleOffsetRight - titleOffsetLeft + 5;
                        } else if (titleOffsetLeft > titleOffsetRight) {
                            marginRight = titleOffsetLeft - titleOffsetRight - 5;
                        }
                        if (marginLeft || marginRight) {
                            // only do an update if it has to
                            var innerTitleEle = toolbarEle.querySelector('.toolbar-inner-title');
                            innerTitleEle.style.margin = "0 " + marginRight + "px 0 " + marginLeft + "px";
                        }
                        this.aligned = true;
                    }
                }]);

                return ToolbarBase;
            })(Ion);

            _export("ToolbarBase", ToolbarBase);

            Toolbar = (function (_ToolbarBase) {
                _inherits(Toolbar, _ToolbarBase);

                function Toolbar(elementRef, ionicConfig) {
                    _classCallCheck(this, Toolbar);

                    _get(Object.getPrototypeOf(Toolbar.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.itemEles = [];
                }

                _createClass(Toolbar, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this = this;

                        _get(Object.getPrototypeOf(Toolbar.prototype), "onInit", this).call(this);
                        // TODO: THIS IS HORRIBLE, FIX
                        setTimeout(function () {
                            _this.alignTitle();
                            setTimeout(function () {
                                _this.alignTitle();
                            }, 64);
                        }, 32);
                    }
                }]);

                return Toolbar;
            })(ToolbarBase);

            _export("Toolbar", Toolbar);

            _export("Toolbar", Toolbar = __decorate([IonicComponent({
                selector: 'ion-toolbar'
            }), View({
                template: "\n    <div class=\"toolbar-inner\">\n      <ng-content select=\"[aside-toggle]\"></ng-content>\n      <div class=\"toolbar-title\">\n        <div class=\"toolbar-inner-title\">\n          <ng-content select=\"ion-title\"></ng-content>\n        </div>\n      </div>\n      <div class=\"toolbar-item toolbar-primary-item\">\n        <ng-content select=\"[primary]\"></ng-content>\n      </div>\n      <div class=\"toolbar-item toolbar-secondary-item\">\n        <ng-content select=\"[secondary]\"></ng-content>\n      </div>\n    </div>\n  ",
                directives: [forwardRef(function () {
                    return ToolbarTitle;
                }), forwardRef(function () {
                    return ToolbarItem;
                })]
            }), __metadata('design:paramtypes', [typeof ElementRef !== 'undefined' && ElementRef || Object, typeof IonicConfig !== 'undefined' && IonicConfig || Object])], Toolbar));

            ToolbarTitle = function ToolbarTitle(toolbar, elementRef) {
                _classCallCheck(this, ToolbarTitle);

                toolbar.titleElement(elementRef);
            };

            ToolbarTitle = __decorate([Directive({
                selector: '.toolbar-title'
            }), __param(0, Host()), __metadata('design:paramtypes', [Toolbar, typeof ElementRef !== 'undefined' && ElementRef || Object])], ToolbarTitle);

            ToolbarItem = function ToolbarItem(toolbar, elementRef) {
                _classCallCheck(this, ToolbarItem);

                toolbar.itemElements(elementRef);
            };

            ToolbarItem = __decorate([Directive({
                selector: '.toolbar-item'
            }), __param(0, Host()), __metadata('design:paramtypes', [Toolbar, typeof ElementRef !== 'undefined' && ElementRef || Object])], ToolbarItem);
        }
    };
});
System.register('ionic/components/view/view-controller', ['angular2/angular2', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/compiler/view_manager', '../ion', '../../config/config', '../app/app', './view-item', '../nav/nav-controller', '../nav/pane', '../../transitions/transition', '../../util/click-block', 'ionic/util'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var Compiler, Injector, bind, DynamicComponentLoader, AppViewManager, Ion, IonicConfig, IonicApp, ViewItem, NavController, PaneController, Transition, ClickBlock, util, ViewController, ACTIVE_STATE, CACHED_STATE, STAGED_ENTERING_STATE, STAGED_LEAVING_STATE, ctrlIds;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Compiler = _angular2Angular2.Compiler;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
            DynamicComponentLoader = _angular2SrcCoreCompilerDynamic_component_loader.DynamicComponentLoader;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_viewItem) {
            ViewItem = _viewItem.ViewItem;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navPane) {
            PaneController = _navPane.PaneController;
        }, function (_transitionsTransition) {
            Transition = _transitionsTransition.Transition;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            ViewController = (function (_Ion) {
                _inherits(ViewController, _Ion);

                function ViewController(parentViewCtrl, injector, elementRef, zone) {
                    _classCallCheck(this, ViewController);

                    var config = injector.get(IonicConfig);
                    _get(Object.getPrototypeOf(ViewController.prototype), 'constructor', this).call(this, elementRef, config);
                    this.parent = parentViewCtrl;
                    this.compiler = injector.get(Compiler);
                    this.loader = injector.get(DynamicComponentLoader);
                    this.viewMngr = injector.get(AppViewManager);
                    this.app = injector.get(IonicApp);
                    this.config = config;
                    this.zone = zone;
                    this.items = [];
                    this.panes = new PaneController(this);
                    this.sbTransition = null;
                    this.sbActive = false;
                    this.sbEnabled = true;
                    this.id = ++ctrlIds;
                    this._ids = -1;
                    this.zIndexes = -1;
                    // build a new injector for child ViewItems to use
                    this.bindings = Injector.resolve([bind(ViewController).toValue(this), bind(NavController).toValue(new NavController(this))]);
                }

                /**
                 * TODO
                 * @param {TODO} componentType  TODO
                 * @param {TODO} [params={}]  TODO
                 * @param {TODO} [opts={}]  TODO
                 * @returns {Promise} TODO
                 */

                _createClass(ViewController, [{
                    key: 'push',
                    value: function push(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        if (!componentType || this.isTransitioning()) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // do not animate if this is the first in the stack
                        if (!this.items.length) {
                            opts.animation = 'none';
                        }
                        // default the direction to "forward"
                        opts.direction = opts.direction || 'forward';
                        // the active item is going to be the leaving one (if one exists)
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : true;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // create a new ViewItem
                        var enteringItem = new ViewItem(this, componentType, params);
                        // add the item to the stack
                        this.add(enteringItem);
                        if (this.router) {
                            // notify router of the state change
                            this.router.stateChange('push', enteringItem, params);
                        }
                        // start the transition
                        this.transition(enteringItem, leavingItem, opts, function () {
                            resolve();
                        });
                        return promise;
                    }

                    /**
                     * TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'pop',
                    value: function pop() {
                        var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                        if (this.isTransitioning() || this.items.length < 2) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // default the direction to "back"
                        opts.direction = opts.direction || 'back';
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : false;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // the entering item is now the new last item
                        // Note: we might not have an entering item if this is the
                        // only item on the history stack.
                        var enteringItem = this.getPrevious(leavingItem);
                        if (enteringItem) {
                            if (this.router) {
                                // notify router of the state change
                                this.router.stateChange('pop', enteringItem);
                            }
                            // start the transition
                            this.transition(enteringItem, leavingItem, opts, function () {
                                // transition completed, destroy the leaving item
                                resolve();
                            });
                        } else {
                            this.transitionComplete();
                            resolve();
                        }
                        return promise;
                    }

                    /**
                     * Set the item stack to reflect the given component classes.
                     * @param {TODO} components  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'setItems',
                    value: function setItems(components) {
                        var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        if (!components || !components.length) {
                            return Promise.resolve();
                        }
                        // if animate has not been set then default to false
                        opts.animate = opts.animate || false;
                        // ensure leaving items are not cached, and should be destroyed
                        opts.cacheLeavingItem = false;
                        // get the items to auto remove without having to do a transiton for each
                        // the last item (the currently active one) will do a normal transition out
                        if (this.items.length > 1) {
                            var autoRemoveItems = this.items.slice(0, this.items.length - 1);
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                autoRemoveItems[i].shouldDestroy = true;
                                autoRemoveItems[i].shouldCache = false;
                                autoRemoveItems[i].willUnload();
                            }
                        }
                        var componentObj = null;
                        var componentType = null;
                        var viewItem = null;
                        // create the ViewItems that go before the new active ViewItem in the stack
                        // but the previous views won't should render yet
                        if (components.length > 1) {
                            var newBeforeItems = components.slice(0, components.length - 1);
                            for (var j = 0; j < newBeforeItems.length; j++) {
                                componentObj = newBeforeItems[j];
                                if (componentObj) {
                                    // could be an object with a componentType property, or it is a componentType
                                    componentType = componentObj.componentType || componentObj;
                                    viewItem = new ViewItem(this, componentType, componentObj.params);
                                    viewItem.state = CACHED_STATE;
                                    viewItem.shouldDestroy = false;
                                    viewItem.shouldCache = false;
                                    // add the item to the stack
                                    this.add(viewItem);
                                }
                            }
                        }
                        // get the component that will become the active item
                        // it'll be the last one in the given components array
                        componentObj = components[components.length - 1];
                        componentType = componentObj.componentType || componentObj;
                        // transition the leaving and entering
                        return this.push(componentType, componentObj.params, opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} componentType  TODO
                     * @param {TODO} [params={}]  TODO
                     * @param {TODO} [opts={}]  TODO
                     * @returns {Promise} TODO
                     */
                }, {
                    key: 'setRoot',
                    value: function setRoot(componentType) {
                        var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                        return this.setItems([{
                            componentType: componentType,
                            params: params
                        }], opts);
                    }

                    /**
                     * TODO
                     * @param {TODO} enteringItem  TODO
                     * @param {TODO} leavingItem  TODO
                     * @param {TODO} opts  TODO
                     * @param {Function} callback  TODO
                     * @returns {any} TODO
                     */
                }, {
                    key: 'transition',
                    value: function transition(enteringItem, leavingItem, opts, callback) {
                        var _this = this;

                        if (!enteringItem || enteringItem === leavingItem) {
                            return callback();
                        }
                        if (opts.animate === false) {
                            opts.animation = 'none';
                        } else if (!opts.animation) {
                            opts.animation = this.config.setting('viewTransition');
                        }
                        opts.animate = opts.animation !== 'none';
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            _this.zone.runOutsideAngular(function () {
                                enteringItem.shouldDestroy = false;
                                enteringItem.shouldCache = false;
                                enteringItem.willEnter();
                                leavingItem.willLeave();
                                // set that the new item pushed on the stack is staged to be entering/leaving
                                // staged state is important for the transition to find the correct item
                                enteringItem.state = STAGED_ENTERING_STATE;
                                leavingItem.state = STAGED_LEAVING_STATE;
                                // init the transition animation
                                var transAnimation = Transition.create(_this, opts);
                                if (!opts.animate) {
                                    // force it to not animate the elements, just apply the "to" styles
                                    transAnimation.duration(0);
                                }
                                var duration = transAnimation.duration();
                                if (duration > 64) {
                                    // block any clicks during the transition and provide a
                                    // fallback to remove the clickblock if something goes wrong
                                    ClickBlock(true, duration + 200);
                                    _this.app.setTransitioning(true);
                                }
                                // start the transition
                                transAnimation.play().then(function () {
                                    // transition has completed, update each item's state
                                    enteringItem.state = ACTIVE_STATE;
                                    leavingItem.state = CACHED_STATE;
                                    // dispose any items that shouldn't stay around
                                    transAnimation.dispose();
                                    enteringItem.didEnter();
                                    leavingItem.didLeave();
                                    // all done!
                                    _this.zone.run(function () {
                                        _this.transitionComplete();
                                        callback();
                                    });
                                });
                            });
                        });
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'swipeBackStart',
                    value: function swipeBackStart() {
                        var _this2 = this;

                        if (this.isTransitioning() || this.items.length < 2) {
                            return;
                        }
                        this.sbActive = true;
                        this.sbResolve = null;
                        // default the direction to "back"
                        var opts = {
                            direction: 'back'
                        };
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldDestroy = true;
                        leavingItem.shouldCache = false;
                        leavingItem.willLeave();
                        leavingItem.willUnload();
                        // the entering item is now the new last item
                        var enteringItem = this.getPrevious(leavingItem);
                        enteringItem.shouldDestroy = false;
                        enteringItem.shouldCache = false;
                        enteringItem.willEnter();
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            // set that the new item pushed on the stack is staged to be entering/leaving
                            // staged state is important for the transition to find the correct item
                            enteringItem.state = STAGED_ENTERING_STATE;
                            leavingItem.state = STAGED_LEAVING_STATE;
                            // init the transition animation
                            _this2.sbTransition = Transition.create(_this2, opts);
                            _this2.sbTransition.easing('linear');
                            _this2.sbTransition.stage();
                            var swipeBackPromise = new Promise(function (res) {
                                _this2.sbResolve = res;
                            });
                            swipeBackPromise.then(function (completeSwipeBack) {
                                if (completeSwipeBack) {
                                    // swipe back has completed, update each item's state
                                    enteringItem.state = ACTIVE_STATE;
                                    leavingItem.state = CACHED_STATE;
                                    enteringItem.didEnter();
                                    leavingItem.didLeave();
                                    if (_this2.router) {
                                        // notify router of the state change
                                        _this2.router.stateChange('pop', enteringItem);
                                    }
                                } else {
                                    // cancelled the swipe back, return items to original state
                                    leavingItem.state = ACTIVE_STATE;
                                    enteringItem.state = CACHED_STATE;
                                    leavingItem.willEnter();
                                    leavingItem.didEnter();
                                    enteringItem.didLeave();
                                    leavingItem.shouldDestroy = false;
                                    enteringItem.shouldDestroy = false;
                                }
                                // all done!
                                _this2.transitionComplete();
                            });
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} progress  TODO
                     */
                }, {
                    key: 'swipeBackProgress',
                    value: function swipeBackProgress(progress) {
                        if (this.sbTransition) {
                            ClickBlock(true, 4000);
                            this.app.setTransitioning(true);
                            this.sbTransition.progress(Math.min(1, Math.max(0, progress)));
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} completeSwipeBack  TODO
                     * @param {TODO} progress  TODO
                     * @param {TODO} playbackRate  TODO
                     */
                }, {
                    key: 'swipeBackEnd',
                    value: function swipeBackEnd(completeSwipeBack, progress, playbackRate) {
                        var _this3 = this;

                        // to reverse the animation use a negative playbackRate
                        if (this.sbTransition && this.sbActive) {
                            this.sbActive = false;
                            if (progress <= 0) {
                                this.swipeBackProgress(0.0001);
                            } else if (progress >= 1) {
                                this.swipeBackProgress(0.9999);
                            }
                            if (!completeSwipeBack) {
                                playbackRate = playbackRate * -1;
                            }
                            this.sbTransition.playbackRate(playbackRate);
                            this.sbTransition.play().then(function () {
                                _this3.sbResolve && _this3.sbResolve(completeSwipeBack);
                                _this3.sbTransition && _this3.sbTransition.dispose();
                                _this3.sbResolve = _this3.sbTransition = null;
                            });
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isSwipeBackEnabled',
                    value: function isSwipeBackEnabled(val) {
                        if (arguments.length) {
                            this.sbEnabled = !!val;
                        }
                        return this.sbEnabled;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'canSwipeBack',
                    value: function canSwipeBack() {
                        if (this.sbEnabled) {
                            var activeItem = this.getActive();
                            if (activeItem) {
                                return activeItem.enableBack();
                            }
                        }
                        return false;
                    }

                    /**
                     * TODO
                     */
                }, {
                    key: 'transitionComplete',
                    value: function transitionComplete() {
                        var _this4 = this;

                        var destroys = [];
                        this.items.forEach(function (item) {
                            if (item) {
                                if (item.shouldDestroy) {
                                    destroys.push(item);
                                } else if (item.state === CACHED_STATE && item.shouldCache) {
                                    item.shouldCache = false;
                                }
                            }
                        });
                        destroys.forEach(function (item) {
                            _this4.remove(item);
                            item.destroy();
                        });
                        // allow clicks again
                        ClickBlock(false);
                        this.app.setTransitioning(false);
                    }

                    /**
                     * TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'isTransitioning',
                    value: function isTransitioning() {
                        var state = undefined;
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            state = this.items[i].state;
                            if (state === STAGED_ENTERING_STATE || state === STAGED_LEAVING_STATE) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getActive',
                    value: function getActive() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === ACTIVE_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} instance  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getByInstance',
                    value: function getByInstance(instance) {
                        if (instance) {
                            for (var i = 0, ii = this.items.length; i < ii; i++) {
                                if (this.items[i].instance === instance) {
                                    return this.items[i];
                                }
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} index  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getByIndex',
                    value: function getByIndex(index) {
                        if (index < this.items.length && index > -1) {
                            return this.items[index];
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getPrevious',
                    value: function getPrevious(item) {
                        if (item) {
                            return this.items[this.items.indexOf(item) - 1];
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getStagedEnteringItem',
                    value: function getStagedEnteringItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_ENTERING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'getStagedLeavingItem',
                    value: function getStagedLeavingItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_LEAVING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }

                    /**
                     * TODO
                     * @param {TODO} nbContainer  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarViewContainer',
                    value: function navbarViewContainer(nbContainer) {
                        if (nbContainer) {
                            this._nbContainer = nbContainer;
                        }
                        if (this._nbContainer) {
                            return this._nbContainer;
                        }
                        if (this.parent) {
                            return this.parent.navbarViewContainer();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorElementRef',
                    value: function anchorElementRef() {
                        if (arguments.length) {
                            this._anchorER = arguments[0];
                        }
                        return this._anchorER;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'anchorViewContainerRef',
                    value: function anchorViewContainerRef() {
                        if (arguments.length) {
                            this._anchorVC = arguments[0];
                        }
                        return this._anchorVC;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'childNavbar',
                    value: function childNavbar() {
                        if (arguments.length) {
                            this._childNavbar = arguments[0];
                        }
                        return this._childNavbar;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'add',
                    value: function add(item) {
                        item.id = this.id + '-' + ++this._ids;
                        this.items.push(item);
                    }

                    /**
                     * TODO
                     * @param {TODO} itemOrIndex  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'remove',
                    value: function remove(itemOrIndex) {
                        util.array.remove(this.items, itemOrIndex);
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'indexOf',
                    value: function indexOf(item) {
                        return this.items.indexOf(item);
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'length',
                    value: function length() {
                        return this.items.length;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'instances',
                    value: function instances() {
                        var instances = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var item = _step.value;

                                if (item.instance) {
                                    instances.push(item.instance);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return instances;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isActive',
                    value: function isActive(item) {
                        return item && item.state === ACTIVE_STATE;
                    }

                    /**
                     * TODO
                     * @param {TODO} item  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'isStagedEntering',
                    value: function isStagedEntering(item) {
                        return item && item.state === STAGED_ENTERING_STATE;
                    }

                    /**
                     * TODO
                     * @param {TODO} router  TODO
                     */
                }, {
                    key: 'registerRouter',
                    value: function registerRouter(router) {
                        this.router = router;
                    }
                }]);

                return ViewController;
            })(Ion);

            _export('ViewController', ViewController);

            ACTIVE_STATE = 1;
            CACHED_STATE = 2;
            STAGED_ENTERING_STATE = 3;
            STAGED_LEAVING_STATE = 4;
            ctrlIds = -1;
        }
    };
});
System.register('ionic/components/view/view-item', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../nav/nav-controller'], function (_export) {
    /**
     * TODO
     */
    'use strict';

    var Component, bind, Injector, ComponentRef, DirectiveBinding, NavParams, ViewItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function isComponent(elementBinder, id) {
        return elementBinder && elementBinder.componentDirective && elementBinder.componentDirective.metadata.id == id;
    }
    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            bind = _angular2Angular2.bind;
            Injector = _angular2Angular2.Injector;
            ComponentRef = _angular2Angular2.ComponentRef;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_navNavController) {
            NavParams = _navNavController.NavParams;
        }],
        execute: function () {
            ViewItem = (function () {
                function ViewItem(viewCtrl, componentType) {
                    var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, ViewItem);

                    this.viewCtrl = viewCtrl;
                    this.componentType = componentType;
                    this.params = new NavParams(params);
                    this.instance = null;
                    this.state = 0;
                    this.disposals = [];
                    this.protos = {};
                    this._nbItms = [];
                    this._promises = [];
                    this.templateRefs = {};
                }

                /**
                 * TODO
                 * @param {TODO} name  TODO
                 * @param {TODO} protoViewRef  TODO
                 */

                _createClass(ViewItem, [{
                    key: 'addProtoViewRef',
                    value: function addProtoViewRef(name, protoViewRef) {
                        this.protos[name] = protoViewRef;
                    }

                    /**
                     * TODO
                     * @param {TODO} name  TODO
                     * @param {TODO} templateRef  TODO
                     */
                }, {
                    key: 'addTemplateRef',
                    value: function addTemplateRef(name, templateRef) {
                        this.templateRefs[name] = templateRef;
                    }

                    /**
                     * TODO
                     * @param {Function} callback  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'stage',
                    value: function stage(callback) {
                        var _this = this;

                        var viewCtrl = this.viewCtrl;
                        if (this.instance || !viewCtrl) {
                            // already compiled this view
                            return callback();
                        }
                        var annotation = new Component({
                            selector: 'ion-view',
                            host: {
                                'class': 'nav-item'
                            }
                        });
                        var ionViewComponentType = DirectiveBinding.createFromType(this.componentType, annotation);
                        // create a unique token that works as a cache key
                        ionViewComponentType.token = 'ionView' + this.componentType.name;
                        // compile the Component
                        viewCtrl.compiler.compileInHost(ionViewComponentType).then(function (hostProtoViewRef) {
                            // figure out the sturcture of this Component
                            // does it have a navbar? Is it tabs? Should it not have a navbar or any toolbars?
                            var itemStructure = _this.sturcture = _this.inspectStructure(hostProtoViewRef);
                            // get the appropriate Pane which this ViewItem will fit into
                            viewCtrl.panes.get(itemStructure, function (pane) {
                                _this.pane = pane;
                                var bindings = viewCtrl.bindings.concat(Injector.resolve([bind(NavParams).toValue(_this.params), bind(ViewItem).toValue(_this)]));
                                // add the content of the view to the content area
                                // it will already have the correct context
                                var contentContainer = pane.contentContainerRef;
                                // the same guts as DynamicComponentLoader.loadNextToLocation
                                var hostViewRef = contentContainer.createHostView(hostProtoViewRef, -1, bindings);
                                var newLocation = viewCtrl.viewMngr.getHostElement(hostViewRef);
                                var newComponent = viewCtrl.viewMngr.getComponent(newLocation);
                                pane.totalItems++;
                                var dispose = function dispose() {
                                    var index = contentContainer.indexOf(hostViewRef);
                                    if (index !== -1) {
                                        contentContainer.remove(index);
                                        // remove the pane if there are no view items left
                                        pane.totalItems--;
                                        if (pane.totalItems === 0) {
                                            pane.dispose();
                                        }
                                    }
                                };
                                _this.disposals.push(dispose);
                                var viewComponetRef = new ComponentRef(newLocation, newComponent, dispose);
                                // get the component's instance, and set it to the this ViewItem
                                _this.setInstance(viewComponetRef.instance);
                                _this.viewElementRef(viewComponetRef.location);
                                // // get the item container's nav bar
                                var navbarViewContainer = viewCtrl.navbarViewContainer();
                                // // get the item's navbar protoview
                                var navbarTemplateRef = _this.templateRefs.navbar;
                                // add a navbar view if the pane has a navbar container, and the
                                // item's instance has a navbar protoview to go to inside of it
                                if (navbarViewContainer && navbarTemplateRef) {
                                    (function () {
                                        var navbarView = navbarViewContainer.createEmbeddedView(navbarTemplateRef, -1);
                                        _this.disposals.push(function () {
                                            var index = navbarViewContainer.indexOf(navbarView);
                                            if (index > -1) {
                                                navbarViewContainer.remove(index);
                                            }
                                        });
                                    })();
                                }
                                // this item has finished loading
                                try {
                                    _this.loaded();
                                } catch (e) {
                                    console.error(e);
                                }
                                // fire callback when all child promises have been resolved
                                Promise.all(_this._promises).then(function () {
                                    callback();
                                    _this._promises = [];
                                });
                            }, function (panesErr) {
                                console.error(panesErr);
                            });
                        }, function (compileInHostErr) {
                            console.error(compileInHostErr);
                        });
                    }

                    /**
                     * TODO
                     * @param {TODO} childPromise  TODO
                     */
                }, {
                    key: 'addPromise',
                    value: function addPromise(childPromise) {
                        this._promises.push(childPromise);
                    }

                    /**
                     * TODO
                     * @param {TODO} componentProtoViewRef  TODO
                     */
                }, {
                    key: 'inspectStructure',
                    value: function inspectStructure(componentProtoViewRef) {
                        var navbar = false;
                        var key = '_';
                        componentProtoViewRef._protoView.elementBinders.forEach(function (rootElementBinder) {
                            if (!rootElementBinder.componentDirective || !rootElementBinder.nestedProtoView) return;
                            rootElementBinder.nestedProtoView.elementBinders.forEach(function (nestedElementBinder) {
                                if (isComponent(nestedElementBinder, 'Tabs')) {
                                    navbar = true;
                                }
                                if (!nestedElementBinder.componentDirective && nestedElementBinder.nestedProtoView) {
                                    nestedElementBinder.nestedProtoView.elementBinders.forEach(function (templatedElementBinder) {
                                        if (isComponent(templatedElementBinder, 'Navbar')) {
                                            navbar = true;
                                        }
                                    });
                                }
                            });
                        });
                        if (this.viewCtrl.childNavbar()) {
                            navbar = false;
                        }
                        if (navbar) key += 'n';
                        return {
                            navbar: navbar,
                            key: key
                        };
                    }

                    /**
                     * TODO
                     * @returns {boolean} TODO
                     */
                }, {
                    key: 'enableBack',
                    value: function enableBack() {
                        // update if it's possible to go back from this nav item
                        if (this.viewCtrl) {
                            var previousItem = this.viewCtrl.getPrevious(this);
                            // the previous view may exist, but if it's about to be destroyed
                            // it shouldn't be able to go back to
                            return !!(previousItem && !previousItem.shouldDestroy);
                        }
                        return false;
                    }

                    /**
                     * TODO
                     * @param {TODO} instance  TODO
                     */
                }, {
                    key: 'setInstance',
                    value: function setInstance(instance) {
                        this.instance = instance;
                        this.instance._viewItem = this;
                    }
                }, {
                    key: 'destroy',

                    /**
                     * TODO
                     */
                    value: function destroy() {
                        for (var i = 0; i < this.disposals.length; i++) {
                            this.disposals[i]();
                        }
                        this.didUnload();
                        // just to help prevent any possible memory leaks
                        for (var _name in this) {
                            if (this.hasOwnProperty(_name)) {
                                this[_name] = null;
                            }
                        }
                    }

                    /**
                     * TODO
                     * @param {TODO} val  TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'viewElementRef',
                    value: function viewElementRef(val) {
                        if (arguments.length) {
                            this._vwEle = val;
                        }
                        return this._vwEle;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarView',
                    value: function navbarView() {
                        if (arguments.length) {
                            this._nbView = arguments[0];
                        }
                        return this._nbView;
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarElement',
                    value: function navbarElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getElementRef();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'titleElement',
                    value: function titleElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.titleElement();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'backButtonElement',
                    value: function backButtonElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.backButtonElement();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'backButtonTextElement',
                    value: function backButtonTextElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.backButtonTextElement();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'navbarItemElements',
                    value: function navbarItemElements() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.itemElements();
                        }
                    }

                    /**
                     * TODO
                     * @returns {TODO} TODO
                     */
                }, {
                    key: 'postRender',
                    value: function postRender() {
                        // the elements are in the DOM and the browser
                        // has rendered them in their correct locations
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.alignTitle();
                        }
                    }

                    /**
                     * The view has loaded. This event only happens once per view being
                     * created. If a view leaves but is cached, then this will not
                     * fire again on a subsequent viewing. This method is a good place
                     * to put your setup code for the view; however, it is not the
                     * recommended method to use when a view becomes active.
                     */
                }, {
                    key: 'loaded',
                    value: function loaded() {
                        this.instance && this.instance.viewLoaded && this.instance.viewLoaded();
                    }

                    /**
                     * The view is about to enter and become the active view.
                     */
                }, {
                    key: 'willEnter',
                    value: function willEnter() {
                        this.instance && this.instance.viewWillEnter && this.instance.viewWillEnter();
                    }

                    /**
                     * The view has fully entered and is now the active view. This
                     * will fire, whether it was the first load or loaded from the cache.
                     */
                }, {
                    key: 'didEnter',
                    value: function didEnter() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.didEnter();
                        }
                        this.instance && this.instance.viewDidEnter && this.instance.viewDidEnter();
                    }

                    /**
                     * The view has is about to leave and no longer be the active view.
                     */
                }, {
                    key: 'willLeave',
                    value: function willLeave() {
                        this.instance && this.instance.viewWillLeave && this.instance.viewWillLeave();
                    }

                    /**
                     * The view has finished leaving and is no longer the active view. This
                     * will fire, whether it is cached or unloaded.
                     */
                }, {
                    key: 'didLeave',
                    value: function didLeave() {
                        this.instance && this.instance.viewDidLeave && this.instance.viewDidLeave();
                    }

                    /**
                     * The view is about to be destroyed and have its elements removed.
                     */
                }, {
                    key: 'willUnload',
                    value: function willUnload() {
                        this.instance && this.instance.viewWillUnload && this.instance.viewWillUnload();
                    }

                    /**
                     * The view has been destroyed and its elements have been removed.
                     */
                }, {
                    key: 'didUnload',
                    value: function didUnload() {
                        this.instance && this.instance.viewDidUnload && this.instance.viewDidUnload();
                    }
                }, {
                    key: 'index',
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.indexOf(this) : -1;
                    }
                }]);

                return ViewItem;
            })();

            _export('ViewItem', ViewItem);
        }
    };
});
System.register("ionic/native/battery/battery", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, _Battery;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _Battery = (function () {
                function Battery() {
                    _classCallCheck(this, Battery);
                }

                _createClass(Battery, null, [{
                    key: "getStatus",
                    value: function getStatus() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (navigator.getBattery) {
                                navigator.getBattery().then(function (battery) {
                                    _this.battery = battery;
                                    resolve(_Battery._format(battery));
                                });
                            } else {
                                var fnCb = function fnCb(battery) {
                                    resolve(battery);
                                    window.removeEventListener('batterystatus', fnCb);
                                };
                                window.addEventListener('batterystatus', fnCb);
                            }
                        });
                    }
                }, {
                    key: "_format",
                    value: function _format(batteryObj) {
                        if (typeof batteryObj.isPlugged !== 'undefined') {
                            // This is the old format, map it to the new format
                            util.extend(batteryObj, {
                                charging: batteryObj.isPlugged,
                                level: batteryObj.level / 100,
                                chargingTime: 0,
                                dischargingTime: 0 //not provided
                            });
                        }
                        return batteryObj;
                    }
                }]);

                return Battery;
            })();

            _export("Battery", _Battery);

            _Battery = __decorate([NativePlugin({
                name: 'Battery',
                platforms: {
                    cordova: 'cordova-plugin-battery-status'
                }
            }), __metadata('design:paramtypes', [])], _Battery);
        }
    };
});
System.register("ionic/native/camera/camera", ["ionic/util", "../plugin"], function (_export) {
    "use strict";

    var util, NativePlugin, __decorate, __metadata, Camera;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Camera = (function () {
                function Camera() {
                    _classCallCheck(this, Camera);
                }

                _createClass(Camera, null, [{
                    key: "getPicture",
                    value: function getPicture(options) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.camera) {
                                _this.pluginWarn();
                                resolve(null);
                                return;
                            }
                            var options = util.defaults({
                                quality: 80,
                                destinationType: window.Camera.DestinationType.DATA_URL,
                                sourceType: window.Camera.PictureSourceType.CAMERA,
                                allowEdit: true,
                                encodingType: window.Camera.EncodingType.JPEG,
                                popoverOptions: window.CameraPopoverOptions,
                                saveToPhotoAlbum: false
                            }, options);
                            navigator.camera.getPicture(function (imageData) {
                                resolve(imageData);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "cleanup",
                    value: function cleanup() {
                        return new Promise(function (resolve, reject) {
                            navigator.camera.cleanup(function () {
                                resolve();
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Camera;
            })();

            _export("Camera", Camera);

            _export("Camera", Camera = __decorate([NativePlugin({
                name: 'Camera',
                platforms: {
                    cordova: 'cordova-plugin-camera'
                }
            }), __metadata('design:paramtypes', [])], Camera));
        }
    };
});
System.register("ionic/native/contacts/contacts", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Contacts;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Contacts = (function () {
                function Contacts() {
                    _classCallCheck(this, Contacts);
                }

                _createClass(Contacts, null, [{
                    key: "save",
                    value: function save(contact) {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.save(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "remove",
                    value: function remove(contact) {
                        var _this2 = this;

                        return new Promise(function (resolve, reject) {
                            if (!navigator.contacts) {
                                _this2.pluginWarn();
                                reject('Contacts plugin not installed');
                            }
                            var deviceContact = navigator.contacts.create(contact);
                            deviceContact.remove(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }, {
                    key: "clone",
                    value: function clone(contact) {
                        if (!navigator.contacts) {
                            this.pluginWarn();
                            return null;
                        }
                        var deviceContact = navigator.contacts.create(contact);
                        return deviceContact.clone(contact);
                    }
                }, {
                    key: "find",
                    value: function find(options) {
                        return new Promise(function (resolve, reject) {
                            var fields = options.fields || ['id', 'displayName'];
                            delete options.fields;
                            if (Object.keys(options).length === 0) {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                navigator.contacts.find(fields, function (results) {
                                    resolve(results);
                                }, function (err) {
                                    reject(err);
                                }, options);
                            }
                        });
                    }
                }, {
                    key: "pickContact",
                    value: function pickContact() {
                        return new Promise(function (resolve, reject) {
                            navigator.contacts.pickContact(function (contact) {
                                resolve(contact);
                            }, function (err) {
                                reject(err);
                            });
                        });
                    }
                }]);

                return Contacts;
            })();

            _export("Contacts", Contacts);

            _export("Contacts", Contacts = __decorate([NativePlugin({
                name: 'Contacts',
                platforms: {
                    cordova: 'cordova-plugin-contacts'
                }
            }), __metadata('design:paramtypes', [])], Contacts));
        }
    };
});
System.register("ionic/native/device/device", ["../plugin", "../../platform/platform"], function (_export) {
    "use strict";

    var NativePlugin, Platform, __decorate, __metadata, Device;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Device = (function () {
                function Device() {
                    _classCallCheck(this, Device);
                }

                _createClass(Device, null, [{
                    key: "getDevice",

                    /**
                     * Returns the whole device object.
                     * @see https://github.com/apache/cordova-plugin-device
                     * @returns {Object} The device object.
                     */
                    value: function getDevice() {
                        return this.ifPlugin(window.device, function () {
                            return device;
                        }, function () {
                            return {
                                name: Platform.platforms().join(',')
                            };
                        });
                    }

                    /**
                     * Returns the Cordova version.
                     * @see https://github.com/apache/cordova-plugin-device#devicecordova
                     * @returns {String} The Cordova version.
                     */
                }, {
                    key: "getCordova",
                    value: function getCordova() {
                        this.ifPlugin(window.device, function () {
                            return device.cordova;
                        });
                    }

                    /**
                     * Returns the name of the device's model or product.
                     * @see https://github.com/apache/cordova-plugin-device#devicemodel
                     * @returns {String} The name of the device's model or product.
                     */
                }, {
                    key: "getModel",
                    value: function getModel() {
                        this.ifPlugin(window.device, function () {
                            return device.model;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * @deprecated device.name is deprecated as of version 2.3.0. Use device.model instead.
                     * @returns {String}
                     */
                }, {
                    key: "getName",
                    value: function getName() {
                        this.ifPlugin(window.device, function () {
                            return device.name;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device's operating system name.
                     * @see https://github.com/apache/cordova-plugin-device#deviceplatform
                     * @returns {String} The device's operating system name.
                     */
                }, {
                    key: "getPlatform",
                    value: function getPlatform() {
                        this.ifPlugin(window.device, function () {
                            return device.name;
                        }, function () {
                            return {
                                name: Platform.name()
                            };
                        });
                    }

                    /**
                     * Returns the device's Universally Unique Identifier.
                     * @see https://github.com/apache/cordova-plugin-device#deviceuuid
                     * @returns {String} The device's Universally Unique Identifier
                     */
                }, {
                    key: "getUUID",
                    value: function getUUID() {
                        this.ifPlugin(window.device, function () {
                            return device.uuid;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the operating system version.
                     * @see https://github.com/apache/cordova-plugin-device#deviceversion
                     * @returns {String}
                     */
                }, {
                    key: "getVersion",
                    value: function getVersion() {
                        this.ifPlugin(window.device, function () {
                            return device.version;
                        }, function () {
                            return 'unknown';
                        });
                    }

                    /**
                     * Returns the device manufacturer.
                     * @returns {String}
                     */
                }, {
                    key: "getManufacturer",
                    value: function getManufacturer() {
                        this.ifPlugin(window.device, function () {
                            return device.manufacturer;
                        }, function () {
                            return 'unknown';
                        });
                    }
                }]);

                return Device;
            })();

            _export("Device", Device);

            _export("Device", Device = __decorate([NativePlugin({
                name: 'Device',
                platforms: {
                    cordova: 'cordova-plugin-device'
                }
            }), __metadata('design:paramtypes', [])], Device));
        }
    };
});
System.register("ionic/native/device-motion/device-motion", ["rx", "../plugin"], function (_export) {
    "use strict";

    var Rx, NativePlugin, __decorate, __metadata, _DeviceMotion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceMotion = (function () {
                function DeviceMotion() {
                    _classCallCheck(this, DeviceMotion);
                }

                _createClass(DeviceMotion, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        // Mimic the DeviceMotionEvent
                        return {
                            acceleration: result,
                            accelerationIncludingGravity: result,
                            rotationRate: 0,
                            interval: 0,
                            native: true
                        };
                    }
                }, {
                    key: "getCurrentAcceleration",
                    value: function getCurrentAcceleration() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                                var fnCb = function fnCb(eventData) {
                                    console.log('Event', eventData);
                                    resolve(eventData);
                                    window.removeEventListener('devicemotion', fnCb);
                                };
                                window.addEventListener('devicemotion', fnCb);
                            } else if (navigator.accelerometer) {
                                navigator.accelerometer.getCurrentAcceleration(function (result) {
                                    resolve(_DeviceMotion._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device motion events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchAcceleration",
                    value: function watchAcceleration(options) {
                        if (window.DeviceMotionEvent || 'listenForDeviceMovement' in window) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    console.log(eventData);
                                    observer.onNext(eventData);
                                };
                                window.addEventListener('devicemotion', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('devicemotion', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.accelerometer.watchAcceleration(function (result) {
                                        observer.onNext(result);
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.accelerometer.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceMotion;
            })();

            _export("DeviceMotion", _DeviceMotion);

            _DeviceMotion = __decorate([NativePlugin({
                name: 'Device Motion',
                platforms: {
                    cordova: 'cordova-plugin-device-motion'
                }
            }), __metadata('design:paramtypes', [])], _DeviceMotion);
        }
    };
});
System.register("ionic/native/device-orientation/device-orientation", ["rx", "../plugin"], function (_export) {
    "use strict";

    var Rx, NativePlugin, __decorate, __metadata, _DeviceOrientation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            _DeviceOrientation = (function () {
                function DeviceOrientation() {
                    _classCallCheck(this, DeviceOrientation);
                }

                _createClass(DeviceOrientation, null, [{
                    key: "_wrap",
                    value: function _wrap(result) {
                        return result;
                    }
                }, {
                    key: "getCurrentAcceleration",
                    value: function getCurrentAcceleration() {
                        var _this = this;

                        return new Promise(function (resolve, reject) {
                            if (window.DeviceOrientationEvent) {
                                var fnCb = function fnCb(eventData) {
                                    resolve(eventData);
                                    window.removeEventListener('deviceorientation', fnCb);
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            } else if (navigator.compass) {
                                navigator.compass.getCurrentHeading(function (result) {
                                    resolve(_DeviceOrientation._wrap(result));
                                }, function (err) {
                                    reject(err);
                                });
                            } else {
                                _this.pluginWarn();
                                reject('The Device does not support device orientation events.');
                                return;
                            }
                        });
                    }
                }, {
                    key: "watchHeading",
                    value: function watchHeading(options) {
                        if (window.DeviceOrientationEvent) {
                            var watchID = undefined;
                            var source = Rx.Observable.create(function (observer) {
                                var fnCb = function fnCb(eventData) {
                                    console.log(eventData);
                                    observer.onNext(eventData);
                                };
                                window.addEventListener('deviceorientation', fnCb);
                            });
                            return {
                                source: source,
                                watchID: watchID,
                                clear: function clear() {
                                    window.removeEventListener('deviceorientation', fnCb);
                                }
                            };
                        } else if (navigator.accelerometer) {
                            var _ret = (function () {
                                var watchID = undefined;
                                var source = Rx.Observable.create(function (observer) {
                                    watchID = navigator.compass.watchHeading(function (result) {
                                        observer.onNext(result);
                                    }, function (err) {
                                        observer.onError(err, observer);
                                    }, options);
                                });
                                return {
                                    v: {
                                        source: source,
                                        watchID: watchID,
                                        clear: function clear() {
                                            navigator.compass.clearWatch(watchID);
                                        }
                                    }
                                };
                            })();

                            if (typeof _ret === "object") return _ret.v;
                        }
                    }
                }]);

                return DeviceOrientation;
            })();

            _export("DeviceOrientation", _DeviceOrientation);

            _DeviceOrientation = __decorate([NativePlugin({
                name: 'Device Orientation',
                platforms: {
                    cordova: 'cordova-plugin-device-orientation'
                }
            }), __metadata('design:paramtypes', [])], _DeviceOrientation);
        }
    };
});
System.register("ionic/native/geolocation/geolocation", ["rx", "../plugin"], function (_export) {
    "use strict";

    var Rx, NativePlugin, __decorate, __metadata, Geolocation;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_rx) {
            Rx = _rx;
        }, function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Geolocation = (function () {
                function Geolocation() {
                    _classCallCheck(this, Geolocation);
                }

                _createClass(Geolocation, null, [{
                    key: "getCurrentPosition",
                    value: function getCurrentPosition(options) {
                        return new Promise(function (resolve, reject) {
                            navigator.geolocation.getCurrentPosition(function (result) {
                                resolve(result);
                            }, function (err) {
                                reject(err);
                            }, options);
                        });
                    }
                }, {
                    key: "watchPosition",
                    value: function watchPosition(options) {
                        var watchID = undefined;
                        var source = Rx.Observable.create(function (observer) {
                            watchID = navigator.geolocation.watchPosition(function (result) {
                                observer.onNext(result);
                            }, function (err) {
                                observer.onError(err, observer);
                            }, options);
                        });
                        return {
                            source: source,
                            watchID: watchID,
                            clear: function clear() {
                                navigator.geolocation.clearWatch(watchID);
                            }
                        };
                    }
                }, {
                    key: "clearWatch",
                    value: function clearWatch(watchID) {
                        return navigator.geolocation.clearWatch(watchID);
                    }
                }]);

                return Geolocation;
            })();

            _export("Geolocation", Geolocation);

            _export("Geolocation", Geolocation = __decorate([NativePlugin({
                name: 'Geolocation',
                platforms: {
                    cordova: 'cordova-plugin-geolocation'
                }
            }), __metadata('design:paramtypes', [])], Geolocation));
        }
    };
});
System.register("ionic/native/vibration/vibration", ["../plugin"], function (_export) {
    "use strict";

    var NativePlugin, __decorate, __metadata, Vibration;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_plugin) {
            NativePlugin = _plugin.NativePlugin;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Vibration = (function () {
                function Vibration() {
                    _classCallCheck(this, Vibration);
                }

                _createClass(Vibration, null, [{
                    key: "vibrate",
                    value: function vibrate(pattern) {
                        if (!navigator.vibrate) {
                            this.pluginWarn();
                            console.log('Vibrate (dev): ', pattern);
                        } else {
                            navigator.vibrate(pattern);
                        }
                    }
                }]);

                return Vibration;
            })();

            _export("Vibration", Vibration);

            _export("Vibration", Vibration = __decorate([NativePlugin({
                name: 'Vibration',
                platforms: {
                    cordova: 'cordova-plugin-vibration'
                }
            }), __metadata('design:paramtypes', [])], Vibration));
        }
    };
});
System.register('ionic/components/aside/extensions/gestures', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, AsideTargetGesture, AsideGesture, LeftAsideGesture, RightAsideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            AsideTargetGesture = (function (_SlideEdgeGesture) {
                _inherits(AsideTargetGesture, _SlideEdgeGesture);

                function AsideTargetGesture(aside) {
                    _classCallCheck(this, AsideTargetGesture);

                    var asideElement = aside.getNativeElement();
                    _get(Object.getPrototypeOf(AsideTargetGesture.prototype), 'constructor', this).call(this, asideElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 0
                    });
                    this.aside = aside;
                }

                _createClass(AsideTargetGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.aside.isOpen;
                    }

                    // Set CSS, then wait one frame for it to apply before sliding starts
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform(slide.distance);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setSliding(false);
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                            this.aside.setDoneTransforming(!this.aside.isOpen);
                        } else {
                            this.aside.setDoneTransforming(this.aside.isOpen);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideTargetGesture;
            })(SlideEdgeGesture);

            AsideGesture = (function (_SlideEdgeGesture2) {
                _inherits(AsideGesture, _SlideEdgeGesture2);

                function AsideGesture(aside) {
                    _classCallCheck(this, AsideGesture);

                    // TODO figure out the sliding element, dont just use the parent
                    var contentElement = aside.getContentElement();
                    _get(Object.getPrototypeOf(AsideGesture.prototype), 'constructor', this).call(this, contentElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 75
                    });
                    this.aside = aside;
                    this.slideElement = contentElement;
                    this.listen();
                    var contentGesture = new AsideTargetGesture(aside);
                    contentGesture.listen();
                }

                _createClass(AsideGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        // Only restrict edges if the aside is closed
                        return this.aside.isOpen ? true : _get(Object.getPrototypeOf(AsideGesture.prototype), 'canStart', this).call(this, ev);
                    }

                    // Set CSS, then wait one frame for it to apply before sliding starts
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform(slide.distance);
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setSliding(false);
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                            this.aside.setDoneTransforming(!this.aside.isOpen);
                        } else {
                            this.aside.setDoneTransforming(false);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideGesture;
            })(SlideEdgeGesture);

            LeftAsideGesture = (function (_AsideGesture) {
                _inherits(LeftAsideGesture, _AsideGesture);

                function LeftAsideGesture() {
                    _classCallCheck(this, LeftAsideGesture);

                    _get(Object.getPrototypeOf(LeftAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                return LeftAsideGesture;
            })(AsideGesture);

            _export('LeftAsideGesture', LeftAsideGesture);

            RightAsideGesture = (function (_LeftAsideGesture) {
                _inherits(RightAsideGesture, _LeftAsideGesture);

                function RightAsideGesture() {
                    _classCallCheck(this, RightAsideGesture);

                    _get(Object.getPrototypeOf(RightAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                /*
                 Not supported right now
                export class TopAsideGesture extends AsideGesture {
                  onSlide(slide, ev) {
                    this.aside.setTransform(slide.distance);
                  }
                  getSlideBoundaries() {
                    return {
                      min: 0,
                      max: this.aside.height()
                    };
                  }
                }
                
                export class BottomAsideGesture extends TopAsideGesture {
                  getElementStartPos(slide, ev) {
                    return this.aside.isOpen ? slide.min : slide.max;
                  }
                  getSlideBoundaries() {
                    return {
                      min: -this.aside.height(),
                      max: 0
                    };
                  }
                }
                */

                _createClass(RightAsideGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.aside.width(),
                            max: 0
                        };
                    }
                }]);

                return RightAsideGesture;
            })(LeftAsideGesture);

            _export('RightAsideGesture', RightAsideGesture);
        }
    };
});
System.register('ionic/components/aside/extensions/types', ['ionic/util/dom'], function (_export) {
    // TODO use setters instead of direct dom manipulation
    'use strict';

    var CSS, asideManipulator, contentManipulator, backdropManipulator, AsideType, AsideTypeOverlay, AsideTypePush, AsideTypeReveal;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtilDom) {
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            asideManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.getNativeElement().classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.getNativeElement().classList[open ? 'add' : 'remove']('open');
                },
                setTransform: function setTransform(t) {
                    if (t === null) {
                        this.aside.getNativeElement().style[CSS.transform] = '';
                    } else {
                        this.aside.getNativeElement().style[CSS.transform] = 'translate3d(' + t + 'px,0,0)';
                    }
                }
            };
            contentManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.contentElement.classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.contentElement.classList[open ? 'add' : 'remove']('aside-open-' + this.aside.side);
                },
                setTransform: function setTransform(t) {
                    if (t === null) {
                        this.aside.contentElement.style[CSS.transform] = '';
                    } else {
                        this.aside.contentElement.style[CSS.transform] = 'translate3d(' + t + 'px,0,0)';
                    }
                }
            };
            backdropManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.backdrop.isTransitioning = sliding;
                    //.classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    var amt = open ? 0.5 : 0;
                    this.aside.backdrop.opacity = amt;
                },
                setTransform: function setTransform(t) {
                    if (t === null) {
                        t = this.aside.width();
                    }
                    var fade = 0.5 * t / this.aside.width();
                    this.aside.backdrop.opacity = fade;
                }
            };

            AsideType = function AsideType(aside) {
                _classCallCheck(this, AsideType);

                this.aside = aside;
                setTimeout(function () {
                    aside.contentElement.classList.add('aside-content');
                });
            };

            _export('AsideType', AsideType);

            AsideTypeOverlay = (function (_AsideType) {
                _inherits(AsideTypeOverlay, _AsideType);

                function AsideTypeOverlay() {
                    _classCallCheck(this, AsideTypeOverlay);

                    _get(Object.getPrototypeOf(AsideTypeOverlay.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(AsideTypeOverlay, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                        backdropManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                        backdropManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                        backdropManipulator.setTransform.call(this, t);
                    }
                }, {
                    key: 'setDoneTransforming',
                    value: function setDoneTransforming(willOpen) {
                        asideManipulator.setTransform.call(this, null);
                        backdropManipulator.setTransform.call(this, null);
                        asideManipulator.setOpen.call(this, willOpen);
                        backdropManipulator.setOpen.call(this, willOpen);
                    }
                }]);

                return AsideTypeOverlay;
            })(AsideType);

            _export('AsideTypeOverlay', AsideTypeOverlay);

            AsideTypePush = (function (_AsideType2) {
                _inherits(AsideTypePush, _AsideType2);

                function AsideTypePush() {
                    _classCallCheck(this, AsideTypePush);

                    _get(Object.getPrototypeOf(AsideTypePush.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(AsideTypePush, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                        contentManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                        contentManipulator.setTransform.call(this, t);
                    }
                }, {
                    key: 'setDoneTransforming',
                    value: function setDoneTransforming(willOpen) {
                        asideManipulator.setOpen.call(this, willOpen);
                        asideManipulator.setTransform.call(this, null);
                        contentManipulator.setOpen.call(this, willOpen);
                        contentManipulator.setTransform.call(this, null);
                    }
                }]);

                return AsideTypePush;
            })(AsideType);

            _export('AsideTypePush', AsideTypePush);

            AsideTypeReveal = (function (_AsideType3) {
                _inherits(AsideTypeReveal, _AsideType3);

                function AsideTypeReveal() {
                    _classCallCheck(this, AsideTypeReveal);

                    _get(Object.getPrototypeOf(AsideTypeReveal.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(AsideTypeReveal, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(sliding) {
                        asideManipulator.setOpen.call(this, sliding);
                        contentManipulator.setOpen.call(this, sliding);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        contentManipulator.setTransform.call(this, t);
                    }
                }, {
                    key: 'setDoneTransforming',
                    value: function setDoneTransforming(willOpen) {
                        contentManipulator.setOpen.call(this, willOpen);
                        contentManipulator.setTransform.call(this, null);
                    }
                }]);

                return AsideTypeReveal;
            })(AsideType);

            _export('AsideTypeReveal', AsideTypeReveal);
        }
    };
});
// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){b["true"]=a,function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}var c={},d={},e={},f=null;!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear"}function e(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==t.indexOf(b[c]))return;if("direction"==c&&-1==u.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function f(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function g(b,c){b=a.numericTimingToObject(b);var d=e(b,c);return d._easing=j(d.easing),d}function h(a,b,c,d){return 0>a||a>1||0>c||c>1?C:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(0==e||1==e)return e;for(var g=0,h=1;;){var i=(g+h)/2,j=f(a,c,i);if(Math.abs(e-j)<.001)return f(b,d,i);e>j?g=i:h=i}}}function i(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function j(a){var b=A.exec(a);if(b)return h.apply(this,b.slice(1).map(Number));var c=B.exec(a);if(c)return i(Number(c[1]),{start:v,middle:w,end:x}[c[2]]);var d=y[a];return d?d:C}function k(a){return Math.abs(l(a)/a.playbackRate)}function l(a){return a.duration*a.iterations}function m(a,b,c){return null==b?D:b<c.delay?E:b>=c.delay+a?F:G}function n(a,b,c,d,e){switch(d){case E:return"backwards"==b||"both"==b?0:null;case G:return c-e;case F:return"forwards"==b||"both"==b?a:null;case D:return null}}function o(a,b,c,d){return(d.playbackRate<0?b-a:b)*d.playbackRate+c}function p(a,b,c,d,e){return c===1/0||c===-(1/0)||c-d==b&&e.iterations&&(e.iterations+e.iterationStart)%1==0?a:c%a}function q(a,b,c,d){return 0===c?0:b==a?d.iterationStart+d.iterations-1:Math.floor(c/a)}function r(a,b,c,d){var e=a%2>=1,f="normal"==d.direction||d.direction==(e?"alternate-reverse":"alternate"),g=f?c:b-c,h=g/b;return b*d.easing(h)}function s(a,b,c){var d=m(a,b,c),e=n(a,c.fill,b,d,c.delay);if(null===e)return null;if(0===a)return d===E?0:1;var f=c.iterationStart*c.duration,g=o(a,e,f,c),h=p(c.duration,l(c),g,f,c),i=q(c.duration,h,g,c);return r(i,c.duration,h,c)/c.duration}var t="backwards|forwards|both|none".split("|"),u="reverse|alternate|alternate-reverse".split("|");d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(a.normalizeTimingInput(this._effect._timingInput)),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){this._setMember("iterations",a)},get iterations(){return this._iterations}};var v=1,w=.5,x=0,y={ease:h(.25,.1,.25,1),"ease-in":h(.42,0,1,1),"ease-out":h(0,0,.58,1),"ease-in-out":h(.42,0,.58,1),"step-start":i(1,v),"step-middle":i(1,w),"step-end":i(1,x)},z="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",A=new RegExp("cubic-bezier\\("+z+","+z+","+z+","+z+"\\)"),B=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,C=function(a){return a},D=0,E=1,F=2,G=3;a.cloneTimingInput=c,a.makeTiming=e,a.numericTimingToObject=f,a.normalizeTimingInput=g,a.calculateActiveDuration=k,a.calculateTimeFraction=s,a.calculatePhase=m,a.toTimingFunction=j}(c,f),function(a,b){function c(a,b){return a in i?i[a][b]||b:b}function d(a,b,d){var e=f[a];if(e){g.style[a]=b;for(var h in e){var i=e[h],j=g.style[i];d[i]=c(i,j)}}else d[a]=c(a,b)}function e(b){function c(){var a=e.length;null==e[a-1].offset&&(e[a-1].offset=1),a>1&&null==e[0].offset&&(e[0].offset=0);for(var b=0,c=e[0].offset,d=1;a>d;d++){var f=e[d].offset;if(null!=f){for(var g=1;d-b>g;g++)e[b+g].offset=c+(f-c)*g/(d-b);b=d,c=f}}}if(!Array.isArray(b)&&null!==b)throw new TypeError("Keyframes must be null or an array of keyframes");if(null==b)return[];for(var e=b.map(function(b){var c={};for(var e in b){var f=b[e];if("offset"==e){if(null!=f&&(f=Number(f),!isFinite(f)))throw new TypeError("keyframe offsets must be numbers.")}else{if("composite"==e)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};f="easing"==e?a.toTimingFunction(f):""+f}d(e,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing=a.toTimingFunction("linear")),c}),f=!0,g=-(1/0),h=0;h<e.length;h++){var i=e[h].offset;if(null!=i){if(g>i)throw{code:DOMException.INVALID_MODIFICATION_ERR,name:"InvalidModificationError",message:"Keyframes are not loosely sorted by offset. Sort or specify offsets."};g=i}else f=!1}return e=e.filter(function(a){return a.offset>=0&&a.offset<=1}),f||c(),e}var f={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},g=document.createElementNS("http://www.w3.org/1999/xhtml","div"),h={thin:"1px",medium:"3px",thick:"5px"},i={borderBottomWidth:h,borderLeftWidth:h,borderRightWidth:h,borderTopWidth:h,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:h,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.normalizeKeyframes=e}(c,f),function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(a){var c=[];for(var d in a)for(var e=a[d],f=0;f<e.length-1;f++){var g=e[f].offset,h=e[f+1].offset,i=e[f].value,j=e[f+1].value;g==h&&(1==h?i=j:j=i),c.push({startTime:g,endTime:h,easing:e[f].easing,property:d,interpolation:b.propertyInterpolation(d,i,j)})}return c.sort(function(a,b){return a.startTime-b.startTime}),c}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){null!=c&&h.filter(function(a){return 0>=c&&0==a.startTime||c>=1&&1==a.endTime||c>=a.startTime&&c<=a.endTime}).forEach(function(d){var e=c-d.startTime,f=d.endTime-d.startTime,g=0==f?0:d.easing(e/f);b.apply(a,d.property,d.interpolation(g))})}}}(c,d,f),function(a,b){function c(a,b,c){f[c]=f[c]||[],f[c].push([a,b])}function d(a,b,d){for(var e=0;e<d.length;e++){var f=d[e];c(a,b,f),/-/.test(f)&&c(a,b,f.replace(/-(.)/g,function(a,b){return b.toUpperCase()}))}}function e(b,c,d){if("initial"==c||"initial"==d){var e=b.replace(/-(.)/g,function(a,b){return b.toUpperCase()});"initial"==c&&(c=g[e]),"initial"==d&&(d=g[e])}for(var h=c==d?[]:f[b],i=0;h&&i<h.length;i++){var j=h[i][0](c),k=h[i][0](d);if(void 0!==j&&void 0!==k){var l=h[i][1](j,k);if(l){var m=a.Interpolation.apply(null,l);return function(a){return 0==a?c:1==a?d:m(a)}}}}return a.Interpolation(!1,!0,function(a){return a?d:c})}var f={};a.addPropertiesHandler=d;var g={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};a.propertyInterpolation=e}(d,f),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateTimeFraction(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d._isCurrent=function(d){var e=a.calculatePhase(c,d,b);return e===PhaseActive||e===PhaseBefore},d}b.KeyframeEffect=function(c,e,f){var g,h=d(a.normalizeTimingInput(f)),i=b.convertEffectInput(e),j=function(){i(c,g)};return j._update=function(a){return g=h(a),null!==g},j._clear=function(){i(c,null)},j._hasSameTarget=function(a){return c===a},j._isCurrent=h._isCurrent,j._totalDuration=h._totalDuration,j},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._isCurrent=function(){return!1},b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a,b){a.apply=function(b,c,d){b.style[a.propertyName(c)]=d},a.clear=function(b,c){b.style[a.propertyName(c)]=""}}(d,f),function(a){window.Element.prototype.animate=function(b,c){return a.timeline._play(a.KeyframeEffect(this,b,c))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return.5>d?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d,f),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!1,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._tickCurrentTime(a,!0),b.invalidateEffects()))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.invalidateEffects())},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var b=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&this.play(),null!=b&&(this.currentTime=b)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._currentTime=this._playbackRate>0?0:this._totalDuration,this._startTime=null,b.invalidateEffects()),this._finishedFlag=!1,b.restart(),this._idle=!1,this._ensureAlive()},pause:function(){this._isFinished||this._paused||this._idle||(this._currentTimePending=!0),this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1)},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this.currentTime=0,this._startTime=null,this._effect._update(null),b.invalidateEffects(),b.restart())},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){var b=this._isFinished;if((b||this._idle)&&!this._finishedFlag){var c=new d(this,this._currentTime,a),e=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);e.forEach(function(a){a.call(c.target,c)})}this._finishedFlag=b},_tick:function(a){return this._idle||this._paused||(null==this._startTime?this.startTime=a-this._currentTime/this.playbackRate:this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),this._currentTimePending=!1,this._fireEvents(a),!this._idle&&(this._inEffect||!this._finishedFlag)}}}(c,d,f),function(a,b,c){function d(a){var b=j;j=[],a<t.currentTime&&(a=t.currentTime),h(a),b.forEach(function(b){b[1](a)}),p&&h(a),g(),m=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){q.forEach(function(a){a()}),q.length=0}function h(a){o=!1;var c=b.timeline;c.currentTime=a,c._animations.sort(e),n=!1;var d=c._animations;c._animations=[];var f=[],g=[];d=d.filter(function(b){return b._inTimeline=b._tick(a),b._inEffect?g.push(b._effect):f.push(b._effect),b._isFinished||b._paused||b._idle||(n=!0),b._inTimeline}),q.push.apply(q,f),q.push.apply(q,g),c._animations.push.apply(c._animations,d),p=!1,n&&requestAnimationFrame(function(){})}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.invalidateEffects(),d}};var l,m=void 0,l=function(){return void 0==m&&(m=performance.now()),m},n=!1,o=!1;b.restart=function(){return n||(n=!0,requestAnimationFrame(function(){}),o=!0),o};var p=!1;b.invalidateEffects=function(){p=!0};var q=[],r=1e3/60,s=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){if(p){var a=l();a-t.currentTime>0&&(t.currentTime+=r*(Math.floor((a-t.currentTime)/r)+1)),h(t.currentTime)}return g(),s.apply(this,arguments)}});var t=new f;b.timeline=t}(c,d,f),function(a){function b(a,b){var c=a.exec(b);return c?(c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]):void 0}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);return c?[c[0],c[1].replace(/^\s*/,"")]:void 0}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,0>=c))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}return""==c?d:void 0}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;j>k;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);return e&&e[0].length?[d,e[1]]:void 0}function c(c){var d=a.consumeRepeated(b,/^,/,c);return d&&""==d[1]?d[0]:void 0}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(".000","")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){return/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a)?Number(a):void 0}function f(a,b){return[a,b,c]}function g(a,b){return 0!=a?i(0,1/0)(a,b):void 0}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,j,["z-index"]),a.parseNumber=e,a.mergeNumbers=f,a.numberToString=c}(d,f),function(a,b){function c(a,b){return"visible"==a||"visible"==b?[0,1,function(c){return 0>=c?a:c>=1?b:"visible"}]:void 0}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;3>d;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);return b&&""==b[1]?b[0]:void 0},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);return d&&4==d[0].length?d[0]:void 0}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d,f),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r],void 0===p)return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(f).join(",");return h}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"])}(d,f),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b)})}var d={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a}}(d,f)}()}({},function(){return this}());
//# sourceMappingURL=web-animations.min.js.map