webpackJsonp([0],{

/***/ 22:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 22;

/***/ }),

/***/ 24:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 24;

/***/ }),

/***/ 25:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/@angular/platform-browser.es5.js
var platform_browser_es5 = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/@angular/core/@angular/core.es5.js
var core_es5 = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(0);

// CONCATENATED MODULE: ./src/components/app/app-constants.ts
const PORTAL_DEFAULT = 1;
const PORTAL_MODAL = 2;
const PORTAL_LOADING = 3;
const PORTAL_TOAST = 4;
//# sourceMappingURL=app-constants.js.map
// CONCATENATED MODULE: ./src/util/util.ts
function clamp(min, n, max) {
    return Math.max(min, Math.min(n, max));
}
function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    return JSON.stringify(a) === JSON.stringify(b);
}
function util_debounce(fn, wait, immediate = false) {
    var timeout, args, context, timestamp, result;
    return function () {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var later = function () {
            var last = Date.now() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            }
            else {
                timeout = null;
                if (!immediate)
                    result = fn.apply(context, args);
            }
        };
        var callNow = immediate && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow)
            result = fn.apply(context, args);
        return result;
    };
}
function normalizeURL(url) {
    const ionic = window['Ionic'];
    if (ionic && ionic.normalizeURL) {
        return ionic.normalizeURL(url);
    }
    return url;
}
function defaults(dest, ..._args) {
    for (var i = arguments.length - 1; i >= 1; i--) {
        var source = arguments[i];
        if (source) {
            for (var key in source) {
                if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
    }
    return dest;
}
function isBoolean(val) { return typeof val === 'boolean'; }
function isString(val) { return typeof val === 'string'; }
function isNumber(val) { return typeof val === 'number'; }
function isFunction(val) { return typeof val === 'function'; }
function isDefined(val) { return typeof val !== 'undefined'; }
function isUndefined(val) { return typeof val === 'undefined'; }
function isPresent(val) { return val !== undefined && val !== null; }
function isBlank(val) { return val === undefined || val === null; }
function isObject(val) { return typeof val === 'object'; }
function isArray(val) { return Array.isArray(val); }
function isPrimitive(val) {
    return isString(val) || isBoolean(val) || (isNumber(val) && !isNaN(val));
}
function isTrueProperty(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    return !!val;
}
function isCheckedProperty(a, b) {
    if (a === undefined || a === null || a === '') {
        return (b === undefined || b === null || b === '');
    }
    else if (a === true || a === 'true') {
        return (b === true || b === 'true');
    }
    else if (a === false || a === 'false') {
        return (b === false || b === 'false');
    }
    else if (a === 0 || a === '0') {
        return (b === 0 || b === '0');
    }
    return (a == b);
}
function util_isRightSide(side, isRTL, defaultRight = false) {
    switch (side) {
        case 'right': return true;
        case 'left': return false;
        case 'end': return !isRTL;
        case 'start': return isRTL;
        default: return defaultRight ? !isRTL : isRTL;
    }
}
function reorderArray(array, indexes) {
    const element = array[indexes.from];
    array.splice(indexes.from, 1);
    array.splice(indexes.to, 0, element);
    return array;
}
function removeArrayItem(array, item) {
    const index = array.indexOf(item);
    return !!~index && !!array.splice(index, 1);
}
function swipeShouldReset(isResetDirection, isMovingFast, isOnResetZone) {
    let shouldClose = (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);
    return shouldClose;
}
const ASSERT_ENABLED = true;
function _runInDev(fn) {
    if (ASSERT_ENABLED === true) {
        return fn();
    }
}
function _assert(actual, reason) {
    if (!actual && ASSERT_ENABLED === true) {
        let message = 'IONIC ASSERT: ' + reason;
        console.error(message);
        debugger;
        throw new Error(message);
    }
}
function requestIonicCallback(functionToLazy) {
    if ('requestIdleCallback' in window) {
        return window.requestIdleCallback(functionToLazy);
    }
    else {
        return setTimeout(functionToLazy, 500);
    }
}


//# sourceMappingURL=util.js.map
// CONCATENATED MODULE: ./src/config/config.ts


class config_Config {
    constructor() {
        this._c = {};
        this._s = {};
        this._modes = {};
        this._trns = {};
    }
    init(config, plt) {
        this._s = config && isObject(config) && !isArray(config) ? config : {};
        this.plt = plt;
    }
    get(key, fallbackValue = null) {
        const platform = this.plt;
        if (!isDefined(this._c[key])) {
            if (!isDefined(key)) {
                throw 'config key is not defined';
            }
            var userPlatformValue = undefined;
            var userDefaultValue = this._s[key];
            var userPlatformModeValue = undefined;
            var userDefaultModeValue = undefined;
            var platformValue = undefined;
            var platformModeValue = undefined;
            var configObj = null;
            if (platform) {
                var queryStringValue = platform.getQueryParam('ionic' + key);
                if (isDefined(queryStringValue)) {
                    return this._c[key] = (queryStringValue === 'true' ? true : queryStringValue === 'false' ? false : queryStringValue);
                }
                var activePlatformKeys = platform.platforms();
                for (var i = 0, ilen = activePlatformKeys.length; i < ilen; i++) {
                    if (this._s.platforms) {
                        configObj = this._s.platforms[activePlatformKeys[i]];
                        if (configObj) {
                            if (isDefined(configObj[key])) {
                                userPlatformValue = configObj[key];
                            }
                            configObj = this.getModeConfig(configObj.mode);
                            if (configObj && isDefined(configObj[key])) {
                                userPlatformModeValue = configObj[key];
                            }
                        }
                    }
                    configObj = platform.getPlatformConfig(activePlatformKeys[i]);
                    if (configObj && configObj.settings) {
                        if (isDefined(configObj.settings[key])) {
                            platformValue = configObj.settings[key];
                        }
                        configObj = this.getModeConfig(configObj.settings.mode);
                        if (configObj && isDefined(configObj[key])) {
                            platformModeValue = configObj[key];
                        }
                    }
                }
            }
            configObj = this.getModeConfig(this._s.mode);
            if (configObj && isDefined(configObj[key])) {
                userDefaultModeValue = configObj[key];
            }
            this._c[key] = isDefined(userPlatformValue) ? userPlatformValue :
                isDefined(userDefaultValue) ? userDefaultValue :
                    isDefined(userPlatformModeValue) ? userPlatformModeValue :
                        isDefined(userDefaultModeValue) ? userDefaultModeValue :
                            isDefined(platformValue) ? platformValue :
                                isDefined(platformModeValue) ? platformModeValue :
                                    null;
        }
        var rtnVal = this._c[key];
        if (isFunction(rtnVal)) {
            rtnVal = rtnVal(platform);
        }
        return (rtnVal !== null ? rtnVal : fallbackValue);
    }
    getBoolean(key, fallbackValue = false) {
        const val = this.get(key);
        if (val === null) {
            return fallbackValue;
        }
        if (typeof val === 'string') {
            return val === 'true';
        }
        return !!val;
    }
    getNumber(key, fallbackValue = NaN) {
        const val = parseFloat(this.get(key));
        return isNaN(val) ? fallbackValue : val;
    }
    set(...args) {
        const arg0 = args[0];
        const arg1 = args[1];
        switch (args.length) {
            case 2:
                this._s[arg0] = arg1;
                delete this._c[arg0];
                break;
            case 3:
                this._s.platforms = this._s.platforms || {};
                this._s.platforms[arg0] = this._s.platforms[arg0] || {};
                this._s.platforms[arg0][arg1] = args[2];
                delete this._c[arg1];
                break;
        }
        return this;
    }
    settings(arg0, arg1) {
        switch (arguments.length) {
            case 0:
                return this._s;
            case 1:
                this._s = arg0;
                this._c = {};
                break;
            case 2:
                this._s.platforms = this._s.platforms || {};
                this._s.platforms[arg0] = arg1;
                this._c = {};
                break;
        }
        return this;
    }
    setModeConfig(modeName, modeConfig) {
        this._modes[modeName] = modeConfig;
    }
    getModeConfig(modeName) {
        return this._modes[modeName] || null;
    }
    setTransition(trnsName, trnsClass) {
        this._trns[trnsName] = trnsClass;
    }
    getTransition(trnsName) {
        return this._trns[trnsName] || null;
    }
}
function setupConfig(userConfig, plt) {
    const config = new config_Config();
    config.init(userConfig, plt);
    const win = plt.win();
    win['Ionic'] = win['Ionic'] || {};
    win['Ionic']['config'] = config;
    return config;
}
const ConfigToken = new core_es5["H" /* OpaqueToken */]('USERCONFIG');
//# sourceMappingURL=config.js.map
// CONCATENATED MODULE: ./src/navigation/nav-params.ts
class NavParams {
    constructor(data = {}) {
        this.data = data;
    }
    get(param) {
        return this.data[param];
    }
}
//# sourceMappingURL=nav-params.js.map
// CONCATENATED MODULE: ./src/navigation/view-controller.ts






class view_controller_ViewController {
    constructor(component, data, rootCssClass = DEFAULT_CSS_CLASS) {
        this.component = component;
        this._isHidden = false;
        this._state = STATE_NEW;
        this.willEnter = new core_es5["r" /* EventEmitter */]();
        this.didEnter = new core_es5["r" /* EventEmitter */]();
        this.willLeave = new core_es5["r" /* EventEmitter */]();
        this.didLeave = new core_es5["r" /* EventEmitter */]();
        this.willUnload = new core_es5["r" /* EventEmitter */]();
        this.readReady = new core_es5["r" /* EventEmitter */]();
        this.writeReady = new core_es5["r" /* EventEmitter */]();
        this.isOverlay = false;
        this._emitter = new core_es5["r" /* EventEmitter */]();
        this.data = (data instanceof NavParams ? data.data : (isPresent(data) ? data : {}));
        this._cssClass = rootCssClass;
        this._ts = Date.now();
    }
    init(componentRef) {
        _assert(componentRef, 'componentRef can not be null');
        this._ts = Date.now();
        this._cmp = componentRef;
        this.instance = this.instance || componentRef.instance;
        this._detached = false;
    }
    _setNav(navCtrl) {
        this._nav = navCtrl;
    }
    _setInstance(instance) {
        this.instance = instance;
    }
    subscribe(generatorOrNext) {
        return this._emitter.subscribe(generatorOrNext);
    }
    emit(data) {
        this._emitter.emit(data);
    }
    onDidDismiss(callback) {
        this._onDidDismiss = callback;
    }
    onWillDismiss(callback) {
        this._onWillDismiss = callback;
    }
    dismiss(data, role, navOptions = {}) {
        if (!this._nav) {
            _assert(this._state === STATE_DESTROYED, 'ViewController does not have a valid _nav');
            return Promise.resolve(false);
        }
        if (this.isOverlay && !navOptions.minClickBlockDuration) {
            navOptions.minClickBlockDuration = 400;
        }
        this._dismissData = data;
        this._dismissRole = role;
        const options = Object.assign({}, this._leavingOpts, navOptions);
        return this._nav.removeView(this, options).then(() => data);
    }
    getNav() {
        return this._nav;
    }
    getTransitionName(_direction) {
        return this._nav && this._nav.config.get('pageTransition');
    }
    getNavParams() {
        return new NavParams(this.data);
    }
    setLeavingOpts(opts) {
        this._leavingOpts = opts;
    }
    enableBack() {
        if (!this._nav) {
            return false;
        }
        const previousItem = this._nav.getPrevious(this);
        return !!(previousItem);
    }
    get name() {
        return (this.component ? this.component.name : '');
    }
    get index() {
        return (this._nav ? this._nav.indexOf(this) : -1);
    }
    isFirst() {
        return (this._nav ? this._nav.first() === this : false);
    }
    isLast() {
        return (this._nav ? this._nav.last() === this : false);
    }
    _domShow(shouldShow, renderer) {
        if (this._cmp && shouldShow === this._isHidden) {
            this._isHidden = !shouldShow;
            let value = (shouldShow ? null : '');
            renderer.setElementAttribute(this.pageRef().nativeElement, 'hidden', value);
        }
    }
    getZIndex() {
        return this._zIndex;
    }
    _setZIndex(zIndex, renderer) {
        if (zIndex !== this._zIndex) {
            this._zIndex = zIndex;
            const pageRef = this.pageRef();
            if (pageRef) {
                renderer.setElementStyle(pageRef.nativeElement, 'z-index', zIndex);
            }
        }
    }
    pageRef() {
        return this._cmp && this._cmp.location;
    }
    _setContent(directive) {
        this._cntDir = directive;
    }
    getContent() {
        return this._cntDir;
    }
    _setContentRef(elementRef) {
        this._cntRef = elementRef;
    }
    contentRef() {
        return this._cntRef;
    }
    _setIONContent(content) {
        this._setContent(content);
        this._ionCntDir = content;
    }
    getIONContent() {
        return this._ionCntDir;
    }
    _setIONContentRef(elementRef) {
        this._setContentRef(elementRef);
        this._ionCntRef = elementRef;
    }
    getIONContentRef() {
        return this._ionCntRef;
    }
    _setHeader(directive) {
        this._hdrDir = directive;
    }
    getHeader() {
        return this._hdrDir;
    }
    _setFooter(directive) {
        this._ftrDir = directive;
    }
    getFooter() {
        return this._ftrDir;
    }
    _setNavbar(directive) {
        this._nb = directive;
    }
    getNavbar() {
        return this._nb;
    }
    hasNavbar() {
        return !!this._nb;
    }
    setBackButtonText(val) {
        this._nb && this._nb.setBackButtonText(val);
    }
    showBackButton(shouldShow) {
        if (this._nb) {
            this._nb.hideBackButton = !shouldShow;
        }
    }
    _preLoad() {
        _assert(this._state === STATE_INITIALIZED, 'view state must be INITIALIZED');
        this._lifecycle('PreLoad');
    }
    _willLoad() {
        _assert(this._state === STATE_INITIALIZED, 'view state must be INITIALIZED');
        this._lifecycle('WillLoad');
    }
    _didLoad() {
        _assert(this._state === STATE_ATTACHED, 'view state must be ATTACHED');
        this._lifecycle('DidLoad');
    }
    _willEnter() {
        _assert(this._state === STATE_ATTACHED, 'view state must be ATTACHED');
        if (this._detached && this._cmp) {
            this._cmp.changeDetectorRef.reattach();
            this._detached = false;
        }
        this.willEnter.emit(null);
        this._lifecycle('WillEnter');
    }
    _didEnter() {
        _assert(this._state === STATE_ATTACHED, 'view state must be ATTACHED');
        this._nb && this._nb.didEnter();
        this.didEnter.emit(null);
        this._lifecycle('DidEnter');
    }
    _willLeave(willUnload) {
        this.willLeave.emit(null);
        this._lifecycle('WillLeave');
        if (willUnload && this._onWillDismiss) {
            this._onWillDismiss(this._dismissData, this._dismissRole);
            this._onWillDismiss = null;
        }
    }
    _didLeave() {
        this.didLeave.emit(null);
        this._lifecycle('DidLeave');
        if (!this._detached && this._cmp) {
            this._cmp.changeDetectorRef.detach();
            this._detached = true;
        }
    }
    _willUnload() {
        this.willUnload.emit(null);
        this._lifecycle('WillUnload');
        this._onDidDismiss && this._onDidDismiss(this._dismissData, this._dismissRole);
        this._onDidDismiss = null;
        this._dismissData = null;
        this._dismissRole = null;
    }
    _destroy(renderer) {
        _assert(this._state !== STATE_DESTROYED, 'view state must be ATTACHED');
        if (this._cmp) {
            if (renderer) {
                var cmpEle = this._cmp.location.nativeElement;
                renderer.setElementAttribute(cmpEle, 'class', null);
                renderer.setElementAttribute(cmpEle, 'style', null);
            }
            this._cmp.destroy();
        }
        this._nav = this._cmp = this.instance = this._cntDir = this._cntRef = this._leavingOpts = this._hdrDir = this._ftrDir = this._nb = this._onDidDismiss = this._onWillDismiss = null;
        this._state = STATE_DESTROYED;
    }
    _lifecycleTest(lifecycle) {
        const instance = this.instance;
        const methodName = 'ionViewCan' + lifecycle;
        if (instance && instance[methodName]) {
            try {
                var result = instance[methodName]();
                if (result instanceof Promise) {
                    return result;
                }
                else {
                    return Promise.resolve(result !== false);
                }
            }
            catch (e) {
                return Promise.reject(`${this.name} ${methodName} error: ${e.message}`);
            }
        }
        return Promise.resolve(true);
    }
    _lifecycle(lifecycle) {
        const instance = this.instance;
        const methodName = 'ionView' + lifecycle;
        if (instance && instance[methodName]) {
            instance[methodName]();
        }
    }
}
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (_a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && _a || Object)
], view_controller_ViewController.prototype, "_emitter", void 0);
function isViewController(viewCtrl) {
    return !!(viewCtrl && viewCtrl._didLoad && viewCtrl._willUnload);
}
const DEFAULT_CSS_CLASS = 'ion-page';
var _a;




// CONCATENATED MODULE: ./src/navigation/nav-util.ts


function getComponent(linker, nameOrPageOrView, params) {
    if (typeof nameOrPageOrView === 'function') {
        return Promise.resolve(new view_controller_ViewController(nameOrPageOrView, params));
    }
    if (typeof nameOrPageOrView === 'string') {
        return linker.getComponentFromName(nameOrPageOrView).then((component) => {
            const vc = new view_controller_ViewController(component, params);
            vc.id = nameOrPageOrView;
            return vc;
        });
    }
    return Promise.resolve(null);
}
function convertToView(linker, nameOrPageOrView, params) {
    if (nameOrPageOrView) {
        if (isViewController(nameOrPageOrView)) {
            return Promise.resolve(nameOrPageOrView);
        }
        return getComponent(linker, nameOrPageOrView, params);
    }
    return Promise.resolve(null);
}
function convertToViews(linker, pages) {
    const views = [];
    if (isArray(pages)) {
        for (var i = 0; i < pages.length; i++) {
            var page = pages[i];
            if (page) {
                if (isViewController(page)) {
                    views.push(page);
                }
                else if (page.page) {
                    views.push(convertToView(linker, page.page, page.params));
                }
                else {
                    views.push(convertToView(linker, page, null));
                }
            }
        }
    }
    return Promise.all(views);
}
let portalZindex = 9999;
function setZIndex(nav, enteringView, leavingView, direction, renderer) {
    if (enteringView) {
        if (nav._isPortal) {
            if (direction === DIRECTION_FORWARD) {
                enteringView._setZIndex(nav._zIndexOffset + portalZindex, renderer);
            }
            portalZindex++;
            return;
        }
        leavingView = leavingView || nav.getPrevious(enteringView);
        if (leavingView && isPresent(leavingView._zIndex)) {
            if (direction === DIRECTION_BACK) {
                enteringView._setZIndex(leavingView._zIndex - 1, renderer);
            }
            else {
                enteringView._setZIndex(leavingView._zIndex + 1, renderer);
            }
        }
        else {
            enteringView._setZIndex(INIT_ZINDEX + nav._zIndexOffset, renderer);
        }
    }
}
function isTabs(nav) {
    return !!nav && !!nav.getSelected;
}
function isTab(nav) {
    return !!nav && isPresent(nav._tabId);
}
function isNav(nav) {
    return !!nav && !!nav.push && nav.getType() === 'nav';
}
function linkToSegment(navId, type, secondaryId, link) {
    const segment = Object.assign({}, link);
    segment.navId = navId;
    segment.type = type;
    segment.secondaryId = secondaryId;
    return segment;
}
class DeepLinkMetadata {
}
var DeepLinkMetadataFactory;
const STATE_NEW = 1;
const STATE_INITIALIZED = 2;
const STATE_ATTACHED = 3;
const STATE_DESTROYED = 4;
const INIT_ZINDEX = 100;
const DIRECTION_BACK = 'back';
const DIRECTION_FORWARD = 'forward';
const DIRECTION_SWITCH = 'switch';
const NAV = 'nav';
const TABS = 'tabs';
//# sourceMappingURL=nav-util.js.map
// CONCATENATED MODULE: ./src/components/app/menu-controller.ts

class menu_controller_MenuController {
    constructor() {
        this._menus = [];
    }
    open(menuId) {
        const menu = this.get(menuId);
        if (menu && !this.isAnimating()) {
            let openedMenu = this.getOpen();
            if (openedMenu && menu !== openedMenu) {
                openedMenu.setOpen(false, false);
            }
            return menu.open();
        }
        return Promise.resolve(false);
    }
    close(menuId) {
        let menu;
        if (menuId) {
            menu = this.get(menuId);
        }
        else {
            menu = this.getOpen();
        }
        if (menu) {
            return menu.close();
        }
        return Promise.resolve(false);
    }
    toggle(menuId) {
        const menu = this.get(menuId);
        if (menu && !this.isAnimating()) {
            var openedMenu = this.getOpen();
            if (openedMenu && menu !== openedMenu) {
                openedMenu.setOpen(false, false);
            }
            return menu.toggle();
        }
        return Promise.resolve(false);
    }
    enable(shouldEnable, menuId) {
        const menu = this.get(menuId);
        if (menu) {
            return menu.enable(shouldEnable);
        }
    }
    swipeEnable(shouldEnable, menuId) {
        const menu = this.get(menuId);
        if (menu) {
            return menu.swipeEnable(shouldEnable);
        }
    }
    isOpen(menuId) {
        if (menuId) {
            var menu = this.get(menuId);
            return menu && menu.isOpen || false;
        }
        else {
            return !!this.getOpen();
        }
    }
    isEnabled(menuId) {
        const menu = this.get(menuId);
        return menu && menu.enabled || false;
    }
    get(menuId) {
        var menu;
        if (menuId === 'left' || menuId === 'right') {
            menu = this._menus.find(m => m.side === menuId && m.enabled);
            if (menu) {
                return menu;
            }
            return this._menus.find(m => m.side === menuId) || null;
        }
        else if (menuId) {
            return this._menus.find(m => m.id === menuId) || null;
        }
        menu = this._menus.find(m => m.enabled);
        if (menu) {
            return menu;
        }
        return (this._menus.length ? this._menus[0] : null);
    }
    getOpen() {
        return this._menus.find(m => m.isOpen);
    }
    getMenus() {
        return this._menus;
    }
    isAnimating() {
        return this._menus.some(menu => menu.isAnimating());
    }
    _register(menu) {
        _assert(this._menus.indexOf(menu) < 0, 'menu was already registered');
        this._menus.push(menu);
    }
    _unregister(menu) {
        _assert(this._menus.indexOf(menu) >= 0, 'menu is not registered');
        removeArrayItem(this._menus, menu);
    }
    _setActiveMenu(menu) {
        _assert(menu.enabled, 'menu must be enabled');
        _assert(this._menus.indexOf(menu) >= 0, 'menu is not registered');
        const side = menu.side;
        this._menus
            .filter(m => m.side === side && m !== menu)
            .map(m => m.enable(false));
    }
    static registerType(name, cls) {
        menuTypes[name] = cls;
    }
    static create(type, menuCmp, plt) {
        return new menuTypes[type](menuCmp, plt);
    }
}
let menuTypes = {};
//# sourceMappingURL=menu-controller.js.map
// CONCATENATED MODULE: ./src/util/dom.ts
function getCss(docEle) {
    const css = {};
    var i;
    var keys = ['webkitTransform', '-webkit-transform', 'webkit-transform', 'transform'];
    for (i = 0; i < keys.length; i++) {
        if (docEle.style[keys[i]] !== undefined) {
            css.transform = keys[i];
            break;
        }
    }
    keys = ['webkitTransition', 'transition'];
    for (i = 0; i < keys.length; i++) {
        if (docEle.style[keys[i]] !== undefined) {
            css.transition = keys[i];
            break;
        }
    }
    var isWebkit = css.transition.indexOf('webkit') > -1;
    css.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
    css.transitionTimingFn = (isWebkit ? '-webkit-' : '') + 'transition-timing-function';
    css.transitionDelay = (isWebkit ? '-webkit-' : '') + 'transition-delay';
    css.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
    css.transformOrigin = (isWebkit ? '-webkit-' : '') + 'transform-origin';
    css.animationDelay = (isWebkit ? 'webkitAnimationDelay' : 'animationDelay');
    return css;
}
function pointerCoord(ev) {
    if (ev) {
        var changedTouches = ev.changedTouches;
        if (changedTouches && changedTouches.length > 0) {
            var touch = changedTouches[0];
            return { x: touch.clientX, y: touch.clientY };
        }
        var pageX = ev.pageX;
        if (pageX !== undefined) {
            return { x: pageX, y: ev.pageY };
        }
    }
    return { x: 0, y: 0 };
}
function hasPointerMoved(threshold, startCoord, endCoord) {
    if (startCoord && endCoord) {
        const deltaX = (startCoord.x - endCoord.x);
        const deltaY = (startCoord.y - endCoord.y);
        const distance = deltaX * deltaX + deltaY * deltaY;
        return distance > (threshold * threshold);
    }
    return false;
}
function isTextInput(ele) {
    return !!ele &&
        (ele.tagName === 'TEXTAREA' ||
            ele.contentEditable === 'true' ||
            (ele.tagName === 'INPUT' && !(NON_TEXT_INPUT_REGEX.test(ele.type))));
}
const NON_TEXT_INPUT_REGEX = /^(radio|checkbox|range|file|submit|reset|color|image|button)$/i;
const SKIP_INPUT_ATTR = ['value', 'checked', 'disabled', 'readonly', 'placeholder', 'type', 'class', 'style', 'id', 'autofocus', 'autocomplete', 'autocorrect'];
function copyInputAttributes(srcElement, destElement) {
    const attrs = srcElement.attributes;
    for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (SKIP_INPUT_ATTR.indexOf(attr.name) === -1) {
            destElement.setAttribute(attr.name, attr.value);
        }
    }
}
//# sourceMappingURL=dom.js.map
// CONCATENATED MODULE: ./src/platform/query-params.ts
class QueryParams {
    constructor() {
        this.data = {};
    }
    parseUrl(url) {
        if (url) {
            var startIndex = url.indexOf('?');
            if (startIndex > -1) {
                var queries = url.slice(startIndex + 1).split('&');
                for (var i = 0; i < queries.length; i++) {
                    if (queries[i].indexOf('=') > 0) {
                        var split = queries[i].split('=');
                        if (split.length > 1) {
                            this.data[split[0].toLowerCase()] = split[1].split('#')[0];
                        }
                    }
                }
            }
        }
    }
    get(key) {
        return this.data[key.toLowerCase()];
    }
}
//# sourceMappingURL=query-params.js.map
// CONCATENATED MODULE: ./src/platform/platform.ts




class platform_Platform {
    constructor() {
        this._versions = {};
        this._qp = new QueryParams();
        this._bbActions = [];
        this._pW = 0;
        this._pH = 0;
        this._lW = 0;
        this._lH = 0;
        this._isPortrait = null;
        this._uiEvtOpts = false;
        this._platforms = [];
        this.backButton = new core_es5["r" /* EventEmitter */]();
        this.pause = new core_es5["r" /* EventEmitter */]();
        this.resume = new core_es5["r" /* EventEmitter */]();
        this.resize = new core_es5["r" /* EventEmitter */]();
        this._readyPromise = new Promise(res => { this._readyResolve = res; });
        this.backButton.subscribe(() => {
            console.debug('hardware back button');
            this.runBackButtonAction();
        });
    }
    setWindow(win) {
        this._win = win;
    }
    win() {
        return this._win;
    }
    setDocument(doc) {
        this._doc = doc;
    }
    doc() {
        return this._doc;
    }
    setZone(zone) {
        this.zone = zone;
    }
    setCssProps(docElement) {
        this.Css = getCss(docElement);
    }
    is(platformName) {
        return (this._platforms.indexOf(platformName) > -1);
    }
    platforms() {
        return this._platforms;
    }
    versions() {
        return this._versions;
    }
    version() {
        for (var platformName in this._versions) {
            if (this._versions[platformName]) {
                return this._versions[platformName];
            }
        }
        return {};
    }
    ready() {
        return this._readyPromise;
    }
    triggerReady(readySource) {
        this.zone.run(() => {
            this._readyResolve(readySource);
        });
    }
    prepareReady() {
        const self = this;
        if (self._doc.readyState === 'complete' || self._doc.readyState === 'interactive') {
            self.triggerReady('dom');
        }
        else {
            self._doc.addEventListener('DOMContentLoaded', completed, false);
            self._win.addEventListener('load', completed, false);
        }
        function completed() {
            self._doc.removeEventListener('DOMContentLoaded', completed, false);
            self._win.removeEventListener('load', completed, false);
            self.triggerReady('dom');
        }
    }
    setDir(dir, updateDocument) {
        this._dir = dir;
        this.isRTL = (dir === 'rtl');
        if (updateDocument !== false) {
            this._doc['documentElement'].setAttribute('dir', dir);
        }
    }
    dir() {
        return this._dir;
    }
    setLang(language, updateDocument) {
        this._lang = language;
        if (updateDocument !== false) {
            this._doc['documentElement'].setAttribute('lang', language);
        }
    }
    lang() {
        return this._lang;
    }
    exitApp() { }
    registerBackButtonAction(fn, priority = 0) {
        const action = { fn, priority };
        this._bbActions.push(action);
        return () => {
            removeArrayItem(this._bbActions, action);
        };
    }
    runBackButtonAction() {
        let winner = null;
        this._bbActions.forEach((action) => {
            if (!winner || action.priority >= winner.priority) {
                winner = action;
            }
        });
        winner && winner.fn && winner.fn();
    }
    setUserAgent(userAgent) {
        this._ua = userAgent;
    }
    setQueryParams(url) {
        this._qp.parseUrl(url);
    }
    getQueryParam(key) {
        return this._qp.get(key);
    }
    url() {
        return this._win['location']['href'];
    }
    userAgent() {
        return this._ua || '';
    }
    setNavigatorPlatform(navigatorPlt) {
        this._nPlt = navigatorPlt;
    }
    navigatorPlatform() {
        return this._nPlt || '';
    }
    width() {
        this._calcDim();
        return this._isPortrait ? this._pW : this._lW;
    }
    height() {
        this._calcDim();
        return this._isPortrait ? this._pH : this._lH;
    }
    getElementComputedStyle(ele, pseudoEle) {
        return this._win['getComputedStyle'](ele, pseudoEle);
    }
    getElementFromPoint(x, y) {
        return this._doc['elementFromPoint'](x, y);
    }
    getElementBoundingClientRect(ele) {
        return ele['getBoundingClientRect']();
    }
    isPortrait() {
        this._calcDim();
        return this._isPortrait;
    }
    isLandscape() {
        return !this.isPortrait();
    }
    _calcDim() {
        if (this._isPortrait === null || this._isPortrait === false && this._win['innerWidth'] < this._win['innerHeight']) {
            var win = this._win;
            var innerWidth = win['innerWidth'];
            var innerHeight = win['innerHeight'];
            if (win.screen.width > 0 && win.screen.height > 0) {
                if (innerWidth < innerHeight) {
                    if (this._pW <= innerWidth) {
                        console.debug('setting _isPortrait to true');
                        this._isPortrait = true;
                        this._pW = innerWidth;
                    }
                    if (this._pH <= innerHeight) {
                        console.debug('setting _isPortrait to true');
                        this._isPortrait = true;
                        this._pH = innerHeight;
                    }
                }
                else {
                    if (this._lW !== innerWidth) {
                        console.debug('setting _isPortrait to false');
                        this._isPortrait = false;
                        this._lW = innerWidth;
                    }
                    if (this._lH !== innerHeight) {
                        console.debug('setting _isPortrait to false');
                        this._isPortrait = false;
                        this._lH = innerHeight;
                    }
                }
            }
        }
    }
    raf(callback) {
        const win = this._win;
        return win['__zone_symbol__requestAnimationFrame'](callback);
    }
    cancelRaf(rafId) {
        const win = this._win;
        return win['__zone_symbol__cancelAnimationFrame'](rafId);
    }
    timeout(callback, timeout) {
        const win = this._win;
        return win['__zone_symbol__setTimeout'](callback, timeout);
    }
    cancelTimeout(timeoutId) {
        const win = this._win;
        win['__zone_symbol__clearTimeout'](timeoutId);
    }
    registerListener(ele, eventName, callback, opts, unregisterListenersCollection) {
        const listenerOpts = this._uiEvtOpts ? {
            'capture': !!opts.capture,
            'passive': !!opts.passive,
        } : !!opts.capture;
        let unReg;
        if (!opts.zone && ele['__zone_symbol__addEventListener']) {
            ele['__zone_symbol__addEventListener'](eventName, callback, listenerOpts);
            unReg = function unregisterListener() {
                ele['__zone_symbol__removeEventListener'](eventName, callback, listenerOpts);
            };
        }
        else {
            ele['addEventListener'](eventName, callback, listenerOpts);
            unReg = function unregisterListener() {
                ele['removeEventListener'](eventName, callback, listenerOpts);
            };
        }
        if (unregisterListenersCollection) {
            unregisterListenersCollection.push(unReg);
        }
        return unReg;
    }
    transitionEnd(el, callback, zone = true) {
        const unRegs = [];
        function unregister() {
            unRegs.forEach(unReg => {
                unReg();
            });
        }
        function onTransitionEnd(ev) {
            if (el === ev.target) {
                unregister();
                callback(ev);
            }
        }
        if (el) {
            this.registerListener(el, 'webkitTransitionEnd', onTransitionEnd, { zone: zone }, unRegs);
            this.registerListener(el, 'transitionend', onTransitionEnd, { zone: zone }, unRegs);
        }
        return unregister;
    }
    windowLoad(callback) {
        const win = this._win;
        const doc = this._doc;
        let unreg;
        if (doc.readyState === 'complete') {
            callback(win, doc);
        }
        else {
            unreg = this.registerListener(win, 'load', () => {
                unreg && unreg();
                callback(win, doc);
            }, { zone: false });
        }
    }
    isActiveElement(ele) {
        return !!(ele && (this.getActiveElement() === ele));
    }
    getActiveElement() {
        return this._doc['activeElement'];
    }
    hasFocus(ele) {
        return !!((ele && (this.getActiveElement() === ele)) && (ele.parentElement.querySelector(':focus') === ele));
    }
    hasFocusedTextInput() {
        const ele = this.getActiveElement();
        if (isTextInput(ele)) {
            return (ele.parentElement.querySelector(':focus') === ele);
        }
        return false;
    }
    focusOutActiveElement() {
        const activeElement = this.getActiveElement();
        activeElement && activeElement.blur && activeElement.blur();
    }
    _initEvents() {
        try {
            var opts = Object.defineProperty({}, 'passive', {
                get: () => {
                    this._uiEvtOpts = true;
                }
            });
            this._win.addEventListener('optsTest', null, opts);
        }
        catch (e) { }
        this.timeout(() => {
            var timerId;
            this.registerListener(this._win, 'resize', () => {
                clearTimeout(timerId);
                timerId = setTimeout(() => {
                    if (this.hasFocusedTextInput() === false) {
                        this._isPortrait = null;
                    }
                    this.zone.run(() => this.resize.emit());
                }, 200);
            }, { passive: true, zone: false });
        }, 2000);
    }
    setPlatformConfigs(platformConfigs) {
        this._registry = platformConfigs || {};
    }
    getPlatformConfig(platformName) {
        return this._registry[platformName] || {};
    }
    registry() {
        return this._registry;
    }
    setDefault(platformName) {
        this._default = platformName;
    }
    testQuery(queryValue, queryTestValue) {
        const valueSplit = queryValue.toLowerCase().split(';');
        return valueSplit.indexOf(queryTestValue) > -1;
    }
    testNavigatorPlatform(navigatorPlatformExpression) {
        const rgx = new RegExp(navigatorPlatformExpression, 'i');
        return rgx.test(this._nPlt);
    }
    matchUserAgentVersion(userAgentExpression) {
        if (this._ua && userAgentExpression) {
            const val = this._ua.match(userAgentExpression);
            if (val) {
                return {
                    major: val[1],
                    minor: val[2]
                };
            }
        }
    }
    testUserAgent(expression) {
        if (this._ua) {
            return this._ua.indexOf(expression) >= 0;
        }
        return false;
    }
    isPlatformMatch(queryStringName, userAgentAtLeastHas, userAgentMustNotHave = []) {
        const queryValue = this._qp.get('ionicplatform');
        if (queryValue) {
            return this.testQuery(queryValue, queryStringName);
        }
        userAgentAtLeastHas = userAgentAtLeastHas || [queryStringName];
        const userAgent = this._ua.toLowerCase();
        for (var i = 0; i < userAgentAtLeastHas.length; i++) {
            if (userAgent.indexOf(userAgentAtLeastHas[i]) > -1) {
                for (var j = 0; j < userAgentMustNotHave.length; j++) {
                    if (userAgent.indexOf(userAgentMustNotHave[j]) > -1) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
    init() {
        this._initEvents();
        let rootPlatformNode;
        let enginePlatformNode;
        let tmpPlt;
        for (let platformName in this._registry) {
            tmpPlt = this.matchPlatform(platformName);
            if (tmpPlt) {
                if (tmpPlt.isEngine) {
                    enginePlatformNode = tmpPlt;
                }
                else if (!rootPlatformNode || tmpPlt.depth > rootPlatformNode.depth) {
                    rootPlatformNode = tmpPlt;
                }
            }
        }
        if (!rootPlatformNode) {
            rootPlatformNode = new PlatformNode(this._registry, this._default);
        }
        if (rootPlatformNode) {
            if (enginePlatformNode) {
                enginePlatformNode.child = rootPlatformNode;
                rootPlatformNode.parent = enginePlatformNode;
                rootPlatformNode = enginePlatformNode;
            }
            let platformNode = rootPlatformNode;
            while (platformNode) {
                insertSuperset(this._registry, platformNode);
                platformNode = platformNode.child;
            }
            platformNode = rootPlatformNode.parent;
            while (platformNode) {
                rootPlatformNode = platformNode;
                platformNode = platformNode.parent;
            }
            platformNode = rootPlatformNode;
            while (platformNode) {
                platformNode.initialize(this);
                if (platformNode.name === 'iphone' && this.navigatorPlatform() === 'iPad') {
                    this._platforms.push('tablet');
                    this._platforms.push('ipad');
                    return;
                }
                this._platforms.push(platformNode.name);
                this._versions[platformNode.name] = platformNode.version(this);
                platformNode = platformNode.child;
            }
        }
        if (this._platforms.indexOf('mobile') > -1 && this._platforms.indexOf('cordova') === -1) {
            this._platforms.push('mobileweb');
        }
    }
    matchPlatform(platformName) {
        let platformNode = new PlatformNode(this._registry, platformName);
        let rootNode = platformNode.getRoot(this);
        if (rootNode) {
            rootNode.depth = 0;
            let childPlatform = rootNode.child;
            while (childPlatform) {
                rootNode.depth++;
                childPlatform = childPlatform.child;
            }
        }
        return rootNode;
    }
}
function insertSuperset(registry, platformNode) {
    let supersetPlaformName = platformNode.superset();
    if (supersetPlaformName) {
        let supersetPlatform = new PlatformNode(registry, supersetPlaformName);
        supersetPlatform.parent = platformNode.parent;
        supersetPlatform.child = platformNode;
        if (supersetPlatform.parent) {
            supersetPlatform.parent.child = supersetPlatform;
        }
        platformNode.parent = supersetPlatform;
    }
}
class PlatformNode {
    constructor(registry, platformName) {
        this.registry = registry;
        this.c = registry[platformName];
        this.name = platformName;
        this.isEngine = this.c.isEngine;
    }
    settings() {
        return this.c.settings || {};
    }
    superset() {
        return this.c.superset;
    }
    isMatch(p) {
        return this.c.isMatch && this.c.isMatch(p) || false;
    }
    initialize(plt) {
        this.c.initialize && this.c.initialize(plt);
    }
    version(plt) {
        if (this.c.versionParser) {
            const v = this.c.versionParser(plt);
            if (v) {
                const str = v.major + '.' + v.minor;
                return {
                    str: str,
                    num: parseFloat(str),
                    major: parseInt(v.major, 10),
                    minor: parseInt(v.minor, 10)
                };
            }
        }
    }
    getRoot(plt) {
        if (this.isMatch(plt)) {
            let parents = this.getSubsetParents(this.name);
            if (!parents.length) {
                return this;
            }
            let platformNode = null;
            let rootPlatformNode = null;
            for (let i = 0; i < parents.length; i++) {
                platformNode = new PlatformNode(this.registry, parents[i]);
                platformNode.child = this;
                rootPlatformNode = platformNode.getRoot(plt);
                if (rootPlatformNode) {
                    this.parent = platformNode;
                    return rootPlatformNode;
                }
            }
        }
        return null;
    }
    getSubsetParents(subsetPlatformName) {
        const parentPlatformNames = [];
        let pltConfig = null;
        for (let platformName in this.registry) {
            pltConfig = this.registry[platformName];
            if (pltConfig.subsets && pltConfig.subsets.indexOf(subsetPlatformName) > -1) {
                parentPlatformNames.push(platformName);
            }
        }
        return parentPlatformNames;
    }
}
function setupPlatform(doc, platformConfigs, zone) {
    const plt = new platform_Platform();
    plt.setDefault('core');
    plt.setPlatformConfigs(platformConfigs);
    plt.setZone(zone);
    const docElement = doc.documentElement;
    plt.setDocument(doc);
    const dir = docElement.dir;
    plt.setDir(dir === 'rtl' ? 'rtl' : 'ltr', !dir);
    plt.setLang(docElement.lang, false);
    plt.setCssProps(docElement);
    const win = doc.defaultView;
    plt.setWindow(win);
    plt.setNavigatorPlatform(win.navigator.platform);
    plt.setUserAgent(win.navigator.userAgent);
    plt.setQueryParams(win.location.href);
    plt.init();
    win['Ionic'] = win['Ionic'] || {};
    win['Ionic']['platform'] = plt;
    return plt;
}
//# sourceMappingURL=platform.js.map
// CONCATENATED MODULE: ./src/animations/animation.ts

class animation_Animation {
    constructor(plt, ele, opts) {
        this._dur = null;
        this._es = null;
        this._rvEs = null;
        this.hasChildren = false;
        this.isPlaying = false;
        this.hasCompleted = false;
        this.plt = plt;
        this.element(ele);
        this.opts = opts;
    }
    element(ele) {
        if (ele) {
            if (typeof ele === 'string') {
                ele = this.plt.doc().querySelectorAll(ele);
                for (let i = 0; i < ele.length; i++) {
                    this._addEle(ele[i]);
                }
            }
            else if (ele.length) {
                for (let i = 0; i < ele.length; i++) {
                    this._addEle(ele[i]);
                }
            }
            else {
                this._addEle(ele);
            }
        }
        return this;
    }
    _addEle(ele) {
        if (ele.nativeElement) {
            ele = ele.nativeElement;
        }
        if (ele.nodeType === 1) {
            this._eL = (this._e = this._e || []).push(ele);
        }
    }
    add(childAnimation) {
        childAnimation.parent = this;
        this.hasChildren = true;
        this._cL = (this._c = this._c || []).push(childAnimation);
        return this;
    }
    getDuration(opts) {
        if (opts && isDefined(opts.duration)) {
            return opts.duration;
        }
        else if (this._dur !== null) {
            return this._dur;
        }
        else if (this.parent) {
            return this.parent.getDuration();
        }
        return 0;
    }
    isRoot() {
        return !this.parent;
    }
    duration(milliseconds) {
        this._dur = milliseconds;
        return this;
    }
    getEasing() {
        if (this._rv && this._rvEs) {
            return this._rvEs;
        }
        return this._es !== null ? this._es : (this.parent && this.parent.getEasing()) || null;
    }
    easing(name) {
        this._es = name;
        return this;
    }
    easingReverse(name) {
        this._rvEs = name;
        return this;
    }
    from(prop, val) {
        this._addProp('from', prop, val);
        return this;
    }
    to(prop, val, clearProperyAfterTransition) {
        const fx = this._addProp('to', prop, val);
        if (clearProperyAfterTransition) {
            this.afterClearStyles([fx.trans ? this.plt.Css.transform : prop]);
        }
        return this;
    }
    fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {
        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);
    }
    _getProp(name) {
        if (this._fx) {
            return this._fx.find((prop) => prop.name === name);
        }
        else {
            this._fx = [];
        }
        return null;
    }
    _addProp(state, prop, val) {
        let fxProp = this._getProp(prop);
        if (!fxProp) {
            const shouldTrans = (ANIMATION_TRANSFORMS[prop] === 1);
            fxProp = {
                name: prop,
                trans: shouldTrans,
                wc: (shouldTrans ? this.plt.Css.transform : prop)
            };
            this._fx.push(fxProp);
        }
        let fxState = {
            val: val,
            num: null,
            unit: '',
        };
        fxProp[state] = fxState;
        if (typeof val === 'string' && val.indexOf(' ') < 0) {
            let r = val.match(ANIMATION_CSS_VALUE_REGEX);
            let num = parseFloat(r[1]);
            if (!isNaN(num)) {
                fxState.num = num;
            }
            fxState.unit = (r[0] !== r[2] ? r[2] : '');
        }
        else if (typeof val === 'number') {
            fxState.num = val;
        }
        return fxProp;
    }
    beforeAddClass(className) {
        (this._bfAdd = this._bfAdd || []).push(className);
        return this;
    }
    beforeRemoveClass(className) {
        (this._bfRm = this._bfRm || []).push(className);
        return this;
    }
    beforeStyles(styles) {
        this._bfSty = styles;
        return this;
    }
    beforeClearStyles(propertyNames) {
        this._bfSty = this._bfSty || {};
        for (let i = 0; i < propertyNames.length; i++) {
            this._bfSty[propertyNames[i]] = '';
        }
        return this;
    }
    beforeAddRead(domReadFn) {
        (this._rdFn = this._rdFn || []).push(domReadFn);
        return this;
    }
    beforeAddWrite(domWriteFn) {
        (this._wrFn = this._wrFn || []).push(domWriteFn);
        return this;
    }
    afterAddClass(className) {
        (this._afAdd = this._afAdd || []).push(className);
        return this;
    }
    afterRemoveClass(className) {
        (this._afRm = this._afRm || []).push(className);
        return this;
    }
    afterStyles(styles) {
        this._afSty = styles;
        return this;
    }
    afterClearStyles(propertyNames) {
        this._afSty = this._afSty || {};
        for (let i = 0; i < propertyNames.length; i++) {
            this._afSty[propertyNames[i]] = '';
        }
        return this;
    }
    play(opts) {
        if (!this.plt) {
            return;
        }
        this._isAsync = this._hasDuration(opts);
        this._clearAsync();
        this._playInit(opts);
        this.plt.raf(() => {
            this.plt.raf(this._playDomInspect.bind(this, opts));
        });
    }
    syncPlay() {
        if (!this.plt) {
            return;
        }
        const opts = { duration: 0 };
        this._isAsync = false;
        this._clearAsync();
        this._playInit(opts);
        this._playDomInspect(opts);
    }
    _playInit(opts) {
        this._twn = false;
        this.isPlaying = true;
        this.hasCompleted = false;
        this._hasDur = (this.getDuration(opts) > ANIMATION_DURATION_MIN);
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._playInit(opts);
        }
        if (this._hasDur) {
            this._progress(0);
            this._willChg(true);
        }
    }
    _playDomInspect(opts) {
        this._beforeAnimation();
        const dur = this.getDuration(opts);
        if (this._isAsync) {
            this._asyncEnd(dur, true);
        }
        this._playProgress(opts);
        if (this._isAsync && this.plt) {
            this.plt.raf(this._playToStep.bind(this, 1));
        }
    }
    _playProgress(opts) {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._playProgress(opts);
        }
        if (this._hasDur) {
            this._setTrans(this.getDuration(opts), false);
        }
        else {
            this._progress(1);
            this._setAfterStyles();
            this._didFinish(true);
        }
    }
    _playToStep(stepValue) {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._playToStep(stepValue);
        }
        if (this._hasDur) {
            this._progress(stepValue);
        }
    }
    _asyncEnd(dur, shouldComplete) {
        _assert(!this._unrgTrns, '_unrgTrns must be null');
        _assert(!this._tm, '_tm must be null');
        _assert(dur > 0, 'duration can not be 0 in async animations');
        const self = this;
        function onTransitionEnd() {
            self._clearAsync();
            self._playEnd();
            self._didFinishAll(shouldComplete, true, false);
        }
        function onTransitionFallback() {
            console.debug('Animation onTransitionFallback, CSS onTransitionEnd did not fire!');
            self._tm = undefined;
            self._clearAsync();
            self._playEnd(shouldComplete ? 1 : 0);
            self._didFinishAll(shouldComplete, true, false);
        }
        self._unrgTrns = this.plt.transitionEnd(self._transEl(), onTransitionEnd, false);
        self._tm = self.plt.timeout(onTransitionFallback, (dur + ANIMATION_TRANSITION_END_FALLBACK_PADDING_MS));
    }
    _playEnd(stepValue) {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._playEnd(stepValue);
        }
        if (this._hasDur) {
            if (isDefined(stepValue)) {
                this._setTrans(0, true);
                this._progress(stepValue);
            }
            this._setAfterStyles();
            this._willChg(false);
        }
    }
    _hasDuration(opts) {
        if (this.getDuration(opts) > ANIMATION_DURATION_MIN) {
            return true;
        }
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            if (children[i]._hasDuration(opts)) {
                return true;
            }
        }
        return false;
    }
    _hasDomReads() {
        if (this._rdFn && this._rdFn.length) {
            return true;
        }
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            if (children[i]._hasDomReads()) {
                return true;
            }
        }
        return false;
    }
    stop(stepValue = 1) {
        this._clearAsync();
        this._hasDur = true;
        this._playEnd(stepValue);
    }
    _clearAsync() {
        this._unrgTrns && this._unrgTrns();
        this._tm && clearTimeout(this._tm);
        this._tm = this._unrgTrns = undefined;
    }
    _progress(stepValue) {
        let val;
        let effects = this._fx;
        let nuElements = this._eL;
        if (!effects || !nuElements) {
            return;
        }
        if (this._rv) {
            stepValue = ((stepValue * -1) + 1);
        }
        let i, j;
        let finalTransform = '';
        const elements = this._e;
        for (i = 0; i < effects.length; i++) {
            const fx = effects[i];
            if (fx.from && fx.to) {
                const fromNum = fx.from.num;
                const toNum = fx.to.num;
                const tweenEffect = (fromNum !== toNum);
                _assert(tweenEffect || !this._isAsync, 'in async animations to != from value');
                if (tweenEffect) {
                    this._twn = true;
                }
                if (stepValue === 0) {
                    val = fx.from.val;
                }
                else if (stepValue === 1) {
                    val = fx.to.val;
                }
                else if (tweenEffect) {
                    let valNum = (((toNum - fromNum) * stepValue) + fromNum);
                    const unit = fx.to.unit;
                    if (unit === 'px') {
                        valNum = Math.round(valNum);
                    }
                    val = valNum + unit;
                }
                if (val !== null) {
                    const prop = fx.name;
                    if (fx.trans) {
                        finalTransform += prop + '(' + val + ') ';
                    }
                    else {
                        for (j = 0; j < nuElements; j++) {
                            elements[j].style[prop] = val;
                        }
                    }
                }
            }
        }
        if (finalTransform.length) {
            if (!this._rv && stepValue !== 1 || this._rv && stepValue !== 0) {
                finalTransform += 'translateZ(0px)';
            }
            const cssTransform = this.plt.Css.transform;
            for (i = 0; i < elements.length; i++) {
                elements[i].style[cssTransform] = finalTransform;
            }
        }
    }
    _setTrans(dur, forcedLinearEasing) {
        if (!this._fx) {
            return;
        }
        const elements = this._e;
        const easing = (forcedLinearEasing ? 'linear' : this.getEasing());
        const durString = dur + 'ms';
        const Css = this.plt.Css;
        const cssTransform = Css.transition;
        const cssTransitionDuration = Css.transitionDuration;
        const cssTransitionTimingFn = Css.transitionTimingFn;
        let eleStyle;
        for (let i = 0; i < this._eL; i++) {
            eleStyle = elements[i].style;
            if (dur > 0) {
                eleStyle[cssTransform] = '';
                eleStyle[cssTransitionDuration] = durString;
                if (easing) {
                    eleStyle[cssTransitionTimingFn] = easing;
                }
            }
            else {
                eleStyle[cssTransform] = 'none';
            }
        }
    }
    _beforeAnimation() {
        this._fireBeforeReadFunc();
        this._fireBeforeWriteFunc();
        this._setBeforeStyles();
    }
    _setBeforeStyles() {
        let i, j;
        const children = this._c;
        for (i = 0; i < this._cL; i++) {
            children[i]._setBeforeStyles();
        }
        if (this._rv) {
            return;
        }
        const addClasses = this._bfAdd;
        const removeClasses = this._bfRm;
        let ele;
        let eleClassList;
        let prop;
        for (i = 0; i < this._eL; i++) {
            ele = this._e[i];
            eleClassList = ele.classList;
            if (addClasses) {
                for (j = 0; j < addClasses.length; j++) {
                    eleClassList.add(addClasses[j]);
                }
            }
            if (removeClasses) {
                for (j = 0; j < removeClasses.length; j++) {
                    eleClassList.remove(removeClasses[j]);
                }
            }
            if (this._bfSty) {
                for (prop in this._bfSty) {
                    ele.style[prop] = this._bfSty[prop];
                }
            }
        }
    }
    _fireBeforeReadFunc() {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._fireBeforeReadFunc();
        }
        const readFunctions = this._rdFn;
        if (readFunctions) {
            for (let i = 0; i < readFunctions.length; i++) {
                readFunctions[i]();
            }
        }
    }
    _fireBeforeWriteFunc() {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._fireBeforeWriteFunc();
        }
        const writeFunctions = this._wrFn;
        if (this._wrFn) {
            for (let i = 0; i < writeFunctions.length; i++) {
                writeFunctions[i]();
            }
        }
    }
    _setAfterStyles() {
        let i, j;
        let ele;
        let eleClassList;
        let elements = this._e;
        for (i = 0; i < this._eL; i++) {
            ele = elements[i];
            eleClassList = ele.classList;
            ele.style[this.plt.Css.transitionDuration] = ele.style[this.plt.Css.transitionTimingFn] = '';
            if (this._rv) {
                if (this._bfAdd) {
                    for (j = 0; j < this._bfAdd.length; j++) {
                        eleClassList.remove(this._bfAdd[j]);
                    }
                }
                if (this._bfRm) {
                    for (j = 0; j < this._bfRm.length; j++) {
                        eleClassList.add(this._bfRm[j]);
                    }
                }
                if (this._bfSty) {
                    for (const prop in this._bfSty) {
                        ele.style[prop] = '';
                    }
                }
            }
            else {
                if (this._afAdd) {
                    for (j = 0; j < this._afAdd.length; j++) {
                        eleClassList.add(this._afAdd[j]);
                    }
                }
                if (this._afRm) {
                    for (j = 0; j < this._afRm.length; j++) {
                        eleClassList.remove(this._afRm[j]);
                    }
                }
                if (this._afSty) {
                    for (const prop in this._afSty) {
                        ele.style[prop] = this._afSty[prop];
                    }
                }
            }
        }
    }
    _willChg(addWillChange) {
        let wc;
        let effects = this._fx;
        let willChange;
        if (addWillChange && effects) {
            wc = [];
            for (let i = 0; i < effects.length; i++) {
                const propWC = effects[i].wc;
                if (propWC === 'webkitTransform') {
                    wc.push('transform', '-webkit-transform');
                }
                else {
                    wc.push(propWC);
                }
            }
            willChange = wc.join(',');
        }
        else {
            willChange = '';
        }
        for (let i = 0; i < this._eL; i++) {
            this._e[i].style.willChange = willChange;
        }
    }
    progressStart() {
        this._clearAsync();
        this._beforeAnimation();
        this._progressStart();
    }
    _progressStart() {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._progressStart();
        }
        this._setTrans(0, true);
        this._willChg(true);
    }
    progressStep(stepValue) {
        stepValue = Math.min(1, Math.max(0, stepValue));
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i].progressStep(stepValue);
        }
        if (this._rv) {
            stepValue = ((stepValue * -1) + 1);
        }
        this._progress(stepValue);
    }
    progressEnd(shouldComplete, currentStepValue, dur = -1) {
        console.debug('Animation, progressEnd, shouldComplete', shouldComplete, 'currentStepValue', currentStepValue);
        if (this._rv) {
            currentStepValue = ((currentStepValue * -1) + 1);
        }
        const stepValue = shouldComplete ? 1 : 0;
        const diff = Math.abs(currentStepValue - stepValue);
        if (diff < 0.05) {
            dur = 0;
        }
        else if (dur < 0) {
            dur = this._dur;
        }
        this._isAsync = (dur > 30);
        this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);
        if (this._isAsync) {
            this._asyncEnd(dur, shouldComplete);
            this.plt && this.plt.raf(this._playToStep.bind(this, stepValue));
        }
    }
    _progressEnd(shouldComplete, stepValue, dur, isAsync) {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._progressEnd(shouldComplete, stepValue, dur, isAsync);
        }
        if (!isAsync) {
            this._progress(stepValue);
            this._willChg(false);
            this._setAfterStyles();
            this._didFinish(shouldComplete);
        }
        else {
            this.isPlaying = true;
            this.hasCompleted = false;
            this._hasDur = true;
            this._willChg(true);
            this._setTrans(dur, false);
        }
    }
    onFinish(callback, onceTimeCallback = false, clearOnFinishCallacks = false) {
        if (clearOnFinishCallacks) {
            this._fFn = this._fOneFn = undefined;
        }
        if (onceTimeCallback) {
            this._fOneFn = this._fOneFn || [];
            this._fOneFn.push(callback);
        }
        else {
            this._fFn = this._fFn || [];
            this._fFn.push(callback);
        }
        return this;
    }
    _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i]._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);
        }
        if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {
            this._didFinish(hasCompleted);
        }
    }
    _didFinish(hasCompleted) {
        this.isPlaying = false;
        this.hasCompleted = hasCompleted;
        if (this._fFn) {
            for (let i = 0; i < this._fFn.length; i++) {
                this._fFn[i](this);
            }
        }
        if (this._fOneFn) {
            for (let i = 0; i < this._fOneFn.length; i++) {
                this._fOneFn[i](this);
            }
            this._fOneFn.length = 0;
        }
    }
    reverse(shouldReverse = true) {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i].reverse(shouldReverse);
        }
        this._rv = shouldReverse;
        return this;
    }
    destroy() {
        const children = this._c;
        for (let i = 0; i < this._cL; i++) {
            children[i].destroy();
        }
        this._clearAsync();
        this.parent = this.plt = this._e = this._rdFn = this._wrFn = null;
        if (this._c) {
            this._c.length = this._cL = 0;
        }
        if (this._fFn) {
            this._fFn.length = 0;
        }
        if (this._fOneFn) {
            this._fOneFn.length = 0;
        }
    }
    _transEl() {
        let targetEl;
        for (let i = 0; i < this._cL; i++) {
            targetEl = this._c[i]._transEl();
            if (targetEl) {
                return targetEl;
            }
        }
        return (this._twn && this._hasDur && this._eL ? this._e[0] : null);
    }
}
const ANIMATION_TRANSFORMS = {
    'translateX': 1,
    'translateY': 1,
    'translateZ': 1,
    'scale': 1,
    'scaleX': 1,
    'scaleY': 1,
    'scaleZ': 1,
    'rotate': 1,
    'rotateX': 1,
    'rotateY': 1,
    'rotateZ': 1,
    'skewX': 1,
    'skewY': 1,
    'perspective': 1
};
const ANIMATION_CSS_VALUE_REGEX = /(^-?\d*\.?\d*)(.*)/;
const ANIMATION_DURATION_MIN = 32;
const ANIMATION_TRANSITION_END_FALLBACK_PADDING_MS = 400;
//# sourceMappingURL=animation.js.map
// CONCATENATED MODULE: ./src/transitions/transition.ts

class Transition extends animation_Animation {
    constructor(plt, enteringView, leavingView, opts) {
        super(plt, null, opts);
        this.enteringView = enteringView;
        this.leavingView = leavingView;
    }
    init() { }
    registerStart(trnsStart) {
        this._trnsStart = trnsStart;
    }
    start() {
        this._trnsStart && this._trnsStart();
        this._trnsStart = null;
        this.parent && this.parent.start();
    }
    destroy() {
        super.destroy();
        this.parent = this.enteringView = this.leavingView = this._trnsStart = null;
    }
}
//# sourceMappingURL=transition.js.map
// CONCATENATED MODULE: ./src/transitions/page-transition.ts


class page_transition_PageTransition extends Transition {
    init() {
        if (this.enteringView) {
            this.enteringPage = new animation_Animation(this.plt, this.enteringView.pageRef());
            this.add(this.enteringPage.beforeAddClass('show-page'));
            this.beforeAddRead(() => {
                this.enteringView.readReady.emit();
            });
            this.beforeAddWrite(() => {
                this.enteringView.writeReady.emit();
            });
        }
    }
    destroy() {
        super.destroy();
        this.enteringPage && this.enteringPage.destroy();
        this.enteringPage = null;
    }
}
//# sourceMappingURL=page-transition.js.map
// CONCATENATED MODULE: ./src/transitions/transition-ios.ts



const transition_ios_DURATION = 500;
const transition_ios_EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
const OPACITY = 'opacity';
const TRANSFORM = 'transform';
const TRANSLATEX = 'translateX';
const CENTER = '0%';
const OFF_OPACITY = 0.8;
const SHOW_BACK_BTN_CSS = 'show-back-button';
class transition_ios_IOSTransition extends page_transition_PageTransition {
    init() {
        super.init();
        const plt = this.plt;
        const OFF_RIGHT = plt.isRTL ? '-99.5%' : '99.5%';
        const OFF_LEFT = plt.isRTL ? '33%' : '-33%';
        const enteringView = this.enteringView;
        const leavingView = this.leavingView;
        const opts = this.opts;
        this.duration(isPresent(opts.duration) ? opts.duration : transition_ios_DURATION);
        this.easing(isPresent(opts.easing) ? opts.easing : transition_ios_EASING);
        const backDirection = (opts.direction === 'back');
        const enteringHasNavbar = (enteringView && enteringView.hasNavbar());
        const leavingHasNavbar = (leavingView && leavingView.hasNavbar());
        if (enteringView) {
            const enteringPageEle = enteringView.pageRef().nativeElement;
            const enteringContent = new animation_Animation(plt, enteringView.contentRef());
            enteringContent.element(enteringPageEle.querySelectorAll('ion-header > *:not(ion-navbar),ion-footer > *'));
            this.add(enteringContent);
            if (backDirection) {
                enteringContent
                    .fromTo(TRANSLATEX, OFF_LEFT, CENTER, true)
                    .fromTo(OPACITY, OFF_OPACITY, 1, true);
            }
            else {
                enteringContent
                    .beforeClearStyles([OPACITY])
                    .fromTo(TRANSLATEX, OFF_RIGHT, CENTER, true);
            }
            if (enteringHasNavbar) {
                const enteringNavbarEle = enteringPageEle.querySelector('ion-navbar');
                const enteringNavBar = new animation_Animation(plt, enteringNavbarEle);
                this.add(enteringNavBar);
                const enteringTitle = new animation_Animation(plt, enteringNavbarEle.querySelector('ion-title'));
                const enteringNavbarItems = new animation_Animation(plt, enteringNavbarEle.querySelectorAll('ion-buttons,[menuToggle]'));
                const enteringNavbarBg = new animation_Animation(plt, enteringNavbarEle.querySelector('.toolbar-background'));
                const enteringBackButton = new animation_Animation(plt, enteringNavbarEle.querySelector('.back-button'));
                enteringNavBar
                    .add(enteringTitle)
                    .add(enteringNavbarItems)
                    .add(enteringNavbarBg)
                    .add(enteringBackButton);
                enteringTitle.fromTo(OPACITY, 0.01, 1, true);
                enteringNavbarItems.fromTo(OPACITY, 0.01, 1, true);
                if (backDirection) {
                    enteringTitle.fromTo(TRANSLATEX, OFF_LEFT, CENTER, true);
                    if (enteringView.enableBack()) {
                        enteringBackButton
                            .beforeAddClass(SHOW_BACK_BTN_CSS)
                            .fromTo(OPACITY, 0.01, 1, true);
                    }
                }
                else {
                    enteringTitle.fromTo(TRANSLATEX, OFF_RIGHT, CENTER, true);
                    enteringNavbarBg
                        .beforeClearStyles([OPACITY])
                        .fromTo(TRANSLATEX, OFF_RIGHT, CENTER, true);
                    if (enteringView.enableBack()) {
                        enteringBackButton
                            .beforeAddClass(SHOW_BACK_BTN_CSS)
                            .fromTo(OPACITY, 0.01, 1, true);
                        const enteringBackBtnText = new animation_Animation(plt, enteringNavbarEle.querySelector('.back-button-text'));
                        enteringBackBtnText.fromTo(TRANSLATEX, (plt.isRTL ? '-100px' : '100px'), '0px');
                        enteringNavBar.add(enteringBackBtnText);
                    }
                    else {
                        enteringBackButton.beforeRemoveClass(SHOW_BACK_BTN_CSS);
                    }
                }
            }
        }
        if (leavingView && leavingView.pageRef()) {
            const leavingPageEle = leavingView.pageRef().nativeElement;
            const leavingContent = new animation_Animation(plt, leavingView.contentRef());
            leavingContent.element(leavingPageEle.querySelectorAll('ion-header > *:not(ion-navbar),ion-footer > *'));
            this.add(leavingContent);
            if (backDirection) {
                leavingContent
                    .beforeClearStyles([OPACITY])
                    .fromTo(TRANSLATEX, CENTER, (plt.isRTL ? '-100%' : '100%'));
            }
            else {
                leavingContent
                    .fromTo(TRANSLATEX, CENTER, OFF_LEFT)
                    .fromTo(OPACITY, 1, OFF_OPACITY)
                    .afterClearStyles([TRANSFORM, OPACITY]);
            }
            if (leavingHasNavbar) {
                const leavingNavbarEle = leavingPageEle.querySelector('ion-navbar');
                const leavingNavBar = new animation_Animation(plt, leavingNavbarEle);
                const leavingTitle = new animation_Animation(plt, leavingNavbarEle.querySelector('ion-title'));
                const leavingNavbarItems = new animation_Animation(plt, leavingNavbarEle.querySelectorAll('ion-buttons,[menuToggle]'));
                const leavingNavbarBg = new animation_Animation(plt, leavingNavbarEle.querySelector('.toolbar-background'));
                const leavingBackButton = new animation_Animation(plt, leavingNavbarEle.querySelector('.back-button'));
                leavingNavBar
                    .add(leavingTitle)
                    .add(leavingNavbarItems)
                    .add(leavingBackButton)
                    .add(leavingNavbarBg);
                this.add(leavingNavBar);
                leavingBackButton.fromTo(OPACITY, 0.99, 0);
                leavingTitle.fromTo(OPACITY, 0.99, 0);
                leavingNavbarItems.fromTo(OPACITY, 0.99, 0);
                if (backDirection) {
                    leavingTitle.fromTo(TRANSLATEX, CENTER, (plt.isRTL ? '-100%' : '100%'));
                    leavingNavbarBg
                        .beforeClearStyles([OPACITY])
                        .fromTo(TRANSLATEX, CENTER, (plt.isRTL ? '-100%' : '100%'));
                    let leavingBackBtnText = new animation_Animation(plt, leavingNavbarEle.querySelector('.back-button-text'));
                    leavingBackBtnText.fromTo(TRANSLATEX, CENTER, (plt.isRTL ? -300 : 300) + 'px');
                    leavingNavBar.add(leavingBackBtnText);
                }
                else {
                    leavingTitle
                        .fromTo(TRANSLATEX, CENTER, OFF_LEFT)
                        .afterClearStyles([TRANSFORM]);
                    leavingBackButton.afterClearStyles([OPACITY]);
                    leavingTitle.afterClearStyles([OPACITY]);
                    leavingNavbarItems.afterClearStyles([OPACITY]);
                }
            }
        }
    }
}
//# sourceMappingURL=transition-ios.js.map
// CONCATENATED MODULE: ./src/transitions/transition-md.ts



const TRANSLATEY = 'translateY';
const OFF_BOTTOM = '40px';
const transition_md_CENTER = '0px';
const transition_md_SHOW_BACK_BTN_CSS = 'show-back-button';
class transition_md_MDTransition extends page_transition_PageTransition {
    init() {
        super.init();
        const plt = this.plt;
        const enteringView = this.enteringView;
        const leavingView = this.leavingView;
        const opts = this.opts;
        const backDirection = (opts.direction === 'back');
        if (enteringView) {
            if (backDirection) {
                this.duration(isPresent(opts.duration) ? opts.duration : 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
            }
            else {
                this.duration(isPresent(opts.duration) ? opts.duration : 280).easing('cubic-bezier(0.36,0.66,0.04,1)');
                this.enteringPage
                    .fromTo(TRANSLATEY, OFF_BOTTOM, transition_md_CENTER, true)
                    .fromTo('opacity', 0.01, 1, true);
            }
            if (enteringView.hasNavbar()) {
                const enteringPageEle = enteringView.pageRef().nativeElement;
                const enteringNavbarEle = enteringPageEle.querySelector('ion-navbar');
                const enteringNavBar = new animation_Animation(plt, enteringNavbarEle);
                this.add(enteringNavBar);
                const enteringBackButton = new animation_Animation(plt, enteringNavbarEle.querySelector('.back-button'));
                this.add(enteringBackButton);
                if (enteringView.enableBack()) {
                    enteringBackButton.beforeAddClass(transition_md_SHOW_BACK_BTN_CSS);
                }
                else {
                    enteringBackButton.beforeRemoveClass(transition_md_SHOW_BACK_BTN_CSS);
                }
            }
        }
        if (leavingView && backDirection) {
            this.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
            const leavingPage = new animation_Animation(plt, leavingView.pageRef());
            this.add(leavingPage.fromTo(TRANSLATEY, transition_md_CENTER, OFF_BOTTOM).fromTo('opacity', 1, 0));
        }
    }
}
//# sourceMappingURL=transition-md.js.map
// CONCATENATED MODULE: ./src/transitions/transition-wp.ts



const transition_wp_SHOW_BACK_BTN_CSS = 'show-back-button';
const SCALE_SMALL = .95;
class transition_wp_WPTransition extends page_transition_PageTransition {
    init() {
        super.init();
        const plt = this.plt;
        const enteringView = this.enteringView;
        const leavingView = this.leavingView;
        const opts = this.opts;
        const backDirection = (opts.direction === 'back');
        if (enteringView) {
            if (backDirection) {
                this.duration(isPresent(opts.duration) ? opts.duration : 120).easing('cubic-bezier(0.47,0,0.745,0.715)');
                this.enteringPage.beforeClearStyles(['scale']);
            }
            else {
                this.duration(isPresent(opts.duration) ? opts.duration : 280).easing('cubic-bezier(0,0,0.05,1)');
                this.enteringPage
                    .fromTo('scale', SCALE_SMALL, 1, true)
                    .fromTo('opacity', 0.01, 1, true);
            }
            if (enteringView.hasNavbar()) {
                const enteringPageEle = enteringView.pageRef().nativeElement;
                const enteringNavbarEle = enteringPageEle.querySelector('ion-navbar');
                const enteringNavBar = new animation_Animation(plt, enteringNavbarEle);
                this.add(enteringNavBar);
                const enteringBackButton = new animation_Animation(plt, enteringNavbarEle.querySelector('.back-button'));
                this.add(enteringBackButton);
                if (enteringView.enableBack()) {
                    enteringBackButton.beforeAddClass(transition_wp_SHOW_BACK_BTN_CSS);
                }
                else {
                    enteringBackButton.beforeRemoveClass(transition_wp_SHOW_BACK_BTN_CSS);
                }
            }
        }
        if (leavingView && backDirection) {
            this.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
            const leavingPage = new animation_Animation(plt, leavingView.pageRef());
            this.add(leavingPage.fromTo('scale', 1, SCALE_SMALL).fromTo('opacity', 0.99, 0));
        }
    }
}
//# sourceMappingURL=transition-wp.js.map
// CONCATENATED MODULE: ./src/components/app/app.ts














let app_App = class App {
    constructor(_config, _plt, _menuCtrl) {
        this._config = _config;
        this._plt = _plt;
        this._menuCtrl = _menuCtrl;
        this._disTime = 0;
        this._scrollTime = 0;
        this._title = '';
        this._titleSrv = new platform_browser_es5["j" /* Title */](platform_browser_es5["b" /* DOCUMENT */]);
        this._rootNavs = new Map();
        this._didScroll = false;
        this.viewDidLoad = new core_es5["r" /* EventEmitter */]();
        this.viewWillEnter = new core_es5["r" /* EventEmitter */]();
        this.viewDidEnter = new core_es5["r" /* EventEmitter */]();
        this.viewWillLeave = new core_es5["r" /* EventEmitter */]();
        this.viewDidLeave = new core_es5["r" /* EventEmitter */]();
        this.viewWillUnload = new core_es5["r" /* EventEmitter */]();
        _plt.registerBackButtonAction(this.goBack.bind(this));
        this._disableScrollAssist = _config.getBoolean('disableScrollAssist', false);
        const blurring = _config.getBoolean('inputBlurring', false);
        if (blurring) {
            this._enableInputBlurring();
        }
        _runInDev(() => {
            const win = _plt.win();
            if (!win['HWBackButton']) {
                win['HWBackButton'] = () => {
                    let p = this.goBack();
                    p && p.catch(() => console.debug('hardware go back cancelled'));
                    return p;
                };
            }
        });
        _config.setTransition('ios-transition', transition_ios_IOSTransition);
        _config.setTransition('md-transition', transition_md_MDTransition);
        _config.setTransition('wp-transition', transition_wp_WPTransition);
    }
    setTitle(val) {
        if (val !== this._title) {
            this._title = val;
            this._titleSrv.setTitle(val);
        }
    }
    setElementClass(className, isAdd) {
        this._appRoot.setElementClass(className, isAdd);
    }
    setEnabled(isEnabled, duration = 700, minDuration = 0) {
        this._disTime = (isEnabled ? 0 : Date.now() + duration);
        if (this._clickBlock) {
            if (isEnabled) {
                this._clickBlock.activate(false, CLICK_BLOCK_BUFFER_IN_MILLIS, minDuration);
            }
            else {
                this._clickBlock.activate(true, duration + CLICK_BLOCK_BUFFER_IN_MILLIS, minDuration);
            }
        }
    }
    _setDisableScroll(disableScroll) {
        if (this._disableScrollAssist) {
            this._appRoot._disableScroll(disableScroll);
        }
    }
    isEnabled() {
        const disTime = this._disTime;
        if (disTime === 0) {
            return true;
        }
        return (disTime < Date.now());
    }
    setScrolling() {
        this._scrollTime = Date.now() + ACTIVE_SCROLLING_TIME;
        this._didScroll = true;
    }
    isScrolling() {
        const scrollTime = this._scrollTime;
        if (scrollTime === 0) {
            return false;
        }
        if (scrollTime < Date.now()) {
            this._scrollTime = 0;
            return false;
        }
        return true;
    }
    getActiveNav() {
        console.warn('(getActiveNav) is deprecated and will be removed in the next major release. Use getActiveNavs instead.');
        const navs = this.getActiveNavs();
        if (navs && navs.length) {
            return navs[0];
        }
        return null;
    }
    getActiveNavs(rootNavId) {
        const portal = this._appRoot._getPortal(PORTAL_MODAL);
        if (portal.length() > 0) {
            return findTopNavs(portal);
        }
        if (!this._rootNavs || !this._rootNavs.size) {
            return [];
        }
        if (this._rootNavs.size === 1) {
            return findTopNavs(this._rootNavs.values().next().value);
        }
        if (rootNavId) {
            return findTopNavs(this._rootNavs.get(rootNavId));
        }
        let activeNavs = [];
        this._rootNavs.forEach(nav => {
            const topNavs = findTopNavs(nav);
            activeNavs = activeNavs.concat(topNavs);
        });
        return activeNavs;
    }
    getRootNav() {
        console.warn('(getRootNav) is deprecated and will be removed in the next major release. Use getRootNavById instead.');
        const rootNavs = this.getRootNavs();
        if (rootNavs.length === 0) {
            return null;
        }
        else if (rootNavs.length > 1) {
            console.warn('(getRootNav) there are multiple root navs, use getRootNavs instead');
        }
        return rootNavs[0];
    }
    getRootNavs() {
        const navs = [];
        this._rootNavs.forEach(nav => navs.push(nav));
        return navs;
    }
    getRootNavById(navId) {
        return this._rootNavs.get(navId);
    }
    registerRootNav(nav) {
        this._rootNavs.set(nav.id, nav);
    }
    getActiveNavContainers() {
        let list = [];
        this._rootNavs.forEach((container) => {
            list = list.concat(findTopNavs(container));
        });
        return list;
    }
    present(enteringView, opts, appPortal) {
        _assert(enteringView.isOverlay, 'presented view controller needs to be an overlay');
        const portal = this._appRoot._getPortal(appPortal);
        enteringView._setNav(portal);
        opts.direction = DIRECTION_FORWARD;
        if (!opts.animation) {
            opts.animation = enteringView.getTransitionName(DIRECTION_FORWARD);
        }
        enteringView.setLeavingOpts({
            keyboardClose: opts.keyboardClose,
            direction: DIRECTION_BACK,
            animation: enteringView.getTransitionName(DIRECTION_BACK),
            ev: opts.ev
        });
        return portal.insertPages(-1, [enteringView], opts);
    }
    goBack() {
        if (this._menuCtrl && this._menuCtrl.isOpen()) {
            return this._menuCtrl.close();
        }
        const navPromise = this.navPop();
        if (!navPromise) {
            if (this._config.getBoolean('navExitApp', true)) {
                console.debug('app, goBack exitApp');
                this._plt.exitApp();
            }
        }
        return navPromise;
    }
    navPop() {
        if (!this._rootNavs || this._rootNavs.size === 0 || !this.isEnabled()) {
            return Promise.resolve();
        }
        const portal = this._appRoot._getPortal(PORTAL_DEFAULT);
        if (portal.length() > 0) {
            return Promise.resolve();
        }
        let navToPop = null;
        let mostRecentVC = null;
        this._rootNavs.forEach((navContainer) => {
            const activeNavs = this.getActiveNavs(navContainer.id);
            const poppableNavs = activeNavs.map(activeNav => getPoppableNav(activeNav)).filter(nav => !!nav);
            poppableNavs.forEach(poppable => {
                const topViewController = poppable.last();
                if (poppable._isPortal || (topViewController && poppable.length() > 1 && (!mostRecentVC || topViewController._ts >= mostRecentVC._ts))) {
                    mostRecentVC = topViewController;
                    navToPop = poppable;
                }
            });
        });
        if (navToPop) {
            return navToPop.pop();
        }
    }
    _enableInputBlurring() {
        console.debug('App: _enableInputBlurring');
        let focused = true;
        const self = this;
        const platform = this._plt;
        platform.registerListener(platform.doc(), 'focusin', onFocusin, { capture: true, zone: false, passive: true });
        platform.registerListener(platform.doc(), 'touchend', onTouchend, { capture: false, zone: false, passive: true });
        function onFocusin() {
            focused = true;
        }
        function onTouchend(ev) {
            if (self._didScroll) {
                self._didScroll = false;
                return;
            }
            const active = self._plt.getActiveElement();
            if (!active) {
                return;
            }
            if (SKIP_BLURRING.indexOf(active.tagName) === -1) {
                return;
            }
            const tapped = ev.target;
            if (tapped === active) {
                return;
            }
            if (SKIP_BLURRING.indexOf(tapped.tagName) >= 0) {
                return;
            }
            if (tapped.classList.contains('input-cover')) {
                return;
            }
            focused = false;
            platform.timeout(() => {
                if (!focused) {
                    active.blur();
                }
            }, 50);
        }
    }
    getNavByIdOrName(id) {
        const navs = Array.from(this._rootNavs.values());
        for (const navContainer of navs) {
            const match = getNavByIdOrName(navContainer, id);
            if (match) {
                return match;
            }
        }
        return null;
    }
};
app_App = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__param"])(2, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (app__a = typeof config_Config !== "undefined" && config_Config) === "function" && app__a || Object, typeof (_b = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && _b || Object, typeof (_c = typeof menu_controller_MenuController !== "undefined" && menu_controller_MenuController) === "function" && _c || Object])
], app_App);

function getNavByIdOrName(nav, id) {
    if (nav.id === id || nav.name === id) {
        return nav;
    }
    for (const child of nav.getAllChildNavs()) {
        const tmp = getNavByIdOrName(child, id);
        if (tmp) {
            return tmp;
        }
    }
    return null;
}
function getPoppableNav(nav) {
    if (!nav) {
        return null;
    }
    if (isTabs(nav)) {
        return getPoppableNav(nav.parent);
    }
    const len = nav.length();
    if (len > 1 || (nav._isPortal && len > 0)) {
        return nav;
    }
    return getPoppableNav(nav.parent);
}
function findTopNavs(nav) {
    let containers = [];
    const childNavs = nav.getActiveChildNavs();
    if (!childNavs || !childNavs.length) {
        containers.push(nav);
    }
    else {
        childNavs.forEach(childNav => {
            const topNavs = findTopNavs(childNav);
            containers = containers.concat(topNavs);
        });
    }
    return containers;
}
const SKIP_BLURRING = ['INPUT', 'TEXTAREA', 'ION-INPUT', 'ION-TEXTAREA'];
const ACTIVE_SCROLLING_TIME = 100;
const CLICK_BLOCK_BUFFER_IN_MILLIS = 64;
var app__a, _b, _c;




// CONCATENATED MODULE: ./src/components/ion.ts



class Ion {
    constructor(config, elementRef, renderer, componentName) {
        this._config = config;
        this._elementRef = elementRef;
        this._renderer = renderer;
        this._componentName = componentName;
        if (componentName) {
            this._setComponentName();
            this._setMode(config.get('mode'));
        }
    }
    set color(val) {
        this._setColor(val);
    }
    get color() {
        return this._color;
    }
    set mode(val) {
        this._setMode(val);
    }
    get mode() {
        return this._mode;
    }
    setElementClass(className, isAdd) {
        this._renderer.setElementClass(this._elementRef.nativeElement, className, isAdd);
    }
    setElementAttribute(attributeName, attributeValue) {
        this._renderer.setElementAttribute(this._elementRef.nativeElement, attributeName, attributeValue);
    }
    setElementStyle(property, value) {
        this._renderer.setElementStyle(this._elementRef.nativeElement, property, value);
    }
    _setColor(newColor, componentName) {
        if (componentName) {
            this._componentName = componentName;
        }
        if (this._color) {
            this.setElementClass(`${this._componentName}-${this._mode}-${this._color}`, false);
        }
        if (newColor) {
            this.setElementClass(`${this._componentName}-${this._mode}-${newColor}`, true);
            this._color = newColor;
        }
    }
    _setMode(newMode) {
        if (this._mode) {
            this.setElementClass(`${this._componentName}-${this._mode}`, false);
        }
        if (newMode) {
            this.setElementClass(`${this._componentName}-${newMode}`, true);
            this._setColor(null);
            this._mode = newMode;
            this._setColor(this._color);
        }
    }
    _setComponentName() {
        this.setElementClass(this._componentName, true);
    }
    getElementRef() {
        return this._elementRef;
    }
    getNativeElement() {
        return this._elementRef.nativeElement;
    }
}
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], Ion.prototype, "color", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], Ion.prototype, "mode", null);




// CONCATENATED MODULE: ./src/navigation/url-serializer.ts


class url_serializer_UrlSerializer {
    constructor(_app, config) {
        this._app = _app;
        if (config && isArray(config.links)) {
            this.links = normalizeLinks(config.links);
        }
        else {
            this.links = [];
        }
    }
    parse(browserUrl) {
        if (browserUrl.charAt(0) === '/') {
            browserUrl = browserUrl.substr(1);
        }
        browserUrl = browserUrl.split('?')[0].split('#')[0];
        return convertUrlToSegments(this._app, browserUrl, this.links);
    }
    createSegmentFromName(navContainer, nameOrComponent) {
        const configLink = this.getLinkFromName(nameOrComponent);
        if (configLink) {
            return this._createSegment(this._app, navContainer, configLink, null);
        }
        return null;
    }
    getLinkFromName(nameOrComponent) {
        return this.links.find(link => {
            return (link.component === nameOrComponent) ||
                (link.name === nameOrComponent);
        });
    }
    serialize(segments) {
        if (!segments || !segments.length) {
            return '/';
        }
        const sections = segments.map(segment => {
            if (segment.type === 'tabs') {
                if (segment.requiresExplicitNavPrefix) {
                    return `/${segment.type}/${segment.navId}/${segment.secondaryId}/${segment.id}`;
                }
                return `/${segment.secondaryId}/${segment.id}`;
            }
            if (segment.requiresExplicitNavPrefix) {
                return `/${segment.type}/${segment.navId}/${segment.id}`;
            }
            return `/${segment.id}`;
        });
        return sections.join('');
    }
    serializeComponent(navContainer, component, data) {
        if (component) {
            const link = findLinkByComponentData(this.links, component, data);
            if (link) {
                return this._createSegment(this._app, navContainer, link, data);
            }
        }
        return null;
    }
    _createSegment(app, navContainer, configLink, data) {
        let urlParts = configLink.segmentParts;
        if (isPresent(data)) {
            urlParts = urlParts.slice();
            const keys = Object.keys(data);
            const keysLength = keys.length;
            if (keysLength) {
                for (var i = 0; i < urlParts.length; i++) {
                    if (urlParts[i].charAt(0) === ':') {
                        for (var j = 0; j < keysLength; j++) {
                            if (urlParts[i] === `:${keys[j]}`) {
                                urlParts[i] = encodeURIComponent(data[keys[j]]);
                                break;
                            }
                        }
                    }
                }
            }
        }
        let requiresExplicitPrefix = true;
        if (navContainer.parent) {
            requiresExplicitPrefix = navContainer.parent && navContainer.parent.getAllChildNavs().length > 1;
        }
        else {
            requiresExplicitPrefix = app.getRootNavById(navContainer.id) && app.getRootNavs().length > 1;
        }
        return {
            id: urlParts.join('/'),
            name: configLink.name,
            component: configLink.component,
            loadChildren: configLink.loadChildren,
            data: data,
            defaultHistory: configLink.defaultHistory,
            navId: navContainer.name || navContainer.id,
            type: navContainer.getType(),
            secondaryId: navContainer.getSecondaryIdentifier(),
            requiresExplicitNavPrefix: requiresExplicitPrefix
        };
    }
}
function formatUrlPart(name) {
    name = name.replace(URL_REPLACE_REG, '-');
    name = name.charAt(0).toLowerCase() + name.substring(1).replace(/[A-Z]/g, match => {
        return '-' + match.toLowerCase();
    });
    while (name.indexOf('--') > -1) {
        name = name.replace('--', '-');
    }
    if (name.charAt(0) === '-') {
        name = name.substring(1);
    }
    if (name.substring(name.length - 1) === '-') {
        name = name.substring(0, name.length - 1);
    }
    return encodeURIComponent(name);
}
const isPartMatch = (urlPart, configLinkPart) => {
    if (isPresent(urlPart) && isPresent(configLinkPart)) {
        if (configLinkPart.charAt(0) === ':') {
            return true;
        }
        return (urlPart === configLinkPart);
    }
    return false;
};
const createMatchedData = (matchedUrlParts, link) => {
    let data = null;
    for (var i = 0; i < link.segmentPartsLen; i++) {
        if (link.segmentParts[i].charAt(0) === ':') {
            data = data || {};
            data[link.segmentParts[i].substring(1)] = decodeURIComponent(matchedUrlParts[i]);
        }
    }
    return data;
};
const findLinkByComponentData = (links, component, instanceData) => {
    let foundLink = null;
    let foundLinkDataMatches = -1;
    for (var i = 0; i < links.length; i++) {
        var link = links[i];
        if (link.component === component) {
            var dataMatches = 0;
            if (instanceData) {
                var instanceDataKeys = Object.keys(instanceData);
                for (var j = 0; j < instanceDataKeys.length; j++) {
                    if (isPresent(link.dataKeys[instanceDataKeys[j]])) {
                        dataMatches++;
                    }
                }
            }
            else if (link.dataLen) {
                continue;
            }
            if (dataMatches >= foundLinkDataMatches) {
                foundLink = link;
                foundLinkDataMatches = dataMatches;
            }
        }
    }
    return foundLink;
};
const normalizeLinks = (links) => {
    for (var i = 0, ilen = links.length; i < ilen; i++) {
        var link = links[i];
        if (isBlank(link.segment)) {
            link.segment = link.name;
        }
        link.dataKeys = {};
        link.segmentParts = link.segment.split('/');
        link.segmentPartsLen = link.segmentParts.length;
        link.staticLen = link.dataLen = 0;
        var stillCountingStatic = true;
        for (var j = 0; j < link.segmentPartsLen; j++) {
            if (link.segmentParts[j].charAt(0) === ':') {
                link.dataLen++;
                stillCountingStatic = false;
                link.dataKeys[link.segmentParts[j].substring(1)] = true;
            }
            else if (stillCountingStatic) {
                link.staticLen++;
            }
        }
    }
    return links.sort(sortConfigLinks);
};
function sortConfigLinks(a, b) {
    if (a.segmentPartsLen > b.segmentPartsLen) {
        return -1;
    }
    if (a.segmentPartsLen < b.segmentPartsLen) {
        return 1;
    }
    if (a.staticLen > b.staticLen) {
        return -1;
    }
    if (a.staticLen < b.staticLen) {
        return 1;
    }
    if (a.dataLen < b.dataLen) {
        return -1;
    }
    if (a.dataLen > b.dataLen) {
        return 1;
    }
    return 0;
}
const URL_REPLACE_REG = /\s+|\?|\!|\$|\,|\.|\+|\"|\'|\*|\^|\||\/|\\|\[|\]|#|%|`|>|<|;|:|@|&|=/g;
const DeepLinkConfigToken = new core_es5["H" /* OpaqueToken */]('USERLINKS');
function setupUrlSerializer(app, userDeepLinkConfig) {
    return new url_serializer_UrlSerializer(app, userDeepLinkConfig);
}
function navGroupStringtoObjects(navGroupStrings) {
    return navGroupStrings.map(navGroupString => {
        const sections = navGroupString.split('/');
        if (sections[0] === 'nav') {
            return {
                type: 'nav',
                navId: sections[1],
                niceId: sections[1],
                secondaryId: null,
                segmentPieces: sections.splice(2)
            };
        }
        else if (sections[0] === 'tabs') {
            return {
                type: 'tabs',
                navId: sections[1],
                niceId: sections[1],
                secondaryId: sections[2],
                segmentPieces: sections.splice(3)
            };
        }
        return {
            type: null,
            navId: null,
            niceId: null,
            secondaryId: null,
            segmentPieces: sections
        };
    });
}
function urlToNavGroupStrings(url) {
    const tokens = url.split('/');
    const keywordIndexes = [];
    for (let i = 0; i < tokens.length; i++) {
        if (i !== 0 && (tokens[i] === 'nav' || tokens[i] === 'tabs')) {
            keywordIndexes.push(i);
        }
    }
    keywordIndexes.push(tokens.length);
    const groupings = [];
    let activeKeywordIndex = 0;
    let tmpArray = [];
    for (let i = 0; i < tokens.length; i++) {
        if (i >= keywordIndexes[activeKeywordIndex]) {
            groupings.push(tmpArray.join('/'));
            tmpArray = [];
            activeKeywordIndex++;
        }
        tmpArray.push(tokens[i]);
    }
    groupings.push(tmpArray.join('/'));
    return groupings;
}
function convertUrlToSegments(app, url, navLinks) {
    const pairs = convertUrlToDehydratedSegments(url, navLinks);
    return hydrateSegmentsWithNav(app, pairs);
}
function convertUrlToDehydratedSegments(url, navLinks) {
    const navGroupStrings = urlToNavGroupStrings(url);
    const navGroups = navGroupStringtoObjects(navGroupStrings);
    return getSegmentsFromNavGroups(navGroups, navLinks);
}
function hydrateSegmentsWithNav(app, dehydratedSegmentPairs) {
    const segments = [];
    for (let i = 0; i < dehydratedSegmentPairs.length; i++) {
        let navs = getNavFromNavGroup(dehydratedSegmentPairs[i].navGroup, app);
        for (const dehydratedSegment of dehydratedSegmentPairs[i].segments) {
            if (navs.length === 1) {
                segments.push(hydrateSegment(dehydratedSegment, navs[0]));
                navs = navs[0].getActiveChildNavs();
            }
            else if (navs.length > 1) {
                segments.push(hydrateSegment(dehydratedSegment, navs[navs.length - 1]));
                navs = navs[navs.length - 1].getActiveChildNavs();
            }
            else {
                break;
            }
        }
    }
    return segments;
}
function getNavFromNavGroup(navGroup, app) {
    if (navGroup.navId) {
        const rootNav = app.getNavByIdOrName(navGroup.navId);
        if (rootNav) {
            return [rootNav];
        }
        return [];
    }
    return app.getRootNavs();
}
function getSegmentsFromNavGroups(navGroups, navLinks) {
    const pairs = [];
    const usedNavLinks = new Set();
    for (const navGroup of navGroups) {
        const segments = [];
        const segmentPieces = navGroup.segmentPieces.concat([]);
        for (let i = segmentPieces.length; i >= 0; i--) {
            let created = false;
            for (let j = 0; j < i; j++) {
                const startIndex = i - j - 1;
                const endIndex = i;
                const subsetOfUrl = segmentPieces.slice(startIndex, endIndex);
                for (const navLink of navLinks) {
                    if (!usedNavLinks.has(navLink.name)) {
                        const segment = getSegmentsFromUrlPieces(subsetOfUrl, navLink);
                        if (segment) {
                            i = startIndex + 1;
                            usedNavLinks.add(navLink.name);
                            created = true;
                            segments.push(segment);
                            for (let k = startIndex; k < endIndex; k++) {
                                segmentPieces[k] = null;
                            }
                            break;
                        }
                    }
                }
                if (created) {
                    break;
                }
            }
            if (!created && segmentPieces[i - 1]) {
                segments.push({
                    id: null,
                    name: null,
                    secondaryId: segmentPieces[i - 1],
                    component: null,
                    loadChildren: null,
                    data: null,
                    defaultHistory: null
                });
            }
        }
        const orderedSegments = segments.reverse();
        for (let i = 0; i < orderedSegments.length; i++) {
            if (orderedSegments[i].secondaryId && !orderedSegments[i].id && ((i + 1) <= orderedSegments.length - 1)) {
                orderedSegments[i + 1].secondaryId = orderedSegments[i].secondaryId;
                orderedSegments[i] = null;
            }
        }
        const cleanedSegments = segments.filter(segment => !!segment);
        if (navGroup.secondaryId && segments.length) {
            cleanedSegments[0].secondaryId = navGroup.secondaryId;
        }
        pairs.push({
            navGroup: navGroup,
            segments: cleanedSegments
        });
    }
    return pairs;
}
function getSegmentsFromUrlPieces(urlSections, navLink) {
    if (navLink.segmentPartsLen !== urlSections.length) {
        return null;
    }
    for (let i = 0; i < urlSections.length; i++) {
        if (!isPartMatch(urlSections[i], navLink.segmentParts[i])) {
            return null;
        }
    }
    return {
        id: urlSections.join('/'),
        name: navLink.name,
        component: navLink.component,
        loadChildren: navLink.loadChildren,
        data: createMatchedData(urlSections, navLink),
        defaultHistory: navLink.defaultHistory
    };
}
function hydrateSegment(segment, nav) {
    const hydratedSegment = Object.assign({}, segment);
    hydratedSegment.type = nav.getType();
    hydratedSegment.navId = nav.name || nav.id;
    hydratedSegment.secondaryId = segment.secondaryId;
    return hydratedSegment;
}
function getNonHydratedSegmentIfLinkAndUrlMatch(urlChunks, navLink) {
    let allSegmentsMatch = true;
    for (let i = 0; i < urlChunks.length; i++) {
        if (!isPartMatch(urlChunks[i], navLink.segmentParts[i])) {
            allSegmentsMatch = false;
            break;
        }
    }
    if (allSegmentsMatch) {
        return {
            id: navLink.segmentParts.join('/'),
            name: navLink.name,
            component: navLink.component,
            loadChildren: navLink.loadChildren,
            data: createMatchedData(urlChunks, navLink),
            defaultHistory: navLink.defaultHistory
        };
    }
    return null;
}
//# sourceMappingURL=url-serializer.js.map
// CONCATENATED MODULE: ./src/navigation/deep-linker.ts




class deep_linker_DeepLinker {
    constructor(_app, _serializer, _location, _moduleLoader, _baseCfr) {
        this._app = _app;
        this._serializer = _serializer;
        this._location = _location;
        this._moduleLoader = _moduleLoader;
        this._baseCfr = _baseCfr;
        this._history = [];
    }
    init() {
        const browserUrl = normalizeUrl(this._location.path());
        console.debug(`DeepLinker, init load: ${browserUrl}`);
        this._historyPush(browserUrl);
        this._location.subscribe((locationChg) => {
            this._urlChange(normalizeUrl(locationChg.url));
        });
    }
    _urlChange(browserUrl) {
        if (!this._isCurrentUrl(browserUrl)) {
            let isGoingBack = true;
            if (this._isBackUrl(browserUrl)) {
                console.debug(`DeepLinker, browser urlChange, back to: ${browserUrl}`);
                this._historyPop();
            }
            else {
                isGoingBack = false;
                console.debug(`DeepLinker, browser urlChange, forward to: ${browserUrl}`);
                this._historyPush(browserUrl);
            }
            const activeNavContainers = this._app.getActiveNavContainers();
            if (activeNavContainers && activeNavContainers.length) {
                if (browserUrl === '/') {
                    if (isPresent(this._indexAliasUrl)) {
                        browserUrl = this._indexAliasUrl;
                    }
                    else {
                        activeNavContainers.forEach((navContainer) => {
                            navContainer.goToRoot({
                                updateUrl: false,
                                isNavRoot: true
                            });
                        });
                        return;
                    }
                }
                const segments = this.getCurrentSegments(browserUrl);
                segments
                    .map(segment => {
                    for (const navContainer of activeNavContainers) {
                        const nav = getNavFromTree(navContainer, segment.navId);
                        if (nav) {
                            return {
                                segment: segment,
                                navContainer: nav
                            };
                        }
                    }
                })
                    .filter(pair => !!pair)
                    .forEach(pair => {
                    this._loadViewForSegment(pair.navContainer, pair.segment, () => { });
                });
            }
        }
    }
    getCurrentSegments(browserUrl) {
        if (!browserUrl) {
            browserUrl = normalizeUrl(this._location.path());
        }
        return this._serializer.parse(browserUrl);
    }
    navChange(direction) {
        if (direction) {
            const activeNavContainers = this._app.getActiveNavContainers();
            for (const activeNavContainer of activeNavContainers) {
                if (isTabs(activeNavContainer) || activeNavContainer.isTransitioning()) {
                    return;
                }
            }
            let segments = [];
            const navContainers = this._app.getRootNavs();
            for (const navContainer of navContainers) {
                const segmentsForNav = this.getSegmentsFromNav(navContainer);
                segments = segments.concat(segmentsForNav);
            }
            segments = segments.filter(segment => !!segment);
            if (segments.length) {
                const browserUrl = this._serializer.serialize(segments);
                this._updateLocation(browserUrl, direction);
            }
        }
    }
    getSegmentsFromNav(nav) {
        let segments = [];
        if (isNav(nav)) {
            segments.push(this.getSegmentFromNav(nav));
        }
        else if (isTab(nav)) {
            segments.push(this.getSegmentFromTab(nav));
        }
        nav.getActiveChildNavs().forEach(child => {
            segments = segments.concat(this.getSegmentsFromNav(child));
        });
        return segments;
    }
    getSegmentFromNav(nav, component, data) {
        if (!component) {
            const viewController = nav.getActive(true);
            if (viewController) {
                component = viewController.component;
                data = viewController.data;
            }
        }
        return this._serializer.serializeComponent(nav, component, data);
    }
    getSegmentFromTab(navContainer, component, data) {
        if (navContainer && navContainer.parent) {
            const tabsNavContainer = navContainer.parent;
            const activeChildNavs = tabsNavContainer.getActiveChildNavs();
            if (activeChildNavs && activeChildNavs.length) {
                const activeChildNav = activeChildNavs[0];
                const viewController = activeChildNav.getActive(true);
                if (viewController) {
                    component = viewController.component;
                    data = viewController.data;
                }
                return this._serializer.serializeComponent(tabsNavContainer, component, data);
            }
        }
    }
    _updateLocation(browserUrl, direction) {
        if (this._indexAliasUrl === browserUrl) {
            browserUrl = '/';
        }
        if (direction === DIRECTION_BACK && this._isBackUrl(browserUrl)) {
            console.debug(`DeepLinker, location.back(), url: '${browserUrl}'`);
            this._historyPop();
            this._location.back();
        }
        else if (!this._isCurrentUrl(browserUrl)) {
            console.debug(`DeepLinker, location.go('${browserUrl}')`);
            this._historyPush(browserUrl);
            this._location.go(browserUrl);
        }
    }
    getComponentFromName(componentName) {
        const link = this._serializer.getLinkFromName(componentName);
        if (link) {
            return this.getNavLinkComponent(link);
        }
        return Promise.reject(`invalid link: ${componentName}`);
    }
    getNavLinkComponent(link) {
        if (link.component) {
            return Promise.resolve(link.component);
        }
        if (link.loadChildren) {
            return this._moduleLoader.load(link.loadChildren).then((response) => {
                link.component = response.component;
                return response.component;
            });
        }
        return Promise.reject(`invalid link component: ${link.name}`);
    }
    resolveComponent(component) {
        let cfr = this._moduleLoader.getComponentFactoryResolver(component);
        if (!cfr) {
            cfr = this._baseCfr;
        }
        return cfr.resolveComponentFactory(component);
    }
    createUrl(navContainer, nameOrComponent, _data, prepareExternalUrl = true) {
        const segment = this._serializer.createSegmentFromName(navContainer, nameOrComponent);
        const allSegments = this.getCurrentSegments();
        if (segment) {
            for (let i = 0; i < allSegments.length; i++) {
                if (allSegments[i].navId === navContainer.name || allSegments[i].navId === navContainer.id) {
                    allSegments[i] = segment;
                    const url = this._serializer.serialize(allSegments);
                    return prepareExternalUrl ? this._location.prepareExternalUrl(url) : url;
                }
            }
        }
        return '';
    }
    getSegmentByNavIdOrName(navId, name) {
        const browserUrl = normalizeUrl(this._location.path());
        const segments = this._serializer.parse(browserUrl);
        for (const segment of segments) {
            if (segment.navId === navId || segment.navId === name) {
                return segment;
            }
        }
        return null;
    }
    initViews(segment) {
        const link = this._serializer.getLinkFromName(segment.name);
        return this.getNavLinkComponent(link).then((component) => {
            segment.component = component;
            const view = new view_controller_ViewController(component, segment.data);
            view.id = segment.id;
            if (isArray(segment.defaultHistory)) {
                return convertToViews(this, segment.defaultHistory).then(views => {
                    views.push(view);
                    return views;
                });
            }
            return [view];
        });
    }
    _isBackUrl(browserUrl) {
        return (browserUrl === this._history[this._history.length - 2]);
    }
    _isCurrentUrl(browserUrl) {
        return (browserUrl === this._history[this._history.length - 1]);
    }
    _historyPush(browserUrl) {
        if (!this._isCurrentUrl(browserUrl)) {
            this._history.push(browserUrl);
            if (this._history.length > 30) {
                this._history.shift();
            }
        }
    }
    _historyPop() {
        this._history.pop();
        if (!this._history.length) {
            this._historyPush(this._location.path());
        }
    }
    _getTabSelector(tab) {
        if (isPresent(tab.tabUrlPath)) {
            return tab.tabUrlPath;
        }
        if (isPresent(tab.tabTitle)) {
            return formatUrlPart(tab.tabTitle);
        }
        return `tab-${tab.index}`;
    }
    _loadViewForSegment(navContainer, segment, done) {
        if (!segment) {
            return done(false, false);
        }
        if (isTabs(navContainer) || (isTab(navContainer) && navContainer.parent)) {
            const tabs = (isTabs(navContainer) ? navContainer : navContainer.parent);
            const selectedIndex = tabs._getSelectedTabIndex(segment.secondaryId);
            const tab = tabs.getByIndex(selectedIndex);
            tab._lazyRootFromUrl = segment.name;
            tab._lazyRootFromUrlData = segment.data;
            tabs.select(tab, {
                updateUrl: false,
                animate: false
            }, true);
            return done(false, false);
        }
        const navController = navContainer;
        const numViews = navController.length() - 1;
        for (let i = numViews; i >= 0; i--) {
            const viewController = navController.getByIndex(i);
            if (viewController && (viewController.id === segment.id || viewController.id === segment.name)) {
                if (i === numViews) {
                    return done(false, false);
                }
                else {
                    return navController.popTo(viewController, {
                        animate: false,
                        updateUrl: false,
                    }, done);
                }
            }
        }
        return navController.setRoot(segment.component || segment.name, segment.data, {
            id: segment.id, animate: false, updateUrl: false
        }, done);
    }
}
function setupDeepLinker(app, serializer, location, moduleLoader, cfr) {
    const deepLinker = new deep_linker_DeepLinker(app, serializer, location, moduleLoader, cfr);
    deepLinker.init();
    return deepLinker;
}
function normalizeUrl(browserUrl) {
    browserUrl = browserUrl.trim();
    if (browserUrl.charAt(0) !== '/') {
        browserUrl = '/' + browserUrl;
    }
    if (browserUrl.length > 1 && browserUrl.charAt(browserUrl.length - 1) === '/') {
        browserUrl = browserUrl.substr(0, browserUrl.length - 1);
    }
    return browserUrl;
}
function getNavFromTree(nav, id) {
    while (nav) {
        if (nav.id === id || nav.name === id) {
            return nav;
        }
        nav = nav.parent;
    }
    return null;
}
//# sourceMappingURL=deep-linker.js.map
// CONCATENATED MODULE: ./src/platform/dom-controller.ts





class DomDebouncer {
    constructor(dom) {
        this.dom = dom;
        this.writeTask = null;
        this.readTask = null;
    }
    read(fn) {
        if (this.readTask) {
            return;
        }
        return this.readTask = this.dom.read((t) => {
            this.readTask = null;
            fn(t);
        });
    }
    write(fn) {
        if (this.writeTask) {
            return;
        }
        return this.writeTask = this.dom.write((t) => {
            this.writeTask = null;
            fn(t);
        });
    }
    cancel() {
        const writeTask = this.writeTask;
        writeTask && this.dom.cancel(writeTask);
        const readTask = this.readTask;
        readTask && this.dom.cancel(readTask);
        this.readTask = this.writeTask = null;
    }
}
let dom_controller_DomController = class DomController {
    constructor(plt) {
        this.plt = plt;
        this.r = [];
        this.w = [];
    }
    debouncer() {
        return new DomDebouncer(this);
    }
    read(fn, timeout) {
        if (timeout) {
            fn.timeoutId = this.plt.timeout(() => {
                this.r.push(fn);
                this._queue();
            }, timeout);
        }
        else {
            this.r.push(fn);
            this._queue();
        }
        return fn;
    }
    write(fn, timeout) {
        if (timeout) {
            fn.timeoutId = this.plt.timeout(() => {
                this.w.push(fn);
                this._queue();
            }, timeout);
        }
        else {
            this.w.push(fn);
            this._queue();
        }
        return fn;
    }
    cancel(fn) {
        if (fn) {
            if (fn.timeoutId) {
                this.plt.cancelTimeout(fn.timeoutId);
            }
            removeArrayItem(this.r, fn) || removeArrayItem(this.w, fn);
        }
    }
    _queue() {
        const self = this;
        if (!self.q) {
            self.q = true;
            self.plt.raf(function rafCallback(timeStamp) {
                self._flush(timeStamp);
            });
        }
    }
    _flush(timeStamp) {
        let err;
        try {
            dispatch(timeStamp, this.r, this.w);
        }
        catch (e) {
            err = e;
        }
        this.q = false;
        if (this.r.length || this.w.length) {
            this._queue();
        }
        if (err) {
            throw err;
        }
    }
};
dom_controller_DomController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (dom_controller__a = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && dom_controller__a || Object])
], dom_controller_DomController);

function dispatch(timeStamp, r, w) {
    let fn;
    while (fn = r.shift()) {
        fn(timeStamp);
    }
    while (fn = w.shift()) {
        fn(timeStamp);
    }
}
var dom_controller__a;




// CONCATENATED MODULE: ./src/gestures/gesture-controller.ts






const GESTURE_GO_BACK_SWIPE = 'goback-swipe';
const GESTURE_MENU_SWIPE = 'menu-swipe';
const GESTURE_ITEM_SWIPE = 'item-swipe';
const GESTURE_REFRESHER = 'refresher';
const GESTURE_TOGGLE = 'toggle';
const GESTURE_PRIORITY_SLIDING_ITEM = -10;
const GESTURE_PRIORITY_REFRESHER = 0;
const GESTURE_PRIORITY_MENU_SWIPE = 10;
const GESTURE_PRIORITY_GO_BACK_SWIPE = 20;
const GESTURE_PRIORITY_TOGGLE = 30;
const BLOCK_ALL = {
    disable: [GESTURE_MENU_SWIPE, GESTURE_GO_BACK_SWIPE],
    disableScroll: true
};
let GestureController = class GestureController {
    constructor(_app) {
        this._app = _app;
        this.id = 1;
        this.requestedStart = {};
        this.disabledGestures = {};
        this.disabledScroll = new Set();
        this.capturedID = null;
    }
    createGesture(opts) {
        if (!opts.name) {
            throw new Error('name is undefined');
        }
        return new gesture_controller_GestureDelegate(opts.name, this.newID(), this, opts.priority || 0, !!opts.disableScroll);
    }
    createBlocker(opts = {}) {
        return new gesture_controller_BlockerDelegate(this.newID(), this, opts.disable, !!opts.disableScroll);
    }
    newID() {
        let id = this.id;
        this.id++;
        return id;
    }
    start(gestureName, id, priority) {
        if (!this.canStart(gestureName)) {
            delete this.requestedStart[id];
            return false;
        }
        this.requestedStart[id] = priority;
        return true;
    }
    capture(gestureName, id, priority) {
        if (!this.start(gestureName, id, priority)) {
            return false;
        }
        let requestedStart = this.requestedStart;
        let maxPriority = -10000;
        for (let gestureID in requestedStart) {
            maxPriority = Math.max(maxPriority, requestedStart[gestureID]);
        }
        if (maxPriority === priority) {
            this.capturedID = id;
            this.requestedStart = {};
            console.debug(`${gestureName} captured!`);
            return true;
        }
        delete requestedStart[id];
        console.debug(`${gestureName} can not start because it is has lower priority`);
        return false;
    }
    release(id) {
        delete this.requestedStart[id];
        if (this.capturedID && id === this.capturedID) {
            this.capturedID = null;
        }
    }
    disableGesture(gestureName, id) {
        let set = this.disabledGestures[gestureName];
        if (!set) {
            set = new Set();
            this.disabledGestures[gestureName] = set;
        }
        set.add(id);
    }
    enableGesture(gestureName, id) {
        let set = this.disabledGestures[gestureName];
        if (set) {
            set.delete(id);
        }
    }
    disableScroll(id) {
        let isEnabled = !this.isScrollDisabled();
        this.disabledScroll.add(id);
        if (this._app && isEnabled && this.isScrollDisabled()) {
            console.debug('GestureController: Disabling scrolling');
            this._app._setDisableScroll(true);
        }
    }
    enableScroll(id) {
        let isDisabled = this.isScrollDisabled();
        this.disabledScroll.delete(id);
        if (this._app && isDisabled && !this.isScrollDisabled()) {
            console.debug('GestureController: Enabling scrolling');
            this._app._setDisableScroll(false);
        }
    }
    canStart(gestureName) {
        if (this.capturedID) {
            console.debug(`${gestureName} can not start becuse gesture was already captured`);
            return false;
        }
        if (this.isDisabled(gestureName)) {
            console.debug(`${gestureName} is disabled`);
            return false;
        }
        return true;
    }
    isCaptured() {
        return !!this.capturedID;
    }
    isScrollDisabled() {
        return this.disabledScroll.size > 0;
    }
    isDisabled(gestureName) {
        let disabled = this.disabledGestures[gestureName];
        return !!(disabled && disabled.size > 0);
    }
};
GestureController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__param"])(0, Object(core_es5["v" /* Inject */])(Object(core_es5["_5" /* forwardRef */])(() => app_App))),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (gesture_controller__a = typeof app_App !== "undefined" && app_App) === "function" && gesture_controller__a || Object])
], GestureController);

class gesture_controller_GestureDelegate {
    constructor(name, id, controller, priority, disableScroll) {
        this.name = name;
        this.id = id;
        this.controller = controller;
        this.priority = priority;
        this.disableScroll = disableScroll;
    }
    canStart() {
        if (!this.controller) {
            _assert(false, 'delegate was destroyed');
            return false;
        }
        return this.controller.canStart(this.name);
    }
    start() {
        if (!this.controller) {
            _assert(false, 'delegate was destroyed');
            return false;
        }
        return this.controller.start(this.name, this.id, this.priority);
    }
    capture() {
        if (!this.controller) {
            _assert(false, 'delegate was destroyed');
            return false;
        }
        let captured = this.controller.capture(this.name, this.id, this.priority);
        if (captured && this.disableScroll) {
            this.controller.disableScroll(this.id);
        }
        return captured;
    }
    release() {
        if (!this.controller) {
            _assert(false, 'delegate was destroyed');
            return;
        }
        this.controller.release(this.id);
        if (this.disableScroll) {
            this.controller.enableScroll(this.id);
        }
    }
    destroy() {
        this.release();
        this.controller = null;
    }
}
class gesture_controller_BlockerDelegate {
    constructor(id, controller, disable, disableScroll) {
        this.id = id;
        this.controller = controller;
        this.disable = disable;
        this.disableScroll = disableScroll;
        this.blocked = false;
    }
    block() {
        if (!this.controller) {
            _assert(false, 'delegate was destroyed');
            return;
        }
        if (this.disable) {
            this.disable.forEach(gesture => {
                this.controller.disableGesture(gesture, this.id);
            });
        }
        if (this.disableScroll) {
            this.controller.disableScroll(this.id);
        }
        this.blocked = true;
    }
    unblock() {
        if (!this.controller) {
            _assert(false, 'delegate was destroyed');
            return;
        }
        if (this.disable) {
            this.disable.forEach(gesture => {
                this.controller.enableGesture(gesture, this.id);
            });
        }
        if (this.disableScroll) {
            this.controller.enableScroll(this.id);
        }
        this.blocked = false;
    }
    destroy() {
        this.unblock();
        this.controller = null;
    }
}
var gesture_controller__a;




// CONCATENATED MODULE: ./src/navigation/nav-controller.ts
class NavController {
}
//# sourceMappingURL=nav-controller.js.map
// CONCATENATED MODULE: ./src/gestures/recognizers.ts
class PanRecognizer {
    constructor(direction, threshold, maxAngle) {
        this.direction = direction;
        this.dirty = false;
        this._angle = 0;
        this._isPan = 0;
        const radians = maxAngle * (Math.PI / 180);
        this.maxCosine = Math.cos(radians);
        this.threshold = threshold * threshold;
    }
    start(coord) {
        this.startCoord = coord;
        this._angle = 0;
        this._isPan = 0;
        this.dirty = true;
    }
    detect(coord) {
        if (!this.dirty) {
            return false;
        }
        const deltaX = (coord.x - this.startCoord.x);
        const deltaY = (coord.y - this.startCoord.y);
        const distance = deltaX * deltaX + deltaY * deltaY;
        if (distance >= this.threshold) {
            var angle = Math.atan2(deltaY, deltaX);
            var cosine = (this.direction === 'y')
                ? Math.sin(angle)
                : Math.cos(angle);
            this._angle = angle;
            if (cosine > this.maxCosine) {
                this._isPan = 1;
            }
            else if (cosine < -this.maxCosine) {
                this._isPan = -1;
            }
            else {
                this._isPan = 0;
            }
            this.dirty = false;
            return true;
        }
        return false;
    }
    angle() {
        return this._angle;
    }
    pan() {
        return this._isPan;
    }
}
//# sourceMappingURL=recognizers.js.map
// CONCATENATED MODULE: ./src/gestures/pointer-events.ts

class pointer_events_PointerEvents {
    constructor(plt, ele, pointerDown, pointerMove, pointerUp, option) {
        this.plt = plt;
        this.ele = ele;
        this.pointerDown = pointerDown;
        this.pointerMove = pointerMove;
        this.pointerUp = pointerUp;
        this.option = option;
        this.rmTouchStart = null;
        this.rmTouchMove = null;
        this.rmTouchEnd = null;
        this.rmTouchCancel = null;
        this.rmMouseStart = null;
        this.rmMouseMove = null;
        this.rmMouseUp = null;
        this.lastTouchEvent = 0;
        this.mouseWait = 2 * 1000;
        _assert(ele, 'element can not be null');
        _assert(pointerDown, 'pointerDown can not be null');
        this.bindTouchEnd = this.handleTouchEnd.bind(this);
        this.bindMouseUp = this.handleMouseUp.bind(this);
        this.rmTouchStart = this.plt.registerListener(ele, 'touchstart', this.handleTouchStart.bind(this), option);
        this.rmMouseStart = this.plt.registerListener(ele, 'mousedown', this.handleMouseDown.bind(this), option);
    }
    handleTouchStart(ev) {
        _assert(this.ele, 'element can not be null');
        _assert(this.pointerDown, 'pointerDown can not be null');
        this.lastTouchEvent = Date.now() + this.mouseWait;
        this.lastEventType = POINTER_EVENT_TYPE_TOUCH;
        if (!this.pointerDown(ev, POINTER_EVENT_TYPE_TOUCH)) {
            return;
        }
        if (!this.rmTouchMove && this.pointerMove) {
            this.rmTouchMove = this.plt.registerListener(this.ele, 'touchmove', this.pointerMove, this.option);
        }
        if (!this.rmTouchEnd) {
            this.rmTouchEnd = this.plt.registerListener(this.ele, 'touchend', this.bindTouchEnd, this.option);
        }
        if (!this.rmTouchCancel) {
            this.rmTouchCancel = this.plt.registerListener(this.ele, 'touchcancel', this.bindTouchEnd, this.option);
        }
    }
    handleMouseDown(ev) {
        _assert(this.ele, 'element can not be null');
        _assert(this.pointerDown, 'pointerDown can not be null');
        if (this.lastTouchEvent > Date.now()) {
            console.debug('mousedown event dropped because of previous touch');
            return;
        }
        this.lastEventType = POINTER_EVENT_TYPE_MOUSE;
        if (!this.pointerDown(ev, POINTER_EVENT_TYPE_MOUSE)) {
            return;
        }
        if (!this.rmMouseMove && this.pointerMove) {
            this.rmMouseMove = this.plt.registerListener(this.plt.doc(), 'mousemove', this.pointerMove, this.option);
        }
        if (!this.rmMouseUp) {
            this.rmMouseUp = this.plt.registerListener(this.plt.doc(), 'mouseup', this.bindMouseUp, this.option);
        }
    }
    handleTouchEnd(ev) {
        this.stopTouch();
        this.pointerUp && this.pointerUp(ev, POINTER_EVENT_TYPE_TOUCH);
    }
    handleMouseUp(ev) {
        this.stopMouse();
        this.pointerUp && this.pointerUp(ev, POINTER_EVENT_TYPE_MOUSE);
    }
    stopTouch() {
        this.rmTouchMove && this.rmTouchMove();
        this.rmTouchEnd && this.rmTouchEnd();
        this.rmTouchCancel && this.rmTouchCancel();
        this.rmTouchMove = this.rmTouchEnd = this.rmTouchCancel = null;
    }
    stopMouse() {
        this.rmMouseMove && this.rmMouseMove();
        this.rmMouseUp && this.rmMouseUp();
        this.rmMouseMove = this.rmMouseUp = null;
    }
    stop() {
        this.stopTouch();
        this.stopMouse();
    }
    destroy() {
        this.rmTouchStart && this.rmTouchStart();
        this.rmMouseStart && this.rmMouseStart();
        this.stop();
        this.ele = this.pointerUp = this.pointerMove = this.pointerDown = this.rmTouchStart = this.rmMouseStart = null;
    }
}
const POINTER_EVENT_TYPE_MOUSE = 1;
const POINTER_EVENT_TYPE_TOUCH = 2;
//# sourceMappingURL=pointer-events.js.map
// CONCATENATED MODULE: ./src/gestures/ui-event-manager.ts

class ui_event_manager_UIEventManager {
    constructor(plt) {
        this.plt = plt;
        this.evts = [];
    }
    pointerEvents(config) {
        if (!config.element || !config.pointerDown) {
            console.error('PointerEvents config is invalid');
            return;
        }
        const eventListnerOpts = {
            capture: config.capture,
            passive: config.passive,
            zone: config.zone
        };
        const pointerEvents = new pointer_events_PointerEvents(this.plt, config.element, config.pointerDown, config.pointerMove, config.pointerUp, eventListnerOpts);
        const removeFunc = () => pointerEvents.destroy();
        this.evts.push(removeFunc);
        return pointerEvents;
    }
    listen(ele, eventName, callback, opts) {
        if (ele) {
            var removeFunc = this.plt.registerListener(ele, eventName, callback, opts);
            this.evts.push(removeFunc);
            return removeFunc;
        }
    }
    unlistenAll() {
        this.evts.forEach(unRegEvent => {
            unRegEvent();
        });
        this.evts.length = 0;
    }
    destroy() {
        this.unlistenAll();
        this.evts = null;
    }
}
//# sourceMappingURL=ui-event-manager.js.map
// CONCATENATED MODULE: ./src/gestures/pan-gesture.ts




class pan_gesture_PanGesture {
    constructor(plt, element, opts = {}) {
        this.plt = plt;
        this.element = element;
        defaults(opts, {
            threshold: 20,
            maxAngle: 40,
            direction: 'x',
            zone: true,
            capture: false,
            passive: false,
        });
        this.events = new ui_event_manager_UIEventManager(plt);
        if (opts.domController) {
            this.debouncer = opts.domController.debouncer();
        }
        this.gestute = opts.gesture;
        this.direction = opts.direction;
        this.eventsConfig = {
            element: this.element,
            pointerDown: this.pointerDown.bind(this),
            pointerMove: this.pointerMove.bind(this),
            pointerUp: this.pointerUp.bind(this),
            zone: opts.zone,
            capture: opts.capture,
            passive: opts.passive
        };
        if (opts.threshold > 0) {
            this.detector = new PanRecognizer(opts.direction, opts.threshold, opts.maxAngle);
        }
    }
    listen() {
        if (!this.isListening) {
            this.pointerEvents = this.events.pointerEvents(this.eventsConfig);
            this.isListening = true;
        }
    }
    unlisten() {
        if (this.isListening) {
            this.gestute && this.gestute.release();
            this.events.unlistenAll();
            this.isListening = false;
        }
    }
    destroy() {
        this.gestute && this.gestute.destroy();
        this.gestute = null;
        this.unlisten();
        this.events.destroy();
        this.events = this.element = this.gestute = null;
    }
    pointerDown(ev) {
        if (this.started) {
            return;
        }
        if (!this.canStart(ev)) {
            return false;
        }
        if (this.gestute) {
            this.gestute.release();
            if (!this.gestute.start()) {
                return false;
            }
        }
        this.started = true;
        this.captured = false;
        const coord = pointerCoord(ev);
        if (this.detector) {
            this.detector.start(coord);
        }
        else {
            if (!this.tryToCapture(ev)) {
                this.started = false;
                this.captured = false;
                this.gestute.release();
                return false;
            }
        }
        return true;
    }
    pointerMove(ev) {
        _assert(this.started === true, 'started must be true');
        if (this.captured) {
            this.debouncer.write(() => {
                this.onDragMove(ev);
            });
            return;
        }
        _assert(this.detector, 'detector has to be valid');
        const coord = pointerCoord(ev);
        if (this.detector.detect(coord)) {
            if (this.detector.pan() !== 0) {
                if (!this.tryToCapture(ev)) {
                    this.abort(ev);
                }
            }
        }
    }
    pointerUp(ev) {
        _assert(this.started, 'started failed');
        this.debouncer.cancel();
        this.gestute && this.gestute.release();
        if (this.captured) {
            this.onDragEnd(ev);
        }
        else {
            this.notCaptured(ev);
        }
        this.captured = false;
        this.started = false;
    }
    tryToCapture(ev) {
        _assert(this.started === true, 'started has be true');
        _assert(this.captured === false, 'captured has be false');
        if (this.gestute && !this.gestute.capture()) {
            return false;
        }
        this.onDragStart(ev);
        this.captured = true;
        return true;
    }
    abort(ev) {
        this.started = false;
        this.captured = false;
        this.gestute.release();
        this.pointerEvents.stop();
        this.notCaptured(ev);
    }
    getNativeElement() {
        return this.element;
    }
    canStart(_ev) { return true; }
    onDragStart(_ev) { }
    onDragMove(_ev) { }
    onDragEnd(_ev) { }
    notCaptured(_ev) { }
}
//# sourceMappingURL=pan-gesture.js.map
// CONCATENATED MODULE: ./src/gestures/slide-gesture.ts



class slide_gesture_SlideGesture extends pan_gesture_PanGesture {
    constructor(plt, element, opts = {}) {
        super(plt, element, opts);
        this.slide = null;
    }
    getSlideBoundaries(_slide, _ev) {
        return {
            min: 0,
            max: this.getNativeElement().offsetWidth
        };
    }
    getElementStartPos(_slide, _ev) {
        return 0;
    }
    onDragStart(ev) {
        this.onSlideBeforeStart(ev);
        let coord = pointerCoord(ev);
        let pos = coord[this.direction];
        this.slide = {
            min: 0,
            max: 0,
            pointerStartPos: pos,
            pos: pos,
            timestamp: Date.now(),
            elementStartPos: 0,
            started: true,
            delta: 0,
            distance: 0,
            velocity: 0,
        };
        let { min, max } = this.getSlideBoundaries(this.slide, ev);
        this.slide.min = min;
        this.slide.max = max;
        this.slide.elementStartPos = this.getElementStartPos(this.slide, ev);
        this.onSlideStart(this.slide, ev);
    }
    onDragMove(ev) {
        let slide = this.slide;
        _assert(slide.min !== slide.max, 'slide data must be properly initialized');
        let coord = pointerCoord(ev);
        let newPos = coord[this.direction];
        let newTimestamp = Date.now();
        let velocity = (this.plt.isRTL ? (slide.pos - newPos) : (newPos - slide.pos)) / (newTimestamp - slide.timestamp);
        slide.pos = newPos;
        slide.timestamp = newTimestamp;
        slide.distance = clamp(slide.min, (this.plt.isRTL ? slide.pointerStartPos - newPos : newPos - slide.pointerStartPos) + slide.elementStartPos, slide.max);
        slide.velocity = velocity;
        slide.delta = (this.plt.isRTL ? slide.pointerStartPos - newPos : newPos - slide.pointerStartPos);
        this.onSlide(slide, ev);
    }
    onDragEnd(ev) {
        this.onSlideEnd(this.slide, ev);
        this.slide = null;
    }
    onSlideBeforeStart(_ev) { }
    onSlideStart(_slide, _ev) { }
    onSlide(_slide, _ev) { }
    onSlideEnd(_slide, _ev) { }
}
//# sourceMappingURL=slide-gesture.js.map
// CONCATENATED MODULE: ./src/gestures/slide-edge-gesture.ts



class slide_edge_gesture_SlideEdgeGesture extends slide_gesture_SlideGesture {
    constructor(plt, element, opts = {}) {
        defaults(opts, {
            edge: 'start',
            maxEdgeStart: 50
        });
        super(plt, element, opts);
        this.setEdges(opts.edge);
        this.maxEdgeStart = opts.maxEdgeStart;
    }
    setEdges(edges) {
        const isRTL = this.plt.isRTL;
        this.edges = edges.split(' ').map((value) => {
            switch (value) {
                case 'start': return isRTL ? 'right' : 'left';
                case 'end': return isRTL ? 'left' : 'right';
                default: return value;
            }
        });
    }
    canStart(ev) {
        const coord = pointerCoord(ev);
        this._d = this.getContainerDimensions();
        return this.edges.every(edge => this._checkEdge(edge, coord));
    }
    getContainerDimensions() {
        const plt = this.plt;
        return {
            left: 0,
            top: 0,
            width: plt.width(),
            height: plt.height()
        };
    }
    _checkEdge(edge, pos) {
        const data = this._d;
        const maxEdgeStart = this.maxEdgeStart;
        switch (edge) {
            case 'left': return pos.x <= data.left + maxEdgeStart;
            case 'right': return pos.x >= data.width - maxEdgeStart;
            case 'top': return pos.y <= data.top + maxEdgeStart;
            case 'bottom': return pos.y >= data.height - maxEdgeStart;
        }
        return false;
    }
}
//# sourceMappingURL=slide-edge-gesture.js.map
// CONCATENATED MODULE: ./src/navigation/swipe-back.ts



class swipe_back_SwipeBackGesture extends slide_edge_gesture_SlideEdgeGesture {
    constructor(plt, _nav, gestureCtlr, domCtrl) {
        super(plt, plt.doc().body, {
            direction: 'x',
            edge: 'start',
            maxEdgeStart: 75,
            threshold: 5,
            zone: false,
            domController: domCtrl,
            gesture: gestureCtlr.createGesture({
                name: GESTURE_GO_BACK_SWIPE,
                priority: GESTURE_PRIORITY_GO_BACK_SWIPE,
                disableScroll: true
            })
        });
        this._nav = _nav;
    }
    canStart(ev) {
        return (this._nav.canSwipeBack() &&
            super.canStart(ev));
    }
    onSlideBeforeStart(_ev) {
        this._nav.swipeBackStart();
    }
    onSlide(slide, ev) {
        ev.preventDefault();
        ev.stopPropagation();
        const stepValue = (slide.distance / slide.max);
        this._nav.swipeBackProgress(stepValue);
    }
    onSlideEnd(slide, _ev) {
        const velocity = slide.velocity;
        const currentStepValue = (slide.distance / slide.max);
        const isResetDirecction = velocity < 0;
        const isMovingFast = Math.abs(slide.velocity) > 0.4;
        const isInResetZone = Math.abs(slide.delta) < Math.abs(slide.max) * 0.5;
        const shouldComplete = !swipeShouldReset(isResetDirecction, isMovingFast, isInResetZone);
        this._nav.swipeBackEnd(shouldComplete, currentStepValue, velocity);
    }
}
//# sourceMappingURL=swipe-back.js.map
// CONCATENATED MODULE: ./src/navigation/nav-controller-base.ts











class nav_controller_base_NavControllerBase extends Ion {
    constructor(parent, _app, config, plt, elementRef, _zone, renderer, _cfr, _gestureCtrl, _trnsCtrl, _linker, _domCtrl, _errHandler) {
        super(config, elementRef, renderer);
        this.parent = parent;
        this._app = _app;
        this.config = config;
        this.plt = plt;
        this._zone = _zone;
        this._cfr = _cfr;
        this._gestureCtrl = _gestureCtrl;
        this._trnsCtrl = _trnsCtrl;
        this._linker = _linker;
        this._domCtrl = _domCtrl;
        this._errHandler = _errHandler;
        this._ids = -1;
        this._init = false;
        this._queue = [];
        this._trnsId = null;
        this._trnsTm = false;
        this._views = [];
        this._zIndexOffset = 0;
        this.viewDidLoad = new core_es5["r" /* EventEmitter */]();
        this.viewWillEnter = new core_es5["r" /* EventEmitter */]();
        this.viewDidEnter = new core_es5["r" /* EventEmitter */]();
        this.viewWillLeave = new core_es5["r" /* EventEmitter */]();
        this.viewDidLeave = new core_es5["r" /* EventEmitter */]();
        this.viewWillUnload = new core_es5["r" /* EventEmitter */]();
        this._sbEnabled = config.getBoolean('swipeBackEnabled');
        this._children = [];
        this.id = 'n' + (++ctrlIds);
        this._destroyed = false;
    }
    get swipeBackEnabled() {
        return this._sbEnabled;
    }
    set swipeBackEnabled(val) {
        this._sbEnabled = isTrueProperty(val);
        this._swipeBackCheck();
    }
    push(page, params, opts, done) {
        return this._queueTrns({
            insertStart: -1,
            insertViews: [{ page: page, params: params }],
            opts: opts,
        }, done);
    }
    insert(insertIndex, page, params, opts, done) {
        return this._queueTrns({
            insertStart: insertIndex,
            insertViews: [{ page: page, params: params }],
            opts: opts,
        }, done);
    }
    insertPages(insertIndex, insertPages, opts, done) {
        return this._queueTrns({
            insertStart: insertIndex,
            insertViews: insertPages,
            opts: opts,
        }, done);
    }
    pop(opts, done) {
        return this._queueTrns({
            removeStart: -1,
            removeCount: 1,
            opts: opts,
        }, done);
    }
    popTo(indexOrViewCtrl, opts, done) {
        let config = {
            removeStart: -1,
            removeCount: -1,
            opts: opts
        };
        if (isViewController(indexOrViewCtrl)) {
            config.removeView = indexOrViewCtrl;
            config.removeStart = 1;
        }
        else if (isNumber(indexOrViewCtrl)) {
            config.removeStart = indexOrViewCtrl + 1;
        }
        return this._queueTrns(config, done);
    }
    popToRoot(opts, done) {
        return this._queueTrns({
            removeStart: 1,
            removeCount: -1,
            opts: opts,
        }, done);
    }
    popAll() {
        let promises = [];
        for (var i = this._views.length - 1; i >= 0; i--) {
            promises.push(this.pop(null));
        }
        return Promise.all(promises);
    }
    remove(startIndex, removeCount = 1, opts, done) {
        return this._queueTrns({
            removeStart: startIndex,
            removeCount: removeCount,
            opts: opts,
        }, done);
    }
    removeView(viewController, opts, done) {
        return this._queueTrns({
            removeView: viewController,
            removeStart: 0,
            removeCount: 1,
            opts: opts,
        }, done);
    }
    setRoot(pageOrViewCtrl, params, opts, done) {
        return this.setPages([{ page: pageOrViewCtrl, params: params }], opts, done);
    }
    setPages(viewControllers, opts, done) {
        if (isBlank(opts)) {
            opts = {};
        }
        if (opts.animate !== true) {
            opts.animate = false;
        }
        return this._queueTrns({
            insertStart: 0,
            insertViews: viewControllers,
            removeStart: 0,
            removeCount: -1,
            opts: opts
        }, done);
    }
    _queueTrns(ti, done) {
        const promise = new Promise((resolve, reject) => {
            ti.resolve = resolve;
            ti.reject = reject;
        });
        ti.done = done;
        if (ti.insertViews && ti.insertViews.length === 0) {
            ti.insertViews = undefined;
        }
        this._queue.push(ti);
        this._nextTrns();
        return promise;
    }
    _success(result, ti) {
        if (this._queue === null) {
            this._fireError('nav controller was destroyed', ti);
            return;
        }
        this._init = true;
        this._trnsId = null;
        this.setTransitioning(false);
        this._swipeBackCheck();
        this._nextTrns();
        if (ti.done) {
            ti.done(result.hasCompleted, result.requiresTransition, result.enteringName, result.leavingName, result.direction);
        }
        ti.resolve(result.hasCompleted);
    }
    _failed(rejectReason, ti) {
        if (this._queue === null) {
            this._fireError('nav controller was destroyed', ti);
            return;
        }
        this._trnsId = null;
        this._queue.length = 0;
        this.setTransitioning(false);
        this._swipeBackCheck();
        this._nextTrns();
        this._fireError(rejectReason, ti);
    }
    _fireError(rejectReason, ti) {
        if (ti.done) {
            ti.done(false, false, rejectReason);
        }
        if (ti.reject && !this._destroyed) {
            ti.reject(rejectReason);
        }
        else {
            ti.resolve(false);
        }
    }
    _nextTrns() {
        if (this.isTransitioning()) {
            return false;
        }
        const ti = this._queue.shift();
        if (!ti) {
            return false;
        }
        let enteringView;
        let leavingView;
        this._startTI(ti)
            .then(() => this._loadLazyLoading(ti))
            .then(() => {
            leavingView = this.getActive();
            enteringView = this._getEnteringView(ti, leavingView);
            if (!leavingView && !enteringView) {
                throw 'no views in the stack to be removed';
            }
            if (enteringView && enteringView._state === STATE_NEW) {
                this._viewInit(enteringView);
            }
            ti.requiresTransition = (ti.enteringRequiresTransition || ti.leavingRequiresTransition) && enteringView !== leavingView;
        })
            .then(() => this._viewTest(enteringView, leavingView, ti))
            .then(() => this._postViewInit(enteringView, leavingView, ti))
            .then(() => this._transition(enteringView, leavingView, ti))
            .then((result) => this._success(result, ti))
            .catch((rejectReason) => this._failed(rejectReason, ti));
        return true;
    }
    _startTI(ti) {
        const viewsLength = this._views.length;
        if (isPresent(ti.removeView)) {
            _assert(isPresent(ti.removeStart), 'removeView needs removeStart');
            _assert(isPresent(ti.removeCount), 'removeView needs removeCount');
            const index = this.indexOf(ti.removeView);
            if (index < 0) {
                return Promise.reject('removeView was not found');
            }
            ti.removeStart += index;
        }
        if (isPresent(ti.removeStart)) {
            if (ti.removeStart < 0) {
                ti.removeStart = (viewsLength - 1);
            }
            if (ti.removeCount < 0) {
                ti.removeCount = (viewsLength - ti.removeStart);
            }
            ti.leavingRequiresTransition = (ti.removeCount > 0) && ((ti.removeStart + ti.removeCount) === viewsLength);
        }
        if (ti.insertViews) {
            if (ti.insertStart < 0 || ti.insertStart > viewsLength) {
                ti.insertStart = viewsLength;
            }
            ti.enteringRequiresTransition = (ti.insertStart === viewsLength);
        }
        this.setTransitioning(true);
        return Promise.resolve();
    }
    _loadLazyLoading(ti) {
        const insertViews = ti.insertViews;
        if (insertViews) {
            _assert(insertViews.length > 0, 'length can not be zero');
            return convertToViews(this._linker, insertViews).then((viewControllers) => {
                _assert(insertViews.length === viewControllers.length, 'lengths does not match');
                viewControllers = viewControllers.filter(v => v !== null);
                if (viewControllers.length === 0) {
                    throw 'invalid views to insert';
                }
                for (var i = 0; i < viewControllers.length; i++) {
                    var view = viewControllers[i];
                    var nav = view._nav;
                    if (nav && nav !== this) {
                        throw 'inserted view was already inserted';
                    }
                    if (view._state === STATE_DESTROYED) {
                        throw 'inserted view was already destroyed';
                    }
                }
                ti.insertViews = viewControllers;
            });
        }
        return Promise.resolve();
    }
    _getEnteringView(ti, leavingView) {
        const insertViews = ti.insertViews;
        if (insertViews) {
            return insertViews[insertViews.length - 1];
        }
        const removeStart = ti.removeStart;
        if (isPresent(removeStart)) {
            var views = this._views;
            var removeEnd = removeStart + ti.removeCount;
            var i;
            var view;
            for (i = views.length - 1; i >= 0; i--) {
                view = views[i];
                if ((i < removeStart || i >= removeEnd) && view !== leavingView) {
                    return view;
                }
            }
        }
        return null;
    }
    _postViewInit(enteringView, leavingView, ti) {
        _assert(leavingView || enteringView, 'Both leavingView and enteringView are null');
        _assert(ti.resolve, 'resolve must be valid');
        _assert(ti.reject, 'reject must be valid');
        const opts = ti.opts || {};
        const insertViews = ti.insertViews;
        const removeStart = ti.removeStart;
        const removeCount = ti.removeCount;
        let view;
        let i;
        let destroyQueue;
        if (isPresent(removeStart)) {
            _assert(removeStart >= 0, 'removeStart can not be negative');
            _assert(removeCount >= 0, 'removeCount can not be negative');
            destroyQueue = [];
            for (i = 0; i < removeCount; i++) {
                view = this._views[i + removeStart];
                if (view && view !== enteringView && view !== leavingView) {
                    destroyQueue.push(view);
                }
            }
            opts.direction = opts.direction || DIRECTION_BACK;
        }
        const finalBalance = this._views.length + (insertViews ? insertViews.length : 0) - (removeCount ? removeCount : 0);
        _assert(finalBalance >= 0, 'final balance can not be negative');
        if (finalBalance === 0 && !this._isPortal) {
            console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.getNativeElement());
            throw 'navigation stack needs at least one root page';
        }
        if (insertViews) {
            if (isPresent(opts.id)) {
                enteringView.id = opts.id;
            }
            for (i = 0; i < insertViews.length; i++) {
                view = insertViews[i];
                this._insertViewAt(view, ti.insertStart + i);
            }
            if (ti.enteringRequiresTransition) {
                opts.direction = opts.direction || DIRECTION_FORWARD;
            }
        }
        if (destroyQueue && destroyQueue.length > 0) {
            this._zone.run(() => {
                for (i = 0; i < destroyQueue.length; i++) {
                    view = destroyQueue[i];
                    this._willLeave(view, true);
                    this._didLeave(view);
                    this._willUnload(view);
                }
            });
            for (i = 0; i < destroyQueue.length; i++) {
                this._destroyView(destroyQueue[i]);
            }
        }
        if (ti.requiresTransition && !opts.animation) {
            if (isPresent(ti.removeStart)) {
                opts.animation = (leavingView || enteringView).getTransitionName(opts.direction);
            }
            else {
                opts.animation = (enteringView || leavingView).getTransitionName(opts.direction);
            }
        }
        ti.opts = opts;
    }
    _viewInit(enteringView) {
        _assert(enteringView, 'enteringView must be non null');
        _assert(enteringView._state === STATE_NEW, 'enteringView state must be NEW');
        const componentProviders = core_es5["N" /* ReflectiveInjector */].resolve([
            { provide: NavController, useValue: this },
            { provide: view_controller_ViewController, useValue: enteringView },
            { provide: NavParams, useValue: enteringView.getNavParams() }
        ]);
        const componentFactory = this._linker.resolveComponent(enteringView.component);
        const childInjector = core_es5["N" /* ReflectiveInjector */].fromResolvedProviders(componentProviders, this._viewport.parentInjector);
        enteringView.init(componentFactory.create(childInjector, []));
        enteringView._state = STATE_INITIALIZED;
        this._preLoad(enteringView);
    }
    _viewAttachToDOM(view, componentRef, viewport) {
        _assert(view._state === STATE_INITIALIZED, 'view state must be INITIALIZED');
        _assert(componentRef, 'componentRef can not be null');
        this._willLoad(view);
        viewport.insert(componentRef.hostView, viewport.length);
        view._state = STATE_ATTACHED;
        if (view._cssClass) {
            var pageElement = componentRef.location.nativeElement;
            this._renderer.setElementClass(pageElement, view._cssClass, true);
        }
        componentRef.changeDetectorRef.detectChanges();
        this._zone.run(this._didLoad.bind(this, view));
    }
    _viewTest(enteringView, leavingView, ti) {
        if (!ti.requiresTransition) {
            return Promise.resolve();
        }
        const promises = [];
        if (leavingView) {
            promises.push(leavingView._lifecycleTest('Leave'));
        }
        if (enteringView) {
            promises.push(enteringView._lifecycleTest('Enter'));
        }
        if (promises.length === 0) {
            return Promise.resolve();
        }
        return Promise.all(promises).then((values) => {
            if (values.some(result => result === false)) {
                throw 'canEnter/Leave returned false';
            }
        }).catch((reason) => {
            ti.reject = null;
            throw reason;
        });
    }
    _transition(enteringView, leavingView, ti) {
        if (!ti.requiresTransition) {
            return Promise.resolve({
                hasCompleted: true,
                requiresTransition: false
            });
        }
        const opts = ti.opts;
        this._trnsId = this._trnsCtrl.getRootTrnsId(this);
        if (this._trnsId === null) {
            this._trnsId = this._trnsCtrl.nextId();
        }
        const animationOpts = {
            animation: opts.animation,
            direction: opts.direction,
            duration: (opts.animate === false ? 0 : opts.duration),
            easing: opts.easing,
            isRTL: this._config.plt.isRTL,
            ev: opts.ev,
        };
        const transition = this._trnsCtrl.get(this._trnsId, enteringView, leavingView, animationOpts);
        this._sbTrns && this._sbTrns.destroy();
        this._sbTrns = null;
        if (transition.isRoot() && opts.progressAnimation) {
            this._sbTrns = transition;
        }
        const promise = new Promise(resolve => transition.registerStart(resolve)).then(() => {
            return this._transitionStart(transition, enteringView, leavingView, opts);
        });
        if (enteringView && (enteringView._state === STATE_INITIALIZED)) {
            this._viewAttachToDOM(enteringView, enteringView._cmp, this._viewport);
        }
        if (!transition.hasChildren) {
            transition.start();
        }
        return promise;
    }
    _transitionStart(transition, enteringView, leavingView, opts) {
        _assert(this.isTransitioning(), 'isTransitioning() has to be true');
        this._trnsId = null;
        setZIndex(this, enteringView, leavingView, opts.direction, this._renderer);
        enteringView && enteringView._domShow(true, this._renderer);
        leavingView && leavingView._domShow(true, this._renderer);
        transition.init();
        const isFirstPage = !this._init && this._views.length === 1;
        const shouldNotAnimate = isFirstPage && !this._isPortal;
        const canNotAnimate = this._config.get('animate') === false;
        if (shouldNotAnimate || canNotAnimate) {
            opts.animate = false;
        }
        if (opts.animate === false) {
            transition.duration(0);
        }
        transition.beforeAddRead(this._viewsWillLifecycles.bind(this, enteringView, leavingView));
        const duration = transition.getDuration();
        const promise = new Promise(resolve => {
            transition.onFinish(resolve);
        });
        if (transition.isRoot()) {
            if (duration > DISABLE_APP_MINIMUM_DURATION && opts.disableApp !== false) {
                this._app.setEnabled(false, duration + ACTIVE_TRANSITION_OFFSET, opts.minClickBlockDuration);
            }
            else {
                console.debug('transition is running but app has not been disabled');
            }
            if (opts.progressAnimation) {
                transition.progressStart();
            }
            else {
                transition.play();
            }
        }
        return promise.then(() => this._zone.run(() => {
            return this._transitionFinish(transition, opts);
        }));
    }
    _transitionFinish(transition, opts) {
        const hasCompleted = transition.hasCompleted;
        const enteringView = transition.enteringView;
        const leavingView = transition.leavingView;
        let enteringName;
        let leavingName;
        if (hasCompleted) {
            if (enteringView) {
                enteringName = enteringView.name;
                this._didEnter(enteringView);
            }
            if (leavingView) {
                leavingName = leavingView.name;
                this._didLeave(leavingView);
            }
            this._cleanup(enteringView);
        }
        else {
            this._cleanup(leavingView);
        }
        if (transition.isRoot()) {
            this._trnsCtrl.destroy(transition.trnsId);
            this._app.setEnabled(true);
            this.setTransitioning(false);
            if (!this.hasChildren() && opts.updateUrl !== false) {
                this._linker.navChange(opts.direction);
            }
            if (opts.keyboardClose !== false) {
                this.plt.focusOutActiveElement();
            }
        }
        return {
            hasCompleted: hasCompleted,
            requiresTransition: true,
            enteringName: enteringName,
            leavingName: leavingName,
            direction: opts.direction
        };
    }
    _viewsWillLifecycles(enteringView, leavingView) {
        if (enteringView || leavingView) {
            this._zone.run(() => {
                leavingView && this._willLeave(leavingView, !enteringView);
                enteringView && this._willEnter(enteringView);
            });
        }
    }
    _insertViewAt(view, index) {
        const existingIndex = this._views.indexOf(view);
        if (existingIndex > -1) {
            _assert(view._nav === this, 'view is not part of the nav');
            this._views.splice(index, 0, this._views.splice(existingIndex, 1)[0]);
        }
        else {
            _assert(!view._nav || (this._isPortal && view._nav === this), 'nav is used');
            view._setNav(this);
            this._ids++;
            if (!view.id) {
                view.id = `${this.id}-${this._ids}`;
            }
            this._views.splice(index, 0, view);
        }
    }
    _removeView(view) {
        _assert(view._state === STATE_ATTACHED || view._state === STATE_DESTROYED, 'view state should be loaded or destroyed');
        const views = this._views;
        const index = views.indexOf(view);
        _assert(index > -1, 'view must be part of the stack');
        if (index >= 0) {
            views.splice(index, 1);
        }
    }
    _destroyView(view) {
        view._destroy(this._renderer);
        this._removeView(view);
    }
    _cleanup(activeView) {
        if (!this._destroyed) {
            const activeViewIndex = this._views.indexOf(activeView);
            const views = this._views;
            let reorderZIndexes = false;
            let view;
            let i;
            for (i = views.length - 1; i >= 0; i--) {
                view = views[i];
                if (i > activeViewIndex) {
                    this._willUnload(view);
                    this._destroyView(view);
                }
                else if (i < activeViewIndex && !this._isPortal) {
                    view._domShow(false, this._renderer);
                }
                if (view._zIndex <= 0) {
                    reorderZIndexes = true;
                }
            }
            if (!this._isPortal && reorderZIndexes) {
                for (i = 0; i < views.length; i++) {
                    view = views[i];
                    view._setZIndex(view._zIndex + INIT_ZINDEX + 1, this._renderer);
                }
            }
        }
    }
    _preLoad(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        view._preLoad();
    }
    _willLoad(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        try {
            view._willLoad();
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    _didLoad(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        try {
            view._didLoad();
            this.viewDidLoad.emit(view);
            this._app.viewDidLoad.emit(view);
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    _willEnter(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        try {
            view._willEnter();
            this.viewWillEnter.emit(view);
            this._app.viewWillEnter.emit(view);
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    _didEnter(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        try {
            view._didEnter();
            this.viewDidEnter.emit(view);
            this._app.viewDidEnter.emit(view);
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    _willLeave(view, willUnload) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        try {
            view._willLeave(willUnload);
            this.viewWillLeave.emit(view);
            this._app.viewWillLeave.emit(view);
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    _didLeave(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        try {
            view._didLeave();
            this.viewDidLeave.emit(view);
            this._app.viewDidLeave.emit(view);
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    _willUnload(view) {
        _assert(this.isTransitioning(), 'nav controller should be transitioning');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        try {
            view._willUnload();
            this.viewWillUnload.emit(view);
            this._app.viewWillUnload.emit(view);
        }
        catch (e) {
            this._errHandler && this._errHandler.handleError(e);
        }
    }
    hasChildren() {
        return this._children && this._children.length > 0;
    }
    getActiveChildNavs() {
        return this._children;
    }
    getAllChildNavs() {
        return this._children;
    }
    registerChildNav(container) {
        this._children.push(container);
    }
    unregisterChildNav(nav) {
        this._children = this._children.filter(child => child !== nav);
    }
    destroy() {
        const views = this._views;
        let view;
        for (var i = 0; i < views.length; i++) {
            view = views[i];
            view._willUnload();
            view._destroy(this._renderer);
        }
        this._sbGesture && this._sbGesture.destroy();
        this._sbTrns && this._sbTrns.destroy();
        this._queue = this._views = this._sbGesture = this._sbTrns = null;
        if (this.parent && this.parent.unregisterChildNav) {
            this.parent.unregisterChildNav(this);
        }
        this._destroyed = true;
    }
    swipeBackStart() {
        if (this.isTransitioning() || this._queue.length > 0) {
            return;
        }
        const opts = {
            direction: DIRECTION_BACK,
            progressAnimation: true
        };
        this._queueTrns({
            removeStart: -1,
            removeCount: 1,
            opts: opts,
        }, null);
    }
    swipeBackProgress(stepValue) {
        if (this._sbTrns && this._sbGesture) {
            this._app.setEnabled(false, ACTIVE_TRANSITION_DEFAULT);
            this.setTransitioning(true);
            this._sbTrns.progressStep(stepValue);
        }
    }
    swipeBackEnd(shouldComplete, currentStepValue, velocity) {
        if (this._sbTrns && this._sbGesture) {
            var dur = this._sbTrns.getDuration() / (Math.abs(velocity) + 1);
            this._sbTrns.progressEnd(shouldComplete, currentStepValue, dur);
        }
    }
    _swipeBackCheck() {
        if (this.canSwipeBack()) {
            if (!this._sbGesture) {
                this._sbGesture = new swipe_back_SwipeBackGesture(this.plt, this, this._gestureCtrl, this._domCtrl);
            }
            this._sbGesture.listen();
        }
        else if (this._sbGesture) {
            this._sbGesture.unlisten();
        }
    }
    canSwipeBack() {
        return (this._sbEnabled &&
            !this._isPortal &&
            !this._children.length &&
            !this.isTransitioning() &&
            this._app.isEnabled() &&
            this.canGoBack());
    }
    canGoBack() {
        const activeView = this.getActive();
        return !!(activeView && activeView.enableBack());
    }
    isTransitioning() {
        return this._trnsTm;
    }
    setTransitioning(isTransitioning) {
        this._trnsTm = isTransitioning;
    }
    getActive() {
        return this._views[this._views.length - 1];
    }
    isActive(view) {
        return (view === this.getActive());
    }
    getByIndex(index) {
        return this._views[index];
    }
    getPrevious(view) {
        if (!view) {
            view = this.getActive();
        }
        const views = this._views;
        return views[views.indexOf(view) - 1];
    }
    first() {
        return this._views[0];
    }
    last() {
        return this._views[this._views.length - 1];
    }
    indexOf(view) {
        return this._views.indexOf(view);
    }
    length() {
        return this._views.length;
    }
    getViews() {
        return this._views;
    }
    getViewById(id) {
        for (const vc of this._views) {
            if (vc && vc.id === id) {
                return vc;
            }
        }
        return null;
    }
    isSwipeBackEnabled() {
        return this._sbEnabled;
    }
    dismissPageChangeViews() {
        for (let view of this._views) {
            if (view.data && view.data.dismissOnPageChange) {
                view.dismiss().catch(() => { });
            }
        }
    }
    setViewport(val) {
        this._viewport = val;
    }
    resize() {
        const active = this.getActive();
        if (!active) {
            return;
        }
        const content = active.getIONContent();
        content && content.resize();
    }
    goToRoot(_opts) {
        return Promise.reject(new Error('goToRoot needs to be implemented by child class'));
    }
    getType() {
        return 'nav';
    }
    getSecondaryIdentifier() {
        return null;
    }
    getActiveChildNav() {
        console.warn('(getActiveChildNav) is deprecated and will be removed in the next major release. Use getActiveChildNavs instead.');
        return this._children[this._children.length - 1];
    }
}
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], nav_controller_base_NavControllerBase.prototype, "swipeBackEnabled", null);
let ctrlIds = -1;
const DISABLE_APP_MINIMUM_DURATION = 64;
const ACTIVE_TRANSITION_DEFAULT = 5000;
const ACTIVE_TRANSITION_OFFSET = 2000;




// CONCATENATED MODULE: ./src/transitions/transition-controller.ts






let transition_controller_TransitionController = class TransitionController {
    constructor(plt, _config) {
        this.plt = plt;
        this._config = _config;
        this._ids = 0;
        this._trns = {};
    }
    getRootTrnsId(nav) {
        nav = nav.parent;
        while (nav) {
            if (isPresent(nav._trnsId)) {
                return nav._trnsId;
            }
            nav = nav.parent;
        }
        return null;
    }
    nextId() {
        return this._ids++;
    }
    get(trnsId, enteringView, leavingView, opts) {
        let TransitionClass = this._config.getTransition(opts.animation);
        if (!TransitionClass) {
            TransitionClass = this._config.getTransition('ios-transition');
        }
        const trns = new TransitionClass(this.plt, enteringView, leavingView, opts);
        trns.trnsId = trnsId;
        if (!this._trns[trnsId]) {
            this._trns[trnsId] = trns;
        }
        else {
            this._trns[trnsId].add(trns);
        }
        return trns;
    }
    destroy(trnsId) {
        const trans = this._trns[trnsId];
        if (trans) {
            trans.destroy();
            delete this._trns[trnsId];
        }
    }
};
transition_controller_TransitionController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (transition_controller__a = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && transition_controller__a || Object, typeof (transition_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && transition_controller__b || Object])
], transition_controller_TransitionController);

var transition_controller__a, transition_controller__b;




// CONCATENATED MODULE: ./src/components/app/overlay-portal.ts












let OverlayPortal = class OverlayPortal extends nav_controller_base_NavControllerBase {
    constructor(app, config, plt, elementRef, zone, renderer, cfr, gestureCtrl, transCtrl, linker, viewPort, domCtrl, errHandler) {
        super(null, app, config, plt, elementRef, zone, renderer, cfr, gestureCtrl, transCtrl, linker, domCtrl, errHandler);
        this._isPortal = true;
        this._init = true;
        this.setViewport(viewPort);
        app.viewDidLeave.subscribe((view) => {
            if (!view.isOverlay) {
                this.dismissPageChangeViews();
            }
        });
    }
    set _overlayPortal(val) {
        this._zIndexOffset = (val || 0);
    }
    ngOnDestroy() {
        this.destroy();
    }
    getType() {
        return 'portal';
    }
    getSecondaryIdentifier() {
        return null;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])('overlay-portal'),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], OverlayPortal.prototype, "_overlayPortal", null);
OverlayPortal = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[overlay-portal]',
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["v" /* Inject */])(Object(core_es5["_5" /* forwardRef */])(() => app_App))),
    Object(tslib_es6["__param"])(9, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (overlay_portal__a = typeof app_App !== "undefined" && app_App) === "function" && overlay_portal__a || Object, typeof (overlay_portal__b = typeof config_Config !== "undefined" && config_Config) === "function" && overlay_portal__b || Object, typeof (overlay_portal__c = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && overlay_portal__c || Object, typeof (_d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && _d || Object, typeof (_e = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && _e || Object, typeof (_f = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && _f || Object, typeof (_g = typeof core_es5["l" /* ComponentFactoryResolver */] !== "undefined" && core_es5["l" /* ComponentFactoryResolver */]) === "function" && _g || Object, typeof (_h = typeof GestureController !== "undefined" && GestureController) === "function" && _h || Object, typeof (_j = typeof transition_controller_TransitionController !== "undefined" && transition_controller_TransitionController) === "function" && _j || Object, typeof (_k = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && _k || Object, typeof (overlay_portal__l = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && overlay_portal__l || Object, typeof (_m = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && _m || Object, typeof (_o = typeof core_es5["q" /* ErrorHandler */] !== "undefined" && core_es5["q" /* ErrorHandler */]) === "function" && _o || Object])
], OverlayPortal);

var overlay_portal__a, overlay_portal__b, overlay_portal__c, _d, _e, _f, _g, _h, _j, _k, overlay_portal__l, _m, _o;




// CONCATENATED MODULE: ./src/components/app/app-root.ts











const AppRootToken = new core_es5["H" /* OpaqueToken */]('USERROOT');
let app_root_IonicApp = class IonicApp extends Ion {
    constructor(_userCmp, _cfr, elementRef, renderer, config, _plt, app) {
        super(config, elementRef, renderer, 'app-root');
        this._userCmp = _userCmp;
        this._cfr = _cfr;
        this._plt = _plt;
        app._appRoot = this;
        this._stopScrollPlugin = window['IonicStopScroll'];
    }
    ngOnInit() {
        const factory = this._cfr.resolveComponentFactory(this._userCmp);
        const componentRef = this._viewport.createComponent(factory);
        this._renderer.setElementClass(componentRef.location.nativeElement, 'app-root', true);
        componentRef.changeDetectorRef.detectChanges();
        this.setElementClass(this._config.get('mode'), true);
        const versions = this._plt.versions();
        this._plt.platforms().forEach(platformName => {
            let platformClass = 'platform-' + platformName;
            this.setElementClass(platformClass, true);
            let platformVersion = versions[platformName];
            if (platformVersion) {
                platformClass += platformVersion.major;
                this.setElementClass(platformClass, true);
                this.setElementClass(platformClass + '_' + platformVersion.minor, true);
            }
        });
        if (this._config.getBoolean('hoverCSS', true)) {
            this.setElementClass('enable-hover', true);
        }
        this._plt.prepareReady();
    }
    _getPortal(portal) {
        if (portal === PORTAL_LOADING) {
            return this._loadingPortal;
        }
        if (portal === PORTAL_TOAST) {
            return this._toastPortal;
        }
        if (portal === PORTAL_MODAL) {
            return this._modalPortal;
        }
        return this._overlayPortal;
    }
    _getActivePortal() {
        const defaultPortal = this._overlayPortal;
        const modalPortal = this._modalPortal;
        const hasModal = modalPortal.length() > 0;
        const hasDefault = defaultPortal.length() > 0;
        if (!hasModal && !hasDefault) {
            return null;
        }
        else if (hasModal && hasDefault) {
            var defaultIndex = defaultPortal.getActive().getZIndex();
            var modalIndex = modalPortal.getActive().getZIndex();
            if (defaultIndex > modalIndex) {
                return defaultPortal;
            }
            else {
                _assert(modalIndex > defaultIndex, 'modal and default zIndex can not be equal');
                return modalPortal;
            }
        }
        if (hasModal) {
            return modalPortal;
        }
        else if (hasDefault) {
            return defaultPortal;
        }
    }
    _disableScroll(shouldDisableScroll) {
        if (shouldDisableScroll) {
            this.stopScroll().then(() => {
                this._tmr = this._plt.timeout(() => {
                    console.debug('App Root: adding .disable-scroll');
                    this.setElementClass('disable-scroll', true);
                }, 32);
            });
        }
        else {
            let plugin = this._stopScrollPlugin;
            if (plugin && plugin.cancel) {
                plugin.cancel();
            }
            clearTimeout(this._tmr);
            console.debug('App Root: removing .disable-scroll');
            this.setElementClass('disable-scroll', false);
        }
    }
    stopScroll() {
        if (this._stopScrollPlugin) {
            return new Promise((resolve) => {
                this._stopScrollPlugin.stop(() => resolve(true));
            });
        }
        else {
            return Promise.resolve(false);
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('viewport', { read: core_es5["_0" /* ViewContainerRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (app_root__a = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && app_root__a || Object)
], app_root_IonicApp.prototype, "_viewport", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('modalPortal', { read: OverlayPortal }),
    Object(tslib_es6["__metadata"])("design:type", typeof (app_root__b = typeof OverlayPortal !== "undefined" && OverlayPortal) === "function" && app_root__b || Object)
], app_root_IonicApp.prototype, "_modalPortal", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('overlayPortal', { read: OverlayPortal }),
    Object(tslib_es6["__metadata"])("design:type", typeof (app_root__c = typeof OverlayPortal !== "undefined" && OverlayPortal) === "function" && app_root__c || Object)
], app_root_IonicApp.prototype, "_overlayPortal", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('loadingPortal', { read: OverlayPortal }),
    Object(tslib_es6["__metadata"])("design:type", typeof (app_root__d = typeof OverlayPortal !== "undefined" && OverlayPortal) === "function" && app_root__d || Object)
], app_root_IonicApp.prototype, "_loadingPortal", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('toastPortal', { read: OverlayPortal }),
    Object(tslib_es6["__metadata"])("design:type", typeof (app_root__e = typeof OverlayPortal !== "undefined" && OverlayPortal) === "function" && app_root__e || Object)
], app_root_IonicApp.prototype, "_toastPortal", void 0);
app_root_IonicApp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-app',
        template: '<div #viewport app-viewport></div>' +
            '<div #modalPortal overlay-portal></div>' +
            '<div #overlayPortal overlay-portal></div>' +
            '<div #loadingPortal class="loading-portal" overlay-portal></div>' +
            '<div #toastPortal class="toast-portal" [overlay-portal]="10000"></div>' +
            '<div class="click-block"></div>'
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["v" /* Inject */])(AppRootToken)),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object, typeof (app_root__f = typeof core_es5["l" /* ComponentFactoryResolver */] !== "undefined" && core_es5["l" /* ComponentFactoryResolver */]) === "function" && app_root__f || Object, typeof (app_root__g = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && app_root__g || Object, typeof (app_root__h = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && app_root__h || Object, typeof (app_root__j = typeof config_Config !== "undefined" && config_Config) === "function" && app_root__j || Object, typeof (app_root__k = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && app_root__k || Object, typeof (app_root__l = typeof app_App !== "undefined" && app_App) === "function" && app_root__l || Object])
], app_root_IonicApp);

var app_root__a, app_root__b, app_root__c, app_root__d, app_root__e, app_root__f, app_root__g, app_root__h, app_root__j, app_root__k, app_root__l;




// CONCATENATED MODULE: ./src/platform/key.ts
const KEY_LEFT = 37;
const KEY_UP = 38;
const KEY_RIGHT = 39;
const KEY_DOWN = 40;
const KEY_ENTER = 13;
const KEY_ESCAPE = 27;
const KEY_SPACE = 32;
const KEY_TAB = 9;
//# sourceMappingURL=key.js.map
// CONCATENATED MODULE: ./src/components/action-sheet/action-sheet-component.ts









let action_sheet_component_ActionSheetCmp = class ActionSheetCmp {
    constructor(_viewCtrl, config, _elementRef, gestureCtrl, params, renderer) {
        this._viewCtrl = _viewCtrl;
        this._elementRef = _elementRef;
        this.gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);
        this.d = params.data;
        this.mode = config.get('mode');
        renderer.setElementClass(_elementRef.nativeElement, `action-sheet-${this.mode}`, true);
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                if (cssClass.trim() !== '')
                    renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++actionSheetIds);
        if (this.d.title) {
            this.hdrId = 'acst-hdr-' + this.id;
        }
        if (this.d.subTitle) {
            this.descId = 'acst-subhdr-' + this.id;
        }
    }
    ionViewDidLoad() {
        this.d.buttons = this.d.buttons.map(button => {
            if (typeof button === 'string') {
                button = { text: button };
            }
            if (!button.cssClass) {
                button.cssClass = '';
            }
            switch (button.role) {
                case 'cancel':
                    this.cancelButton = button;
                    return null;
                case 'destructive':
                    button.cssClass = (button.cssClass + ' ' || '') + 'action-sheet-destructive';
                    break;
                case 'selected':
                    button.cssClass = (button.cssClass + ' ' || '') + 'action-sheet-selected';
                    break;
            }
            return button;
        }).filter(button => button !== null);
    }
    ionViewWillEnter() {
        this.gestureBlocker.block();
    }
    ionViewDidLeave() {
        this.gestureBlocker.unblock();
    }
    ionViewDidEnter() {
        const focusableEle = this._elementRef.nativeElement.querySelector('button');
        if (focusableEle) {
            focusableEle.focus();
        }
        this.enabled = true;
    }
    keyUp(ev) {
        if (this.enabled && ev.keyCode === KEY_ESCAPE && this._viewCtrl.isLast()) {
            console.debug('actionsheet, escape button');
            this.bdClick();
        }
    }
    click(button) {
        if (!this.enabled) {
            return;
        }
        let shouldDismiss = true;
        if (button.handler) {
            if (button.handler() === false) {
                shouldDismiss = false;
            }
        }
        if (shouldDismiss) {
            this.dismiss(button.role);
        }
    }
    bdClick() {
        if (this.enabled && this.d.enableBackdropDismiss) {
            if (this.cancelButton) {
                this.click(this.cancelButton);
            }
            else {
                this.dismiss('backdrop');
            }
        }
    }
    dismiss(role) {
        const opts = {
            minClickBlockDuration: 400
        };
        return this._viewCtrl.dismiss(null, role, opts);
    }
    ngOnDestroy() {
        _assert(this.gestureBlocker.blocked === false, 'gesture blocker must be already unblocked');
        this.d = this.cancelButton = null;
        this.gestureBlocker.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('body:keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], action_sheet_component_ActionSheetCmp.prototype, "keyUp", null);
action_sheet_component_ActionSheetCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-action-sheet',
        template: '<ion-backdrop (click)="bdClick()" [class.backdrop-no-tappable]="!d.enableBackdropDismiss"></ion-backdrop>' +
            '<div class="action-sheet-wrapper">' +
            '<div class="action-sheet-container">' +
            '<div class="action-sheet-group">' +
            '<div class="action-sheet-title" id="{{hdrId}}" *ngIf="d.title">{{d.title}}</div>' +
            '<div class="action-sheet-sub-title" id="{{descId}}" *ngIf="d.subTitle">{{d.subTitle}}</div>' +
            '<button ion-button="action-sheet-button" (click)="click(b)" *ngFor="let b of d.buttons" class="disable-hover" [attr.icon-start]="b.icon ? \'\' : null" [ngClass]="b.cssClass">' +
            '<ion-icon [name]="b.icon" *ngIf="b.icon" class="action-sheet-icon"></ion-icon>' +
            '{{b.text}}' +
            '</button>' +
            '</div>' +
            '<div class="action-sheet-group" *ngIf="cancelButton">' +
            '<button ion-button="action-sheet-button" (click)="click(cancelButton)" class="action-sheet-cancel disable-hover" [attr.icon-start]="cancelButton.icon ? \'\' : null" [ngClass]="cancelButton.cssClass">' +
            '<ion-icon [name]="cancelButton.icon" *ngIf="cancelButton.icon" class="action-sheet-icon"></ion-icon>' +
            '{{cancelButton.text}}' +
            '</button>' +
            '</div>' +
            '</div>' +
            '</div>',
        host: {
            'role': 'dialog',
            '[attr.aria-labelledby]': 'hdrId',
            '[attr.aria-describedby]': 'descId'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (action_sheet_component__a = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && action_sheet_component__a || Object, typeof (action_sheet_component__b = typeof config_Config !== "undefined" && config_Config) === "function" && action_sheet_component__b || Object, typeof (action_sheet_component__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && action_sheet_component__c || Object, typeof (action_sheet_component__d = typeof GestureController !== "undefined" && GestureController) === "function" && action_sheet_component__d || Object, typeof (action_sheet_component__e = typeof NavParams !== "undefined" && NavParams) === "function" && action_sheet_component__e || Object, typeof (action_sheet_component__f = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && action_sheet_component__f || Object])
], action_sheet_component_ActionSheetCmp);

let actionSheetIds = -1;
var action_sheet_component__a, action_sheet_component__b, action_sheet_component__c, action_sheet_component__d, action_sheet_component__e, action_sheet_component__f;




// CONCATENATED MODULE: ./src/components/action-sheet/action-sheet-transitions.ts


class action_sheet_transitions_ActionSheetSlideIn extends Transition {
    init() {
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.action-sheet-wrapper'));
        backdrop.fromTo('opacity', 0.01, 0.4);
        wrapper.fromTo('translateY', '100%', '0%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
    }
}
class action_sheet_transitions_ActionSheetSlideOut extends Transition {
    init() {
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.action-sheet-wrapper'));
        backdrop.fromTo('opacity', 0.4, 0);
        wrapper.fromTo('translateY', '0%', '100%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(300).add(backdrop).add(wrapper);
    }
}
class action_sheet_transitions_ActionSheetMdSlideIn extends Transition {
    init() {
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.action-sheet-wrapper'));
        backdrop.fromTo('opacity', 0.01, 0.26);
        wrapper.fromTo('translateY', '100%', '0%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
    }
}
class action_sheet_transitions_ActionSheetMdSlideOut extends Transition {
    init() {
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.action-sheet-wrapper'));
        backdrop.fromTo('opacity', 0.26, 0);
        wrapper.fromTo('translateY', '0%', '100%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(backdrop).add(wrapper);
    }
}
class action_sheet_transitions_ActionSheetWpSlideIn extends Transition {
    init() {
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.action-sheet-wrapper'));
        backdrop.fromTo('opacity', 0.01, 0.16);
        wrapper.fromTo('translateY', '100%', '0%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
    }
}
class action_sheet_transitions_ActionSheetWpSlideOut extends Transition {
    init() {
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.action-sheet-wrapper'));
        backdrop.fromTo('opacity', 0.1, 0);
        wrapper.fromTo('translateY', '0%', '100%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(backdrop).add(wrapper);
    }
}
//# sourceMappingURL=action-sheet-transitions.js.map
// CONCATENATED MODULE: ./src/components/action-sheet/action-sheet.ts




class action_sheet_ActionSheet extends view_controller_ViewController {
    constructor(app, opts, config) {
        opts.buttons = opts.buttons || [];
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
        super(action_sheet_component_ActionSheetCmp, opts, null);
        this._app = app;
        this.isOverlay = true;
        config.setTransition('action-sheet-slide-in', action_sheet_transitions_ActionSheetSlideIn);
        config.setTransition('action-sheet-slide-out', action_sheet_transitions_ActionSheetSlideOut);
        config.setTransition('action-sheet-md-slide-in', action_sheet_transitions_ActionSheetMdSlideIn);
        config.setTransition('action-sheet-md-slide-out', action_sheet_transitions_ActionSheetMdSlideOut);
        config.setTransition('action-sheet-wp-slide-in', action_sheet_transitions_ActionSheetWpSlideIn);
        config.setTransition('action-sheet-wp-slide-out', action_sheet_transitions_ActionSheetWpSlideOut);
    }
    getTransitionName(direction) {
        const key = 'actionSheet' + (direction === 'back' ? 'Leave' : 'Enter');
        return this._nav && this._nav.config.get(key);
    }
    setTitle(title) {
        this.data.title = title;
        return this;
    }
    setSubTitle(subTitle) {
        this.data.subTitle = subTitle;
        return this;
    }
    addButton(button) {
        this.data.buttons.push(button);
        return this;
    }
    present(navOptions = {}) {
        navOptions.minClickBlockDuration = navOptions.minClickBlockDuration || 400;
        return this._app.present(this, navOptions);
    }
}
//# sourceMappingURL=action-sheet.js.map
// CONCATENATED MODULE: ./src/components/action-sheet/action-sheet-controller.ts






let action_sheet_controller_ActionSheetController = class ActionSheetController {
    constructor(_app, config) {
        this._app = _app;
        this.config = config;
    }
    create(opts = {}) {
        return new action_sheet_ActionSheet(this._app, opts, this.config);
    }
};
action_sheet_controller_ActionSheetController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (action_sheet_controller__a = typeof app_App !== "undefined" && app_App) === "function" && action_sheet_controller__a || Object, typeof (action_sheet_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && action_sheet_controller__b || Object])
], action_sheet_controller_ActionSheetController);

var action_sheet_controller__a, action_sheet_controller__b;




// EXTERNAL MODULE: ./src/components/action-sheet/action-sheet-options.ts
var action_sheet_options = __webpack_require__(43);
var action_sheet_options_default = /*#__PURE__*/__webpack_require__.n(action_sheet_options);

// CONCATENATED MODULE: ./src/components/alert/alert-component.ts











let alert_component_AlertCmp = class AlertCmp {
    constructor(_viewCtrl, _elementRef, config, gestureCtrl, params, _renderer, _plt) {
        this._viewCtrl = _viewCtrl;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._plt = _plt;
        this.gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);
        this.d = params.data;
        this.mode = this.d.mode || config.get('mode');
        this.keyboardResizes = config.getBoolean('keyboardResizes', false);
        _renderer.setElementClass(_elementRef.nativeElement, `alert-${this.mode}`, true);
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                if (cssClass.trim() !== '')
                    _renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++alertIds);
        this.descId = '';
        this.hdrId = 'alert-hdr-' + this.id;
        this.subHdrId = 'alert-subhdr-' + this.id;
        this.msgId = 'alert-msg-' + this.id;
        this.activeId = '';
        this.lastClick = 0;
        if (this.d.message) {
            this.descId = this.msgId;
        }
        else if (this.d.subTitle) {
            this.descId = this.subHdrId;
        }
        if (!this.d.message) {
            this.d.message = '';
        }
    }
    ionViewDidLoad() {
        const data = this.d;
        data.buttons = data.buttons.map(button => {
            if (typeof button === 'string') {
                return { text: button };
            }
            return button;
        });
        data.inputs = data.inputs.map((input, index) => {
            let r = {
                type: input.type || 'text',
                name: isPresent(input.name) ? input.name : index + '',
                placeholder: isPresent(input.placeholder) ? input.placeholder : '',
                value: isPresent(input.value) ? input.value : '',
                label: input.label,
                checked: !!input.checked,
                disabled: !!input.disabled,
                id: isPresent(input.id) ? input.id : `alert-input-${this.id}-${index}`,
                handler: isPresent(input.handler) ? input.handler : null,
                min: isPresent(input.min) ? input.min : null,
                max: isPresent(input.max) ? input.max : null
            };
            return r;
        });
        const inputTypes = [];
        data.inputs.forEach(input => {
            if (inputTypes.indexOf(input.type) < 0) {
                inputTypes.push(input.type);
            }
        });
        if (inputTypes.length > 1 && (inputTypes.indexOf('checkbox') > -1 || inputTypes.indexOf('radio') > -1)) {
            console.warn(`Alert cannot mix input types: ${(inputTypes.join('/'))}. Please see alert docs for more info.`);
        }
        this.inputType = inputTypes.length ? inputTypes[0] : null;
        const checkedInput = this.d.inputs.find(input => input.checked);
        if (checkedInput) {
            this.activeId = checkedInput.id;
        }
        const hasTextInput = (this.d.inputs.length && this.d.inputs.some(i => !(NON_TEXT_INPUT_REGEX.test(i.type))));
        if (!this.keyboardResizes && hasTextInput && this._plt.is('mobile')) {
            this._renderer.setElementClass(this._elementRef.nativeElement, 'alert-top', true);
        }
    }
    ionViewWillEnter() {
        this.gestureBlocker.block();
    }
    ionViewDidLeave() {
        this.gestureBlocker.unblock();
    }
    ionViewDidEnter() {
        const focusableEle = this._elementRef.nativeElement.querySelector('input,button');
        if (focusableEle) {
            focusableEle.focus();
        }
        this.enabled = true;
    }
    keyUp(ev) {
        if (this.enabled && this._viewCtrl.isLast()) {
            if (ev.keyCode === KEY_ENTER) {
                if (this.lastClick + 1000 < Date.now()) {
                    console.debug(`alert, enter button`);
                    let button = this.d.buttons[this.d.buttons.length - 1];
                    this.btnClick(button);
                }
            }
            else if (ev.keyCode === KEY_ESCAPE) {
                console.debug(`alert, escape button`);
                this.bdClick();
            }
        }
    }
    btnClick(button) {
        if (!this.enabled) {
            return;
        }
        this.lastClick = Date.now();
        let shouldDismiss = true;
        if (button.handler) {
            if (button.handler(this.getValues()) === false) {
                shouldDismiss = false;
            }
        }
        if (shouldDismiss) {
            this.dismiss(button.role);
        }
    }
    rbClick(checkedInput) {
        if (this.enabled) {
            this.d.inputs.forEach(input => {
                input.checked = (checkedInput === input);
            });
            this.activeId = checkedInput.id;
            if (checkedInput.handler) {
                checkedInput.handler(checkedInput);
            }
        }
    }
    cbClick(checkedInput) {
        if (this.enabled) {
            checkedInput.checked = !checkedInput.checked;
            if (checkedInput.handler) {
                checkedInput.handler(checkedInput);
            }
        }
    }
    bdClick() {
        if (this.enabled && this.d.enableBackdropDismiss) {
            var cancelBtn = this.d.buttons.find(b => b.role === 'cancel');
            if (cancelBtn) {
                this.btnClick(cancelBtn);
            }
            else {
                this.dismiss('backdrop');
            }
        }
    }
    dismiss(role) {
        const opts = {
            minClickBlockDuration: 400
        };
        return this._viewCtrl.dismiss(this.getValues(), role, opts);
    }
    getValues() {
        if (this.inputType === 'radio') {
            const checkedInput = this.d.inputs.find(i => i.checked);
            return checkedInput ? checkedInput.value : undefined;
        }
        if (this.inputType === 'checkbox') {
            return this.d.inputs.filter(i => i.checked).map(i => i.value);
        }
        if (this.d.inputs.length === 0) {
            return undefined;
        }
        const values = {};
        this.d.inputs.forEach(i => {
            values[i.name] = i.value;
        });
        return values;
    }
    ngOnDestroy() {
        _assert(this.gestureBlocker.blocked === false, 'gesture blocker must be already unblocked');
        this.gestureBlocker.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('body:keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], alert_component_AlertCmp.prototype, "keyUp", null);
alert_component_AlertCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-alert',
        template: '<ion-backdrop (click)="bdClick()" [class.backdrop-no-tappable]="!d.enableBackdropDismiss"></ion-backdrop>' +
            '<div class="alert-wrapper">' +
            '<div class="alert-head">' +
            '<h2 id="{{hdrId}}" class="alert-title" *ngIf="d.title" [innerHTML]="d.title"></h2>' +
            '<h3 id="{{subHdrId}}" class="alert-sub-title" *ngIf="d.subTitle" [innerHTML]="d.subTitle"></h3>' +
            '</div>' +
            '<div id="{{msgId}}" class="alert-message" [innerHTML]="d.message"></div>' +
            '<div *ngIf="d.inputs.length" [ngSwitch]="inputType">' +
            '<ng-template ngSwitchCase="radio">' +
            '<div class="alert-radio-group" role="radiogroup" [attr.aria-labelledby]="hdrId" [attr.aria-activedescendant]="activeId">' +
            '<button ion-button="alert-radio-button" *ngFor="let i of d.inputs" (click)="rbClick(i)" [attr.aria-checked]="i.checked" [disabled]="i.disabled" [attr.id]="i.id" class="alert-tappable alert-radio" role="radio">' +
            '<div class="alert-radio-icon"><div class="alert-radio-inner"></div></div>' +
            '<div class="alert-radio-label">' +
            '{{i.label}}' +
            '</div>' +
            '</button>' +
            '</div>' +
            '</ng-template>' +
            '<ng-template ngSwitchCase="checkbox">' +
            '<div class="alert-checkbox-group">' +
            '<button ion-button="alert-checkbox-button" *ngFor="let i of d.inputs" (click)="cbClick(i)" [attr.aria-checked]="i.checked" [attr.id]="i.id" [disabled]="i.disabled" class="alert-tappable alert-checkbox" role="checkbox">' +
            '<div class="alert-checkbox-icon"><div class="alert-checkbox-inner"></div></div>' +
            '<div class="alert-checkbox-label">' +
            '{{i.label}}' +
            '</div>' +
            '</button>' +
            '</div>' +
            '</ng-template>' +
            '<ng-template ngSwitchDefault>' +
            '<div class="alert-input-group">' +
            '<div *ngFor="let i of d.inputs" class="alert-input-wrapper">' +
            '<input [placeholder]="i.placeholder" [(ngModel)]="i.value" [type]="i.type" [min]="i.min" [max]="i.max" [attr.id]="i.id" class="alert-input">' +
            '</div>' +
            '</div>' +
            '</ng-template>' +
            '</div>' +
            '<div class="alert-button-group" [ngClass]="{\'alert-button-group-vertical\':d.buttons.length>2}">' +
            '<button ion-button="alert-button" *ngFor="let b of d.buttons" (click)="btnClick(b)" [ngClass]="b.cssClass">' +
            '{{b.text}}' +
            '</button>' +
            '</div>' +
            '</div>',
        host: {
            'role': 'dialog',
            '[attr.aria-labelledby]': 'hdrId',
            '[attr.aria-describedby]': 'descId'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (alert_component__a = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && alert_component__a || Object, typeof (alert_component__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && alert_component__b || Object, typeof (alert_component__c = typeof config_Config !== "undefined" && config_Config) === "function" && alert_component__c || Object, typeof (alert_component__d = typeof GestureController !== "undefined" && GestureController) === "function" && alert_component__d || Object, typeof (alert_component__e = typeof NavParams !== "undefined" && NavParams) === "function" && alert_component__e || Object, typeof (alert_component__f = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && alert_component__f || Object, typeof (alert_component__g = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && alert_component__g || Object])
], alert_component_AlertCmp);

let alertIds = -1;
var alert_component__a, alert_component__b, alert_component__c, alert_component__d, alert_component__e, alert_component__f, alert_component__g;




// CONCATENATED MODULE: ./src/components/alert/alert-transitions.ts


class alert_transitions_AlertPopIn extends Transition {
    init() {
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.alert-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
        backdrop.fromTo('opacity', 0.01, 0.3);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class alert_transitions_AlertPopOut extends Transition {
    init() {
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.alert-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
        backdrop.fromTo('opacity', 0.3, 0);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class alert_transitions_AlertMdPopIn extends Transition {
    init() {
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.alert-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
        backdrop.fromTo('opacity', 0.01, 0.5);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class alert_transitions_AlertMdPopOut extends Transition {
    init() {
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.alert-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
        backdrop.fromTo('opacity', 0.5, 0);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class alert_transitions_AlertWpPopIn extends Transition {
    init() {
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.alert-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.3, 1);
        backdrop.fromTo('opacity', 0.01, 0.5);
        this
            .easing('cubic-bezier(0,0,0.05,1)')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class alert_transitions_AlertWpPopOut extends Transition {
    init() {
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.alert-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 1.3);
        backdrop.fromTo('opacity', 0.5, 0);
        this
            .easing('ease-out')
            .duration(150)
            .add(backdrop)
            .add(wrapper);
    }
}
//# sourceMappingURL=alert-transitions.js.map
// CONCATENATED MODULE: ./src/components/alert/alert.ts




class alert_Alert extends view_controller_ViewController {
    constructor(app, opts = {}, config) {
        opts.inputs = opts.inputs || [];
        opts.buttons = opts.buttons || [];
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
        super(alert_component_AlertCmp, opts, null);
        this._app = app;
        this.isOverlay = true;
        config.setTransition('alert-pop-in', alert_transitions_AlertPopIn);
        config.setTransition('alert-pop-out', alert_transitions_AlertPopOut);
        config.setTransition('alert-md-pop-in', alert_transitions_AlertMdPopIn);
        config.setTransition('alert-md-pop-out', alert_transitions_AlertMdPopOut);
        config.setTransition('alert-wp-pop-in', alert_transitions_AlertWpPopIn);
        config.setTransition('alert-wp-pop-out', alert_transitions_AlertWpPopOut);
    }
    getTransitionName(direction) {
        let key = (direction === 'back' ? 'alertLeave' : 'alertEnter');
        return this._nav && this._nav.config.get(key);
    }
    setTitle(title) {
        this.data.title = title;
        return this;
    }
    setSubTitle(subTitle) {
        this.data.subTitle = subTitle;
        return this;
    }
    setMessage(message) {
        this.data.message = message;
        return this;
    }
    addInput(input) {
        this.data.inputs.push(input);
        return this;
    }
    addButton(button) {
        this.data.buttons.push(button);
        return this;
    }
    setCssClass(cssClass) {
        this.data.cssClass = cssClass;
        return this;
    }
    setMode(mode) {
        this.data.mode = mode;
    }
    present(navOptions = {}) {
        navOptions.minClickBlockDuration = navOptions.minClickBlockDuration || 400;
        return this._app.present(this, navOptions);
    }
}
//# sourceMappingURL=alert.js.map
// CONCATENATED MODULE: ./src/components/alert/alert-controller.ts






let alert_controller_AlertController = class AlertController {
    constructor(_app, config) {
        this._app = _app;
        this.config = config;
    }
    create(opts = {}) {
        return new alert_Alert(this._app, opts, this.config);
    }
};
alert_controller_AlertController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (alert_controller__a = typeof app_App !== "undefined" && app_App) === "function" && alert_controller__a || Object, typeof (alert_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && alert_controller__b || Object])
], alert_controller_AlertController);

var alert_controller__a, alert_controller__b;




// EXTERNAL MODULE: ./src/components/alert/alert-options.ts
var alert_options = __webpack_require__(44);
var alert_options_default = /*#__PURE__*/__webpack_require__.n(alert_options);

// CONCATENATED MODULE: ./src/components/avatar/avatar.ts



let Avatar = class Avatar {
    constructor() {
    }
};
Avatar = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-avatar'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [])
], Avatar);





// CONCATENATED MODULE: ./src/components/backdrop/backdrop.ts



let Backdrop = class Backdrop {
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    getNativeElement() {
        return this._elementRef.nativeElement;
    }
    setElementClass(className, add) {
        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);
    }
};
Backdrop = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-backdrop',
        host: {
            'role': 'presentation',
            'tappable': '',
            'disable-activated': ''
        },
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (backdrop__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && backdrop__a || Object, typeof (backdrop__b = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && backdrop__b || Object])
], Backdrop);

var backdrop__a, backdrop__b;




// CONCATENATED MODULE: ./src/components/badge/badge.ts





let Badge = class Badge extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'badge');
    }
};
Badge = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-badge'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (badge__a = typeof config_Config !== "undefined" && config_Config) === "function" && badge__a || Object, typeof (badge__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && badge__b || Object, typeof (badge__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && badge__c || Object])
], Badge);

var badge__a, badge__b, badge__c;




// CONCATENATED MODULE: ./src/components/button/button.ts







let button_Button = class Button extends Ion {
    constructor(ionButton, config, elementRef, renderer) {
        super(config, elementRef, renderer);
        this._role = 'button';
        this._style = 'default';
        this._mode = config.get('mode');
        if (config.get('hoverCSS') === false) {
            this.setElementClass('disable-hover', true);
        }
        if (ionButton.trim().length > 0) {
            this.setRole(ionButton);
        }
    }
    set large(val) {
        this._attr('_size', 'large', val);
    }
    set small(val) {
        this._attr('_size', 'small', val);
    }
    set default(val) {
        this._attr('_size', 'default', val);
    }
    set outline(val) {
        this._attr('_style', 'outline', val);
    }
    set clear(val) {
        this._attr('_style', 'clear', val);
    }
    set solid(val) {
        this._attr('_style', 'solid', val);
    }
    set round(val) {
        this._attr('_shape', 'round', val);
    }
    set block(val) {
        this._attr('_display', 'block', val);
    }
    set full(val) {
        this._attr('_display', 'full', val);
    }
    set strong(val) {
        this._attr('_decorator', 'strong', val);
    }
    set mode(val) {
        this._assignCss(false);
        this._mode = val;
        this._assignCss(true);
    }
    _attr(type, attrName, attrValue) {
        if (type === '_style') {
            this._updateColor(this._color, false);
        }
        this._setClass(this[type], false);
        if (isTrueProperty(attrValue)) {
            this[type] = attrName;
            this._setClass(attrName, true);
        }
        else {
            this[type] = (type === '_style' ? 'default' : null);
            this._setClass(this[type], true);
        }
        if (type === '_style') {
            this._updateColor(this._color, true);
        }
    }
    set color(val) {
        this._updateColor(this._color, false);
        this._updateColor(val, true);
        this._color = val;
    }
    ngAfterContentInit() {
        this._init = true;
        this._assignCss(true);
    }
    setRole(val) {
        this._assignCss(false);
        this._role = val;
        this._assignCss(true);
    }
    _assignCss(assignCssClass) {
        let role = this._role;
        if (role) {
            this.setElementClass(role, assignCssClass);
            this.setElementClass(`${role}-${this._mode}`, assignCssClass);
            this._setClass(this._style, assignCssClass);
            this._setClass(this._shape, assignCssClass);
            this._setClass(this._display, assignCssClass);
            this._setClass(this._size, assignCssClass);
            this._setClass(this._decorator, assignCssClass);
            this._updateColor(this._color, assignCssClass);
        }
    }
    _setClass(type, assignCssClass) {
        if (type && this._init) {
            type = type.toLocaleLowerCase();
            this.setElementClass(`${this._role}-${type}`, assignCssClass);
            this.setElementClass(`${this._role}-${type}-${this._mode}`, assignCssClass);
        }
    }
    _updateColor(color, isAdd) {
        if (color && this._init) {
            let className = this._role;
            let style = this._style;
            style = (this._role !== 'bar-button' && style === 'solid' ? 'default' : style);
            className += (style !== null && style !== '' && style !== 'default' ? '-' + style.toLowerCase() : '');
            if (color !== null && color !== '') {
                this.setElementClass(`${className}-${this._mode}-${color}`, isAdd);
            }
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "large", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "small", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "default", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "outline", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "clear", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "solid", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "round", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "block", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "full", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], button_Button.prototype, "strong", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], button_Button.prototype, "mode", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], button_Button.prototype, "color", null);
button_Button = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: '[ion-button]',
        template: '<span class="button-inner">' +
            '<ng-content></ng-content>' +
            '</span>' +
            '<div class="button-effect"></div>',
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["g" /* Attribute */])('ion-button')),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String, typeof (button__a = typeof config_Config !== "undefined" && config_Config) === "function" && button__a || Object, typeof (button__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && button__b || Object, typeof (button__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && button__c || Object])
], button_Button);

var button__a, button__b, button__c;




// CONCATENATED MODULE: ./src/components/card/card.ts





let Card = class Card extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'card');
    }
};
Card = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-card'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (card__a = typeof config_Config !== "undefined" && config_Config) === "function" && card__a || Object, typeof (card__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && card__b || Object, typeof (card__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && card__c || Object])
], Card);

var card__a, card__b, card__c;




// CONCATENATED MODULE: ./src/components/card/card-content.ts





let CardContent = class CardContent extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'card-content');
    }
};
CardContent = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-card-content'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (card_content__a = typeof config_Config !== "undefined" && config_Config) === "function" && card_content__a || Object, typeof (card_content__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && card_content__b || Object, typeof (card_content__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && card_content__c || Object])
], CardContent);

var card_content__a, card_content__b, card_content__c;




// CONCATENATED MODULE: ./src/components/card/card-header.ts





let CardHeader = class CardHeader extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'card-header');
    }
};
CardHeader = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-card-header'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (card_header__a = typeof config_Config !== "undefined" && config_Config) === "function" && card_header__a || Object, typeof (card_header__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && card_header__b || Object, typeof (card_header__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && card_header__c || Object])
], CardHeader);

var card_header__a, card_header__b, card_header__c;




// CONCATENATED MODULE: ./src/components/card/card-title.ts





let CardTitle = class CardTitle extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'card-title');
    }
};
CardTitle = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-card-title'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (card_title__a = typeof config_Config !== "undefined" && config_Config) === "function" && card_title__a || Object, typeof (card_title__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && card_title__b || Object, typeof (card_title__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && card_title__c || Object])
], CardTitle);

var card_title__a, card_title__b, card_title__c;




// EXTERNAL MODULE: ./node_modules/@angular/forms/@angular/forms.es5.js
var forms_es5 = __webpack_require__(3);

// CONCATENATED MODULE: ./src/util/form.ts



let form_Form = class Form {
    constructor() {
        this._focused = null;
        this._ids = -1;
        this._inputs = [];
    }
    register(input) {
        this._inputs.push(input);
    }
    deregister(input) {
        removeArrayItem(this._inputs, input);
        this.unsetAsFocused(input);
    }
    setAsFocused(input) {
        this._focused = input;
    }
    unsetAsFocused(input) {
        if (input === this._focused) {
            this._focused = null;
        }
    }
    tabFocus(currentInput) {
        const inputs = this._inputs;
        let index = inputs.indexOf(currentInput) + 1;
        if (index > 0 && index < inputs.length) {
            var nextInput = inputs[index];
            if (nextInput !== this._focused) {
                console.debug('tabFocus, next');
                return nextInput.initFocus();
            }
        }
        index = inputs.indexOf(this._focused);
        if (index > 0) {
            var previousInput = inputs[index - 1];
            if (previousInput) {
                console.debug('tabFocus, previous');
                previousInput.initFocus();
            }
        }
    }
    nextId() {
        return ++this._ids;
    }
};
form_Form = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])()
], form_Form);

class IonicTapInput {
}
class IonicFormInput {
}




// CONCATENATED MODULE: ./src/util/debouncer.ts
class TimeoutDebouncer {
    constructor(wait) {
        this.wait = wait;
        this.timer = null;
    }
    debounce(callback) {
        this.callback = callback;
        this.schedule();
    }
    schedule() {
        this.cancel();
        if (this.wait <= 0) {
            this.callback();
        }
        else {
            this.timer = setTimeout(this.callback, this.wait);
        }
    }
    cancel() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
}
//# sourceMappingURL=debouncer.js.map
// CONCATENATED MODULE: ./src/util/base-input.ts






class base_input_BaseInput extends Ion {
    constructor(config, elementRef, renderer, name, _defaultValue, _form, _item, _ngControl) {
        super(config, elementRef, renderer, name);
        this._defaultValue = _defaultValue;
        this._form = _form;
        this._item = _item;
        this._ngControl = _ngControl;
        this._isFocus = false;
        this._disabled = false;
        this._debouncer = new TimeoutDebouncer(0);
        this._init = false;
        this._initModel = false;
        this.ionFocus = new core_es5["r" /* EventEmitter */]();
        this.ionChange = new core_es5["r" /* EventEmitter */]();
        this.ionBlur = new core_es5["r" /* EventEmitter */]();
        _form && _form.register(this);
        this._value = deepCopy(this._defaultValue);
        if (_item) {
            _assert('lbl-' + _item.id === _item.labelId, 'labelId was not calculated correctly');
            this.id = name + '-' + _item.registerInput(name);
            this._labelId = _item.labelId;
            this._item.setElementClass('item-' + name, true);
        }
        if (_ngControl) {
            _ngControl.valueAccessor = this;
        }
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(val) {
        this.setDisabledState(val);
    }
    get value() {
        return this._value;
    }
    set value(val) {
        if (this._writeValue(val)) {
            this.onChange();
            this._fireIonChange();
        }
    }
    setValue(val) {
        this.value = val;
    }
    setDisabledState(isDisabled) {
        this._disabled = isDisabled = isTrueProperty(isDisabled);
        this._item && this._item.setElementClass(`item-${this._componentName}-disabled`, isDisabled);
    }
    writeValue(val) {
        if (this._writeValue(val)) {
            if (this._initModel) {
                this._fireIonChange();
            }
            else if (this._init) {
                this._initModel = true;
            }
        }
    }
    _writeValue(val) {
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'callback should be zoned');
        if (isUndefined(val)) {
            return false;
        }
        const normalized = (val === null)
            ? deepCopy(this._defaultValue)
            : this._inputNormalize(val);
        const notUpdate = isUndefined(normalized) || !this._inputShouldChange(normalized);
        if (notUpdate) {
            return false;
        }
        console.debug('BaseInput: value changed:', normalized, this);
        this._value = normalized;
        if (this._init) {
            this._inputUpdated();
        }
        return true;
    }
    _fireIonChange() {
        if (this._init) {
            this._debouncer.debounce(() => {
                _assert(core_es5["G" /* NgZone */].isInAngularZone(), 'IonChange: should be zoned');
                this.ionChange.emit(this._inputChangeEvent());
                this._initModel = true;
            });
        }
    }
    registerOnChange(fn) {
        this._onChanged = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    _initialize() {
        if (this._init) {
            _assert(false, 'input was already initilized');
            return;
        }
        this._init = true;
        if (isPresent(this._value)) {
            this._inputUpdated();
        }
    }
    _fireFocus() {
        if (this._isFocus) {
            return;
        }
        console.debug('BaseInput: focused:', this);
        this._form && this._form.setAsFocused(this);
        this._setFocus(true);
        this.ionFocus.emit(this);
    }
    _fireBlur() {
        if (!this._isFocus) {
            return;
        }
        console.debug('BaseInput: blurred:', this);
        this._form && this._form.unsetAsFocused(this);
        this._setFocus(false);
        this._fireTouched();
        this.ionBlur.emit(this);
    }
    _fireTouched() {
        this._onTouched && this._onTouched();
    }
    _setFocus(isFocused) {
        _assert(this._init, 'component was not initialized');
        _assert(core_es5["G" /* NgZone */].isInAngularZone(), '_fireFocus: should be zoned');
        _assert(isFocused !== this._isFocus, 'bad internal state');
        this._isFocus = isFocused;
        const item = this._item;
        if (item) {
            item.setElementClass('input-has-focus', isFocused);
            item.setElementClass('item-input-has-focus', isFocused);
        }
        this._inputUpdated();
    }
    onChange() {
        this._onChanged && this._onChanged(this._inputNgModelEvent());
    }
    isFocus() {
        return this._isFocus;
    }
    hasValue() {
        const val = this._value;
        if (!isPresent(val)) {
            return false;
        }
        if (isArray(val) || isString(val)) {
            return val.length > 0;
        }
        return true;
    }
    focusNext() {
        this._form && this._form.tabFocus(this);
    }
    ngOnDestroy() {
        _assert(this._init, 'input was destroed without being initialized');
        const form = this._form;
        form && form.deregister(this);
        this._init = false;
    }
    ngAfterContentInit() {
        this._initialize();
    }
    initFocus() {
        const ele = this._elementRef.nativeElement.querySelector('button');
        ele && ele.focus();
    }
    _inputNormalize(val) {
        return val;
    }
    _inputShouldChange(val) {
        return this._value !== val;
    }
    _inputChangeEvent() {
        return this;
    }
    _inputNgModelEvent() {
        return this._value;
    }
    _inputUpdated() {
        _assert(this._init, 'component should be initialized');
        const item = this._item;
        if (item) {
            setControlCss(item, this._ngControl);
            let hasValue = this.hasValue();
            item.setElementClass('input-has-value', hasValue);
            item.setElementClass('item-input-has-value', hasValue);
        }
    }
}
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (base_input__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && base_input__a || Object)
], base_input_BaseInput.prototype, "ionFocus", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (base_input__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && base_input__b || Object)
], base_input_BaseInput.prototype, "ionChange", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (base_input__c = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && base_input__c || Object)
], base_input_BaseInput.prototype, "ionBlur", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], base_input_BaseInput.prototype, "disabled", null);
function setControlCss(element, control) {
    if (!control) {
        return;
    }
    element.setElementClass('ng-untouched', control.untouched);
    element.setElementClass('ng-touched', control.touched);
    element.setElementClass('ng-pristine', control.pristine);
    element.setElementClass('ng-dirty', control.dirty);
    element.setElementClass('ng-valid', control.valid);
    element.setElementClass('ng-invalid', !control.valid);
}
var base_input__a, base_input__b, base_input__c;




// CONCATENATED MODULE: ./src/components/icon/icon.ts






let icon_Icon = class Icon extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'icon');
        this._isActive = true;
        this._name = '';
        this._ios = '';
        this._md = '';
        this._css = '';
        this._hidden = false;
        this._iconMode = config.get('iconMode');
    }
    ngOnDestroy() {
        if (this._css) {
            this.setElementClass(this._css, false);
        }
    }
    get name() {
        return this._name;
    }
    set name(val) {
        if (!(/^md-|^ios-|^logo-/.test(val))) {
            this._name = this._iconMode + '-' + val;
        }
        else {
            this._name = val;
        }
        this.update();
    }
    get ios() {
        return this._ios;
    }
    set ios(val) {
        this._ios = val;
        this.update();
    }
    get md() {
        return this._md;
    }
    set md(val) {
        this._md = val;
        this.update();
    }
    get isActive() {
        return this._isActive;
    }
    set isActive(val) {
        this._isActive = isTrueProperty(val);
        this.update();
    }
    update() {
        let iconName;
        if (this._ios && this._iconMode === 'ios') {
            iconName = this._ios;
        }
        else if (this._md && this._iconMode === 'md') {
            iconName = this._md;
        }
        else {
            iconName = this._name;
        }
        let hidden = this._hidden = (iconName === null);
        if (hidden) {
            return;
        }
        let iconMode = iconName.split('-', 2)[0];
        if (iconMode === 'ios' &&
            !this._isActive &&
            iconName.indexOf('logo-') < 0 &&
            iconName.indexOf('-outline') < 0) {
            iconName += '-outline';
        }
        let css = 'ion-' + iconName;
        if (this._css === css) {
            return;
        }
        if (this._css) {
            this.setElementClass(this._css, false);
        }
        this._css = css;
        this.setElementClass(css, true);
        let label = iconName
            .replace('ios-', '')
            .replace('md-', '')
            .replace('-', ' ');
        this.setElementAttribute('aria-label', label);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], icon_Icon.prototype, "name", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], icon_Icon.prototype, "ios", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], icon_Icon.prototype, "md", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], icon_Icon.prototype, "isActive", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["t" /* HostBinding */])('class.hide'),
    Object(tslib_es6["__metadata"])("design:type", Boolean)
], icon_Icon.prototype, "_hidden", void 0);
icon_Icon = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-icon',
        host: {
            'role': 'img'
        }
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (icon__a = typeof config_Config !== "undefined" && config_Config) === "function" && icon__a || Object, typeof (icon__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && icon__b || Object, typeof (icon__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && icon__c || Object])
], icon_Icon);

var icon__a, icon__b, icon__c;




// CONCATENATED MODULE: ./src/components/label/label.ts






let Label = class Label extends Ion {
    constructor(config, elementRef, renderer, isFloating, isStacked, isFixed, isInset) {
        super(config, elementRef, renderer, 'label');
        this.type = (isFloating === '' ? 'floating' : (isStacked === '' ? 'stacked' : (isFixed === '' ? 'fixed' : (isInset === '' ? 'inset' : null))));
    }
    get id() {
        return this._id;
    }
    set id(val) {
        this._id = val;
        if (val) {
            this.setElementAttribute('id', val);
        }
    }
    get text() {
        return this.getNativeElement().textContent || '';
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], Label.prototype, "id", null);
Label = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-label'
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["g" /* Attribute */])('floating')),
    Object(tslib_es6["__param"])(4, Object(core_es5["g" /* Attribute */])('stacked')),
    Object(tslib_es6["__param"])(5, Object(core_es5["g" /* Attribute */])('fixed')),
    Object(tslib_es6["__param"])(6, Object(core_es5["g" /* Attribute */])('inset')),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (label__a = typeof config_Config !== "undefined" && config_Config) === "function" && label__a || Object, typeof (label__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && label__b || Object, typeof (label__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && label__c || Object, String, String, String, String])
], Label);

var label__a, label__b, label__c;




// CONCATENATED MODULE: ./src/platform/keyboard.ts








let keyboard_Keyboard = class Keyboard {
    constructor(config, _plt, _zone, _dom) {
        this._plt = _plt;
        this._zone = _zone;
        this._dom = _dom;
        this.willShow = new core_es5["r" /* EventEmitter */]();
        this.willHide = new core_es5["r" /* EventEmitter */]();
        this.didShow = new core_es5["r" /* EventEmitter */]();
        this.didHide = new core_es5["r" /* EventEmitter */]();
        this.eventsAvailable = false;
        this.focusOutline(config.get('focusOutline'));
        const win = _plt.win();
        if (config.getBoolean('keyboardResizes', false)) {
            this.listenV2(win);
        }
        else {
            this.listenV1(win);
        }
    }
    listenV2(win) {
        const platform = this._plt;
        platform.registerListener(win, 'keyboardWillShow', () => {
            this._zone.run(() => {
                this.willShow.emit();
            });
        }, { zone: false, passive: true });
        platform.registerListener(win, 'keyboardWillHide', () => {
            this._zone.run(() => {
                this.willHide.emit();
            });
        }, { zone: false, passive: true });
        platform.registerListener(win, 'keyboardDidShow', () => {
            this._zone.run(() => {
                this.didShow.emit();
            });
        }, { zone: false, passive: true });
        platform.registerListener(win, 'keyboardDidHide', () => {
            this._zone.run(() => {
                this.didHide.emit();
            });
        }, { zone: false, passive: true });
        this.eventsAvailable = true;
    }
    listenV1(win) {
        const platform = this._plt;
        platform.registerListener(win, 'native.keyboardhide', () => {
            this.blurActiveInput(true);
        }, { zone: false, passive: true });
        platform.registerListener(win, 'native.keyboardshow', () => {
            this.blurActiveInput(false);
        }, { zone: false, passive: true });
    }
    blurActiveInput(shouldBlur) {
        const platform = this._plt;
        platform.cancelTimeout(this._tmr);
        if (shouldBlur) {
            this._tmr = platform.timeout(() => {
                if (this.isOpen()) {
                    platform.focusOutActiveElement();
                }
            }, 80);
        }
    }
    isOpen() {
        return this.hasFocusedTextInput();
    }
    onClose(callback, pollingInternval = KEYBOARD_CLOSE_POLLING, pollingChecksMax = KEYBOARD_POLLING_CHECKS_MAX) {
        console.debug(`keyboard, onClose created`);
        const self = this;
        let checks = 0;
        let promise = null;
        if (!callback) {
            promise = new Promise(resolve => { callback = resolve; });
        }
        function checkKeyboard() {
            console.debug(`keyboard, isOpen: ${self.isOpen()}`);
            if (!self.isOpen() || checks > pollingChecksMax) {
                self._plt.timeout(function () {
                    self._zone.run(function () {
                        console.debug(`keyboard, closed`);
                        callback();
                    });
                }, 400);
            }
            else {
                self._plt.timeout(checkKeyboard, pollingInternval);
            }
            checks++;
        }
        self._plt.timeout(checkKeyboard, pollingInternval);
        return promise;
    }
    close() {
        this._dom.read(() => {
            if (this.isOpen()) {
                console.debug(`keyboard, close()`);
                this._dom.write(() => {
                    this._plt.focusOutActiveElement();
                });
            }
        });
    }
    focusOutline(setting) {
        const self = this;
        const platform = self._plt;
        const doc = platform.doc();
        let isKeyInputEnabled = false;
        let unRegMouse;
        let unRegTouch;
        const evOpts = { passive: true, zone: false };
        function cssClass() {
            self._dom.write(() => {
                platform.doc().body.classList[isKeyInputEnabled ? 'add' : 'remove']('focus-outline');
            });
        }
        if (setting === true) {
            isKeyInputEnabled = true;
            return cssClass();
        }
        else if (setting === false) {
            return;
        }
        function keyDown(ev) {
            if (!isKeyInputEnabled && ev.keyCode === KEY_TAB) {
                isKeyInputEnabled = true;
                enableKeyInput();
            }
        }
        function pointerDown() {
            isKeyInputEnabled = false;
            enableKeyInput();
        }
        function enableKeyInput() {
            cssClass();
            unRegMouse && unRegMouse();
            unRegTouch && unRegTouch();
            if (isKeyInputEnabled) {
                unRegMouse = platform.registerListener(doc, 'mousedown', pointerDown, evOpts);
                unRegTouch = platform.registerListener(doc, 'touchstart', pointerDown, evOpts);
            }
        }
        platform.registerListener(platform.doc(), 'keydown', keyDown, evOpts);
    }
    hasFocusedTextInput() {
        const activeEle = this._plt.getActiveElement();
        if (isTextInput(activeEle)) {
            return (activeEle.parentElement.querySelector(':focus') === activeEle);
        }
        return false;
    }
};
keyboard_Keyboard = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (keyboard__a = typeof config_Config !== "undefined" && config_Config) === "function" && keyboard__a || Object, typeof (keyboard__b = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && keyboard__b || Object, typeof (keyboard__c = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && keyboard__c || Object, typeof (keyboard__d = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && keyboard__d || Object])
], keyboard_Keyboard);

const KEYBOARD_CLOSE_POLLING = 150;
const KEYBOARD_POLLING_CHECKS_MAX = 100;
var keyboard__a, keyboard__b, keyboard__c, keyboard__d;




// CONCATENATED MODULE: ./src/util/scroll-view.ts


class scroll_view_ScrollView {
    constructor(_app, _plt, _dom) {
        this._app = _app;
        this._plt = _plt;
        this._dom = _dom;
        this.isScrolling = false;
        this.initialized = false;
        this._eventsEnabled = false;
        this._t = 0;
        this._l = 0;
        this.ev = {
            timeStamp: 0,
            scrollTop: 0,
            scrollLeft: 0,
            scrollHeight: 0,
            scrollWidth: 0,
            contentHeight: 0,
            contentWidth: 0,
            contentTop: 0,
            contentBottom: 0,
            startY: 0,
            startX: 0,
            deltaY: 0,
            deltaX: 0,
            velocityY: 0,
            velocityX: 0,
            directionY: 'down',
            directionX: null,
            domWrite: _dom.write.bind(_dom)
        };
    }
    init(ele, contentTop, contentBottom) {
        _assert(ele, 'scroll-view, element can not be null');
        this._el = ele;
        if (!this.initialized) {
            this.initialized = true;
            if (this._js) {
                this.enableJsScroll(contentTop, contentBottom);
            }
            else {
                this.enableNativeScrolling();
            }
        }
    }
    enableEvents() {
        this._eventsEnabled = true;
    }
    setScrolling(isScrolling, ev) {
        if (this.isScrolling) {
            if (isScrolling) {
                this.onScroll && this.onScroll(ev);
            }
            else {
                this.isScrolling = false;
                this.onScrollEnd && this.onScrollEnd(ev);
            }
        }
        else if (isScrolling) {
            this.isScrolling = true;
            this.onScrollStart && this.onScrollStart(ev);
        }
    }
    enableNativeScrolling() {
        _assert(this.onScrollStart, 'onScrollStart is not defined');
        _assert(this.onScroll, 'onScroll is not defined');
        _assert(this.onScrollEnd, 'onScrollEnd is not defined');
        this._js = false;
        if (!this._el) {
            return;
        }
        console.debug(`ScrollView, enableNativeScrolling`);
        const self = this;
        const ev = self.ev;
        const positions = [];
        function scrollCallback(scrollEvent) {
            self._app.setScrolling();
            if (!self._eventsEnabled) {
                return;
            }
            ev.timeStamp = scrollEvent.timeStamp;
            if (!ev.timeStamp) {
                ev.timeStamp = Date.now();
            }
            ev.scrollTop = self.getTop();
            ev.scrollLeft = self.getLeft();
            if (!self.isScrolling) {
                ev.startY = ev.scrollTop;
                ev.startX = ev.scrollLeft;
                ev.velocityY = ev.velocityX = 0;
                ev.deltaY = ev.deltaX = 0;
                positions.length = 0;
            }
            positions.push(ev.scrollTop, ev.scrollLeft, ev.timeStamp);
            if (positions.length > 3) {
                ev.deltaY = (ev.scrollTop - ev.startY);
                ev.deltaX = (ev.scrollLeft - ev.startX);
                var endPos = (positions.length - 1);
                var startPos = endPos;
                var timeRange = (ev.timeStamp - 100);
                for (var i = endPos; i > 0 && positions[i] > timeRange; i -= 3) {
                    startPos = i;
                }
                if (startPos !== endPos) {
                    var movedTop = (positions[startPos - 2] - positions[endPos - 2]);
                    var movedLeft = (positions[startPos - 1] - positions[endPos - 1]);
                    var factor = FRAME_MS / (positions[endPos] - positions[startPos]);
                    ev.velocityY = movedTop * factor;
                    ev.velocityX = movedLeft * factor;
                    ev.directionY = (movedTop > 0 ? 'up' : 'down');
                    ev.directionX = (movedLeft > 0 ? 'left' : 'right');
                }
            }
            function scrollEnd() {
                ev.velocityY = ev.velocityX = 0;
                self.setScrolling(false, ev);
                self._endTmr = null;
            }
            self.setScrolling(true, ev);
            self._dom.cancel(self._endTmr);
            self._endTmr = self._dom.read(scrollEnd, SCROLL_END_DEBOUNCE_MS);
        }
        self._lsn && self._lsn();
        self._lsn = self._plt.registerListener(self._el, 'scroll', scrollCallback, EVENT_OPTS);
    }
    enableJsScroll(contentTop, contentBottom) {
        const self = this;
        self._js = true;
        const ele = self._el;
        if (!ele) {
            return;
        }
        console.debug(`ScrollView, enableJsScroll`);
        const ev = self.ev;
        const positions = [];
        let rafCancel;
        let max;
        function setMax() {
            if (!max) {
                max = ele.scrollHeight - ele.parentElement.offsetHeight + contentTop + contentBottom;
            }
        }
        function jsScrollDecelerate(timeStamp) {
            ev.timeStamp = timeStamp;
            console.debug(`scroll-view, decelerate, velocity: ${ev.velocityY}`);
            if (ev.velocityY) {
                ev.velocityY *= DECELERATION_FRICTION;
                setMax();
                self._t = Math.min(Math.max(self._t + ev.velocityY, 0), max);
                ev.scrollTop = self._t;
                self.onScroll(ev);
                self._dom.write(() => {
                    self.setTop(self._t);
                    if (self._t > 0 && self._t < max && Math.abs(ev.velocityY) > MIN_VELOCITY_CONTINUE_DECELERATION) {
                        rafCancel = self._dom.read(rafTimeStamp => {
                            jsScrollDecelerate(rafTimeStamp);
                        });
                    }
                    else {
                        self.isScrolling = false;
                        ev.velocityY = ev.velocityX = 0;
                        self.onScrollEnd(ev);
                    }
                });
            }
        }
        function jsScrollTouchStart(touchEvent) {
            positions.length = 0;
            max = null;
            self._dom.cancel(rafCancel);
            positions.push(pointerCoord(touchEvent).y, touchEvent.timeStamp);
        }
        function jsScrollTouchMove(touchEvent) {
            if (!positions.length) {
                return;
            }
            ev.timeStamp = touchEvent.timeStamp;
            var y = pointerCoord(touchEvent).y;
            setMax();
            self._t -= (y - positions[positions.length - 2]);
            self._t = Math.min(Math.max(self._t, 0), max);
            positions.push(y, ev.timeStamp);
            if (!self.isScrolling) {
                ev.startY = self._t;
                ev.velocityY = ev.deltaY = 0;
                self.isScrolling = true;
                self.onScrollStart(ev);
            }
            self._dom.write(() => {
                self.setTop(self._t);
            });
        }
        function jsScrollTouchEnd(touchEvent) {
            self._dom.cancel(rafCancel);
            if (!positions.length && self.isScrolling) {
                self.isScrolling = false;
                ev.velocityY = ev.velocityX = 0;
                self.onScrollEnd(ev);
                return;
            }
            var y = pointerCoord(touchEvent).y;
            positions.push(y, touchEvent.timeStamp);
            var endPos = (positions.length - 1);
            var startPos = endPos;
            var timeRange = (touchEvent.timeStamp - 100);
            for (var i = endPos; i > 0 && positions[i] > timeRange; i -= 2) {
                startPos = i;
            }
            if (startPos !== endPos) {
                var timeOffset = (positions[endPos] - positions[startPos]);
                var movedTop = (positions[startPos - 1] - positions[endPos - 1]);
                ev.velocityY = ((movedTop / timeOffset) * FRAME_MS);
                if (Math.abs(ev.velocityY) > MIN_VELOCITY_START_DECELERATION) {
                    setMax();
                    rafCancel = self._dom.read((rafTimeStamp) => {
                        jsScrollDecelerate(rafTimeStamp);
                    });
                }
            }
            else {
                self.isScrolling = false;
                ev.velocityY = 0;
                self.onScrollEnd(ev);
            }
            positions.length = 0;
        }
        const plt = self._plt;
        const unRegStart = plt.registerListener(ele, 'touchstart', jsScrollTouchStart, EVENT_OPTS);
        const unRegMove = plt.registerListener(ele, 'touchmove', jsScrollTouchMove, EVENT_OPTS);
        const unRegEnd = plt.registerListener(ele, 'touchend', jsScrollTouchEnd, EVENT_OPTS);
        ele.parentElement.classList.add('js-scroll');
        self._lsn && self._lsn();
        self._lsn = () => {
            unRegStart();
            unRegMove();
            unRegEnd();
            ele.parentElement.classList.remove('js-scroll');
        };
    }
    getTop() {
        if (this._js) {
            return this._t;
        }
        return this._t = this._el.scrollTop;
    }
    getLeft() {
        if (this._js) {
            return 0;
        }
        return this._l = this._el.scrollLeft;
    }
    setTop(top) {
        this._t = top;
        if (this._js) {
            this._el.style[this._plt.Css.transform] = `translate3d(${this._l * -1}px,${top * -1}px,0px)`;
        }
        else {
            this._el.scrollTop = top;
        }
    }
    setLeft(left) {
        this._l = left;
        if (this._js) {
            this._el.style[this._plt.Css.transform] = `translate3d(${left * -1}px,${this._t * -1}px,0px)`;
        }
        else {
            this._el.scrollLeft = left;
        }
    }
    scrollTo(x, y, duration, done) {
        let promise;
        if (done === undefined) {
            promise = new Promise(resolve => {
                done = resolve;
            });
        }
        const self = this;
        const el = self._el;
        if (!el) {
            done();
            return promise;
        }
        if (duration < 32) {
            self.setTop(y);
            self.setLeft(x);
            done();
            return promise;
        }
        const fromY = el.scrollTop;
        const fromX = el.scrollLeft;
        const maxAttempts = (duration / 16) + 100;
        const transform = self._plt.Css.transform;
        let startTime;
        let attempts = 0;
        let stopScroll = false;
        function step(timeStamp) {
            attempts++;
            if (!self._el || stopScroll || attempts > maxAttempts) {
                self.setScrolling(false, null);
                el.style[transform] = '';
                done();
                return;
            }
            let time = Math.min(1, ((timeStamp - startTime) / duration));
            let easedT = (--time) * time * time + 1;
            if (fromY !== y) {
                self.setTop((easedT * (y - fromY)) + fromY);
            }
            if (fromX !== x) {
                self.setLeft(Math.floor((easedT * (x - fromX)) + fromX));
            }
            if (easedT < 1) {
                self._plt.raf(step);
            }
            else {
                stopScroll = true;
                self.setScrolling(false, null);
                el.style[transform] = '';
                done();
            }
        }
        self.setScrolling(true, null);
        self.isScrolling = true;
        self._dom.write(timeStamp => {
            startTime = timeStamp;
            step(timeStamp);
        }, 16);
        return promise;
    }
    scrollToTop(duration) {
        return this.scrollTo(0, 0, duration);
    }
    scrollToBottom(duration) {
        let y = 0;
        if (this._el) {
            y = this._el.scrollHeight - this._el.clientHeight;
        }
        return this.scrollTo(0, y, duration);
    }
    stop() {
        this.setScrolling(false, null);
    }
    destroy() {
        this.stop();
        this._endTmr && this._dom.cancel(this._endTmr);
        this._lsn && this._lsn();
        let ev = this.ev;
        ev.domWrite = ev.contentElement = ev.fixedElement = ev.scrollElement = ev.headerElement = null;
        this._lsn = this._el = this._dom = this.ev = ev = null;
        this.onScrollStart = this.onScroll = this.onScrollEnd = null;
    }
}
const SCROLL_END_DEBOUNCE_MS = 80;
const MIN_VELOCITY_START_DECELERATION = 4;
const MIN_VELOCITY_CONTINUE_DECELERATION = 0.12;
const DECELERATION_FRICTION = 0.97;
const FRAME_MS = (1000 / 60);
const EVENT_OPTS = {
    passive: true,
    zone: false
};
//# sourceMappingURL=scroll-view.js.map
// CONCATENATED MODULE: ./src/components/content/content.ts
















class EventEmitterProxy extends core_es5["r" /* EventEmitter */] {
    subscribe(generatorOrNext, error, complete) {
        this.onSubscribe();
        return super.subscribe(generatorOrNext, error, complete);
    }
}
let content_Content = class Content extends Ion {
    constructor(config, _plt, _dom, elementRef, renderer, _app, _keyboard, _zone, viewCtrl, navCtrl) {
        super(config, elementRef, renderer, 'content');
        this._plt = _plt;
        this._dom = _dom;
        this._app = _app;
        this._keyboard = _keyboard;
        this._zone = _zone;
        this._scrollPadding = 0;
        this._inputPolling = false;
        this._hasRefresher = false;
        this._imgs = [];
        this._scrollDownOnLoad = false;
        this.ionScrollStart = new EventEmitterProxy();
        this.ionScroll = new EventEmitterProxy();
        this.ionScrollEnd = new EventEmitterProxy();
        const enableScrollListener = () => this._scroll.enableEvents();
        this.ionScroll.onSubscribe = enableScrollListener;
        this.ionScrollStart.onSubscribe = enableScrollListener;
        this.ionScrollEnd.onSubscribe = enableScrollListener;
        this.statusbarPadding = config.getBoolean('statusbarPadding', false);
        this._imgReqBfr = config.getNumber('imgRequestBuffer', 1400);
        this._imgRndBfr = config.getNumber('imgRenderBuffer', 400);
        this._imgVelMax = config.getNumber('imgVelocityMax', 3);
        this._scroll = new scroll_view_ScrollView(_app, _plt, _dom);
        while (navCtrl) {
            if (isTabs(navCtrl)) {
                this._tabs = navCtrl;
                break;
            }
            navCtrl = navCtrl.parent;
        }
        if (viewCtrl) {
            viewCtrl._setIONContent(this);
            viewCtrl._setIONContentRef(elementRef);
            this._viewCtrlReadSub = viewCtrl.readReady.subscribe(() => {
                this._viewCtrlReadSub.unsubscribe();
                this._readDimensions();
            });
            this._viewCtrlWriteSub = viewCtrl.writeReady.subscribe(() => {
                this._viewCtrlWriteSub.unsubscribe();
                this._writeDimensions();
            });
        }
        else {
            _dom.read(this._readDimensions.bind(this));
            _dom.write(this._writeDimensions.bind(this));
        }
    }
    get contentHeight() {
        return this._scroll.ev.contentHeight;
    }
    get contentWidth() {
        return this._scroll.ev.contentWidth;
    }
    get scrollHeight() {
        return this._scroll.ev.scrollHeight;
    }
    get scrollWidth() {
        return this._scroll.ev.scrollWidth;
    }
    get scrollTop() {
        return this._scroll.ev.scrollTop;
    }
    set scrollTop(top) {
        this._scroll.setTop(top);
    }
    get scrollLeft() {
        return this._scroll.ev.scrollLeft;
    }
    set scrollLeft(top) {
        this._scroll.setLeft(top);
    }
    get isScrolling() {
        return this._scroll.isScrolling;
    }
    get directionY() {
        return this._scroll.ev.directionY;
    }
    get directionX() {
        return this._scroll.ev.directionX;
    }
    ngAfterViewInit() {
        _assert(this.getFixedElement(), 'fixed element was not found');
        _assert(this.getScrollElement(), 'scroll element was not found');
        const scroll = this._scroll;
        scroll.ev.fixedElement = this.getFixedElement();
        scroll.ev.scrollElement = this.getScrollElement();
        scroll.onScrollStart = (ev) => {
            this.ionScrollStart.emit(ev);
        };
        scroll.onScroll = (ev) => {
            this.ionScroll.emit(ev);
            this.imgsUpdate();
        };
        scroll.onScrollEnd = (ev) => {
            this.ionScrollEnd.emit(ev);
            this.imgsUpdate();
        };
    }
    enableJsScroll() {
        this._scroll.enableJsScroll(this._cTop, this._cBottom);
    }
    ngOnDestroy() {
        this._scLsn && this._scLsn();
        this._viewCtrlReadSub && this._viewCtrlReadSub.unsubscribe();
        this._viewCtrlWriteSub && this._viewCtrlWriteSub.unsubscribe();
        this._viewCtrlReadSub = this._viewCtrlWriteSub = null;
        this._scroll && this._scroll.destroy();
        this._footerEle = this._scLsn = this._scroll = null;
    }
    getScrollElement() {
        return this._scrollContent.nativeElement;
    }
    getFixedElement() {
        return this._fixedContent.nativeElement;
    }
    onScrollElementTransitionEnd(callback) {
        this._plt.transitionEnd(this.getScrollElement(), callback);
    }
    scrollTo(x, y, duration = 300, done) {
        console.debug(`content, scrollTo started, y: ${y}, duration: ${duration}`);
        return this._scroll.scrollTo(x, y, duration, done);
    }
    scrollToTop(duration = 300) {
        console.debug(`content, scrollToTop, duration: ${duration}`);
        return this._scroll.scrollToTop(duration);
    }
    scrollToBottom(duration = 300) {
        console.debug(`content, scrollToBottom, duration: ${duration}`);
        return this._scroll.scrollToBottom(duration);
    }
    get fullscreen() {
        return this._fullscreen;
    }
    set fullscreen(val) {
        this._fullscreen = isTrueProperty(val);
    }
    get scrollDownOnLoad() {
        return this._scrollDownOnLoad;
    }
    set scrollDownOnLoad(val) {
        this._scrollDownOnLoad = isTrueProperty(val);
    }
    addImg(img) {
        this._imgs.push(img);
    }
    removeImg(img) {
        removeArrayItem(this._imgs, img);
    }
    setScrollElementStyle(prop, val) {
        const scrollEle = this.getScrollElement();
        if (scrollEle) {
            this._dom.write(() => {
                scrollEle.style[prop] = val;
            });
        }
    }
    getContentDimensions() {
        const scrollEle = this.getScrollElement();
        const parentElement = scrollEle.parentElement;
        return {
            contentHeight: parentElement.offsetHeight - this._cTop - this._cBottom,
            contentTop: this._cTop,
            contentBottom: this._cBottom,
            contentWidth: parentElement.offsetWidth,
            contentLeft: parentElement.offsetLeft,
            scrollHeight: scrollEle.scrollHeight,
            scrollTop: scrollEle.scrollTop,
            scrollWidth: scrollEle.scrollWidth,
            scrollLeft: scrollEle.scrollLeft,
        };
    }
    addScrollPadding(newPadding) {
        _assert(typeof this._scrollPadding === 'number', '_scrollPadding must be a number');
        if (newPadding > this._scrollPadding) {
            console.debug(`content, addScrollPadding, newPadding: ${newPadding}, this._scrollPadding: ${this._scrollPadding}`);
            this._scrollPadding = newPadding;
            var scrollEle = this.getScrollElement();
            if (scrollEle) {
                this._dom.write(() => {
                    scrollEle.style.paddingBottom = (newPadding > 0) ? newPadding + 'px' : '';
                });
            }
        }
    }
    clearScrollPaddingFocusOut() {
        if (!this._inputPolling) {
            console.debug(`content, clearScrollPaddingFocusOut begin`);
            this._inputPolling = true;
            this._keyboard.onClose(() => {
                console.debug(`content, clearScrollPaddingFocusOut _keyboard.onClose`);
                this._inputPolling = false;
                this._scrollPadding = -1;
                this.addScrollPadding(0);
            }, 200, 3000);
        }
    }
    resize() {
        this._dom.read(this._readDimensions.bind(this));
        this._dom.write(this._writeDimensions.bind(this));
    }
    _readDimensions() {
        const cachePaddingTop = this._pTop;
        const cachePaddingRight = this._pRight;
        const cachePaddingBottom = this._pBottom;
        const cachePaddingLeft = this._pLeft;
        const cacheHeaderHeight = this._hdrHeight;
        const cacheFooterHeight = this._ftrHeight;
        const cacheTabsPlacement = this._tabsPlacement;
        let tabsTop = 0;
        let scrollEvent;
        this._pTop = 0;
        this._pRight = 0;
        this._pBottom = 0;
        this._pLeft = 0;
        this._hdrHeight = 0;
        this._ftrHeight = 0;
        this._tabsPlacement = null;
        this._tTop = 0;
        this._fTop = 0;
        this._fBottom = 0;
        if (!this._scroll) {
            return;
        }
        scrollEvent = this._scroll.ev;
        let ele = this.getNativeElement();
        if (!ele) {
            _assert(false, 'ele should be valid');
            return;
        }
        let computedStyle;
        let tagName;
        let parentEle = ele.parentElement;
        let children = parentEle.children;
        for (var i = children.length - 1; i >= 0; i--) {
            ele = children[i];
            tagName = ele.tagName;
            if (tagName === 'ION-CONTENT') {
                scrollEvent.contentElement = ele;
                if (this._fullscreen) {
                    computedStyle = getComputedStyle(ele);
                    this._pTop = parsePxUnit(computedStyle.paddingTop);
                    this._pBottom = parsePxUnit(computedStyle.paddingBottom);
                    this._pRight = parsePxUnit(computedStyle.paddingRight);
                    this._pLeft = parsePxUnit(computedStyle.paddingLeft);
                }
            }
            else if (tagName === 'ION-HEADER') {
                scrollEvent.headerElement = ele;
                this._hdrHeight = ele.clientHeight;
            }
            else if (tagName === 'ION-FOOTER') {
                scrollEvent.footerElement = ele;
                this._ftrHeight = ele.clientHeight;
                this._footerEle = ele;
            }
        }
        ele = parentEle;
        let tabbarEle;
        while (ele && ele.tagName !== 'ION-MODAL' && !ele.classList.contains('tab-subpage')) {
            if (ele.tagName === 'ION-TABS') {
                tabbarEle = ele.firstElementChild;
                this._tabbarHeight = tabbarEle.clientHeight;
                if (this._tabsPlacement === null) {
                    this._tabsPlacement = ele.getAttribute('tabsplacement');
                }
            }
            ele = ele.parentElement;
        }
        if (this._tabs && this._tabsPlacement === 'top') {
            this._tTop = this._hdrHeight;
            tabsTop = this._tabs._top;
        }
        this._cTop = this._hdrHeight;
        this._cBottom = this._ftrHeight;
        if (this._tabsPlacement === 'top') {
            this._cTop += this._tabbarHeight;
        }
        else if (this._tabsPlacement === 'bottom') {
            this._cBottom += this._tabbarHeight;
        }
        if (this._hasRefresher) {
            this._cTop -= 1;
        }
        this._fTop = this._cTop;
        this._fBottom = this._cBottom;
        if (this._fullscreen) {
            this._cTop += this._pTop;
            this._cBottom += this._pBottom;
        }
        const contentDimensions = this.getContentDimensions();
        scrollEvent.scrollHeight = contentDimensions.scrollHeight;
        scrollEvent.scrollWidth = contentDimensions.scrollWidth;
        scrollEvent.contentHeight = contentDimensions.contentHeight;
        scrollEvent.contentWidth = contentDimensions.contentWidth;
        scrollEvent.contentTop = contentDimensions.contentTop;
        scrollEvent.contentBottom = contentDimensions.contentBottom;
        this._dirty = (cachePaddingTop !== this._pTop ||
            cachePaddingBottom !== this._pBottom ||
            cachePaddingLeft !== this._pLeft ||
            cachePaddingRight !== this._pRight ||
            cacheHeaderHeight !== this._hdrHeight ||
            cacheFooterHeight !== this._ftrHeight ||
            cacheTabsPlacement !== this._tabsPlacement ||
            tabsTop !== this._tTop ||
            this._cTop !== this.contentTop ||
            this._cBottom !== this.contentBottom);
        this._scroll.init(this.getScrollElement(), this._cTop, this._cBottom);
        this.imgsUpdate();
    }
    _writeDimensions() {
        if (!this._dirty) {
            console.debug('Skipping writeDimensions');
            return;
        }
        const scrollEle = this.getScrollElement();
        if (!scrollEle) {
            _assert(false, 'this.getScrollElement() should be valid');
            return;
        }
        const fixedEle = this.getFixedElement();
        if (!fixedEle) {
            _assert(false, 'this._fixedEle should be valid');
            return;
        }
        if (this._tabsPlacement === 'bottom' && this._cBottom > 0 && this._footerEle) {
            var footerPos = this._cBottom - this._ftrHeight;
            _assert(footerPos >= 0, 'footerPos has to be positive');
            this._footerEle.style.bottom = cssFormat(footerPos);
        }
        let topProperty = 'marginTop';
        let bottomProperty = 'marginBottom';
        let fixedTop = this._fTop;
        let fixedBottom = this._fBottom;
        if (this._fullscreen) {
            _assert(this._pTop >= 0, '_paddingTop has to be positive');
            _assert(this._pBottom >= 0, '_paddingBottom has to be positive');
            topProperty = 'paddingTop';
            bottomProperty = 'paddingBottom';
        }
        if (this._cTop !== this.contentTop) {
            _assert(this._cTop >= 0, 'contentTop has to be positive');
            _assert(fixedTop >= 0, 'fixedTop has to be positive');
            scrollEle.style[topProperty] = cssFormat(this._cTop);
            fixedEle.style.marginTop = cssFormat(fixedTop);
            this.contentTop = this._cTop;
        }
        if (this._cBottom !== this.contentBottom) {
            _assert(this._cBottom >= 0, 'contentBottom has to be positive');
            _assert(fixedBottom >= 0, 'fixedBottom has to be positive');
            scrollEle.style[bottomProperty] = cssFormat(this._cBottom);
            fixedEle.style.marginBottom = cssFormat(fixedBottom);
            this.contentBottom = this._cBottom;
        }
        if (this._tabsPlacement !== null && this._tabs) {
            if (this._tabsPlacement === 'top') {
                this._tabs.setTabbarPosition(this._tTop, -1);
            }
            else {
                _assert(this._tabsPlacement === 'bottom', 'tabsPlacement should be bottom');
                this._tabs.setTabbarPosition(-1, 0);
            }
        }
        if (this._scrollDownOnLoad) {
            this.scrollToBottom(0);
            this._scrollDownOnLoad = false;
        }
    }
    imgsUpdate() {
        if (this._scroll.initialized && this._imgs.length && this.isImgsUpdatable()) {
            updateImgs(this._imgs, this.scrollTop, this.contentHeight, this.directionY, this._imgReqBfr, this._imgRndBfr);
        }
    }
    isImgsUpdatable() {
        return Math.abs(this._scroll.ev.velocityY) < this._imgVelMax;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('fixedContent', { read: core_es5["p" /* ElementRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (content__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && content__a || Object)
], content_Content.prototype, "_fixedContent", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('scrollContent', { read: core_es5["p" /* ElementRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (content__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && content__b || Object)
], content_Content.prototype, "_scrollContent", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", EventEmitterProxy)
], content_Content.prototype, "ionScrollStart", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", EventEmitterProxy)
], content_Content.prototype, "ionScroll", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", EventEmitterProxy)
], content_Content.prototype, "ionScrollEnd", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], content_Content.prototype, "fullscreen", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], content_Content.prototype, "scrollDownOnLoad", null);
content_Content = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-content',
        template: '<div class="fixed-content" #fixedContent>' +
            '<ng-content select="[ion-fixed],ion-fab"></ng-content>' +
            '</div>' +
            '<div class="scroll-content" #scrollContent>' +
            '<ng-content></ng-content>' +
            '</div>' +
            '<ng-content select="ion-refresher"></ng-content>',
        host: {
            '[class.statusbar-padding]': 'statusbarPadding',
            '[class.has-refresher]': '_hasRefresher'
        },
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None
    }),
    Object(tslib_es6["__param"])(8, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(9, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (content__c = typeof config_Config !== "undefined" && config_Config) === "function" && content__c || Object, typeof (content__d = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && content__d || Object, typeof (content__e = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && content__e || Object, typeof (content__f = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && content__f || Object, typeof (content__g = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && content__g || Object, typeof (content__h = typeof app_App !== "undefined" && app_App) === "function" && content__h || Object, typeof (content__j = typeof keyboard_Keyboard !== "undefined" && keyboard_Keyboard) === "function" && content__j || Object, typeof (content__k = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && content__k || Object, typeof (content__l = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && content__l || Object, typeof (content__m = typeof NavController !== "undefined" && NavController) === "function" && content__m || Object])
], content_Content);

function updateImgs(imgs, viewableTop, contentHeight, scrollDirectionY, requestableBuffer, renderableBuffer) {
    const viewableBottom = (viewableTop + contentHeight);
    const priority1 = [];
    const priority2 = [];
    let img;
    for (var i = 0, ilen = imgs.length; i < ilen; i++) {
        img = imgs[i];
        if (scrollDirectionY === 'up') {
            if (img.top < viewableBottom && img.bottom > viewableTop - renderableBuffer) {
                img.canRequest = img.canRender = true;
                priority1.push(img);
                continue;
            }
            if (img.bottom <= viewableTop && img.bottom > viewableTop - requestableBuffer) {
                img.canRequest = true;
                img.canRender = false;
                priority2.push(img);
                continue;
            }
            if (img.top >= viewableBottom && img.top < viewableBottom + renderableBuffer) {
                img.canRequest = img.canRender = false;
                continue;
            }
        }
        else {
            if (img.bottom > viewableTop && img.top < viewableBottom + renderableBuffer) {
                img.canRequest = img.canRender = true;
                priority1.push(img);
                continue;
            }
            if (img.top >= viewableBottom && img.top < viewableBottom + requestableBuffer) {
                img.canRequest = true;
                img.canRender = false;
                priority2.push(img);
                continue;
            }
            if (img.bottom <= viewableTop && img.bottom > viewableTop - renderableBuffer) {
                img.canRequest = img.canRender = false;
                continue;
            }
        }
        img.canRequest = img.canRender = false;
        img.reset();
    }
    priority1.sort(sortTopToBottom).forEach(i => i.update());
    if (scrollDirectionY === 'up') {
        priority2.sort(sortTopToBottom).reverse().forEach(i => i.update());
    }
    else {
        priority2.sort(sortTopToBottom).forEach(i => i.update());
    }
}
function sortTopToBottom(a, b) {
    if (a.top < b.top) {
        return -1;
    }
    if (a.top > b.top) {
        return 1;
    }
    return 0;
}
function parsePxUnit(val) {
    return (val.indexOf('px') > 0) ? parseInt(val, 10) : 0;
}
function cssFormat(val) {
    return (val > 0 ? val + 'px' : '');
}
var content__a, content__b, content__c, content__d, content__e, content__f, content__g, content__h, content__j, content__k, content__l, content__m;




// CONCATENATED MODULE: ./src/components/item/item-reorder-util.ts
function indexForItem(element) {
    return element['$ionIndex'];
}
function reorderListForItem(element) {
    return element['$ionReorderList'];
}
function findReorderItem(node, listNode) {
    let nested = 0;
    while (node && nested < 4) {
        if (indexForItem(node) !== undefined) {
            if (listNode && node.parentNode !== listNode) {
                return null;
            }
            return node;
        }
        node = node.parentNode;
        nested++;
    }
    return null;
}
//# sourceMappingURL=item-reorder-util.js.map
// CONCATENATED MODULE: ./src/components/item/item-reorder-gesture.ts



class item_reorder_gesture_ItemReorderGesture {
    constructor(plt, reorderList) {
        this.plt = plt;
        this.reorderList = reorderList;
        this.selectedItemEle = null;
        this.events = new ui_event_manager_UIEventManager(plt);
        this.events.pointerEvents({
            element: this.reorderList.getNativeElement(),
            pointerDown: this.onDragStart.bind(this),
            pointerMove: this.onDragMove.bind(this),
            pointerUp: this.onDragEnd.bind(this),
            zone: false
        });
    }
    onDragStart(ev) {
        if (this.selectedItemEle) {
            return false;
        }
        let reorderElement = ev.target;
        if (reorderElement.nodeName !== 'ION-REORDER') {
            return false;
        }
        let reorderMark = reorderElement['$ionComponent'];
        if (!reorderMark) {
            console.error('ion-reorder does not contain $ionComponent');
            return false;
        }
        this.reorderList._reorderPrepare();
        const item = reorderMark.getReorderNode();
        if (!item) {
            console.error('reorder node not found');
            return false;
        }
        ev.preventDefault();
        this.selectedItemEle = item;
        this.selectedItemHeight = item.offsetHeight;
        this.lastYcoord = -100;
        this.lastToIndex = indexForItem(item);
        this.windowHeight = this.plt.height() - AUTO_SCROLL_MARGIN;
        this.lastScrollPosition = this.reorderList._scrollContent(0);
        this.offset = pointerCoord(ev);
        this.offset.y += this.lastScrollPosition;
        item.classList.add(ITEM_REORDER_ACTIVE);
        this.reorderList._reorderStart();
        return true;
    }
    onDragMove(ev) {
        const selectedItem = this.selectedItemEle;
        if (!selectedItem) {
            return;
        }
        ev.preventDefault();
        const coord = pointerCoord(ev);
        const posY = coord.y;
        const scrollPosition = this.scroll(posY);
        if (Math.abs(posY - this.lastYcoord) > 30) {
            var overItem = this.itemForCoord(coord);
            if (overItem) {
                var toIndex = indexForItem(overItem);
                if (toIndex !== undefined && (toIndex !== this.lastToIndex || this.emptyZone)) {
                    var fromIndex = indexForItem(selectedItem);
                    this.lastToIndex = toIndex;
                    this.lastYcoord = posY;
                    this.emptyZone = false;
                    this.reorderList._reorderMove(fromIndex, toIndex, this.selectedItemHeight);
                }
            }
            else {
                this.emptyZone = true;
            }
        }
        const ydiff = Math.round(posY - this.offset.y + scrollPosition);
        selectedItem.style[this.plt.Css.transform] = `translateY(${ydiff}px)`;
    }
    onDragEnd(ev) {
        const selectedItem = this.selectedItemEle;
        if (!selectedItem) {
            return;
        }
        if (ev) {
            ev.preventDefault();
            ev.stopPropagation();
        }
        const toIndex = this.lastToIndex;
        const fromIndex = indexForItem(selectedItem);
        const reorderInactive = () => {
            this.selectedItemEle.style.transition = '';
            this.selectedItemEle.classList.remove(ITEM_REORDER_ACTIVE);
            this.selectedItemEle = null;
        };
        if (toIndex === fromIndex) {
            selectedItem.style.transition = 'transform 200ms ease-in-out';
            setTimeout(reorderInactive, 200);
        }
        else {
            reorderInactive();
        }
        this.reorderList._reorderEmit(fromIndex, toIndex);
    }
    itemForCoord(coord) {
        const sideOffset = this.reorderList._isStart === this.plt.isRTL ? -100 : 100;
        const x = this.offset.x + sideOffset;
        const y = coord.y;
        const element = this.plt.getElementFromPoint(x, y);
        return findReorderItem(element, this.reorderList.getNativeElement());
    }
    scroll(posY) {
        if (posY < AUTO_SCROLL_MARGIN) {
            this.lastScrollPosition = this.reorderList._scrollContent(-SCROLL_JUMP);
        }
        else if (posY > this.windowHeight) {
            this.lastScrollPosition = this.reorderList._scrollContent(SCROLL_JUMP);
        }
        return this.lastScrollPosition;
    }
    destroy() {
        this.onDragEnd(null);
        this.events.destroy();
        this.events = null;
        this.reorderList = null;
    }
}
const AUTO_SCROLL_MARGIN = 60;
const SCROLL_JUMP = 10;
const ITEM_REORDER_ACTIVE = 'reorder-active';
//# sourceMappingURL=item-reorder-gesture.js.map
// CONCATENATED MODULE: ./src/components/item/item-reorder.ts









class item_reorder_ReorderIndexes {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
    applyTo(array) {
        reorderArray(array, this);
    }
}
let item_reorder_ItemReorder = class ItemReorder {
    constructor(_plt, _dom, elementRef, _rendered, _zone, _content) {
        this._plt = _plt;
        this._dom = _dom;
        this._rendered = _rendered;
        this._zone = _zone;
        this._content = _content;
        this._enableReorder = false;
        this._visibleReorder = false;
        this._isStart = false;
        this._lastToIndex = -1;
        this.ionItemReorder = new core_es5["r" /* EventEmitter */]();
        this._element = elementRef.nativeElement;
    }
    set side(side) {
        this._isStart = side === 'start';
    }
    ngOnDestroy() {
        this._element = null;
        this._reorderGesture && this._reorderGesture.destroy();
    }
    get reorder() {
        return this._enableReorder;
    }
    set reorder(val) {
        let enabled = isTrueProperty(val);
        if (!enabled && this._reorderGesture) {
            this._reorderGesture.destroy();
            this._reorderGesture = null;
            this._visibleReorder = false;
            setTimeout(() => this._enableReorder = false, 400);
        }
        else if (enabled && !this._reorderGesture) {
            console.debug('enableReorderItems');
            this._reorderGesture = new item_reorder_gesture_ItemReorderGesture(this._plt, this);
            this._enableReorder = true;
            this._dom.write(() => {
                this._zone.run(() => {
                    this._visibleReorder = true;
                });
            }, 16);
        }
    }
    _reorderPrepare() {
        let ele = this._element;
        let children = ele.children;
        for (let i = 0, ilen = children.length; i < ilen; i++) {
            var child = children[i];
            child.$ionIndex = i;
            child.$ionReorderList = ele;
        }
    }
    _reorderStart() {
        this.setElementClass('reorder-list-active', true);
    }
    _reorderEmit(fromIndex, toIndex) {
        this._reorderReset();
        if (fromIndex !== toIndex) {
            this._zone.run(() => {
                const indexes = new item_reorder_ReorderIndexes(fromIndex, toIndex);
                this.ionItemReorder.emit(indexes);
            });
        }
    }
    _scrollContent(scroll) {
        const scrollTop = this._content.scrollTop + scroll;
        if (scroll !== 0) {
            this._content.scrollTo(0, scrollTop, 0);
        }
        return scrollTop;
    }
    _reorderReset() {
        let children = this._element.children;
        let len = children.length;
        this.setElementClass('reorder-list-active', false);
        let transform = this._plt.Css.transform;
        for (let i = 0; i < len; i++) {
            children[i].style[transform] = '';
        }
        this._lastToIndex = -1;
    }
    _reorderMove(fromIndex, toIndex, itemHeight) {
        if (this._lastToIndex === -1) {
            this._lastToIndex = fromIndex;
        }
        let lastToIndex = this._lastToIndex;
        this._lastToIndex = toIndex;
        let children = this._element.children;
        let transform = this._plt.Css.transform;
        if (toIndex >= lastToIndex) {
            for (let i = lastToIndex; i <= toIndex; i++) {
                if (i !== fromIndex) {
                    children[i].style[transform] = (i > fromIndex)
                        ? `translateY(${-itemHeight}px)` : '';
                }
            }
        }
        if (toIndex <= lastToIndex) {
            for (let i = toIndex; i <= lastToIndex; i++) {
                if (i !== fromIndex) {
                    children[i].style[transform] = (i < fromIndex)
                        ? `translateY(${itemHeight}px)` : '';
                }
            }
        }
    }
    setElementClass(classname, add) {
        this._rendered.setElementClass(this._element, classname, add);
    }
    getNativeElement() {
        return this._element;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (item_reorder__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && item_reorder__a || Object)
], item_reorder_ItemReorder.prototype, "ionItemReorder", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])('side'),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], item_reorder_ItemReorder.prototype, "side", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], item_reorder_ItemReorder.prototype, "reorder", null);
item_reorder_ItemReorder = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-list[reorder],ion-item-group[reorder]',
        host: {
            '[class.reorder-enabled]': '_enableReorder',
            '[class.reorder-visible]': '_visibleReorder',
            '[class.reorder-side-start]': '_isStart'
        }
    }),
    Object(tslib_es6["__param"])(5, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item_reorder__b = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && item_reorder__b || Object, typeof (item_reorder__c = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && item_reorder__c || Object, typeof (item_reorder__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && item_reorder__d || Object, typeof (item_reorder__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && item_reorder__e || Object, typeof (item_reorder__f = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && item_reorder__f || Object, typeof (item_reorder__g = typeof content_Content !== "undefined" && content_Content) === "function" && item_reorder__g || Object])
], item_reorder_ItemReorder);

var item_reorder__a, item_reorder__b, item_reorder__c, item_reorder__d, item_reorder__e, item_reorder__f, item_reorder__g;




// CONCATENATED MODULE: ./src/components/item/item.ts











let Item = class Item extends Ion {
    constructor(form, config, elementRef, renderer, reorder) {
        super(config, elementRef, renderer, 'item');
        this._ids = -1;
        this._inputs = [];
        this._viewLabel = true;
        this._name = 'item';
        this.labelId = null;
        this._setName(elementRef);
        this._hasReorder = !!reorder;
        this.id = form.nextId().toString();
        this.labelId = 'lbl-' + this.id;
        if (!renderer.orgListen) {
            renderer.orgListen = renderer.listen;
            renderer.listen = function (renderElement, name, callback) {
                if (name === 'click' && renderElement.setAttribute) {
                    renderElement.setAttribute('tappable', '');
                }
                return renderer.orgListen(renderElement, name, callback);
            };
        }
    }
    registerInput(type) {
        this._inputs.push(type);
        return this.id + '-' + (++this._ids);
    }
    ngAfterContentInit() {
        if (this._viewLabel && this._inputs.length) {
            let labelText = this.getLabelText().trim();
            this._viewLabel = (labelText.length > 0);
        }
        if (this._inputs.length > 1) {
            this.setElementClass('item-multiple-inputs', true);
        }
    }
    _updateColor(newColor, componentName) {
        componentName = componentName || 'item';
        this._setColor(newColor, componentName);
    }
    _setName(elementRef) {
        let nodeName = elementRef.nativeElement.nodeName.replace('ION-', '');
        if (nodeName === 'LIST-HEADER' || nodeName === 'ITEM-DIVIDER') {
            this._name = nodeName;
        }
    }
    getLabelText() {
        return this._label ? this._label.text : '';
    }
    set contentLabel(label) {
        if (label) {
            this._label = label;
            label.id = this.labelId;
            if (label.type) {
                this.setElementClass('item-label-' + label.type, true);
            }
            this._viewLabel = false;
        }
    }
    set viewLabel(label) {
        if (!this._label) {
            this._label = label;
        }
    }
    set _buttons(buttons) {
        buttons.forEach(button => {
            if (!button._size) {
                button.setElementClass('item-button', true);
            }
        });
    }
    set _icons(icons) {
        icons.forEach(icon => {
            icon.setElementClass('item-icon', true);
        });
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(Label),
    Object(tslib_es6["__metadata"])("design:type", typeof (item__a = typeof Label !== "undefined" && Label) === "function" && item__a || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item__b = typeof Label !== "undefined" && Label) === "function" && item__b || Object])
], Item.prototype, "contentLabel", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])(Label),
    Object(tslib_es6["__metadata"])("design:type", typeof (item__c = typeof Label !== "undefined" && Label) === "function" && item__c || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item__d = typeof Label !== "undefined" && Label) === "function" && item__d || Object])
], Item.prototype, "viewLabel", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(button_Button),
    Object(tslib_es6["__metadata"])("design:type", typeof (item__e = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && item__e || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item__f = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && item__f || Object])
], Item.prototype, "_buttons", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(icon_Icon),
    Object(tslib_es6["__metadata"])("design:type", typeof (item__g = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && item__g || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item__h = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && item__h || Object])
], Item.prototype, "_icons", null);
Item = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-list-header,ion-item,[ion-item],ion-item-divider',
        template: '<ng-content select="[item-start],[item-left],ion-checkbox:not([item-end]):not([item-right])"></ng-content>' +
            '<div class="item-inner">' +
            '<div class="input-wrapper">' +
            '<ng-content select="ion-label"></ng-content>' +
            '<ion-label *ngIf="_viewLabel">' +
            '<ng-content></ng-content>' +
            '</ion-label>' +
            '<ng-content select="ion-select,ion-input,ion-textarea,ion-datetime,ion-range,[item-content]"></ng-content>' +
            '</div>' +
            '<ng-content select="[item-end],[item-right],ion-radio,ion-toggle"></ng-content>' +
            '<ion-reorder *ngIf="_hasReorder"></ion-reorder>' +
            '</div>' +
            '<div class="button-effect"></div>',
        host: {
            'class': 'item'
        },
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(4, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item__j = typeof form_Form !== "undefined" && form_Form) === "function" && item__j || Object, typeof (item__k = typeof config_Config !== "undefined" && config_Config) === "function" && item__k || Object, typeof (item__l = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && item__l || Object, typeof (item__m = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && item__m || Object, typeof (item__o = typeof item_reorder_ItemReorder !== "undefined" && item_reorder_ItemReorder) === "function" && item__o || Object])
], Item);

var item__a, item__b, item__c, item__d, item__e, item__f, item__g, item__h, item__j, item__k, item__l, item__m, item__o;




// CONCATENATED MODULE: ./src/components/checkbox/checkbox.ts










let checkbox_Checkbox = Checkbox_1 = class Checkbox extends base_input_BaseInput {
    constructor(config, form, item, elementRef, renderer) {
        super(config, elementRef, renderer, 'checkbox', false, form, item, null);
    }
    get checked() {
        return this.value;
    }
    set checked(val) {
        this.value = val;
    }
    _click(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.value = !this.value;
        this._fireTouched();
    }
    _inputNormalize(val) {
        return isTrueProperty(val);
    }
    _inputUpdated() {
        this._item && this._item.setElementClass('item-checkbox-checked', this._value);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], checkbox_Checkbox.prototype, "checked", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], checkbox_Checkbox.prototype, "_click", null);
checkbox_Checkbox = Checkbox_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-checkbox',
        template: '<div class="checkbox-icon" [class.checkbox-checked]="_value">' +
            '<div class="checkbox-inner"></div>' +
            '</div>' +
            '<button role="checkbox" ' +
            'type="button" ' +
            'ion-button="item-cover" ' +
            '[id]="id" ' +
            '[attr.aria-checked]="_value" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.aria-disabled]="_disabled" ' +
            'class="item-cover"> ' +
            '</button>',
        host: {
            '[class.checkbox-disabled]': '_disabled'
        },
        providers: [{ provide: forms_es5["e" /* NG_VALUE_ACCESSOR */], useExisting: Checkbox_1, multi: true }],
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(2, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (checkbox__a = typeof config_Config !== "undefined" && config_Config) === "function" && checkbox__a || Object, typeof (checkbox__b = typeof form_Form !== "undefined" && form_Form) === "function" && checkbox__b || Object, typeof (checkbox__c = typeof Item !== "undefined" && Item) === "function" && checkbox__c || Object, typeof (checkbox__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && checkbox__d || Object, typeof (checkbox__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && checkbox__e || Object])
], checkbox_Checkbox);

var Checkbox_1, checkbox__a, checkbox__b, checkbox__c, checkbox__d, checkbox__e;




// CONCATENATED MODULE: ./src/components/chip/chip.ts





let Chip = class Chip extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'chip');
    }
};
Chip = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-chip'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (chip__a = typeof config_Config !== "undefined" && config_Config) === "function" && chip__a || Object, typeof (chip__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && chip__b || Object, typeof (chip__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && chip__c || Object])
], Chip);

var chip__a, chip__b, chip__c;




// CONCATENATED MODULE: ./src/tap-click/haptic.ts




let Haptic = class Haptic {
    constructor(plt) {
        if (plt) {
            plt.ready().then(() => {
                this._p = plt.win().TapticEngine;
            });
        }
    }
    available() {
        return !!this._p;
    }
    selection() {
        this._p && this._p.selection();
    }
    gestureSelectionStart() {
        this._p && this._p.gestureSelectionStart();
    }
    gestureSelectionChanged() {
        this._p && this._p.gestureSelectionChanged();
    }
    gestureSelectionEnd() {
        this._p && this._p.gestureSelectionEnd();
    }
    notification(options) {
        this._p && this._p.notification(options);
    }
    impact(options) {
        this._p && this._p.impact(options);
    }
};
Haptic = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (haptic__a = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && haptic__a || Object])
], Haptic);

var haptic__a;




// CONCATENATED MODULE: ./src/components/picker/picker-options.ts
const PICKER_OPT_SELECTED = 'picker-opt-selected';
const picker_options_DECELERATION_FRICTION = 0.97;
const picker_options_FRAME_MS = (1000 / 60);
const MAX_PICKER_SPEED = 60;
//# sourceMappingURL=picker-options.js.map
// CONCATENATED MODULE: ./src/components/picker/picker-column.ts











let picker_column_PickerColumnCmp = class PickerColumnCmp {
    constructor(config, _plt, elementRef, _zone, _haptic, plt, domCtrl) {
        this._plt = _plt;
        this.elementRef = elementRef;
        this._zone = _zone;
        this._haptic = _haptic;
        this.y = 0;
        this.pos = [];
        this.startY = null;
        this.ionChange = new core_es5["r" /* EventEmitter */]();
        this.events = new ui_event_manager_UIEventManager(plt);
        this.rotateFactor = config.getNumber('pickerRotateFactor', 0);
        this.scaleFactor = config.getNumber('pickerScaleFactor', 1);
        this.decelerateFunc = this.decelerate.bind(this);
        this.debouncer = domCtrl.debouncer();
    }
    ngAfterViewInit() {
        let colEle = this.colEle.nativeElement;
        this.colHeight = colEle.clientHeight;
        this.optHeight = (colEle.firstElementChild ? colEle.firstElementChild.clientHeight : 0);
        this.events.pointerEvents({
            element: this.elementRef.nativeElement,
            pointerDown: this.pointerStart.bind(this),
            pointerMove: this.pointerMove.bind(this),
            pointerUp: this.pointerEnd.bind(this),
            capture: true,
            zone: false
        });
    }
    ngOnDestroy() {
        this._plt.cancelRaf(this.rafId);
        this.events.destroy();
    }
    pointerStart(ev) {
        console.debug('picker, pointerStart', ev.type, this.startY);
        this._haptic.gestureSelectionStart();
        ev.preventDefault();
        this._plt.cancelRaf(this.rafId);
        this.startY = pointerCoord(ev).y;
        this.velocity = 0;
        this.pos.length = 0;
        this.pos.push(this.startY, Date.now());
        let options = this.col.options;
        let minY = (options.length - 1);
        let maxY = 0;
        for (var i = 0; i < options.length; i++) {
            if (!options[i].disabled) {
                minY = Math.min(minY, i);
                maxY = Math.max(maxY, i);
            }
        }
        this.minY = (minY * this.optHeight * -1);
        this.maxY = (maxY * this.optHeight * -1);
        return true;
    }
    pointerMove(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        let currentY = pointerCoord(ev).y;
        this.pos.push(currentY, Date.now());
        this.debouncer.write(() => {
            if (this.startY === null) {
                return;
            }
            let y = this.y + (currentY - this.startY);
            if (y > this.minY) {
                y = Math.pow(y, 0.8);
                this.bounceFrom = y;
            }
            else if (y < this.maxY) {
                y += Math.pow(this.maxY - y, 0.9);
                this.bounceFrom = y;
            }
            else {
                this.bounceFrom = 0;
            }
            this.update(y, 0, false, false);
            let currentIndex = Math.max(Math.abs(Math.round(y / this.optHeight)), 0);
            if (currentIndex !== this.lastTempIndex) {
                this._haptic.gestureSelectionChanged();
                this.lastTempIndex = currentIndex;
            }
        });
    }
    pointerEnd(ev) {
        ev.preventDefault();
        this.debouncer.cancel();
        if (this.startY === null) {
            return;
        }
        console.debug('picker, pointerEnd', ev.type);
        this.velocity = 0;
        if (this.bounceFrom > 0) {
            this.update(this.minY, 100, true, true);
            return;
        }
        else if (this.bounceFrom < 0) {
            this.update(this.maxY, 100, true, true);
            return;
        }
        let endY = pointerCoord(ev).y;
        this.pos.push(endY, Date.now());
        let endPos = (this.pos.length - 1);
        let startPos = endPos;
        let timeRange = (Date.now() - 100);
        for (var i = endPos; i > 0 && this.pos[i] > timeRange; i -= 2) {
            startPos = i;
        }
        if (startPos !== endPos) {
            var timeOffset = (this.pos[endPos] - this.pos[startPos]);
            var movedTop = (this.pos[startPos - 1] - this.pos[endPos - 1]);
            var velocity = ((movedTop / timeOffset) * picker_options_FRAME_MS);
            this.velocity = clamp(-MAX_PICKER_SPEED, velocity, MAX_PICKER_SPEED);
        }
        if (Math.abs(endY - this.startY) > 3) {
            var y = this.y + (endY - this.startY);
            this.update(y, 0, true, true);
        }
        this.startY = null;
        this.decelerate();
    }
    decelerate() {
        let y = 0;
        if (isNaN(this.y) || !this.optHeight) {
            this.update(y, 0, true, true);
            this._haptic.gestureSelectionEnd();
        }
        else if (Math.abs(this.velocity) > 0) {
            this.velocity *= picker_options_DECELERATION_FRICTION;
            this.velocity = (this.velocity > 0)
                ? Math.max(this.velocity, 1)
                : Math.min(this.velocity, -1);
            y = Math.round(this.y - this.velocity);
            if (y > this.minY) {
                y = this.minY;
                this.velocity = 0;
            }
            else if (y < this.maxY) {
                y = this.maxY;
                this.velocity = 0;
            }
            var notLockedIn = (y % this.optHeight !== 0 || Math.abs(this.velocity) > 1);
            this.update(y, 0, true, !notLockedIn);
            if (notLockedIn) {
                this.rafId = this._plt.raf(this.decelerateFunc);
            }
        }
        else if (this.y % this.optHeight !== 0) {
            var currentPos = Math.abs(this.y % this.optHeight);
            this.velocity = (currentPos > (this.optHeight / 2) ? 1 : -1);
            this._haptic.gestureSelectionEnd();
            this.decelerate();
        }
        let currentIndex = Math.max(Math.abs(Math.round(y / this.optHeight)), 0);
        if (currentIndex !== this.lastTempIndex) {
            this._haptic.gestureSelectionChanged();
        }
        this.lastTempIndex = currentIndex;
    }
    optClick(ev, index) {
        if (!this.velocity) {
            ev.preventDefault();
            ev.stopPropagation();
            this.setSelected(index, 150);
        }
    }
    setSelected(selectedIndex, duration) {
        let y = (selectedIndex > -1) ? ((selectedIndex * this.optHeight) * -1) : 0;
        this._plt.cancelRaf(this.rafId);
        this.velocity = 0;
        this.update(y, duration, true, true);
    }
    update(y, duration, saveY, emitChange) {
        y = Math.round(y);
        let i;
        let button;
        let opt;
        let optOffset;
        let visible;
        let translateX;
        let translateY;
        let translateZ;
        let rotateX;
        let transform;
        let selected;
        const parent = this.colEle.nativeElement;
        const children = parent.children;
        const length = children.length;
        const selectedIndex = this.col.selectedIndex = Math.min(Math.max(Math.round(-y / this.optHeight), 0), length - 1);
        const durationStr = (duration === 0) ? null : duration + 'ms';
        const scaleStr = `scale(${this.scaleFactor})`;
        for (i = 0; i < length; i++) {
            button = children[i];
            opt = this.col.options[i];
            optOffset = (i * this.optHeight) + y;
            visible = true;
            transform = '';
            if (this.rotateFactor !== 0) {
                rotateX = optOffset * this.rotateFactor;
                if (Math.abs(rotateX) > 90) {
                    visible = false;
                }
                else {
                    translateX = 0;
                    translateY = 0;
                    translateZ = 90;
                    transform = `rotateX(${rotateX}deg) `;
                }
            }
            else {
                translateX = 0;
                translateZ = 0;
                translateY = optOffset;
                if (Math.abs(translateY) > 170) {
                    visible = false;
                }
            }
            selected = selectedIndex === i;
            if (visible) {
                transform += `translate3d(0px,${translateY}px,${translateZ}px) `;
                if (this.scaleFactor !== 1 && !selected) {
                    transform += scaleStr;
                }
            }
            else {
                transform = 'translate3d(-9999px,0px,0px)';
            }
            if (duration !== opt._dur) {
                opt._dur = duration;
                button.style[this._plt.Css.transitionDuration] = durationStr;
            }
            if (transform !== opt._trans) {
                opt._trans = transform;
                button.style[this._plt.Css.transform] = transform;
            }
            if (selected !== opt._selected) {
                opt._selected = selected;
                if (selected) {
                    button.classList.add(PICKER_OPT_SELECTED);
                }
                else {
                    button.classList.remove(PICKER_OPT_SELECTED);
                }
            }
        }
        this.col.prevSelected = selectedIndex;
        if (saveY) {
            this.y = y;
        }
        if (emitChange) {
            if (this.lastIndex === undefined) {
                this.lastIndex = this.col.selectedIndex;
            }
            else if (this.lastIndex !== this.col.selectedIndex) {
                this.lastIndex = this.col.selectedIndex;
                var ionChange = this.ionChange;
                if (ionChange.observers.length > 0) {
                    this._zone.run(ionChange.emit.bind(ionChange, this.col.options[this.col.selectedIndex]));
                }
            }
        }
    }
    refresh() {
        let min = this.col.options.length - 1;
        let max = 0;
        const options = this.col.options;
        for (var i = 0; i < options.length; i++) {
            if (!options[i].disabled) {
                min = Math.min(min, i);
                max = Math.max(max, i);
            }
        }
        const selectedIndex = clamp(min, this.col.selectedIndex, max);
        if (this.col.prevSelected !== selectedIndex) {
            var y = (selectedIndex * this.optHeight) * -1;
            this._plt.cancelRaf(this.rafId);
            this.velocity = 0;
            this.update(y, 150, true, false);
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('colEle'),
    Object(tslib_es6["__metadata"])("design:type", typeof (picker_column__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && picker_column__a || Object)
], picker_column_PickerColumnCmp.prototype, "colEle", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (picker_column__b = typeof /* Cannot get final name for export "PickerColumn" in "./src/components/picker/picker-options.ts" (known exports: PICKER_OPT_SELECTED DECELERATION_FRICTION FRAME_MS MAX_PICKER_SPEED, known reexports: ) */ undefined !== "undefined" && /* Cannot get final name for export "PickerColumn" in "./src/components/picker/picker-options.ts" (known exports: PICKER_OPT_SELECTED DECELERATION_FRICTION FRAME_MS MAX_PICKER_SPEED, known reexports: ) */ undefined) === "function" && picker_column__b || Object)
], picker_column_PickerColumnCmp.prototype, "col", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (picker_column__c = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && picker_column__c || Object)
], picker_column_PickerColumnCmp.prototype, "ionChange", void 0);
picker_column_PickerColumnCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: '.picker-col',
        template: '<div *ngIf="col.prefix" class="picker-prefix" [style.width]="col.prefixWidth">{{col.prefix}}</div>' +
            '<div class="picker-opts" #colEle [style.max-width]="col.optionsWidth">' +
            '<button *ngFor="let o of col.options; let i=index"' +
            '[class.picker-opt-disabled]="o.disabled" ' +
            'class="picker-opt" disable-activated (click)="optClick($event, i)">' +
            '{{o.text}}' +
            '</button>' +
            '</div>' +
            '<div *ngIf="col.suffix" class="picker-suffix" [style.width]="col.suffixWidth">{{col.suffix}}</div>',
        host: {
            '[style.max-width]': 'col.columnWidth',
            '[class.picker-opts-left]': 'col.align=="left"',
            '[class.picker-opts-right]': 'col.align=="right"',
        }
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (picker_column__d = typeof config_Config !== "undefined" && config_Config) === "function" && picker_column__d || Object, typeof (picker_column__e = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && picker_column__e || Object, typeof (picker_column__f = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && picker_column__f || Object, typeof (picker_column__g = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && picker_column__g || Object, typeof (picker_column__h = typeof Haptic !== "undefined" && Haptic) === "function" && picker_column__h || Object, typeof (picker_column__j = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && picker_column__j || Object, typeof (picker_column__k = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && picker_column__k || Object])
], picker_column_PickerColumnCmp);

var picker_column__a, picker_column__b, picker_column__c, picker_column__d, picker_column__e, picker_column__f, picker_column__g, picker_column__h, picker_column__j, picker_column__k;




// CONCATENATED MODULE: ./src/components/picker/picker-component.ts










let picker_component_PickerCmp = class PickerCmp {
    constructor(_viewCtrl, _elementRef, config, gestureCtrl, params, renderer) {
        this._viewCtrl = _viewCtrl;
        this._elementRef = _elementRef;
        this._gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);
        this.d = params.data;
        this.mode = config.get('mode');
        renderer.setElementClass(_elementRef.nativeElement, `picker-${this.mode}`, true);
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++pickerIds);
        this.lastClick = 0;
    }
    ionViewWillLoad() {
        let data = this.d;
        data.buttons = data.buttons.map(button => {
            if (isString(button)) {
                return { text: button };
            }
            if (button.role) {
                button.cssRole = `picker-toolbar-${button.role}`;
            }
            return button;
        });
        data.columns = data.columns.map(column => {
            if (!isPresent(column.options)) {
                column.options = [];
            }
            column.selectedIndex = column.selectedIndex || 0;
            column.options = column.options.map(inputOpt => {
                let opt = {
                    text: '',
                    value: '',
                    disabled: inputOpt.disabled,
                };
                if (isPresent(inputOpt)) {
                    if (isString(inputOpt) || isNumber(inputOpt)) {
                        opt.text = inputOpt.toString();
                        opt.value = inputOpt;
                    }
                    else {
                        opt.text = isPresent(inputOpt.text) ? inputOpt.text : inputOpt.value;
                        opt.value = isPresent(inputOpt.value) ? inputOpt.value : inputOpt.text;
                    }
                }
                return opt;
            });
            return column;
        });
    }
    ionViewDidLoad() {
        this.refresh();
    }
    ionViewWillEnter() {
        this._gestureBlocker.block();
    }
    ionViewDidLeave() {
        this._gestureBlocker.unblock();
    }
    refresh() {
        this._cols.forEach(column => column.refresh());
    }
    _colChange() {
        var picker = this._viewCtrl;
        picker.ionChange.emit(this.getSelected());
    }
    _keyUp(ev) {
        if (this.enabled && this._viewCtrl.isLast()) {
            if (ev.keyCode === KEY_ENTER) {
                if (this.lastClick + 1000 < Date.now()) {
                    console.debug('picker, enter button');
                    let button = this.d.buttons[this.d.buttons.length - 1];
                    this.btnClick(button);
                }
            }
            else if (ev.keyCode === KEY_ESCAPE) {
                console.debug('picker, escape button');
                this.bdClick();
            }
        }
    }
    ionViewDidEnter() {
        let focusableEle = this._elementRef.nativeElement.querySelector('button');
        if (focusableEle) {
            focusableEle.focus();
        }
        this.enabled = true;
    }
    btnClick(button) {
        if (!this.enabled) {
            return;
        }
        this.lastClick = Date.now();
        let shouldDismiss = true;
        if (button.handler) {
            if (button.handler(this.getSelected()) === false) {
                shouldDismiss = false;
            }
        }
        if (shouldDismiss) {
            this.dismiss(button.role);
        }
    }
    bdClick() {
        if (this.enabled && this.d.enableBackdropDismiss) {
            let cancelBtn = this.d.buttons.find(b => b.role === 'cancel');
            if (cancelBtn) {
                this.btnClick(cancelBtn);
            }
            else {
                this.dismiss('backdrop');
            }
        }
    }
    dismiss(role) {
        return this._viewCtrl.dismiss(this.getSelected(), role);
    }
    getSelected() {
        let selected = {};
        this.d.columns.forEach((col, index) => {
            let selectedColumn = col.options[col.selectedIndex];
            selected[col.name] = {
                text: selectedColumn ? selectedColumn.text : null,
                value: selectedColumn ? selectedColumn.value : null,
                columnIndex: index,
            };
        });
        return selected;
    }
    ngOnDestroy() {
        _assert(this._gestureBlocker.blocked === false, 'gesture blocker must be already unblocked');
        this._gestureBlocker.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Z" /* ViewChildren */])(picker_column_PickerColumnCmp),
    Object(tslib_es6["__metadata"])("design:type", typeof (picker_component__a = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && picker_component__a || Object)
], picker_component_PickerCmp.prototype, "_cols", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('body:keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], picker_component_PickerCmp.prototype, "_keyUp", null);
picker_component_PickerCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-picker-cmp',
        template: `
    <ion-backdrop (click)="bdClick()"></ion-backdrop>
    <div class="picker-wrapper">
      <div class="picker-toolbar">
        <div *ngFor="let b of d.buttons" class="picker-toolbar-button" [ngClass]="b.cssRole">
          <button ion-button (click)="btnClick(b)" [ngClass]="b.cssClass" class="picker-button" clear>
            {{b.text}}
          </button>
        </div>
      </div>
      <div class="picker-columns">
        <div class="picker-above-highlight"></div>
        <div *ngFor="let c of d.columns" [col]="c" class="picker-col" (ionChange)="_colChange($event)"></div>
        <div class="picker-below-highlight"></div>
      </div>
    </div>
  `,
        host: {
            'role': 'dialog'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (picker_component__b = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && picker_component__b || Object, typeof (picker_component__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && picker_component__c || Object, typeof (picker_component__d = typeof config_Config !== "undefined" && config_Config) === "function" && picker_component__d || Object, typeof (picker_component__e = typeof GestureController !== "undefined" && GestureController) === "function" && picker_component__e || Object, typeof (picker_component__f = typeof NavParams !== "undefined" && NavParams) === "function" && picker_component__f || Object, typeof (picker_component__g = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && picker_component__g || Object])
], picker_component_PickerCmp);

let pickerIds = -1;
var picker_component__a, picker_component__b, picker_component__c, picker_component__d, picker_component__e, picker_component__f, picker_component__g;




// CONCATENATED MODULE: ./src/components/picker/picker-transitions.ts


class picker_transitions_PickerSlideIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.picker-wrapper'));
        backdrop.fromTo('opacity', 0.01, 0.26);
        wrapper.fromTo('translateY', '100%', '0%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
    }
}
class picker_transitions_PickerSlideOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.picker-wrapper'));
        backdrop.fromTo('opacity', 0.26, 0);
        wrapper.fromTo('translateY', '0%', '100%');
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(backdrop).add(wrapper);
    }
}
//# sourceMappingURL=picker-transitions.js.map
// CONCATENATED MODULE: ./src/components/picker/picker.ts







class picker_Picker extends view_controller_ViewController {
    constructor(app, opts = {}, config) {
        if (!opts) {
            opts = {};
        }
        opts.columns = opts.columns || [];
        opts.buttons = opts.buttons || [];
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? Boolean(opts.enableBackdropDismiss) : true;
        super(picker_component_PickerCmp, opts, null);
        this._app = app;
        this.isOverlay = true;
        this.ionChange = new core_es5["r" /* EventEmitter */]();
        config.setTransition('picker-slide-in', picker_transitions_PickerSlideIn);
        config.setTransition('picker-slide-out', picker_transitions_PickerSlideOut);
    }
    getTransitionName(direction) {
        let key = (direction === 'back' ? 'pickerLeave' : 'pickerEnter');
        return this._nav && this._nav.config.get(key);
    }
    addButton(button) {
        this.data.buttons.push(button);
    }
    addColumn(column) {
        this.data.columns.push(column);
    }
    getColumns() {
        return this.data.columns;
    }
    getColumn(name) {
        return this.getColumns().find(column => column.name === name);
    }
    refresh() {
        _assert(this._cmp, 'componentRef must be valid');
        _assert(this._cmp.instance.refresh, 'instance must implement refresh()');
        this._cmp && this._cmp.instance.refresh && this._cmp.instance.refresh();
    }
    setCssClass(cssClass) {
        this.data.cssClass = cssClass;
    }
    present(navOptions = {}) {
        return this._app.present(this, navOptions);
    }
}
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (picker__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && picker__a || Object)
], picker_Picker.prototype, "ionChange", void 0);
var picker__a;




// CONCATENATED MODULE: ./src/components/picker/picker-controller.ts






let picker_controller_PickerController = class PickerController {
    constructor(_app, config) {
        this._app = _app;
        this.config = config;
    }
    create(opts = {}) {
        return new picker_Picker(this._app, opts, this.config);
    }
};
picker_controller_PickerController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (picker_controller__a = typeof app_App !== "undefined" && app_App) === "function" && picker_controller__a || Object, typeof (picker_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && picker_controller__b || Object])
], picker_controller_PickerController);

var picker_controller__a, picker_controller__b;




// CONCATENATED MODULE: ./src/util/datetime-util.ts

function renderDateTime(template, value, locale) {
    if (isBlank(value)) {
        return '';
    }
    let tokens = [];
    let hasText = false;
    FORMAT_KEYS.forEach((format, index) => {
        if (template.indexOf(format.f) > -1) {
            const token = '{' + index + '}';
            const text = renderTextFormat(format.f, value[format.k], value, locale);
            if (!hasText && text && isPresent(value[format.k])) {
                hasText = true;
            }
            tokens.push(token, text);
            template = template.replace(format.f, token);
        }
    });
    if (!hasText) {
        return '';
    }
    for (let i = 0; i < tokens.length; i += 2) {
        template = template.replace(tokens[i], tokens[i + 1]);
    }
    return template;
}
function renderTextFormat(format, value, date, locale) {
    if (format === FORMAT_DDDD || format === FORMAT_DDD) {
        try {
            value = (new Date(date.year, date.month - 1, date.day)).getDay();
            if (format === FORMAT_DDDD) {
                return (isPresent(locale.dayNames) ? locale.dayNames : DAY_NAMES)[value];
            }
            return (isPresent(locale.dayShortNames) ? locale.dayShortNames : DAY_SHORT_NAMES)[value];
        }
        catch (e) { }
        return '';
    }
    if (format === FORMAT_A) {
        return date ? date.hour < 12 ? 'AM' : 'PM' : isPresent(value) ? value.toUpperCase() : '';
    }
    if (format === FORMAT_a) {
        return date ? date.hour < 12 ? 'am' : 'pm' : isPresent(value) ? value : '';
    }
    if (isBlank(value)) {
        return '';
    }
    if (format === FORMAT_YY || format === FORMAT_MM ||
        format === FORMAT_DD || format === FORMAT_HH ||
        format === FORMAT_mm || format === FORMAT_ss) {
        return twoDigit(value);
    }
    if (format === FORMAT_YYYY) {
        return fourDigit(value);
    }
    if (format === FORMAT_MMMM) {
        return (isPresent(locale.monthNames) ? locale.monthNames : MONTH_NAMES)[value - 1];
    }
    if (format === FORMAT_MMM) {
        return (isPresent(locale.monthShortNames) ? locale.monthShortNames : MONTH_SHORT_NAMES)[value - 1];
    }
    if (format === FORMAT_hh || format === FORMAT_h) {
        if (value === 0) {
            return '12';
        }
        if (value > 12) {
            value -= 12;
        }
        if (format === FORMAT_hh && value < 10) {
            return ('0' + value);
        }
    }
    return value.toString();
}
function dateValueRange(format, min, max) {
    let opts = [];
    let i;
    if (format === FORMAT_YYYY || format === FORMAT_YY) {
        i = max.year;
        while (i >= min.year) {
            opts.push(i--);
        }
    }
    else if (format === FORMAT_MMMM || format === FORMAT_MMM ||
        format === FORMAT_MM || format === FORMAT_M ||
        format === FORMAT_hh || format === FORMAT_h) {
        for (i = 1; i < 13; i++) {
            opts.push(i);
        }
    }
    else if (format === FORMAT_DDDD || format === FORMAT_DDD ||
        format === FORMAT_DD || format === FORMAT_D) {
        for (i = 1; i < 32; i++) {
            opts.push(i);
        }
    }
    else if (format === FORMAT_HH || format === FORMAT_H) {
        for (i = 0; i < 24; i++) {
            opts.push(i);
        }
    }
    else if (format === FORMAT_mm || format === FORMAT_m) {
        for (i = 0; i < 60; i++) {
            opts.push(i);
        }
    }
    else if (format === FORMAT_ss || format === FORMAT_s) {
        for (i = 0; i < 60; i++) {
            opts.push(i);
        }
    }
    else if (format === FORMAT_A || format === FORMAT_a) {
        opts.push('am', 'pm');
    }
    return opts;
}
function dateSortValue(year, month, day, hour = 0, minute = 0) {
    return parseInt(`1${fourDigit(year)}${twoDigit(month)}${twoDigit(day)}${twoDigit(hour)}${twoDigit(minute)}`, 10);
}
function dateDataSortValue(data) {
    if (data) {
        return dateSortValue(data.year, data.month, data.day, data.hour, data.minute);
    }
    return -1;
}
function daysInMonth(month, year) {
    return (month === 4 || month === 6 || month === 9 || month === 11) ? 30 : (month === 2) ? isLeapYear(year) ? 29 : 28 : 31;
}
function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}
const ISO_8601_REGEXP = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
function parseDate(val) {
    let parse;
    if (isPresent(val) && val !== '') {
        parse = TIME_REGEXP.exec(val);
        if (isPresent(parse)) {
            parse.unshift(undefined, undefined);
            parse[2] = parse[3] = undefined;
        }
        else {
            parse = ISO_8601_REGEXP.exec(val);
        }
    }
    if (isBlank(parse)) {
        return null;
    }
    for (let i = 1; i < 8; i++) {
        parse[i] = (parse[i] !== undefined ? parseInt(parse[i], 10) : null);
    }
    let tzOffset = 0;
    if (isPresent(parse[9]) && isPresent(parse[10])) {
        tzOffset = parseInt(parse[10], 10) * 60;
        if (isPresent(parse[11])) {
            tzOffset += parseInt(parse[11], 10);
        }
        if (parse[9] === '-') {
            tzOffset *= -1;
        }
    }
    return {
        year: parse[1],
        month: parse[2],
        day: parse[3],
        hour: parse[4],
        minute: parse[5],
        second: parse[6],
        millisecond: parse[7],
        tzOffset: tzOffset,
    };
}
function updateDate(existingData, newData) {
    if (isPresent(newData) && newData !== '') {
        if (isString(newData)) {
            newData = parseDate(newData);
            if (newData) {
                Object.assign(existingData, newData);
                return true;
            }
        }
        else if ((isPresent(newData.year) || isPresent(newData.hour) || isPresent(newData.month) || isPresent(newData.day) || isPresent(newData.minute) || isPresent(newData.second))) {
            if (isPresent(newData.ampm) && isPresent(newData.hour)) {
                if (newData.ampm.value === 'pm') {
                    newData.hour.value = (newData.hour.value === 12 ? 12 : newData.hour.value + 12);
                }
                else {
                    newData.hour.value = (newData.hour.value === 12 ? 0 : newData.hour.value);
                }
            }
            for (const k in newData) {
                existingData[k] = newData[k].value;
            }
            return true;
        }
        console.warn(`Error parsing date: "${newData}". Please provide a valid ISO 8601 datetime format: https://www.w3.org/TR/NOTE-datetime`);
    }
    else {
        for (const k in existingData) {
            delete existingData[k];
        }
    }
    return false;
}
function parseTemplate(template) {
    const formats = [];
    template = template.replace(/[^\w\s]/gi, ' ');
    FORMAT_KEYS.forEach(format => {
        if (format.f.length > 1 && template.indexOf(format.f) > -1 && template.indexOf(format.f + format.f.charAt(0)) < 0) {
            template = template.replace(format.f, ' ' + format.f + ' ');
        }
    });
    const words = template.split(' ').filter(w => w.length > 0);
    words.forEach((word, i) => {
        FORMAT_KEYS.forEach(format => {
            if (word === format.f) {
                if (word === FORMAT_A || word === FORMAT_a) {
                    if ((formats.indexOf(FORMAT_h) < 0 && formats.indexOf(FORMAT_hh) < 0) ||
                        VALID_AMPM_PREFIX.indexOf(words[i - 1]) === -1) {
                        return;
                    }
                }
                formats.push(word);
            }
        });
    });
    return formats;
}
function getValueFromFormat(date, format) {
    if (format === FORMAT_A || format === FORMAT_a) {
        return (date.hour < 12 ? 'am' : 'pm');
    }
    if (format === FORMAT_hh || format === FORMAT_h) {
        return (date.hour > 12 ? date.hour - 12 : date.hour);
    }
    return date[convertFormatToKey(format)];
}
function convertFormatToKey(format) {
    for (const k in FORMAT_KEYS) {
        if (FORMAT_KEYS[k].f === format) {
            return FORMAT_KEYS[k].k;
        }
    }
    return null;
}
function convertDataToISO(data) {
    let rtn = '';
    if (isPresent(data)) {
        if (isPresent(data.year)) {
            rtn = fourDigit(data.year);
            if (isPresent(data.month)) {
                rtn += '-' + twoDigit(data.month);
                if (isPresent(data.day)) {
                    rtn += '-' + twoDigit(data.day);
                    if (isPresent(data.hour)) {
                        rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:${twoDigit(data.second)}`;
                        if (data.millisecond > 0) {
                            rtn += '.' + threeDigit(data.millisecond);
                        }
                        if (isBlank(data.tzOffset) || data.tzOffset === 0) {
                            rtn += 'Z';
                        }
                        else {
                            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(data.tzOffset / 60)) + ':' + twoDigit(data.tzOffset % 60);
                        }
                    }
                }
            }
        }
        else if (isPresent(data.hour)) {
            rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
            if (isPresent(data.second)) {
                rtn += ':' + twoDigit(data.second);
                if (isPresent(data.millisecond)) {
                    rtn += '.' + threeDigit(data.millisecond);
                }
            }
        }
    }
    return rtn;
}
function twoDigit(val) {
    return ('0' + (isPresent(val) ? Math.abs(val) : '0')).slice(-2);
}
function threeDigit(val) {
    return ('00' + (isPresent(val) ? Math.abs(val) : '0')).slice(-3);
}
function fourDigit(val) {
    return ('000' + (isPresent(val) ? Math.abs(val) : '0')).slice(-4);
}
const FORMAT_YYYY = 'YYYY';
const FORMAT_YY = 'YY';
const FORMAT_MMMM = 'MMMM';
const FORMAT_MMM = 'MMM';
const FORMAT_MM = 'MM';
const FORMAT_M = 'M';
const FORMAT_DDDD = 'DDDD';
const FORMAT_DDD = 'DDD';
const FORMAT_DD = 'DD';
const FORMAT_D = 'D';
const FORMAT_HH = 'HH';
const FORMAT_H = 'H';
const FORMAT_hh = 'hh';
const FORMAT_h = 'h';
const FORMAT_mm = 'mm';
const FORMAT_m = 'm';
const FORMAT_ss = 'ss';
const FORMAT_s = 's';
const FORMAT_A = 'A';
const FORMAT_a = 'a';
const FORMAT_KEYS = [
    { f: FORMAT_YYYY, k: 'year' },
    { f: FORMAT_MMMM, k: 'month' },
    { f: FORMAT_DDDD, k: 'day' },
    { f: FORMAT_MMM, k: 'month' },
    { f: FORMAT_DDD, k: 'day' },
    { f: FORMAT_YY, k: 'year' },
    { f: FORMAT_MM, k: 'month' },
    { f: FORMAT_DD, k: 'day' },
    { f: FORMAT_HH, k: 'hour' },
    { f: FORMAT_hh, k: 'hour' },
    { f: FORMAT_mm, k: 'minute' },
    { f: FORMAT_ss, k: 'second' },
    { f: FORMAT_M, k: 'month' },
    { f: FORMAT_D, k: 'day' },
    { f: FORMAT_H, k: 'hour' },
    { f: FORMAT_h, k: 'hour' },
    { f: FORMAT_m, k: 'minute' },
    { f: FORMAT_s, k: 'second' },
    { f: FORMAT_A, k: 'ampm' },
    { f: FORMAT_a, k: 'ampm' },
];
const DAY_NAMES = [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
];
const DAY_SHORT_NAMES = [
    'Sun',
    'Mon',
    'Tue',
    'Wed',
    'Thu',
    'Fri',
    'Sat',
];
const MONTH_NAMES = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
];
const MONTH_SHORT_NAMES = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
];
const VALID_AMPM_PREFIX = [
    FORMAT_hh, FORMAT_h, FORMAT_mm, FORMAT_m, FORMAT_ss, FORMAT_s
];
//# sourceMappingURL=datetime-util.js.map
// CONCATENATED MODULE: ./src/components/datetime/datetime.ts












let datetime_DateTime = DateTime_1 = class DateTime extends base_input_BaseInput {
    constructor(form, config, elementRef, renderer, item, _pickerCtrl) {
        super(config, elementRef, renderer, 'datetime', {}, form, item, null);
        this._pickerCtrl = _pickerCtrl;
        this._text = '';
        this._locale = {};
        this.cancelText = 'Cancel';
        this.doneText = 'Done';
        this.pickerOptions = {};
        this.placeholder = '';
        this.ionCancel = new core_es5["r" /* EventEmitter */]();
    }
    ngAfterContentInit() {
        ['monthNames', 'monthShortNames', 'dayNames', 'dayShortNames'].forEach(type => {
            this._locale[type] = convertToArrayOfStrings(isPresent(this[type]) ? this[type] : this._config.get(type), type);
        });
        this._initialize();
    }
    _inputNormalize(val) {
        updateDate(this._value, val);
        return this._value;
    }
    _inputUpdated() {
        super._inputUpdated();
        this.updateText();
    }
    _inputShouldChange() {
        return true;
    }
    _inputChangeEvent() {
        return this.value;
    }
    _inputNgModelEvent() {
        return convertDataToISO(this.value);
    }
    _click(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.open();
    }
    _keyup() {
        this.open();
    }
    open() {
        if (this.isFocus() || this._disabled) {
            return;
        }
        console.debug('datetime, open picker');
        const pickerOptions = deepCopy(this.pickerOptions);
        const picker = this._picker = this._pickerCtrl.create(pickerOptions);
        picker.addButton({
            text: this.cancelText,
            role: 'cancel',
            handler: () => this.ionCancel.emit(this)
        });
        picker.addButton({
            text: this.doneText,
            handler: (data) => this.value = data,
        });
        picker.ionChange.subscribe(() => {
            this.validate();
            picker.refresh();
        });
        this.generate();
        this.validate();
        this._fireFocus();
        picker.present(pickerOptions);
        picker.onDidDismiss(() => {
            this._fireBlur();
        });
    }
    generate() {
        const picker = this._picker;
        let template = this.pickerFormat || this.displayFormat || DEFAULT_FORMAT;
        if (isPresent(template)) {
            this.calcMinMax();
            template = template.replace('DDDD', '{~}').replace('DDD', '{~}');
            if (template.indexOf('D') === -1) {
                template = template.replace('{~}', 'D');
            }
            template = template.replace(/{~}/g, '');
            parseTemplate(template).forEach(format => {
                let key = convertFormatToKey(format);
                let values;
                if (isPresent(this[key + 'Values'])) {
                    values = convertToArrayOfNumbers(this[key + 'Values'], key);
                }
                else {
                    values = dateValueRange(format, this._min, this._max);
                }
                const column = {
                    name: key,
                    selectedIndex: 0,
                    options: values.map(val => {
                        return {
                            value: val,
                            text: renderTextFormat(format, val, null, this._locale),
                        };
                    })
                };
                const optValue = getValueFromFormat(this.getValue(), format);
                const selectedIndex = column.options.findIndex(opt => opt.value === optValue);
                if (selectedIndex >= 0) {
                    column.selectedIndex = selectedIndex;
                }
                picker.addColumn(column);
            });
            const min = this._min;
            const max = this._max;
            const columns = this._picker.getColumns();
            ['month', 'day', 'hour', 'minute']
                .filter(name => !columns.find(column => column.name === name))
                .forEach(name => {
                min[name] = 0;
                max[name] = 0;
            });
            this.divyColumns();
        }
    }
    validateColumn(name, index, min, max, lowerBounds, upperBounds) {
        _assert(lowerBounds.length === 5, 'lowerBounds length must be 5');
        _assert(upperBounds.length === 5, 'upperBounds length must be 5');
        const column = this._picker.getColumn(name);
        if (!column) {
            return 0;
        }
        const lb = lowerBounds.slice();
        const ub = upperBounds.slice();
        const options = column.options;
        let indexMin = options.length - 1;
        let indexMax = 0;
        for (var i = 0; i < options.length; i++) {
            var opt = options[i];
            var value = opt.value;
            lb[index] = opt.value;
            ub[index] = opt.value;
            var disabled = opt.disabled = (value < lowerBounds[index] ||
                value > upperBounds[index] ||
                dateSortValue(ub[0], ub[1], ub[2], ub[3], ub[4]) < min ||
                dateSortValue(lb[0], lb[1], lb[2], lb[3], lb[4]) > max);
            if (!disabled) {
                indexMin = Math.min(indexMin, i);
                indexMax = Math.max(indexMax, i);
            }
        }
        let selectedIndex = column.selectedIndex = clamp(indexMin, column.selectedIndex, indexMax);
        opt = column.options[selectedIndex];
        if (opt) {
            return opt.value;
        }
        return 0;
    }
    validate() {
        const today = new Date();
        const minCompareVal = dateDataSortValue(this._min);
        const maxCompareVal = dateDataSortValue(this._max);
        const yearCol = this._picker.getColumn('year');
        _assert(minCompareVal <= maxCompareVal, 'invalid min/max value');
        let selectedYear = today.getFullYear();
        if (yearCol) {
            if (!yearCol.options.find(col => col.value === today.getFullYear())) {
                selectedYear = yearCol.options[0].value;
            }
            var yearOpt = yearCol.options[yearCol.selectedIndex];
            if (yearOpt) {
                selectedYear = yearOpt.value;
            }
        }
        const selectedMonth = this.validateColumn('month', 1, minCompareVal, maxCompareVal, [selectedYear, 0, 0, 0, 0], [selectedYear, 12, 31, 23, 59]);
        const numDaysInMonth = daysInMonth(selectedMonth, selectedYear);
        const selectedDay = this.validateColumn('day', 2, minCompareVal, maxCompareVal, [selectedYear, selectedMonth, 0, 0, 0], [selectedYear, selectedMonth, numDaysInMonth, 23, 59]);
        const selectedHour = this.validateColumn('hour', 3, minCompareVal, maxCompareVal, [selectedYear, selectedMonth, selectedDay, 0, 0], [selectedYear, selectedMonth, selectedDay, 23, 59]);
        this.validateColumn('minute', 4, minCompareVal, maxCompareVal, [selectedYear, selectedMonth, selectedDay, selectedHour, 0], [selectedYear, selectedMonth, selectedDay, selectedHour, 59]);
    }
    divyColumns() {
        const pickerColumns = this._picker.getColumns();
        let columnsWidth = [];
        let col;
        let width;
        for (var i = 0; i < pickerColumns.length; i++) {
            col = pickerColumns[i];
            columnsWidth.push(0);
            for (var j = 0; j < col.options.length; j++) {
                width = col.options[j].text.length;
                if (width > columnsWidth[i]) {
                    columnsWidth[i] = width;
                }
            }
        }
        if (columnsWidth.length === 2) {
            width = Math.max(columnsWidth[0], columnsWidth[1]);
            pickerColumns[0].align = 'right';
            pickerColumns[1].align = 'left';
            pickerColumns[0].optionsWidth = pickerColumns[1].optionsWidth = `${width * 17}px`;
        }
        else if (columnsWidth.length === 3) {
            width = Math.max(columnsWidth[0], columnsWidth[2]);
            pickerColumns[0].align = 'right';
            pickerColumns[1].columnWidth = `${columnsWidth[1] * 17}px`;
            pickerColumns[0].optionsWidth = pickerColumns[2].optionsWidth = `${width * 17}px`;
            pickerColumns[2].align = 'left';
        }
    }
    updateText() {
        const template = this.displayFormat || this.pickerFormat || DEFAULT_FORMAT;
        this._text = renderDateTime(template, this.getValue(), this._locale);
    }
    getValue() {
        return this._value;
    }
    hasValue() {
        const val = this._value;
        return isPresent(val)
            && isObject(val)
            && Object.keys(val).length > 0;
    }
    calcMinMax(now) {
        const todaysYear = (now || new Date()).getFullYear();
        if (isPresent(this.yearValues)) {
            var years = convertToArrayOfNumbers(this.yearValues, 'year');
            if (isBlank(this.min)) {
                this.min = Math.min.apply(Math, years);
            }
            if (isBlank(this.max)) {
                this.max = Math.max.apply(Math, years);
            }
        }
        else {
            if (isBlank(this.min)) {
                this.min = (todaysYear - 100).toString();
            }
            if (isBlank(this.max)) {
                this.max = todaysYear.toString();
            }
        }
        const min = this._min = parseDate(this.min);
        const max = this._max = parseDate(this.max);
        min.year = min.year || todaysYear;
        max.year = max.year || todaysYear;
        min.month = min.month || 1;
        max.month = max.month || 12;
        min.day = min.day || 1;
        max.day = max.day || 31;
        min.hour = min.hour || 0;
        max.hour = max.hour || 23;
        min.minute = min.minute || 0;
        max.minute = max.minute || 59;
        min.second = min.second || 0;
        max.second = max.second || 59;
        if (min.year > max.year) {
            console.error('min.year > max.year');
            min.year = max.year - 100;
        }
        if (min.year === max.year) {
            if (min.month > max.month) {
                console.error('min.month > max.month');
                min.month = 1;
            }
            else if (min.month === max.month && min.day > max.day) {
                console.error('min.day > max.day');
                min.day = 1;
            }
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "min", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "max", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "displayFormat", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "pickerFormat", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "cancelText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "doneText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "yearValues", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "monthValues", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "dayValues", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "hourValues", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "minuteValues", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "monthNames", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "monthShortNames", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "dayNames", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "dayShortNames", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], datetime_DateTime.prototype, "pickerOptions", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], datetime_DateTime.prototype, "placeholder", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (datetime__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && datetime__a || Object)
], datetime_DateTime.prototype, "ionCancel", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], datetime_DateTime.prototype, "_click", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('keyup.space'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], datetime_DateTime.prototype, "_keyup", null);
datetime_DateTime = DateTime_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-datetime',
        template: '<div *ngIf="!_text" class="datetime-text datetime-placeholder">{{placeholder}}</div>' +
            '<div *ngIf="_text" class="datetime-text">{{_text}}</div>' +
            '<button aria-haspopup="true" ' +
            'type="button" ' +
            '[id]="id" ' +
            'ion-button="item-cover" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.aria-disabled]="_disabled" ' +
            'class="item-cover">' +
            '</button>',
        host: {
            '[class.datetime-disabled]': '_disabled'
        },
        providers: [{ provide: forms_es5["e" /* NG_VALUE_ACCESSOR */], useExisting: DateTime_1, multi: true }],
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(4, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(5, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (datetime__b = typeof form_Form !== "undefined" && form_Form) === "function" && datetime__b || Object, typeof (datetime__c = typeof config_Config !== "undefined" && config_Config) === "function" && datetime__c || Object, typeof (datetime__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && datetime__d || Object, typeof (datetime__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && datetime__e || Object, typeof (datetime__f = typeof Item !== "undefined" && Item) === "function" && datetime__f || Object, typeof (datetime__g = typeof picker_controller_PickerController !== "undefined" && picker_controller_PickerController) === "function" && datetime__g || Object])
], datetime_DateTime);

function convertToArrayOfNumbers(input, type) {
    if (isString(input)) {
        input = input.replace(/\[|\]|\s/g, '').split(',');
    }
    let values;
    if (isArray(input)) {
        values = input
            .map((num) => parseInt(num, 10))
            .filter(isFinite);
    }
    if (!values || !values.length) {
        console.warn(`Invalid "${type}Values". Must be an array of numbers, or a comma separated string of numbers.`);
    }
    return values;
}
function convertToArrayOfStrings(input, type) {
    if (isPresent(input)) {
        if (isString(input)) {
            input = input.replace(/\[|\]/g, '').split(',');
        }
        var values;
        if (isArray(input)) {
            values = input.map((val) => val.trim());
        }
        if (!values || !values.length) {
            console.warn(`Invalid "${type}Names". Must be an array of strings, or a comma separated string.`);
        }
        return values;
    }
}
const DEFAULT_FORMAT = 'MMM D, YYYY';
var DateTime_1, datetime__a, datetime__b, datetime__c, datetime__d, datetime__e, datetime__f, datetime__g;




// CONCATENATED MODULE: ./src/components/fab/fab.ts





let FabButton = class FabButton extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'fab');
    }
    setActiveClose(closeVisible) {
        this.setElementClass('fab-close-active', closeVisible);
    }
};
FabButton = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: '[ion-fab]',
        template: '<ion-icon name="close" class="fab-close-icon"></ion-icon>' +
            '<span class="button-inner">' +
            '<ng-content></ng-content>' +
            '</span>' +
            '<div class="button-effect"></div>',
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (fab__a = typeof config_Config !== "undefined" && config_Config) === "function" && fab__a || Object, typeof (fab__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && fab__b || Object, typeof (fab__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && fab__c || Object])
], FabButton);

var fab__a, fab__b, fab__c;




// CONCATENATED MODULE: ./src/components/fab/fab-list.ts







let fab_list_FabList = class FabList {
    constructor(_elementRef, _renderer, config, _plt) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._plt = _plt;
        this._visible = false;
        this._fabs = [];
        this._mode = config.get('mode');
    }
    set _setbuttons(query) {
        const fabs = this._fabs = query.toArray();
        const className = `fab-${this._mode}-in-list`;
        for (var fab of fabs) {
            fab.setElementClass('fab-in-list', true);
            fab.setElementClass(className, true);
        }
    }
    setVisible(val) {
        let visible = isTrueProperty(val);
        if (visible === this._visible) {
            return;
        }
        this._visible = visible;
        let fabs = this._fabs;
        let i = 1;
        if (visible) {
            fabs.forEach(fab => {
                this._plt.timeout(() => fab.setElementClass('show', true), i * 30);
                i++;
            });
        }
        else {
            fabs.forEach(fab => fab.setElementClass('show', false));
        }
        this.setElementClass('fab-list-active', visible);
    }
    setElementClass(className, add) {
        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(FabButton),
    Object(tslib_es6["__metadata"])("design:type", typeof (fab_list__a = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && fab_list__a || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (fab_list__b = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && fab_list__b || Object])
], fab_list_FabList.prototype, "_setbuttons", null);
fab_list_FabList = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-fab-list',
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (fab_list__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && fab_list__c || Object, typeof (fab_list__d = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && fab_list__d || Object, typeof (fab_list__e = typeof config_Config !== "undefined" && config_Config) === "function" && fab_list__e || Object, typeof (fab_list__f = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && fab_list__f || Object])
], fab_list_FabList);

var fab_list__a, fab_list__b, fab_list__c, fab_list__d, fab_list__e, fab_list__f;




// CONCATENATED MODULE: ./src/components/fab/fab-container.ts







let fab_container_FabContainer = class FabContainer {
    constructor(plt) {
        this._listsActive = false;
        this._events = new ui_event_manager_UIEventManager(plt);
    }
    ngAfterContentInit() {
        const mainButton = this._mainButton;
        if (!mainButton || !mainButton.getNativeElement()) {
            console.error('FAB container needs a main <button ion-fab>');
            return;
        }
        this._events.listen(mainButton.getNativeElement(), 'click', this.clickHandler.bind(this), { zone: true });
    }
    clickHandler(ev) {
        if (this.canActivateList(ev)) {
            this.toggleList();
        }
    }
    canActivateList(ev) {
        if (this._fabLists.length > 0 && this._mainButton && ev.target) {
            let ele = ev.target.closest('ion-fab>[ion-fab]');
            return (ele && ele === this._mainButton.getNativeElement());
        }
        return false;
    }
    toggleList() {
        this.setActiveLists(!this._listsActive);
    }
    setActiveLists(isActive) {
        if (isActive === this._listsActive) {
            return;
        }
        let lists = this._fabLists.toArray();
        for (let list of lists) {
            list.setVisible(isActive);
        }
        this._mainButton.setActiveClose(isActive);
        this._listsActive = isActive;
    }
    close() {
        this.setActiveLists(false);
    }
    ngOnDestroy() {
        this._events.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(FabButton),
    Object(tslib_es6["__metadata"])("design:type", typeof (fab_container__a = typeof FabButton !== "undefined" && FabButton) === "function" && fab_container__a || Object)
], fab_container_FabContainer.prototype, "_mainButton", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(fab_list_FabList),
    Object(tslib_es6["__metadata"])("design:type", typeof (fab_container__b = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && fab_container__b || Object)
], fab_container_FabContainer.prototype, "_fabLists", void 0);
fab_container_FabContainer = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-fab',
        template: '<ng-content></ng-content>'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (fab_container__c = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && fab_container__c || Object])
], fab_container_FabContainer);

var fab_container__a, fab_container__b, fab_container__c;




// CONCATENATED MODULE: ./src/components/grid/col.ts


let Col = class Col {
};
Col = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-col, [ion-col]',
        host: {
            'class': 'col'
        }
    })
], Col);





// CONCATENATED MODULE: ./src/components/grid/grid.ts


let Grid = class Grid {
};
Grid = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-grid, [ion-grid]',
        host: {
            'class': 'grid'
        }
    })
], Grid);





// CONCATENATED MODULE: ./src/components/grid/row.ts


let Row = class Row {
};
Row = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-row, [ion-row]',
        host: {
            'class': 'row'
        }
    })
], Row);





// CONCATENATED MODULE: ./src/components/img/img.ts








let img_Img = class Img {
    constructor(_elementRef, _renderer, _plt, _content, _dom) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._plt = _plt;
        this._content = _content;
        this._dom = _dom;
        this._cache = true;
        this._w = '';
        this._h = '';
        this._wQ = '';
        this._hQ = '';
        this.alt = '';
        if (!this._content) {
            console.warn(`ion-img can only be used within an ion-content`);
        }
        else {
            this._content.addImg(this);
        }
        this._isLoaded(false);
    }
    get src() {
        return this._src;
    }
    set src(newSrc) {
        if (newSrc !== this._src) {
            this.reset();
            this._src = newSrc;
            this._hasLoaded = newSrc.indexOf('data:') === 0;
            this.update();
        }
    }
    reset() {
        if (this._requestingSrc) {
            console.debug(`abortRequest ${this._requestingSrc} ${Date.now()}`);
            this._srcAttr('');
            this._requestingSrc = null;
        }
        if (this._renderedSrc) {
            console.debug(`clearRender ${this._renderedSrc} ${Date.now()}`);
            this._renderedSrc = null;
            this._isLoaded(false);
        }
    }
    update() {
        if (this._src && this._content.isImgsUpdatable()) {
            if (this.canRequest && (this._src !== this._renderedSrc && this._src !== this._requestingSrc) && !this._hasLoaded) {
                console.debug(`request ${this._src} ${Date.now()}`);
                this._requestingSrc = this._src;
                this._isLoaded(false);
                this._srcAttr(this._src);
                this._setDims();
            }
            if (this.canRender && this._hasLoaded && this._src !== this._renderedSrc) {
                this._renderedSrc = this._src;
                this._setDims();
                this._dom.write(() => {
                    if (this._hasLoaded) {
                        console.debug(`render ${this._src} ${Date.now()}`);
                        this._isLoaded(true);
                        this._srcAttr(this._src);
                    }
                });
            }
        }
    }
    _isLoaded(isLoaded) {
        const renderer = this._renderer;
        const ele = this._elementRef.nativeElement;
        renderer.setElementClass(ele, 'img-loaded', isLoaded);
        renderer.setElementClass(ele, 'img-unloaded', !isLoaded);
    }
    _srcAttr(srcAttr) {
        const imgEle = this._img;
        const renderer = this._renderer;
        if (imgEle && imgEle.src !== srcAttr) {
            renderer.setElementAttribute(this._img, 'src', srcAttr);
            renderer.setElementAttribute(this._img, 'alt', this.alt);
        }
    }
    get top() {
        const bounds = this._getBounds();
        return bounds && bounds.top || 0;
    }
    get bottom() {
        const bounds = this._getBounds();
        return bounds && bounds.bottom || 0;
    }
    _getBounds() {
        if (this._bounds) {
            return this._bounds;
        }
        if (!this._rect) {
            this._rect = this._elementRef.nativeElement.getBoundingClientRect();
            console.debug(`img, ${this._src}, read, ${this._rect.top} - ${this._rect.bottom}`);
        }
        return this._rect;
    }
    set bounds(b) {
        if (isPresent(b)) {
            this._bounds = b;
        }
    }
    get cache() {
        return this._cache;
    }
    set cache(val) {
        this._cache = isTrueProperty(val);
    }
    set width(val) {
        this._wQ = getUnitValue(val);
        this._setDims();
    }
    set height(val) {
        this._hQ = getUnitValue(val);
        this._setDims();
    }
    _setDims() {
        if (this.canRender && (this._w !== this._wQ || this._h !== this._hQ)) {
            var wrapperEle = this._elementRef.nativeElement;
            var renderer = this._renderer;
            this._dom.write(() => {
                if (this._w !== this._wQ) {
                    this._w = this._wQ;
                    renderer.setElementStyle(wrapperEle, 'width', this._w);
                }
                if (this._h !== this._hQ) {
                    this._h = this._hQ;
                    renderer.setElementStyle(wrapperEle, 'height', this._h);
                }
            });
        }
    }
    ngAfterContentInit() {
        this._img = this._elementRef.nativeElement.firstChild;
        this._unreg = this._plt.registerListener(this._img, 'load', () => {
            this._hasLoaded = true;
            this.update();
        }, { passive: true });
    }
    ngOnDestroy() {
        this._unreg && this._unreg();
        this._content && this._content.removeImg(this);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], img_Img.prototype, "src", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], img_Img.prototype, "bounds", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], img_Img.prototype, "cache", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], img_Img.prototype, "width", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], img_Img.prototype, "height", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], img_Img.prototype, "alt", void 0);
img_Img = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-img',
        template: '<img>',
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (img__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && img__a || Object, typeof (img__b = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && img__b || Object, typeof (img__c = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && img__c || Object, typeof (img__d = typeof content_Content !== "undefined" && content_Content) === "function" && img__d || Object, typeof (img__e = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && img__e || Object])
], img_Img);

function getUnitValue(val) {
    if (isPresent(val)) {
        if (typeof val === 'string') {
            if (val.indexOf('%') > -1 || val.indexOf('px') > -1) {
                return val;
            }
            if (val.length) {
                return val + 'px';
            }
        }
        else if (typeof val === 'number') {
            return val + 'px';
        }
    }
    return '';
}
var img__a, img__b, img__c, img__d, img__e;




// CONCATENATED MODULE: ./src/components/infinite-scroll/infinite-scroll.ts






let infinite_scroll_InfiniteScroll = class InfiniteScroll {
    constructor(_content, _zone, _elementRef, _dom) {
        this._content = _content;
        this._zone = _zone;
        this._elementRef = _elementRef;
        this._dom = _dom;
        this._lastCheck = 0;
        this._highestY = 0;
        this._thr = '15%';
        this._thrPx = 0;
        this._thrPc = 0.15;
        this._position = POSITION_BOTTOM;
        this._init = false;
        this.state = STATE_ENABLED;
        this.ionInfinite = new core_es5["r" /* EventEmitter */]();
        _content.setElementClass('has-infinite-scroll', true);
    }
    get threshold() {
        return this._thr;
    }
    set threshold(val) {
        this._thr = val;
        if (val.indexOf('%') > -1) {
            this._thrPx = 0;
            this._thrPc = (parseFloat(val) / 100);
        }
        else {
            this._thrPx = parseFloat(val);
            this._thrPc = 0;
        }
    }
    set enabled(shouldEnable) {
        this.enable(shouldEnable);
    }
    get position() {
        return this._position;
    }
    set position(val) {
        if (val === POSITION_TOP || val === POSITION_BOTTOM) {
            this._position = val;
        }
        else {
            console.error(`Invalid value for ion-infinite-scroll's position input. Its value should be '${POSITION_BOTTOM}' or '${POSITION_TOP}'.`);
        }
    }
    _onScroll(ev) {
        if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
            return 1;
        }
        if (this._lastCheck + 32 > ev.timeStamp) {
            return 2;
        }
        this._lastCheck = ev.timeStamp;
        const infiniteHeight = this._elementRef.nativeElement.scrollHeight;
        if (!infiniteHeight) {
            return 3;
        }
        const d = this._content.getContentDimensions();
        const height = d.contentHeight;
        const threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
        let distanceFromInfinite;
        if (this._position === POSITION_BOTTOM) {
            distanceFromInfinite = d.scrollHeight - infiniteHeight - d.scrollTop - height - threshold;
        }
        else {
            _assert(this._position === POSITION_TOP, '_position should be top');
            distanceFromInfinite = d.scrollTop - infiniteHeight - threshold;
        }
        if (distanceFromInfinite < 0) {
            this._dom.write(() => {
                this._zone.run(() => {
                    if (this.state !== STATE_LOADING && this.state !== STATE_DISABLED) {
                        this.state = STATE_LOADING;
                        this.ionInfinite.emit(this);
                    }
                });
            });
            return 5;
        }
        return 6;
    }
    complete() {
        if (this.state !== STATE_LOADING) {
            return;
        }
        if (this._position === POSITION_BOTTOM) {
            this.state = STATE_ENABLED;
            return;
        }
        _assert(this._position === POSITION_TOP, 'position should be top');
        const prevDim = this._content.getContentDimensions();
        this._dom.read(() => {
            const newDim = this._content.getContentDimensions();
            const newScrollTop = newDim.scrollHeight - (prevDim.scrollHeight - prevDim.scrollTop);
            this._dom.write(() => {
                this._content.scrollTop = newScrollTop;
                this.state = STATE_ENABLED;
            });
        });
    }
    waitFor(action) {
        const enable = this.complete.bind(this);
        action.then(enable, enable);
    }
    enable(shouldEnable) {
        this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
        this._setListeners(shouldEnable);
    }
    _setListeners(shouldListen) {
        if (this._init) {
            if (shouldListen) {
                if (!this._scLsn) {
                    this._scLsn = this._content.ionScroll.subscribe(this._onScroll.bind(this));
                }
            }
            else {
                this._scLsn && this._scLsn.unsubscribe();
                this._scLsn = null;
            }
        }
    }
    ngAfterContentInit() {
        this._init = true;
        this._setListeners(this.state !== STATE_DISABLED);
        if (this._position === POSITION_TOP) {
            this._content.scrollDownOnLoad = true;
        }
    }
    ngOnDestroy() {
        this._setListeners(false);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], infinite_scroll_InfiniteScroll.prototype, "threshold", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], infinite_scroll_InfiniteScroll.prototype, "enabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], infinite_scroll_InfiniteScroll.prototype, "position", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (infinite_scroll__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && infinite_scroll__a || Object)
], infinite_scroll_InfiniteScroll.prototype, "ionInfinite", void 0);
infinite_scroll_InfiniteScroll = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-infinite-scroll'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (infinite_scroll__b = typeof content_Content !== "undefined" && content_Content) === "function" && infinite_scroll__b || Object, typeof (infinite_scroll__c = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && infinite_scroll__c || Object, typeof (infinite_scroll__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && infinite_scroll__d || Object, typeof (infinite_scroll__e = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && infinite_scroll__e || Object])
], infinite_scroll_InfiniteScroll);

const STATE_ENABLED = 'enabled';
const STATE_DISABLED = 'disabled';
const STATE_LOADING = 'loading';
const POSITION_TOP = 'top';
const POSITION_BOTTOM = 'bottom';
var infinite_scroll__a, infinite_scroll__b, infinite_scroll__c, infinite_scroll__d, infinite_scroll__e;




// CONCATENATED MODULE: ./src/components/infinite-scroll/infinite-scroll-content.ts





let InfiniteScrollContent = class InfiniteScrollContent {
    constructor(inf, _config) {
        this.inf = inf;
        this._config = _config;
    }
    ngOnInit() {
        if (!this.loadingSpinner) {
            this.loadingSpinner = this._config.get('infiniteLoadingSpinner', this._config.get('spinner', 'ios'));
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], InfiniteScrollContent.prototype, "loadingSpinner", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], InfiniteScrollContent.prototype, "loadingText", void 0);
InfiniteScrollContent = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-infinite-scroll-content',
        template: '<div class="infinite-loading">' +
            '<div class="infinite-loading-spinner" *ngIf="loadingSpinner">' +
            '<ion-spinner [name]="loadingSpinner"></ion-spinner>' +
            '</div>' +
            '<div class="infinite-loading-text" [innerHTML]="loadingText" *ngIf="loadingText"></div>' +
            '</div>',
        host: {
            '[attr.state]': 'inf.state'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (infinite_scroll_content__a = typeof infinite_scroll_InfiniteScroll !== "undefined" && infinite_scroll_InfiniteScroll) === "function" && infinite_scroll_content__a || Object, typeof (infinite_scroll_content__b = typeof config_Config !== "undefined" && config_Config) === "function" && infinite_scroll_content__b || Object])
], InfiniteScrollContent);

var infinite_scroll_content__a, infinite_scroll_content__b;




// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js
var Subject = __webpack_require__(8);
var Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);

// EXTERNAL MODULE: ./node_modules/rxjs/add/operator/takeUntil.js
var takeUntil = __webpack_require__(23);
var takeUntil_default = /*#__PURE__*/__webpack_require__.n(takeUntil);

// CONCATENATED MODULE: ./src/components/input/input.ts

















let input_TextInput = class TextInput extends base_input_BaseInput {
    constructor(config, _plt, _form, _app, elementRef, renderer, _content, _item, ngControl, _dom) {
        super(config, elementRef, renderer, 'input', '', _form, _item, ngControl);
        this._plt = _plt;
        this._app = _app;
        this._content = _content;
        this.ngControl = ngControl;
        this._dom = _dom;
        this._clearInput = false;
        this._readonly = false;
        this._type = 'text';
        this._isTextarea = false;
        this._onDestroy = new Subject["Subject"]();
        this._useAssist = false;
        this._relocated = false;
        this.autocomplete = '';
        this.autocorrect = '';
        this.placeholder = '';
        this.min = null;
        this.max = null;
        this.step = null;
        this.input = new core_es5["r" /* EventEmitter */]();
        this.blur = new core_es5["r" /* EventEmitter */]();
        this.focus = new core_es5["r" /* EventEmitter */]();
        this.autocomplete = config.get('autocomplete', 'off');
        this.autocorrect = config.get('autocorrect', 'off');
        this._autoFocusAssist = config.get('autoFocusAssist', 'delay');
        this._keyboardHeight = config.getNumber('keyboardHeight');
        this._isTextarea = !!(elementRef.nativeElement.tagName === 'ION-TEXTAREA');
        if (this._isTextarea && _item) {
            _item.setElementClass('item-textarea', true);
        }
        if (!_content) {
            return;
        }
        const blurOnScroll = config.getBoolean('hideCaretOnScroll', false);
        if (blurOnScroll) {
            this._enableHideCaretOnScroll();
        }
        const resizeAssist = config.getBoolean('resizeAssist', false);
        if (resizeAssist) {
            this._keyboardHeight = 60;
            this._enableResizeAssist();
        }
        else {
            this._useAssist = config.getBoolean('scrollAssist', false);
            const usePadding = config.getBoolean('scrollPadding', this._useAssist);
            if (usePadding) {
                this._enableScrollPadding();
            }
        }
    }
    get clearInput() {
        return this._clearInput;
    }
    set clearInput(val) {
        this._clearInput = (!this._isTextarea && isTrueProperty(val));
    }
    get type() {
        return (this._isTextarea)
            ? 'text'
            : this._type;
    }
    set type(val) {
        this._type = val;
    }
    get readonly() {
        return this._readonly;
    }
    set readonly(val) {
        this._readonly = isTrueProperty(val);
    }
    get clearOnEdit() {
        return this._clearOnEdit;
    }
    set clearOnEdit(val) {
        this._clearOnEdit = isTrueProperty(val);
    }
    ngAfterContentInit() { }
    ngAfterViewInit() {
        _assert(this._native && this._native.nativeElement, 'input element must be valid');
        if (this.clearOnEdit !== false && this.type === 'password') {
            this.clearOnEdit = true;
        }
        const ionInputEle = this._elementRef.nativeElement;
        const nativeInputEle = this._native.nativeElement;
        copyInputAttributes(ionInputEle, nativeInputEle);
        if (ionInputEle.hasAttribute('tabIndex')) {
            ionInputEle.removeAttribute('tabIndex');
        }
        if (ionInputEle.hasAttribute('autofocus')) {
            ionInputEle.removeAttribute('autofocus');
            switch (this._autoFocusAssist) {
                case 'immediate':
                    nativeInputEle.focus();
                    break;
                case 'delay':
                    this._plt.timeout(() => nativeInputEle.focus(), 800);
                    break;
            }
        }
        this._initialize();
        if (this.focus.observers.length > 0) {
            console.warn('(focus) is deprecated in ion-input, use (ionFocus) instead');
        }
        if (this.blur.observers.length > 0) {
            console.warn('(blur) is deprecated in ion-input, use (ionBlur) instead');
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._onDestroy.next();
        this._onDestroy = null;
    }
    initFocus() {
        this.setFocus();
    }
    setFocus() {
        if (!this.isFocus()) {
            this._native.nativeElement.focus();
        }
    }
    setBlur() {
        if (this.isFocus()) {
            this._native.nativeElement.blur();
        }
    }
    onInput(ev) {
        this.value = ev.target.value;
        this.input.emit(ev);
    }
    onBlur(ev) {
        this._fireBlur();
        this.blur.emit(ev);
        this._scrollData = null;
        if (this._clearOnEdit && this.hasValue()) {
            this._didBlurAfterEdit = true;
        }
    }
    onFocus(ev) {
        this._fireFocus();
        this.focus.emit(ev);
    }
    onKeydown(ev) {
        if (ev && this._clearOnEdit) {
            this.checkClearOnEdit(ev.target.value);
        }
    }
    _inputUpdated() {
        super._inputUpdated();
        const inputEle = this._native.nativeElement;
        const value = this._value;
        if (inputEle.value !== value) {
            inputEle.value = value;
        }
    }
    clearTextInput() {
        this.value = '';
    }
    checkClearOnEdit(_) {
        if (!this._clearOnEdit) {
            return;
        }
        if (this._didBlurAfterEdit && this.hasValue()) {
            this.clearTextInput();
        }
        this._didBlurAfterEdit = false;
    }
    _getScrollData() {
        if (!this._content) {
            return newScrollData();
        }
        if (this._scrollData) {
            return this._scrollData;
        }
        let ele = this._elementRef.nativeElement;
        ele = ele.closest('ion-item,[ion-item]') || ele;
        return this._scrollData = getScrollData(ele.offsetTop, ele.offsetHeight, this._content.getContentDimensions(), this._keyboardHeight, this._plt.height());
    }
    _relocateInput(shouldRelocate) {
        if (this._relocated === shouldRelocate) {
            return;
        }
        const platform = this._plt;
        const componentEle = this.getNativeElement();
        const focusedInputEle = this._native.nativeElement;
        console.debug(`native-input, hideCaret, shouldHideCaret: ${shouldRelocate}, input value: ${focusedInputEle.value}`);
        if (shouldRelocate) {
            cloneInputComponent(platform, componentEle, focusedInputEle);
            const inputRelativeY = this._getScrollData().inputSafeY;
            const tx = this._plt.isRTL ? 9999 : -9999;
            focusedInputEle.style[platform.Css.transform] = `translate3d(${tx}px,${inputRelativeY}px,0)`;
            focusedInputEle.style.opacity = '0';
        }
        else {
            removeClone(platform, componentEle, focusedInputEle);
        }
        this._relocated = shouldRelocate;
    }
    _enableScrollPadding() {
        _assert(this._content, 'content is undefined');
        console.debug('Input: enableScrollPadding');
        this.ionFocus.subscribe(() => {
            const content = this._content;
            content.addScrollPadding(this._getScrollData().scrollPadding);
            content.clearScrollPaddingFocusOut();
        });
    }
    _enableHideCaretOnScroll() {
        _assert(this._content, 'content is undefined');
        const content = this._content;
        console.debug('Input: enableHideCaretOnScroll');
        content.ionScrollStart
            .takeUntil(this._onDestroy)
            .subscribe(() => scrollHideCaret(true));
        content.ionScrollEnd
            .takeUntil(this._onDestroy)
            .subscribe(() => scrollHideCaret(false));
        this.ionBlur.subscribe(() => this._relocateInput(false));
        const self = this;
        function scrollHideCaret(shouldHideCaret) {
            if (self.isFocus()) {
                self._dom.write(() => self._relocateInput(shouldHideCaret));
            }
        }
    }
    _enableResizeAssist() {
        _assert(this._content, 'content is undefined');
        console.debug('Input: enableAutoScroll');
        this.ionFocus.subscribe(() => {
            const scrollData = this._getScrollData();
            if (Math.abs(scrollData.scrollAmount) > 100) {
                this._content.scrollTo(0, scrollData.scrollTo, scrollData.scrollDuration);
            }
        });
    }
    _pointerStart(ev) {
        _assert(this._content, 'content is undefined');
        if (ev.type === 'touchstart') {
            this._isTouch = true;
        }
        if ((this._isTouch || (!this._isTouch && ev.type === 'mousedown')) && this._app.isEnabled()) {
            this._coord = pointerCoord(ev);
        }
        console.debug(`input-base, pointerStart, type: ${ev.type}`);
    }
    _pointerEnd(ev) {
        _assert(this._content, 'content is undefined');
        console.debug(`input-base, pointerEnd, type: ${ev.type}`);
        if ((this._isTouch && ev.type === 'mouseup') || !this._app.isEnabled()) {
            ev.preventDefault();
            ev.stopPropagation();
        }
        else if (this._coord) {
            var endCoord = pointerCoord(ev);
            if (!hasPointerMoved(8, this._coord, endCoord) && !this.isFocus()) {
                ev.preventDefault();
                ev.stopPropagation();
                this._jsSetFocus();
            }
        }
        this._coord = null;
    }
    _jsSetFocus() {
        _assert(this._content, 'content is undefined');
        const content = this._content;
        console.debug(`input-base, initFocus(), scrollView: ${!!content}`);
        if (!content) {
            this.setFocus();
        }
        var scrollData = this._getScrollData();
        if (Math.abs(scrollData.scrollAmount) < 4) {
            this.setFocus();
            return;
        }
        this._relocateInput(true);
        this.setFocus();
        content.scrollTo(0, scrollData.scrollTo, scrollData.scrollDuration, () => {
            this._relocateInput(false);
            this.setFocus();
        });
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], input_TextInput.prototype, "clearInput", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], input_TextInput.prototype, "type", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], input_TextInput.prototype, "readonly", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], input_TextInput.prototype, "clearOnEdit", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('textInput', { read: core_es5["p" /* ElementRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (input__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && input__a || Object)
], input_TextInput.prototype, "_native", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], input_TextInput.prototype, "autocomplete", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], input_TextInput.prototype, "autocorrect", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], input_TextInput.prototype, "placeholder", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], input_TextInput.prototype, "min", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], input_TextInput.prototype, "max", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], input_TextInput.prototype, "step", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], input_TextInput.prototype, "input", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], input_TextInput.prototype, "blur", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], input_TextInput.prototype, "focus", void 0);
input_TextInput = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-input,ion-textarea',
        template: '<input #textInput *ngIf="!_isTextarea" class="text-input" ' +
            '[ngClass]="\'text-input-\' + _mode"' +
            '(input)="onInput($event)" ' +
            '(blur)="onBlur($event)" ' +
            '(focus)="onFocus($event)" ' +
            '(keydown)="onKeydown($event)" ' +
            '[type]="_type" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.min]="min" ' +
            '[attr.max]="max" ' +
            '[attr.step]="step" ' +
            '[attr.autocomplete]="autocomplete" ' +
            '[attr.autocorrect]="autocorrect" ' +
            '[placeholder]="placeholder" ' +
            '[disabled]="_disabled" ' +
            '[readonly]="_readonly">' +
            '<textarea #textInput *ngIf="_isTextarea" class="text-input" ' +
            '[ngClass]="\'text-input-\' + _mode"' +
            '(input)="onInput($event)" ' +
            '(blur)="onBlur($event)" ' +
            '(focus)="onFocus($event)" ' +
            '(keydown)="onKeydown($event)" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.autocomplete]="autocomplete" ' +
            '[attr.autocorrect]="autocorrect" ' +
            '[placeholder]="placeholder" ' +
            '[disabled]="_disabled" ' +
            '[readonly]="_readonly"></textarea>' +
            '<button ion-button *ngIf="_clearInput" clear class="text-input-clear-icon" ' +
            'type="button" ' +
            '(click)="clearTextInput($event)" ' +
            '(mousedown)="clearTextInput($event)" ' +
            'tabindex="-1"></button>' +
            '<div class="input-cover" *ngIf="_useAssist" ' +
            '(touchstart)="_pointerStart($event)" ' +
            '(touchend)="_pointerEnd($event)" ' +
            '(mousedown)="_pointerStart($event)" ' +
            '(mouseup)="_pointerEnd($event)"></div>',
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        inputs: ['value']
    }),
    Object(tslib_es6["__param"])(6, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(7, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(8, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (input__b = typeof config_Config !== "undefined" && config_Config) === "function" && input__b || Object, typeof (input__c = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && input__c || Object, typeof (input__d = typeof form_Form !== "undefined" && form_Form) === "function" && input__d || Object, typeof (input__e = typeof app_App !== "undefined" && app_App) === "function" && input__e || Object, typeof (input__f = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && input__f || Object, typeof (input__g = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && input__g || Object, typeof (input__h = typeof content_Content !== "undefined" && content_Content) === "function" && input__h || Object, typeof (input__j = typeof Item !== "undefined" && Item) === "function" && input__j || Object, typeof (input__k = typeof forms_es5["f" /* NgControl */] !== "undefined" && forms_es5["f" /* NgControl */]) === "function" && input__k || Object, typeof (input__l = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && input__l || Object])
], input_TextInput);

const SCROLL_ASSIST_SPEED = 0.3;
function newScrollData() {
    return {
        scrollAmount: 0,
        scrollTo: 0,
        scrollPadding: 0,
        scrollDuration: 0,
        inputSafeY: 0
    };
}
function getScrollData(inputOffsetTop, inputOffsetHeight, scrollViewDimensions, keyboardHeight, plaformHeight) {
    const inputTop = (inputOffsetTop + scrollViewDimensions.contentTop - scrollViewDimensions.scrollTop);
    const inputBottom = (inputTop + inputOffsetHeight);
    const safeAreaTop = scrollViewDimensions.contentTop;
    const safeAreaHeight = (plaformHeight - keyboardHeight - safeAreaTop) / 2;
    const safeAreaBottom = safeAreaTop + safeAreaHeight;
    const inputTopWithinSafeArea = (inputTop >= safeAreaTop && inputTop <= safeAreaBottom);
    const inputTopAboveSafeArea = (inputTop < safeAreaTop);
    const inputTopBelowSafeArea = (inputTop > safeAreaBottom);
    const inputBottomWithinSafeArea = (inputBottom >= safeAreaTop && inputBottom <= safeAreaBottom);
    const inputBottomBelowSafeArea = (inputBottom > safeAreaBottom);
    const scrollData = newScrollData();
    if (inputTopWithinSafeArea && inputBottomWithinSafeArea) {
        return scrollData;
    }
    if (inputTopBelowSafeArea || inputBottomBelowSafeArea || inputTopAboveSafeArea) {
        if (safeAreaHeight > inputOffsetHeight) {
            scrollData.scrollAmount = Math.round(safeAreaBottom - inputBottom);
        }
        else {
            scrollData.scrollAmount = Math.round(safeAreaTop - inputTop);
        }
        scrollData.inputSafeY = -(inputTop - safeAreaTop) + 4;
        if (inputTopAboveSafeArea && scrollData.scrollAmount > inputOffsetHeight) {
            scrollData.scrollAmount = inputOffsetHeight;
        }
    }
    scrollData.scrollTo = (scrollViewDimensions.scrollTop - scrollData.scrollAmount);
    scrollData.scrollPadding = keyboardHeight;
    const distance = Math.abs(scrollData.scrollAmount);
    const duration = distance / SCROLL_ASSIST_SPEED;
    scrollData.scrollDuration = Math.min(400, Math.max(150, duration));
    return scrollData;
}
function cloneInputComponent(plt, srcComponentEle, srcNativeInputEle) {
    _assert(srcComponentEle.parentElement.querySelector('.cloned-input') === null, 'leaked cloned input');
    if (srcComponentEle) {
        var srcTop = srcComponentEle.offsetTop;
        var srcLeft = srcComponentEle.offsetLeft;
        var srcWidth = srcComponentEle.offsetWidth;
        var srcHeight = srcComponentEle.offsetHeight;
        var clonedComponentEle = srcComponentEle.cloneNode(false);
        var clonedStyle = clonedComponentEle.style;
        clonedComponentEle.classList.add('cloned-input');
        clonedComponentEle.setAttribute('aria-hidden', 'true');
        clonedStyle.pointerEvents = 'none';
        clonedStyle.position = 'absolute';
        clonedStyle.top = srcTop + 'px';
        clonedStyle.left = srcLeft + 'px';
        clonedStyle.width = srcWidth + 'px';
        clonedStyle.height = srcHeight + 'px';
        var clonedNativeInputEle = srcNativeInputEle.cloneNode(false);
        clonedNativeInputEle.value = srcNativeInputEle.value;
        clonedNativeInputEle.tabIndex = -1;
        clonedComponentEle.appendChild(clonedNativeInputEle);
        srcComponentEle.parentNode.appendChild(clonedComponentEle);
        srcComponentEle.style.pointerEvents = 'none';
    }
    srcNativeInputEle.style[plt.Css.transform] = 'scale(0)';
}
function removeClone(plt, srcComponentEle, srcNativeInputEle) {
    if (srcComponentEle && srcComponentEle.parentElement) {
        var clonedInputEles = srcComponentEle.parentElement.querySelectorAll('.cloned-input');
        for (var i = 0; i < clonedInputEles.length; i++) {
            clonedInputEles[i].parentNode.removeChild(clonedInputEles[i]);
        }
        srcComponentEle.style.pointerEvents = '';
    }
    srcNativeInputEle.style[plt.Css.transform] = '';
    srcNativeInputEle.style.opacity = '';
}
var input__a, input__b, input__c, input__d, input__e, input__f, input__g, input__h, input__j, input__k, input__l;




// CONCATENATED MODULE: ./src/components/item/item-content.ts


let ItemContent = class ItemContent {
};
ItemContent = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-item,[ion-item]',
        host: {
            'class': 'item-block'
        }
    })
], ItemContent);





// CONCATENATED MODULE: ./src/components/item/item-divider.ts





let ItemDivider = class ItemDivider extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'item-divider');
    }
};
ItemDivider = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-item-divider',
        host: {
            'class': 'item-divider'
        }
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item_divider__a = typeof config_Config !== "undefined" && config_Config) === "function" && item_divider__a || Object, typeof (item_divider__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && item_divider__b || Object, typeof (item_divider__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && item_divider__c || Object])
], ItemDivider);

var item_divider__a, item_divider__b, item_divider__c;




// CONCATENATED MODULE: ./src/components/item/item-group.ts


let ItemGroup = class ItemGroup {
};
ItemGroup = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-item-group'
    })
], ItemGroup);





// CONCATENATED MODULE: ./src/components/item/item-options.ts





let item_options_ItemOptions = class ItemOptions {
    constructor(_elementRef, _plt) {
        this._elementRef = _elementRef;
        this._plt = _plt;
        this.ionSwipe = new core_es5["r" /* EventEmitter */]();
    }
    isRightSide() {
        return util_isRightSide(this.side, this._plt.isRTL, true);
    }
    width() {
        return this._elementRef.nativeElement.offsetWidth;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (item_options__a = typeof /* Cannot get final name for export "Side" in "./src/util/util.ts" (known exports: clamp deepCopy deepEqual debounce normalizeURL defaults isBoolean isString isNumber isFunction isDefined isUndefined isPresent isBlank isObject isArray isPrimitive isTrueProperty isCheckedProperty isRightSide reorderArray removeArrayItem swipeShouldReset requestIonicCallback assert runInDev, known reexports: ) */ undefined !== "undefined" && /* Cannot get final name for export "Side" in "./src/util/util.ts" (known exports: clamp deepCopy deepEqual debounce normalizeURL defaults isBoolean isString isNumber isFunction isDefined isUndefined isPresent isBlank isObject isArray isPrimitive isTrueProperty isCheckedProperty isRightSide reorderArray removeArrayItem swipeShouldReset requestIonicCallback assert runInDev, known reexports: ) */ undefined) === "function" && item_options__a || Object)
], item_options_ItemOptions.prototype, "side", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (item_options__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && item_options__b || Object)
], item_options_ItemOptions.prototype, "ionSwipe", void 0);
item_options_ItemOptions = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-item-options',
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item_options__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && item_options__c || Object, typeof (item_options__d = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && item_options__d || Object])
], item_options_ItemOptions);

var item_options__a, item_options__b, item_options__c, item_options__d;




// CONCATENATED MODULE: ./src/components/item/item-sliding-gesture.ts



class item_sliding_gesture_ItemSlidingGesture extends pan_gesture_PanGesture {
    constructor(plt, list, gestureCtrl, domCtrl) {
        super(plt, list.getNativeElement(), {
            maxAngle: 20,
            threshold: 5,
            zone: false,
            domController: domCtrl,
            gesture: gestureCtrl.createGesture({
                name: GESTURE_ITEM_SWIPE,
                priority: GESTURE_PRIORITY_SLIDING_ITEM,
                disableScroll: true
            })
        });
        this.list = list;
        this.preSelectedContainer = null;
        this.selectedContainer = null;
        this.openContainer = null;
    }
    canStart(ev) {
        if (this.selectedContainer) {
            return false;
        }
        let container = getContainer(ev);
        if (!container) {
            this.closeOpened();
            return false;
        }
        if (container !== this.openContainer) {
            this.closeOpened();
        }
        let coord = pointerCoord(ev);
        this.preSelectedContainer = container;
        this.firstCoordX = coord.x;
        this.firstTimestamp = Date.now();
        return true;
    }
    onDragStart(ev) {
        ev.preventDefault();
        let coord = pointerCoord(ev);
        this.selectedContainer = this.openContainer = this.preSelectedContainer;
        this.selectedContainer.startSliding(coord.x);
    }
    onDragMove(ev) {
        ev.preventDefault();
        this.selectedContainer.moveSliding(pointerCoord(ev).x);
    }
    onDragEnd(ev) {
        ev.preventDefault();
        let coordX = pointerCoord(ev).x;
        let deltaX = (coordX - this.firstCoordX);
        let deltaT = (Date.now() - this.firstTimestamp);
        this.selectedContainer.endSliding(deltaX / deltaT);
        this.selectedContainer = null;
        this.preSelectedContainer = null;
    }
    notCaptured(ev) {
        if (!clickedOptionButton(ev)) {
            this.closeOpened();
        }
    }
    closeOpened() {
        this.selectedContainer = null;
        if (this.openContainer) {
            this.openContainer.close();
            this.openContainer = null;
            return true;
        }
        return false;
    }
    destroy() {
        super.destroy();
        this.closeOpened();
        this.list = null;
        this.preSelectedContainer = null;
        this.selectedContainer = null;
        this.openContainer = null;
    }
}
function getContainer(ev) {
    let ele = ev.target.closest('ion-item-sliding');
    if (ele) {
        return ele['$ionComponent'];
    }
    return null;
}
function clickedOptionButton(ev) {
    let ele = ev.target.closest('ion-item-options>button');
    return !!ele;
}
//# sourceMappingURL=item-sliding-gesture.js.map
// CONCATENATED MODULE: ./src/components/list/list.ts










let list_List = class List extends Ion {
    constructor(config, elementRef, renderer, _plt, _gestureCtrl, _domCtrl) {
        super(config, elementRef, renderer, 'list');
        this._plt = _plt;
        this._gestureCtrl = _gestureCtrl;
        this._domCtrl = _domCtrl;
        this._enableSliding = true;
        this._containsSlidingItems = false;
    }
    get sliding() {
        return this._enableSliding;
    }
    set sliding(val) {
        this._enableSliding = isTrueProperty(val);
        this._updateSlidingState();
    }
    containsSlidingItem(contains) {
        this._containsSlidingItems = contains;
        this._updateSlidingState();
    }
    _updateSlidingState() {
        let shouldSlide = this._enableSliding && this._containsSlidingItems;
        if (!shouldSlide) {
            this._slidingGesture && this._slidingGesture.destroy();
            this._slidingGesture = null;
        }
        else if (!this._slidingGesture) {
            console.debug('enableSlidingItems');
            this._slidingGesture = new item_sliding_gesture_ItemSlidingGesture(this._plt, this, this._gestureCtrl, this._domCtrl);
            this._slidingGesture.listen();
        }
    }
    closeSlidingItems() {
        this._slidingGesture && this._slidingGesture.closeOpened();
    }
    destroy() {
        this._slidingGesture && this._slidingGesture.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], list_List.prototype, "sliding", null);
list_List = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-list',
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (list__a = typeof config_Config !== "undefined" && config_Config) === "function" && list__a || Object, typeof (list__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && list__b || Object, typeof (list__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && list__c || Object, typeof (list__d = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && list__d || Object, typeof (list__e = typeof GestureController !== "undefined" && GestureController) === "function" && list__e || Object, typeof (list__f = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && list__f || Object])
], list_List);

var list__a, list__b, list__c, list__d, list__e, list__f;




// CONCATENATED MODULE: ./src/components/item/item-sliding.ts









const SWIPE_MARGIN = 30;
const ELASTIC_FACTOR = 0.55;
const ITEM_SIDE_FLAG_NONE = 0;
const ITEM_SIDE_FLAG_LEFT = 1 << 0;
const ITEM_SIDE_FLAG_RIGHT = 1 << 1;
const ITEM_SIDE_FLAG_BOTH = ITEM_SIDE_FLAG_LEFT | ITEM_SIDE_FLAG_RIGHT;
var SlidingState;
(function (SlidingState) {
    SlidingState[SlidingState["Disabled"] = 2] = "Disabled";
    SlidingState[SlidingState["Enabled"] = 4] = "Enabled";
    SlidingState[SlidingState["Right"] = 8] = "Right";
    SlidingState[SlidingState["Left"] = 16] = "Left";
    SlidingState[SlidingState["SwipeRight"] = 32] = "SwipeRight";
    SlidingState[SlidingState["SwipeLeft"] = 64] = "SwipeLeft";
})(SlidingState || (SlidingState = {}));
let item_sliding_ItemSliding = class ItemSliding {
    constructor(list, _plt, _renderer, _elementRef, _zone) {
        this._plt = _plt;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._zone = _zone;
        this._openAmount = 0;
        this._startX = 0;
        this._optsWidthRightSide = 0;
        this._optsWidthLeftSide = 0;
        this._tmr = null;
        this._optsDirty = true;
        this._state = SlidingState.Disabled;
        this.ionDrag = new core_es5["r" /* EventEmitter */]();
        list && list.containsSlidingItem(true);
        _elementRef.nativeElement.$ionComponent = this;
        this.setElementClass('item-wrapper', true);
    }
    set _itemOptions(itemOptions) {
        let sides = 0;
        this._leftOptions = this._rightOptions = null;
        for (var item of itemOptions.toArray()) {
            if (item.isRightSide()) {
                this._rightOptions = item;
                sides |= ITEM_SIDE_FLAG_RIGHT;
            }
            else {
                this._leftOptions = item;
                sides |= ITEM_SIDE_FLAG_LEFT;
            }
        }
        this._optsDirty = true;
        this._sides = sides;
    }
    getOpenAmount() {
        return this._openAmount;
    }
    getSlidingPercent() {
        const openAmount = this._openAmount;
        if (openAmount > 0) {
            return openAmount / this._optsWidthRightSide;
        }
        else if (openAmount < 0) {
            return openAmount / this._optsWidthLeftSide;
        }
        else {
            return 0;
        }
    }
    startSliding(startX) {
        if (this._tmr) {
            this._plt.cancelTimeout(this._tmr);
            this._tmr = null;
        }
        if (this._openAmount === 0) {
            this._optsDirty = true;
            this._setState(SlidingState.Enabled);
        }
        this._startX = startX + this._openAmount;
        this.item.setElementStyle(this._plt.Css.transition, 'none');
    }
    moveSliding(x) {
        if (this._optsDirty) {
            this.calculateOptsWidth();
            return;
        }
        let openAmount = (this._startX - x);
        switch (this._sides) {
            case ITEM_SIDE_FLAG_RIGHT:
                openAmount = Math.max(0, openAmount);
                break;
            case ITEM_SIDE_FLAG_LEFT:
                openAmount = Math.min(0, openAmount);
                break;
            case ITEM_SIDE_FLAG_BOTH: break;
            case ITEM_SIDE_FLAG_NONE: return;
            default:
                _assert(false, 'invalid ItemSideFlags value');
                break;
        }
        if (openAmount > this._optsWidthRightSide) {
            const optsWidth = this._optsWidthRightSide;
            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
        }
        else if (openAmount < -this._optsWidthLeftSide) {
            const optsWidth = -this._optsWidthLeftSide;
            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
        }
        this._setOpenAmount(openAmount, false);
        return openAmount;
    }
    endSliding(velocity) {
        let restingPoint = (this._openAmount > 0)
            ? this._optsWidthRightSide
            : -this._optsWidthLeftSide;
        const isResetDirection = (this._openAmount > 0) === !(velocity < 0);
        const isMovingFast = Math.abs(velocity) > 0.3;
        const isOnCloseZone = Math.abs(this._openAmount) < Math.abs(restingPoint / 2);
        if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {
            restingPoint = 0;
        }
        this.fireSwipeEvent();
        this._setOpenAmount(restingPoint, true);
        return restingPoint;
    }
    fireSwipeEvent() {
        if (this._state & SlidingState.SwipeRight) {
            this._zone.run(() => this._rightOptions.ionSwipe.emit(this));
        }
        else if (this._state & SlidingState.SwipeLeft) {
            this._zone.run(() => this._leftOptions.ionSwipe.emit(this));
        }
    }
    calculateOptsWidth() {
        if (!this._optsDirty) {
            return;
        }
        this._optsWidthRightSide = 0;
        if (this._rightOptions) {
            this._optsWidthRightSide = this._rightOptions.width();
            _assert(this._optsWidthRightSide > 0, '_optsWidthRightSide should not be zero');
        }
        this._optsWidthLeftSide = 0;
        if (this._leftOptions) {
            this._optsWidthLeftSide = this._leftOptions.width();
            _assert(this._optsWidthLeftSide > 0, '_optsWidthLeftSide should not be zero');
        }
        this._optsDirty = false;
    }
    _setOpenAmount(openAmount, isFinal) {
        const platform = this._plt;
        if (this._tmr) {
            platform.cancelTimeout(this._tmr);
            this._tmr = null;
        }
        this._openAmount = openAmount;
        if (isFinal) {
            this.item.setElementStyle(platform.Css.transition, '');
        }
        if (openAmount > 0) {
            var state = (openAmount >= (this._optsWidthRightSide + SWIPE_MARGIN))
                ? SlidingState.Right | SlidingState.SwipeRight
                : SlidingState.Right;
            this._setState(state);
        }
        else if (openAmount < 0) {
            const state = (openAmount <= (-this._optsWidthLeftSide - SWIPE_MARGIN))
                ? SlidingState.Left | SlidingState.SwipeLeft
                : SlidingState.Left;
            this._setState(state);
        }
        else {
            _assert(openAmount === 0, 'bad internal state');
            this._tmr = platform.timeout(() => {
                this._setState(SlidingState.Disabled);
                this._tmr = null;
            }, 600);
            this.item.setElementStyle(platform.Css.transform, '');
            return;
        }
        this.item.setElementStyle(platform.Css.transform, `translate3d(${-openAmount}px,0,0)`);
        const ionDrag = this.ionDrag;
        if (ionDrag.observers.length > 0) {
            ionDrag.emit(this);
        }
    }
    _setState(state) {
        if (state === this._state) {
            return;
        }
        this.setElementClass('active-slide', (state !== SlidingState.Disabled));
        this.setElementClass('active-options-right', !!(state & SlidingState.Right));
        this.setElementClass('active-options-left', !!(state & SlidingState.Left));
        this.setElementClass('active-swipe-right', !!(state & SlidingState.SwipeRight));
        this.setElementClass('active-swipe-left', !!(state & SlidingState.SwipeLeft));
        this._state = state;
    }
    close() {
        this._setOpenAmount(0, true);
    }
    setElementClass(cssClass, shouldAdd) {
        this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, shouldAdd);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(Item),
    Object(tslib_es6["__metadata"])("design:type", typeof (item_sliding__a = typeof Item !== "undefined" && Item) === "function" && item_sliding__a || Object)
], item_sliding_ItemSliding.prototype, "item", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (item_sliding__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && item_sliding__b || Object)
], item_sliding_ItemSliding.prototype, "ionDrag", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(Object(core_es5["_5" /* forwardRef */])(() => item_options_ItemOptions)),
    Object(tslib_es6["__metadata"])("design:type", typeof (item_sliding__c = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && item_sliding__c || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item_sliding__d = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && item_sliding__d || Object])
], item_sliding_ItemSliding.prototype, "_itemOptions", null);
item_sliding_ItemSliding = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-item-sliding',
        template: `
    <ng-content select="ion-item,[ion-item]"></ng-content>
    <ng-content select="ion-item-options"></ng-content>
  `,
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (item_sliding__e = typeof list_List !== "undefined" && list_List) === "function" && item_sliding__e || Object, typeof (item_sliding__f = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && item_sliding__f || Object, typeof (item_sliding__g = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && item_sliding__g || Object, typeof (item_sliding__h = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && item_sliding__h || Object, typeof (item_sliding__j = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && item_sliding__j || Object])
], item_sliding_ItemSliding);

var item_sliding__a, item_sliding__b, item_sliding__c, item_sliding__d, item_sliding__e, item_sliding__f, item_sliding__g, item_sliding__h, item_sliding__j;




// CONCATENATED MODULE: ./src/components/item/reorder.ts




let reorder_Reorder = class Reorder {
    constructor(elementRef) {
        this.elementRef = elementRef;
        elementRef.nativeElement['$ionComponent'] = this;
    }
    getReorderNode() {
        return findReorderItem(this.elementRef.nativeElement, null);
    }
    onClick(ev) {
        ev.preventDefault();
        ev.stopPropagation();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], reorder_Reorder.prototype, "onClick", null);
reorder_Reorder = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-reorder',
        template: `<ion-icon name="reorder"></ion-icon>`
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (reorder__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && reorder__a || Object])
], reorder_Reorder);

var reorder__a;




// CONCATENATED MODULE: ./src/components/list/list-header.ts






let ListHeader = class ListHeader extends Ion {
    constructor(config, renderer, elementRef, _id) {
        super(config, elementRef, renderer, 'list-header');
        this._id = _id;
    }
    get id() {
        return this._id;
    }
    set id(val) {
        this._id = val;
        this.setElementAttribute('id', val);
    }
};
ListHeader = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-list-header'
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["g" /* Attribute */])('id')),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (list_header__a = typeof config_Config !== "undefined" && config_Config) === "function" && list_header__a || Object, typeof (list_header__b = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && list_header__b || Object, typeof (list_header__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && list_header__c || Object, String])
], ListHeader);

var list_header__a, list_header__b, list_header__c;




// CONCATENATED MODULE: ./src/components/loading/loading-component.ts









let loading_component_LoadingCmp = class LoadingCmp {
    constructor(_viewCtrl, _config, _elementRef, gestureCtrl, params, renderer) {
        this._viewCtrl = _viewCtrl;
        this._config = _config;
        _assert(params.data, 'params data must be valid');
        this.gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);
        this.d = params.data;
        renderer.setElementClass(_elementRef.nativeElement, `loading-${_config.get('mode')}`, true);
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                if (cssClass.trim() !== '')
                    renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++loadingIds);
    }
    ngOnInit() {
        if (isUndefined(this.d.spinner)) {
            this.d.spinner = this._config.get('loadingSpinner', this._config.get('spinner', 'ios'));
        }
        this.showSpinner = isDefined(this.d.spinner) && this.d.spinner !== 'hide';
    }
    ionViewWillEnter() {
        this.gestureBlocker.block();
    }
    ionViewDidLeave() {
        this.gestureBlocker.unblock();
    }
    ionViewDidEnter() {
        if (this.d && this.d.duration) {
            this.durationTimeout = setTimeout(() => this.dismiss('backdrop'), this.d.duration);
        }
    }
    keyUp(ev) {
        if (this._viewCtrl.isLast() && ev.keyCode === KEY_ESCAPE) {
            this.bdClick();
        }
    }
    bdClick() {
        if (this.d.enableBackdropDismiss) {
            this.dismiss('backdrop');
        }
    }
    dismiss(role) {
        if (this.durationTimeout) {
            clearTimeout(this.durationTimeout);
        }
        return this._viewCtrl.dismiss(null, role);
    }
    ngOnDestroy() {
        _assert(this.gestureBlocker.blocked === false, 'gesture blocker must be already unblocked');
        this.gestureBlocker.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('body:keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], loading_component_LoadingCmp.prototype, "keyUp", null);
loading_component_LoadingCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-loading',
        template: '<ion-backdrop [hidden]="!d.showBackdrop" (click)="bdClick()" [class.backdrop-no-tappable]="!d.enableBackdropDismiss"></ion-backdrop>' +
            '<div class="loading-wrapper">' +
            '<div *ngIf="showSpinner" class="loading-spinner">' +
            '<ion-spinner [name]="d.spinner"></ion-spinner>' +
            '</div>' +
            '<div *ngIf="d.content" [innerHTML]="d.content" class="loading-content"></div>' +
            '</div>',
        host: {
            'role': 'dialog'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (loading_component__a = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && loading_component__a || Object, typeof (loading_component__b = typeof config_Config !== "undefined" && config_Config) === "function" && loading_component__b || Object, typeof (loading_component__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && loading_component__c || Object, typeof (loading_component__d = typeof GestureController !== "undefined" && GestureController) === "function" && loading_component__d || Object, typeof (loading_component__e = typeof NavParams !== "undefined" && NavParams) === "function" && loading_component__e || Object, typeof (loading_component__f = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && loading_component__f || Object])
], loading_component_LoadingCmp);

let loadingIds = -1;
var loading_component__a, loading_component__b, loading_component__c, loading_component__d, loading_component__e, loading_component__f;




// CONCATENATED MODULE: ./src/components/loading/loading-transitions.ts


class loading_transitions_LoadingPopIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.loading-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
        backdrop.fromTo('opacity', 0.01, 0.3);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class loading_transitions_LoadingPopOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.loading-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
        backdrop.fromTo('opacity', 0.3, 0);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class loading_transitions_LoadingMdPopIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.loading-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
        backdrop.fromTo('opacity', 0.01, 0.5);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class loading_transitions_LoadingMdPopOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.loading-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
        backdrop.fromTo('opacity', 0.5, 0);
        this
            .easing('ease-in-out')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class loading_transitions_LoadingWpPopIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.loading-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.3, 1);
        backdrop.fromTo('opacity', 0.01, 0.16);
        this
            .easing('cubic-bezier(0,0,0.05,1)')
            .duration(200)
            .add(backdrop)
            .add(wrapper);
    }
}
class loading_transitions_LoadingWpPopOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.loading-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 1.3);
        backdrop.fromTo('opacity', 0.16, 0);
        this
            .easing('ease-out')
            .duration(150)
            .add(backdrop)
            .add(wrapper);
    }
}
//# sourceMappingURL=loading-transitions.js.map
// CONCATENATED MODULE: ./src/components/loading/loading.ts





class loading_Loading extends view_controller_ViewController {
    constructor(app, opts = {}, config) {
        opts.showBackdrop = isPresent(opts.showBackdrop) ? !!opts.showBackdrop : true;
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : false;
        opts.dismissOnPageChange = isPresent(opts.dismissOnPageChange) ? !!opts.dismissOnPageChange : false;
        super(loading_component_LoadingCmp, opts, null);
        this._app = app;
        this.isOverlay = true;
        config.setTransition('loading-pop-in', loading_transitions_LoadingPopIn);
        config.setTransition('loading-pop-out', loading_transitions_LoadingPopOut);
        config.setTransition('loading-md-pop-in', loading_transitions_LoadingMdPopIn);
        config.setTransition('loading-md-pop-out', loading_transitions_LoadingMdPopOut);
        config.setTransition('loading-wp-pop-in', loading_transitions_LoadingWpPopIn);
        config.setTransition('loading-wp-pop-out', loading_transitions_LoadingWpPopOut);
    }
    getTransitionName(direction) {
        let key = (direction === 'back' ? 'loadingLeave' : 'loadingEnter');
        return this._nav && this._nav.config.get(key);
    }
    setContent(content) {
        this.data.content = content;
        return this;
    }
    setSpinner(spinner) {
        this.data.spinner = spinner;
        return this;
    }
    setCssClass(cssClass) {
        this.data.cssClass = cssClass;
        return this;
    }
    setShowBackdrop(showBackdrop) {
        this.data.showBackdrop = showBackdrop;
        return this;
    }
    setDuration(dur) {
        this.data.duration = dur;
        return this;
    }
    present(navOptions = {}) {
        return this._app.present(this, navOptions, PORTAL_LOADING);
    }
    dismissAll() {
        this._nav && this._nav.popAll();
    }
}
//# sourceMappingURL=loading.js.map
// CONCATENATED MODULE: ./src/components/loading/loading-controller.ts






let loading_controller_LoadingController = class LoadingController {
    constructor(_app, config) {
        this._app = _app;
        this.config = config;
    }
    create(opts = {}) {
        return new loading_Loading(this._app, opts, this.config);
    }
};
loading_controller_LoadingController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (loading_controller__a = typeof app_App !== "undefined" && app_App) === "function" && loading_controller__a || Object, typeof (loading_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && loading_controller__b || Object])
], loading_controller_LoadingController);

var loading_controller__a, loading_controller__b;




// EXTERNAL MODULE: ./src/components/loading/loading-options.ts
var loading_options = __webpack_require__(51);
var loading_options_default = /*#__PURE__*/__webpack_require__.n(loading_options);

// CONCATENATED MODULE: ./src/components/menu/menu-gestures.ts


class menu_gestures_MenuContentGesture extends slide_edge_gesture_SlideEdgeGesture {
    constructor(plt, menu, gestureCtrl, domCtrl) {
        super(plt, plt.doc().body, {
            direction: 'x',
            edge: menu.side,
            threshold: 5,
            maxEdgeStart: menu.maxEdgeStart || 50,
            zone: false,
            passive: true,
            domController: domCtrl,
            gesture: gestureCtrl.createGesture({
                name: GESTURE_MENU_SWIPE,
                priority: GESTURE_PRIORITY_MENU_SWIPE,
                disableScroll: true
            })
        });
        this.menu = menu;
    }
    canStart(ev) {
        const menu = this.menu;
        if (!menu.canSwipe()) {
            return false;
        }
        if (menu.isOpen) {
            return true;
        }
        else if (menu.getMenuController().getOpen()) {
            return false;
        }
        return super.canStart(ev);
    }
    onSlideBeforeStart() {
        console.debug('menu gesture, onSlideBeforeStart', this.menu.side);
        this.menu._swipeBeforeStart();
    }
    onSlideStart() {
        console.debug('menu gesture, onSlideStart', this.menu.side);
        this.menu._swipeStart();
    }
    onSlide(slide) {
        const z = (this.menu.isRightSide !== this.plt.isRTL ? slide.min : slide.max);
        const stepValue = (slide.distance / z);
        this.menu._swipeProgress(stepValue);
    }
    onSlideEnd(slide) {
        let z = (this.menu.isRightSide !== this.plt.isRTL ? slide.min : slide.max);
        const currentStepValue = (slide.distance / z);
        const velocity = slide.velocity;
        z = Math.abs(z * 0.5);
        const shouldCompleteRight = (velocity >= 0)
            && (velocity > 0.2 || slide.delta > z);
        const shouldCompleteLeft = (velocity <= 0)
            && (velocity < -0.2 || slide.delta < -z);
        console.debug('menu gesture, onSlideEnd', this.menu.side, 'distance', slide.distance, 'delta', slide.delta, 'velocity', velocity, 'min', slide.min, 'max', slide.max, 'shouldCompleteLeft', shouldCompleteLeft, 'shouldCompleteRight', shouldCompleteRight, 'currentStepValue', currentStepValue);
        this.menu._swipeEnd(shouldCompleteLeft, shouldCompleteRight, currentStepValue, velocity);
    }
    getElementStartPos(slide) {
        const menu = this.menu;
        if (menu.isRightSide !== this.plt.isRTL) {
            return menu.isOpen ? slide.min : slide.max;
        }
        return menu.isOpen ? slide.max : slide.min;
    }
    getSlideBoundaries() {
        const menu = this.menu;
        if (menu.isRightSide !== this.plt.isRTL) {
            return {
                min: -menu.width(),
                max: 0
            };
        }
        return {
            min: 0,
            max: menu.width()
        };
    }
}
//# sourceMappingURL=menu-gestures.js.map
// CONCATENATED MODULE: ./src/components/split-pane/split-pane.ts







const QUERY = {
    xs: '(min-width: 0px)',
    sm: '(min-width: 576px)',
    md: '(min-width: 768px)',
    lg: '(min-width: 992px)',
    xl: '(min-width: 1200px)',
    never: ''
};
class RootNode {
}
let split_pane_SplitPane = SplitPane_1 = class SplitPane extends Ion {
    constructor(_zone, _plt, config, elementRef, renderer) {
        super(config, elementRef, renderer, 'split-pane');
        this._zone = _zone;
        this._plt = _plt;
        this._init = false;
        this._visible = false;
        this._isEnabled = true;
        this._mediaQuery = QUERY['md'];
        this.sideContent = null;
        this.mainContent = null;
        this.ionChange = new core_es5["r" /* EventEmitter */]();
    }
    set _setchildren(query) {
        const children = this._children = query.filter((child => child !== this));
        children.forEach(child => {
            var isMain = child.initPane();
            this._setPaneCSSClass(child.getElementRef(), isMain);
        });
    }
    set when(query) {
        if (typeof query === 'boolean') {
            this._mediaQuery = query;
        }
        else {
            const defaultQuery = QUERY[query];
            this._mediaQuery = (defaultQuery)
                ? defaultQuery
                : query;
        }
        this._update();
    }
    get when() {
        return this._mediaQuery;
    }
    set enabled(val) {
        this._isEnabled = isTrueProperty(val);
        this._update();
    }
    get enabled() {
        return this._isEnabled;
    }
    _register(node, isMain, callback) {
        if (this.getElementRef().nativeElement !== node.getElementRef().nativeElement.parentNode) {
            return false;
        }
        this._setPaneCSSClass(node.getElementRef(), isMain);
        if (callback) {
            this.ionChange.subscribe(callback);
        }
        if (isMain) {
            if (this.mainContent) {
                console.error('split pane: main content was already set');
            }
            this.mainContent = node;
        }
        return true;
    }
    ngAfterViewInit() {
        this._init = true;
        this._update();
    }
    _update() {
        if (!this._init) {
            return;
        }
        this._rmListener && this._rmListener();
        this._rmListener = null;
        if (!this._isEnabled) {
            this._setVisible(false);
            return;
        }
        const query = this._mediaQuery;
        if (typeof query === 'boolean') {
            this._setVisible(query);
            return;
        }
        if (query && query.length > 0) {
            const callback = (query) => this._setVisible(query.matches);
            const mediaList = this._plt.win().matchMedia(query);
            mediaList.addListener(callback);
            this._setVisible(mediaList.matches);
            this._rmListener = function () {
                mediaList.removeListener(callback);
            };
        }
        else {
            this._setVisible(false);
        }
    }
    _updateChildren() {
        this.mainContent = null;
        this.sideContent = null;
        const visible = this._visible;
        this._children.forEach(child => child.paneChanged && child.paneChanged(visible));
    }
    _setVisible(visible) {
        if (this._visible === visible) {
            return;
        }
        this._visible = visible;
        this.setElementClass('split-pane-visible', visible);
        this._updateChildren();
        this._zone.run(() => {
            this.ionChange.emit(this);
        });
    }
    isVisible() {
        return this._visible;
    }
    setElementClass(className, add) {
        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);
    }
    _setPaneCSSClass(elementRef, isMain) {
        const ele = elementRef.nativeElement;
        this._renderer.setElementClass(ele, 'split-pane-main', isMain);
        this._renderer.setElementClass(ele, 'split-pane-side', !isMain);
    }
    ngOnDestroy() {
        _assert(this._rmListener, 'at this point _rmListerner should be valid');
        this._rmListener && this._rmListener();
        this._rmListener = null;
    }
    initPane() {
        return true;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(RootNode, { descendants: false }),
    Object(tslib_es6["__metadata"])("design:type", typeof (split_pane__a = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && split_pane__a || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (split_pane__b = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && split_pane__b || Object])
], split_pane_SplitPane.prototype, "_setchildren", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], split_pane_SplitPane.prototype, "when", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], split_pane_SplitPane.prototype, "enabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (split_pane__c = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && split_pane__c || Object)
], split_pane_SplitPane.prototype, "ionChange", void 0);
split_pane_SplitPane = SplitPane_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-split-pane',
        providers: [{ provide: RootNode, useExisting: Object(core_es5["_5" /* forwardRef */])(() => SplitPane_1) }]
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (split_pane__d = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && split_pane__d || Object, typeof (split_pane__e = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && split_pane__e || Object, typeof (split_pane__f = typeof config_Config !== "undefined" && config_Config) === "function" && split_pane__f || Object, typeof (split_pane__g = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && split_pane__g || Object, typeof (split_pane__h = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && split_pane__h || Object])
], split_pane_SplitPane);

var SplitPane_1, split_pane__a, split_pane__b, split_pane__c, split_pane__d, split_pane__e, split_pane__f, split_pane__g, split_pane__h;




// CONCATENATED MODULE: ./src/components/nav/nav.ts















let Nav = Nav_1 = class Nav extends nav_controller_base_NavControllerBase {
    constructor(viewCtrl, parent, app, config, plt, elementRef, zone, renderer, cfr, gestureCtrl, transCtrl, linker, domCtrl, errHandler) {
        super(parent, app, config, plt, elementRef, zone, renderer, cfr, gestureCtrl, transCtrl, linker, domCtrl, errHandler);
        this._hasInit = false;
        if (viewCtrl) {
            viewCtrl._setContent(this);
        }
        if (parent) {
            parent.registerChildNav(this);
        }
        else if (viewCtrl && viewCtrl.getNav()) {
            this.parent = viewCtrl.getNav();
            this.parent.registerChildNav(this);
        }
        else if (app && !app.getRootNavById(this.id)) {
            app.registerRootNav(this);
        }
    }
    set _vp(val) {
        this.setViewport(val);
    }
    ngAfterViewInit() {
        this._hasInit = true;
        const segment = this._linker.getSegmentByNavIdOrName(this.id, this.name);
        if (segment && (segment.component || segment.loadChildren)) {
            return this._linker.initViews(segment).then(views => {
                return this.setPages(views, null, null);
            });
        }
        else if (this._root) {
            const setUrl = segment ? false : true;
            return this.push(this._root, this.rootParams, {
                isNavRoot: (this._app.getRootNavById(this.id) === this),
                updateUrl: setUrl
            }, null);
        }
    }
    get root() {
        return this._root;
    }
    set root(page) {
        this._root = page;
        if (this._hasInit) {
            this.setRoot(page);
        }
    }
    ngOnDestroy() {
        this.destroy();
    }
    initPane() {
        const isMain = this._elementRef.nativeElement.hasAttribute('main');
        return isMain;
    }
    paneChanged(isPane) {
        if (isPane) {
            this.resize();
        }
    }
    goToRoot(opts) {
        return this.setRoot(this._root, this.rootParams, opts, null);
    }
    getType() {
        return 'nav';
    }
    getSecondaryIdentifier() {
        return null;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('viewport', { read: core_es5["_0" /* ViewContainerRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (nav__a = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && nav__a || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (nav__b = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && nav__b || Object])
], Nav.prototype, "_vp", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], Nav.prototype, "root", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], Nav.prototype, "rootParams", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], Nav.prototype, "name", void 0);
Nav = Nav_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-nav',
        template: '<div #viewport nav-viewport></div>' +
            '<div class="nav-decor"></div>',
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
        providers: [{ provide: RootNode, useExisting: Object(core_es5["_5" /* forwardRef */])(() => Nav_1) }]
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(1, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(11, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (nav__c = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && nav__c || Object, typeof (nav__d = typeof NavController !== "undefined" && NavController) === "function" && nav__d || Object, typeof (nav__e = typeof app_App !== "undefined" && app_App) === "function" && nav__e || Object, typeof (nav__f = typeof config_Config !== "undefined" && config_Config) === "function" && nav__f || Object, typeof (nav__g = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && nav__g || Object, typeof (nav__h = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && nav__h || Object, typeof (nav__j = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && nav__j || Object, typeof (nav__k = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && nav__k || Object, typeof (nav__l = typeof core_es5["l" /* ComponentFactoryResolver */] !== "undefined" && core_es5["l" /* ComponentFactoryResolver */]) === "function" && nav__l || Object, typeof (nav__m = typeof GestureController !== "undefined" && GestureController) === "function" && nav__m || Object, typeof (nav__o = typeof transition_controller_TransitionController !== "undefined" && transition_controller_TransitionController) === "function" && nav__o || Object, typeof (_p = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && _p || Object, typeof (_q = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && _q || Object, typeof (_r = typeof core_es5["q" /* ErrorHandler */] !== "undefined" && core_es5["q" /* ErrorHandler */]) === "function" && _r || Object])
], Nav);

var Nav_1, nav__a, nav__b, nav__c, nav__d, nav__e, nav__f, nav__g, nav__h, nav__j, nav__k, nav__l, nav__m, nav__o, _p, _q, _r;




// CONCATENATED MODULE: ./src/components/menu/menu.ts

















let menu_Menu = Menu_1 = class Menu {
    constructor(_menuCtrl, _elementRef, _config, _plt, _renderer, _keyboard, _gestureCtrl, _domCtrl, _app) {
        this._menuCtrl = _menuCtrl;
        this._elementRef = _elementRef;
        this._config = _config;
        this._plt = _plt;
        this._renderer = _renderer;
        this._keyboard = _keyboard;
        this._gestureCtrl = _gestureCtrl;
        this._domCtrl = _domCtrl;
        this._app = _app;
        this._isSwipeEnabled = true;
        this._isAnimating = false;
        this._isPersistent = false;
        this._init = false;
        this._isPane = false;
        this.isOpen = false;
        this.isRightSide = false;
        this.ionDrag = new core_es5["r" /* EventEmitter */]();
        this.ionOpen = new core_es5["r" /* EventEmitter */]();
        this.ionClose = new core_es5["r" /* EventEmitter */]();
        this._events = new ui_event_manager_UIEventManager(_plt);
        this._gestureBlocker = _gestureCtrl.createBlocker({
            disable: [GESTURE_GO_BACK_SWIPE]
        });
        this.side = 'start';
    }
    get enabled() {
        return this._isEnabled;
    }
    set enabled(val) {
        const isEnabled = isTrueProperty(val);
        this.enable(isEnabled);
    }
    get side() {
        return this._side;
    }
    set side(val) {
        this.isRightSide = util_isRightSide(val, this._plt.isRTL);
        if (this.isRightSide) {
            this._side = 'right';
        }
        else {
            this._side = 'left';
        }
    }
    get swipeEnabled() {
        return this._isSwipeEnabled;
    }
    set swipeEnabled(val) {
        const isEnabled = isTrueProperty(val);
        this.swipeEnable(isEnabled);
    }
    get persistent() {
        return this._isPersistent;
    }
    set persistent(val) {
        this._isPersistent = isTrueProperty(val);
    }
    ngOnInit() {
        this._init = true;
        let content = this.content;
        this._cntEle = (content instanceof Node) ? content : content && content.getNativeElement && content.getNativeElement();
        if (!this._cntEle) {
            return console.error('Menu: must have a [content] element to listen for drag events on. Example:\n\n<ion-menu [content]="content"></ion-menu>\n\n<ion-nav #content></ion-nav>');
        }
        this.setElementAttribute('side', this._side);
        if (!this.type) {
            this.type = this._config.get('menuType');
        }
        this.setElementAttribute('type', this.type);
        this._gesture = new menu_gestures_MenuContentGesture(this._plt, this, this._gestureCtrl, this._domCtrl);
        this._cntEle.classList.add('menu-content');
        this._cntEle.classList.add('menu-content-' + this.type);
        let isEnabled = this._isEnabled;
        if (isEnabled === true || typeof isEnabled === 'undefined') {
            isEnabled = !this._menuCtrl.getMenus().some(m => {
                return m.side === this.side && m.enabled;
            });
        }
        this._menuCtrl._register(this);
        this.enable(isEnabled);
    }
    onBackdropClick(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this._menuCtrl.close();
    }
    _getType() {
        if (!this._type) {
            this._type = menu_controller_MenuController.create(this.type, this, this._plt);
            if (this._config.get('animate') === false) {
                this._type.ani.duration(0);
            }
        }
        return this._type;
    }
    setOpen(shouldOpen, animated = true) {
        if ((shouldOpen === this.isOpen) || !this._canOpen() || this._isAnimating) {
            return Promise.resolve(this.isOpen);
        }
        return new Promise(resolve => {
            this._before();
            this._getType().setOpen(shouldOpen, animated, () => {
                this._after(shouldOpen);
                resolve(this.isOpen);
            });
        });
    }
    _forceClosing() {
        _assert(this.isOpen, 'menu cannot be closed');
        this._isAnimating = true;
        this._getType().setOpen(false, false, () => {
            this._after(false);
        });
    }
    canSwipe() {
        return this._isSwipeEnabled &&
            !this._isAnimating &&
            this._canOpen() &&
            this._app.isEnabled();
    }
    isAnimating() {
        return this._isAnimating;
    }
    _swipeBeforeStart() {
        if (!this.canSwipe()) {
            _assert(false, 'canSwipe() has to be true');
            return;
        }
        this._before();
    }
    _swipeStart() {
        if (!this._isAnimating) {
            _assert(false, '_isAnimating has to be true');
            return;
        }
        this._getType().setProgressStart(this.isOpen);
    }
    _swipeProgress(stepValue) {
        if (!this._isAnimating) {
            _assert(false, '_isAnimating has to be true');
            return;
        }
        this._getType().setProgessStep(stepValue);
        const ionDrag = this.ionDrag;
        if (ionDrag.observers.length > 0) {
            ionDrag.emit(stepValue);
        }
    }
    _swipeEnd(shouldCompleteLeft, shouldCompleteRight, stepValue, velocity) {
        if (!this._isAnimating) {
            _assert(false, '_isAnimating has to be true');
            return;
        }
        const isRightSide = this.isRightSide;
        const isRTL = this._plt.isRTL;
        const opening = !this.isOpen;
        const shouldComplete = (opening)
            ? (isRightSide !== isRTL) ? shouldCompleteLeft : shouldCompleteRight
            : (isRightSide !== isRTL) ? shouldCompleteRight : shouldCompleteLeft;
        this._getType().setProgressEnd(shouldComplete, stepValue, velocity, (isOpen) => {
            console.debug('menu, swipeEnd', this.side);
            this._after(isOpen);
        });
    }
    _before() {
        _assert(!this._isAnimating, '_before() should not be called while animating');
        this.setElementClass('show-menu', true);
        this.backdrop.setElementClass('show-backdrop', true);
        this.resize();
        this._keyboard.close();
        this._isAnimating = true;
    }
    _after(isOpen) {
        _assert(this._isAnimating, '_before() should be called while animating');
        this._app.setEnabled(false, 100);
        this.isOpen = isOpen;
        this._isAnimating = false;
        this._events.unlistenAll();
        if (isOpen) {
            this._gestureBlocker.block();
            this._cntEle.classList.add('menu-content-open');
            let callback = this.onBackdropClick.bind(this);
            this._events.listen(this._cntEle, 'click', callback, { capture: true });
            this._events.listen(this.backdrop.getNativeElement(), 'click', callback, { capture: true });
            this.ionOpen.emit(true);
        }
        else {
            this._gestureBlocker.unblock();
            this._cntEle.classList.remove('menu-content-open');
            this.setElementClass('show-menu', false);
            this.backdrop.setElementClass('show-menu', false);
            this.ionClose.emit(true);
        }
    }
    open() {
        return this.setOpen(true);
    }
    close() {
        return this.setOpen(false);
    }
    resize() {
        const content = this.menuContent
            ? this.menuContent
            : this.menuNav;
        content && content.resize();
    }
    toggle() {
        return this.setOpen(!this.isOpen);
    }
    _canOpen() {
        return this._isEnabled && !this._isPane;
    }
    _updateState() {
        const canOpen = this._canOpen();
        if (!canOpen && this.isOpen) {
            _assert(this._init, 'menu must be initialized');
            this._forceClosing();
        }
        if (this._isEnabled && this._menuCtrl) {
            this._menuCtrl._setActiveMenu(this);
        }
        if (!this._init) {
            return;
        }
        const gesture = this._gesture;
        if (canOpen && this._isSwipeEnabled && !gesture.isListening) {
            console.debug('menu, gesture listen', this.side);
            gesture.listen();
        }
        else if (gesture.isListening && (!canOpen || !this._isSwipeEnabled)) {
            console.debug('menu, gesture unlisten', this.side);
            gesture.unlisten();
        }
        if (this.isOpen || (this._isPane && this._isEnabled)) {
            this.resize();
        }
        _assert(!this._isAnimating, 'can not be animating');
    }
    enable(shouldEnable) {
        this._isEnabled = shouldEnable;
        this.setElementClass('menu-enabled', shouldEnable);
        this._updateState();
        return this;
    }
    initPane() {
        return false;
    }
    paneChanged(isPane) {
        this._isPane = isPane;
        this._updateState();
    }
    swipeEnable(shouldEnable) {
        this._isSwipeEnabled = shouldEnable;
        this._updateState();
        return this;
    }
    getNativeElement() {
        return this._elementRef.nativeElement;
    }
    getMenuElement() {
        return this.getNativeElement().querySelector('.menu-inner');
    }
    getContentElement() {
        return this._cntEle;
    }
    getBackdropElement() {
        return this.backdrop.getNativeElement();
    }
    width() {
        return this.getMenuElement().offsetWidth;
    }
    getMenuController() {
        return this._menuCtrl;
    }
    setElementClass(className, add) {
        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);
    }
    setElementAttribute(attributeName, value) {
        this._renderer.setElementAttribute(this._elementRef.nativeElement, attributeName, value);
    }
    getElementRef() {
        return this._elementRef;
    }
    ngOnDestroy() {
        this._menuCtrl._unregister(this);
        this._events.destroy();
        this._gesture && this._gesture.destroy();
        this._type && this._type.destroy();
        this._gesture = null;
        this._type = null;
        this._cntEle = null;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])(Backdrop),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__a = typeof Backdrop !== "undefined" && Backdrop) === "function" && menu__a || Object)
], menu_Menu.prototype, "backdrop", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(content_Content),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__b = typeof content_Content !== "undefined" && content_Content) === "function" && menu__b || Object)
], menu_Menu.prototype, "menuContent", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(Nav),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__c = typeof Nav !== "undefined" && Nav) === "function" && menu__c || Object)
], menu_Menu.prototype, "menuNav", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], menu_Menu.prototype, "content", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], menu_Menu.prototype, "id", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], menu_Menu.prototype, "type", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], menu_Menu.prototype, "enabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__d = typeof /* Cannot get final name for export "Side" in "./src/util/util.ts" (known exports: clamp deepCopy deepEqual debounce normalizeURL defaults isBoolean isString isNumber isFunction isDefined isUndefined isPresent isBlank isObject isArray isPrimitive isTrueProperty isCheckedProperty isRightSide reorderArray removeArrayItem swipeShouldReset requestIonicCallback assert runInDev, known reexports: ) */ undefined !== "undefined" && /* Cannot get final name for export "Side" in "./src/util/util.ts" (known exports: clamp deepCopy deepEqual debounce normalizeURL defaults isBoolean isString isNumber isFunction isDefined isUndefined isPresent isBlank isObject isArray isPrimitive isTrueProperty isCheckedProperty isRightSide reorderArray removeArrayItem swipeShouldReset requestIonicCallback assert runInDev, known reexports: ) */ undefined) === "function" && menu__d || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (menu__e = typeof /* Cannot get final name for export "Side" in "./src/util/util.ts" (known exports: clamp deepCopy deepEqual debounce normalizeURL defaults isBoolean isString isNumber isFunction isDefined isUndefined isPresent isBlank isObject isArray isPrimitive isTrueProperty isCheckedProperty isRightSide reorderArray removeArrayItem swipeShouldReset requestIonicCallback assert runInDev, known reexports: ) */ undefined !== "undefined" && /* Cannot get final name for export "Side" in "./src/util/util.ts" (known exports: clamp deepCopy deepEqual debounce normalizeURL defaults isBoolean isString isNumber isFunction isDefined isUndefined isPresent isBlank isObject isArray isPrimitive isTrueProperty isCheckedProperty isRightSide reorderArray removeArrayItem swipeShouldReset requestIonicCallback assert runInDev, known reexports: ) */ undefined) === "function" && menu__e || Object])
], menu_Menu.prototype, "side", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], menu_Menu.prototype, "swipeEnabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], menu_Menu.prototype, "persistent", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], menu_Menu.prototype, "maxEdgeStart", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__f = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && menu__f || Object)
], menu_Menu.prototype, "ionDrag", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__g = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && menu__g || Object)
], menu_Menu.prototype, "ionOpen", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (menu__h = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && menu__h || Object)
], menu_Menu.prototype, "ionClose", void 0);
menu_Menu = Menu_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-menu',
        template: '<div class="menu-inner"><ng-content></ng-content></div>' +
            '<ion-backdrop></ion-backdrop>',
        host: {
            'role': 'navigation'
        },
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
        providers: [{ provide: RootNode, useExisting: Object(core_es5["_5" /* forwardRef */])(() => Menu_1) }]
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (menu__j = typeof menu_controller_MenuController !== "undefined" && menu_controller_MenuController) === "function" && menu__j || Object, typeof (menu__k = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && menu__k || Object, typeof (menu__l = typeof config_Config !== "undefined" && config_Config) === "function" && menu__l || Object, typeof (menu__m = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && menu__m || Object, typeof (menu__o = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && menu__o || Object, typeof (menu__p = typeof keyboard_Keyboard !== "undefined" && keyboard_Keyboard) === "function" && menu__p || Object, typeof (menu__q = typeof GestureController !== "undefined" && GestureController) === "function" && menu__q || Object, typeof (menu__r = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && menu__r || Object, typeof (_s = typeof app_App !== "undefined" && app_App) === "function" && _s || Object])
], menu_Menu);

var Menu_1, menu__a, menu__b, menu__c, menu__d, menu__e, menu__f, menu__g, menu__h, menu__j, menu__k, menu__l, menu__m, menu__o, menu__p, menu__q, menu__r, _s;




// CONCATENATED MODULE: ./src/components/menu/menu-close.ts




let MenuClose = class MenuClose {
    constructor(_menu) {
        this._menu = _menu;
    }
    close() {
        const menu = this._menu.get(this.menuClose);
        menu && menu.close();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], MenuClose.prototype, "menuClose", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], MenuClose.prototype, "close", null);
MenuClose = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[menuClose]'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (menu_close__a = typeof menu_controller_MenuController !== "undefined" && menu_controller_MenuController) === "function" && menu_close__a || Object])
], MenuClose);

var menu_close__a;




// CONCATENATED MODULE: ./src/components/toolbar/toolbar-base.ts

class ToolbarBase extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'toolbar');
    }
    _setTitle(titleCmp) {
        this._title = titleCmp;
    }
    getTitleText() {
        return (this._title && this._title.getTitleText()) || '';
    }
}
//# sourceMappingURL=toolbar-base.js.map
// CONCATENATED MODULE: ./src/components/toolbar/navbar.ts










let navbar_Navbar = class Navbar extends ToolbarBase {
    constructor(_app, viewCtrl, navCtrl, config, elementRef, renderer) {
        super(config, elementRef, renderer);
        this._app = _app;
        this.navCtrl = navCtrl;
        this._hidden = false;
        this._hideBb = false;
        viewCtrl && viewCtrl._setNavbar(this);
        this._bbIcon = config.get('backButtonIcon');
        this._sbPadding = config.getBoolean('statusbarPadding');
        this._backText = config.get('backButtonText', 'Back');
    }
    get hideBackButton() {
        return this._hideBb;
    }
    set hideBackButton(val) {
        this._hideBb = isTrueProperty(val);
    }
    backButtonClick(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.navCtrl && this.navCtrl.pop(null, null);
    }
    setBackButtonText(text) {
        this._backText = text;
    }
    didEnter() {
        try {
            this._app.setTitle(this.getTitleText());
        }
        catch (e) {
            console.error(e);
        }
    }
    setHidden(isHidden) {
        this._hidden = isHidden;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], navbar_Navbar.prototype, "hideBackButton", null);
navbar_Navbar = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-navbar',
        template: '<div class="toolbar-background" [ngClass]="\'toolbar-background-\' + _mode"></div>' +
            '<button (click)="backButtonClick($event)" ion-button="bar-button" class="back-button" [ngClass]="\'back-button-\' + _mode" [hidden]="_hideBb">' +
            '<ion-icon class="back-button-icon" [ngClass]="\'back-button-icon-\' + _mode" [name]="_bbIcon"></ion-icon>' +
            '<span class="back-button-text" [ngClass]="\'back-button-text-\' + _mode">{{_backText}}</span>' +
            '</button>' +
            '<ng-content select="[menuToggle],ion-buttons[left]"></ng-content>' +
            '<ng-content select="ion-buttons[start]"></ng-content>' +
            '<ng-content select="ion-buttons[end],ion-buttons[right]"></ng-content>' +
            '<div class="toolbar-content" [ngClass]="\'toolbar-content-\' + _mode">' +
            '<ng-content></ng-content>' +
            '</div>',
        host: {
            '[hidden]': '_hidden',
            'class': 'toolbar',
            '[class.statusbar-padding]': '_sbPadding'
        }
    }),
    Object(tslib_es6["__param"])(1, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(2, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (navbar__a = typeof app_App !== "undefined" && app_App) === "function" && navbar__a || Object, typeof (navbar__b = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && navbar__b || Object, typeof (navbar__c = typeof NavController !== "undefined" && NavController) === "function" && navbar__c || Object, typeof (navbar__d = typeof config_Config !== "undefined" && config_Config) === "function" && navbar__d || Object, typeof (navbar__e = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && navbar__e || Object, typeof (navbar__f = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && navbar__f || Object])
], navbar_Navbar);

var navbar__a, navbar__b, navbar__c, navbar__d, navbar__e, navbar__f;




// CONCATENATED MODULE: ./src/components/menu/menu-toggle.ts








let MenuToggle = class MenuToggle {
    constructor(_menu, _viewCtrl, _button, _navbar) {
        this._menu = _menu;
        this._viewCtrl = _viewCtrl;
        this._button = _button;
        this._isButton = !!_button;
        this._inNavbar = !!_navbar;
    }
    ngAfterContentInit() {
        if (this._isButton) {
            this._button._setClass('menutoggle', true);
        }
    }
    toggle() {
        const menu = this._menu.get(this.menuToggle);
        menu && menu.toggle();
    }
    get isHidden() {
        const menu = this._menu.get(this.menuToggle);
        if (this._inNavbar && this._viewCtrl) {
            if (!menu || !menu._canOpen()) {
                return true;
            }
            if (this._viewCtrl.isFirst()) {
                return false;
            }
            if (menu) {
                return !menu.persistent;
            }
        }
        return false;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], MenuToggle.prototype, "menuToggle", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], MenuToggle.prototype, "toggle", null);
MenuToggle = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[menuToggle]',
        host: {
            '[hidden]': 'isHidden'
        }
    }),
    Object(tslib_es6["__param"])(1, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(2, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (menu_toggle__a = typeof menu_controller_MenuController !== "undefined" && menu_controller_MenuController) === "function" && menu_toggle__a || Object, typeof (menu_toggle__b = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && menu_toggle__b || Object, typeof (menu_toggle__c = typeof button_Button !== "undefined" && button_Button) === "function" && menu_toggle__c || Object, typeof (menu_toggle__d = typeof navbar_Navbar !== "undefined" && navbar_Navbar) === "function" && menu_toggle__d || Object])
], MenuToggle);

var menu_toggle__a, menu_toggle__b, menu_toggle__c, menu_toggle__d;




// CONCATENATED MODULE: ./src/components/menu/menu-types.ts


class menu_types_MenuType {
    constructor(plt) {
        this.ani = new animation_Animation(plt);
        this.ani
            .easing('cubic-bezier(0.0, 0.0, 0.2, 1)')
            .easingReverse('cubic-bezier(0.4, 0.0, 0.6, 1)')
            .duration(280);
    }
    setOpen(shouldOpen, animated, done) {
        const ani = this.ani
            .onFinish(done, true, true)
            .reverse(!shouldOpen);
        if (animated) {
            ani.play();
        }
        else {
            ani.syncPlay();
        }
    }
    setProgressStart(isOpen) {
        this.isOpening = !isOpen;
        this.ani
            .reverse(isOpen)
            .progressStart();
    }
    setProgessStep(stepValue) {
        this.ani.progressStep(stepValue);
    }
    setProgressEnd(shouldComplete, currentStepValue, velocity, done) {
        let isOpen = (this.isOpening && shouldComplete);
        if (!this.isOpening && !shouldComplete) {
            isOpen = true;
        }
        const ani = this.ani;
        ani.onFinish(() => {
            this.isOpening = false;
            done(isOpen);
        }, true);
        const factor = 1 - Math.min(Math.abs(velocity) / 4, 0.7);
        const dur = ani.getDuration() * factor;
        ani.progressEnd(shouldComplete, currentStepValue, dur);
    }
    destroy() {
        this.ani.destroy();
        this.ani = null;
    }
}
class menu_types_MenuRevealType extends menu_types_MenuType {
    constructor(menu, plt) {
        super(plt);
        const openedX = (menu.width() * (menu.isRightSide ? -1 : 1)) + 'px';
        const contentOpen = new animation_Animation(plt, menu.getContentElement());
        contentOpen.fromTo('translateX', '0px', openedX);
        this.ani.add(contentOpen);
    }
}
menu_controller_MenuController.registerType('reveal', menu_types_MenuRevealType);
class menu_types_MenuPushType extends menu_types_MenuType {
    constructor(menu, plt) {
        super(plt);
        let contentOpenedX, menuClosedX, menuOpenedX;
        const width = menu.width();
        if (menu.isRightSide) {
            contentOpenedX = -width + 'px';
            menuClosedX = width + 'px';
            menuOpenedX = '0px';
        }
        else {
            contentOpenedX = width + 'px';
            menuOpenedX = '0px';
            menuClosedX = -width + 'px';
        }
        const menuAni = new animation_Animation(plt, menu.getMenuElement());
        menuAni.fromTo('translateX', menuClosedX, menuOpenedX);
        this.ani.add(menuAni);
        const contentApi = new animation_Animation(plt, menu.getContentElement());
        contentApi.fromTo('translateX', '0px', contentOpenedX);
        this.ani.add(contentApi);
    }
}
menu_controller_MenuController.registerType('push', menu_types_MenuPushType);
class menu_types_MenuOverlayType extends menu_types_MenuType {
    constructor(menu, plt) {
        super(plt);
        let closedX, openedX;
        const width = menu.width();
        if (menu.isRightSide) {
            closedX = 8 + width + 'px';
            openedX = '0px';
        }
        else {
            closedX = -(8 + width) + 'px';
            openedX = '0px';
        }
        const menuAni = new animation_Animation(plt, menu.getMenuElement());
        menuAni.fromTo('translateX', closedX, openedX);
        this.ani.add(menuAni);
        const backdropApi = new animation_Animation(plt, menu.getBackdropElement());
        backdropApi.fromTo('opacity', 0.01, 0.35);
        this.ani.add(backdropApi);
    }
}
menu_controller_MenuController.registerType('overlay', menu_types_MenuOverlayType);
//# sourceMappingURL=menu-types.js.map
// CONCATENATED MODULE: ./src/navigation/overlay-proxy.ts

class overlay_proxy_OverlayProxy {
    constructor(_app, _component, _config, _deepLinker) {
        this._app = _app;
        this._component = _component;
        this._config = _config;
        this._deepLinker = _deepLinker;
    }
    getImplementation() {
        throw new Error('Child class must implement "getImplementation" method');
    }
    present(navOptions = {}) {
        const isLazyLoaded = isString(this._component);
        if (isLazyLoaded) {
            return this._deepLinker.getComponentFromName(this._component).then((loadedComponent) => {
                this._component = loadedComponent;
                return this.createAndPresentOverlay(navOptions);
            });
        }
        else {
            return this.createAndPresentOverlay(navOptions);
        }
    }
    dismiss(data, role, navOptions) {
        if (this.overlay) {
            return this.overlay.dismiss(data, role, navOptions);
        }
    }
    onDidDismiss(callback) {
        this._onDidDismiss = callback;
        if (this.overlay) {
            this.overlay.onDidDismiss(this._onDidDismiss);
        }
    }
    createAndPresentOverlay(navOptions) {
        this.overlay = this.getImplementation();
        this.overlay.onWillDismiss(this._onWillDismiss);
        this.overlay.onDidDismiss(this._onDidDismiss);
        return this.overlay.present(navOptions);
    }
    onWillDismiss(callback) {
        this._onWillDismiss = callback;
        if (this.overlay) {
            this.overlay.onWillDismiss(this._onWillDismiss);
        }
    }
}
//# sourceMappingURL=overlay-proxy.js.map
// CONCATENATED MODULE: ./src/util/ng-module-loader.ts



let ng_module_loader_NgModuleLoader = class NgModuleLoader {
    constructor(_compiler) {
        this._compiler = _compiler;
    }
    load(modulePath, ngModuleExport) {
        const offlineMode = this._compiler instanceof core_es5["j" /* Compiler */];
        return offlineMode ? loadPrecompiledFactory(modulePath, ngModuleExport) : loadAndCompile(this._compiler, modulePath, ngModuleExport);
    }
};
ng_module_loader_NgModuleLoader = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (ng_module_loader__a = typeof core_es5["j" /* Compiler */] !== "undefined" && core_es5["j" /* Compiler */]) === "function" && ng_module_loader__a || Object])
], ng_module_loader_NgModuleLoader);

function loadAndCompile(compiler, modulePath, ngModuleExport) {
    if (!ngModuleExport) {
        ngModuleExport = 'default';
    }
    return __webpack_require__(24)(modulePath)
        .then((rawModule) => {
        const module = rawModule[ngModuleExport];
        if (!module) {
            throw new Error(`Module ${modulePath} does not export ${ngModuleExport}`);
        }
        return compiler.compileModuleAsync(module);
    });
}
function loadPrecompiledFactory(modulePath, ngModuleExport) {
    return __webpack_require__(24)(modulePath)
        .then((rawModule) => {
        const ngModuleFactory = rawModule[ngModuleExport];
        if (!ngModuleFactory) {
            throw new Error(`Module ${modulePath} does not export ${ngModuleExport}`);
        }
        return ngModuleFactory;
    });
}
var ng_module_loader__a;




// CONCATENATED MODULE: ./src/util/module-loader.ts





const LAZY_LOADED_TOKEN = new core_es5["H" /* OpaqueToken */]('LZYCMP');
let ModuleLoader = class ModuleLoader {
    constructor(_ngModuleLoader, _injector) {
        this._ngModuleLoader = _ngModuleLoader;
        this._injector = _injector;
        this._cfrMap = new Map();
        this._promiseMap = new Map();
    }
    load(modulePath) {
        console.time(`ModuleLoader, load: ${modulePath}'`);
        const splitString = modulePath.split(SPLITTER);
        let promise = this._promiseMap.get(modulePath);
        if (!promise) {
            promise = this._ngModuleLoader.load(splitString[0], splitString[1]);
            this._promiseMap.set(modulePath, promise);
        }
        return promise.then(loadedModule => {
            console.timeEnd(`ModuleLoader, load: ${modulePath}'`);
            const ref = loadedModule.create(this._injector);
            const component = ref.injector.get(LAZY_LOADED_TOKEN);
            this._cfrMap.set(component, ref.componentFactoryResolver);
            return {
                componentFactoryResolver: ref.componentFactoryResolver,
                component: component
            };
        });
    }
    getComponentFactoryResolver(component) {
        return this._cfrMap.get(component);
    }
};
ModuleLoader = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (module_loader__a = typeof ng_module_loader_NgModuleLoader !== "undefined" && ng_module_loader_NgModuleLoader) === "function" && module_loader__a || Object, typeof (module_loader__b = typeof core_es5["y" /* Injector */] !== "undefined" && core_es5["y" /* Injector */]) === "function" && module_loader__b || Object])
], ModuleLoader);

const SPLITTER = '#';
function provideModuleLoader(ngModuleLoader, injector) {
    return new ModuleLoader(ngModuleLoader, injector);
}
function setupPreloadingImplementation(config, deepLinkConfig, moduleLoader) {
    if (!deepLinkConfig || !deepLinkConfig.links || !config.getBoolean('preloadModules')) {
        return Promise.resolve();
    }
    const linksToLoad = deepLinkConfig.links.filter(link => !!link.loadChildren && link.priority !== 'off');
    const highPriorityPromises = linksToLoad
        .filter(link => link.priority === 'high')
        .map(link => moduleLoader.load(link.loadChildren));
    return Promise.all(highPriorityPromises).then(() => {
        const lowPriorityPromises = linksToLoad
            .filter(link => link.priority === 'low')
            .map(link => moduleLoader.load(link.loadChildren));
        return Promise.all(lowPriorityPromises);
    }).catch(err => {
        console.error(err.message);
    });
}
function setupPreloading(config, deepLinkConfig, moduleLoader, ngZone) {
    return function () {
        requestIonicCallback(() => {
            ngZone.runOutsideAngular(() => {
                setupPreloadingImplementation(config, deepLinkConfig, moduleLoader);
            });
        });
    };
}
var module_loader__a, module_loader__b;




// CONCATENATED MODULE: ./src/components/modal/modal-component.ts









let modal_component_ModalCmp = class ModalCmp {
    constructor(_cfr, _renderer, _elementRef, _navParams, _viewCtrl, gestureCtrl, moduleLoader) {
        this._cfr = _cfr;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._navParams = _navParams;
        this._viewCtrl = _viewCtrl;
        this.moduleLoader = moduleLoader;
        let opts = _navParams.get('opts');
        _assert(opts, 'modal data must be valid');
        this._gestureBlocker = gestureCtrl.createBlocker({
            disable: [GESTURE_MENU_SWIPE, GESTURE_GO_BACK_SWIPE]
        });
        this._bdDismiss = opts.enableBackdropDismiss;
        if (opts.cssClass) {
            opts.cssClass.split(' ').forEach((cssClass) => {
                if (cssClass.trim() !== '')
                    _renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
    }
    ionViewPreLoad() {
        const component = this._navParams.data.component;
        if (!component) {
            console.warn('modal\'s page was not defined');
            return;
        }
        let cfr = this.moduleLoader.getComponentFactoryResolver(component);
        if (!cfr) {
            cfr = this._cfr;
        }
        const componentFactory = cfr.resolveComponentFactory(component);
        const componentRef = this._viewport.createComponent(componentFactory, this._viewport.length, this._viewport.parentInjector, []);
        this._setCssClass(componentRef, 'ion-page');
        this._setCssClass(componentRef, 'show-page');
        this._viewCtrl._setInstance(componentRef.instance);
        this._viewCtrl.willEnter.subscribe(this._viewWillEnter.bind(this));
        this._viewCtrl.didLeave.subscribe(this._viewDidLeave.bind(this));
        this._enabled = true;
    }
    _viewWillEnter() {
        this._gestureBlocker.block();
    }
    _viewDidLeave() {
        this._gestureBlocker.unblock();
    }
    _setCssClass(componentRef, className) {
        this._renderer.setElementClass(componentRef.location.nativeElement, className, true);
    }
    _bdClick() {
        if (this._enabled && this._bdDismiss) {
            const opts = {
                minClickBlockDuration: 400
            };
            return this._viewCtrl.dismiss(null, 'backdrop', opts);
        }
    }
    _keyUp(ev) {
        if (this._enabled && this._viewCtrl.isLast() && ev.keyCode === KEY_ESCAPE) {
            this._bdClick();
        }
    }
    ngOnDestroy() {
        _assert(this._gestureBlocker.blocked === false, 'gesture blocker must be already unblocked');
        this._gestureBlocker.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('viewport', { read: core_es5["_0" /* ViewContainerRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (modal_component__a = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && modal_component__a || Object)
], modal_component_ModalCmp.prototype, "_viewport", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('body:keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], modal_component_ModalCmp.prototype, "_keyUp", null);
modal_component_ModalCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-modal',
        template: '<ion-backdrop (click)="_bdClick()" [class.backdrop-no-tappable]="!_bdDismiss"></ion-backdrop>' +
            '<div class="modal-wrapper">' +
            '<div #viewport nav-viewport></div>' +
            '</div>'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (modal_component__b = typeof core_es5["l" /* ComponentFactoryResolver */] !== "undefined" && core_es5["l" /* ComponentFactoryResolver */]) === "function" && modal_component__b || Object, typeof (modal_component__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && modal_component__c || Object, typeof (modal_component__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && modal_component__d || Object, typeof (modal_component__e = typeof NavParams !== "undefined" && NavParams) === "function" && modal_component__e || Object, typeof (modal_component__f = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && modal_component__f || Object, typeof (modal_component__g = typeof GestureController !== "undefined" && GestureController) === "function" && modal_component__g || Object, typeof (modal_component__h = typeof ModuleLoader !== "undefined" && ModuleLoader) === "function" && modal_component__h || Object])
], modal_component_ModalCmp);

var modal_component__a, modal_component__b, modal_component__c, modal_component__d, modal_component__e, modal_component__f, modal_component__g, modal_component__h;




// CONCATENATED MODULE: ./src/components/modal/modal-transitions.ts


class modal_transitions_ModalSlideIn extends page_transition_PageTransition {
    init() {
        super.init();
        const ele = this.enteringView.pageRef().nativeElement;
        const backdropEle = ele.querySelector('ion-backdrop');
        const backdrop = new animation_Animation(this.plt, backdropEle);
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.modal-wrapper'));
        wrapper.beforeStyles({ 'opacity': 1 });
        wrapper.fromTo('translateY', '100%', '0%');
        backdrop.fromTo('opacity', 0.01, 0.4);
        this
            .element(this.enteringView.pageRef())
            .easing('cubic-bezier(0.36,0.66,0.04,1)')
            .duration(400)
            .add(backdrop)
            .add(wrapper);
    }
}
class modal_transitions_ModalSlideOut extends page_transition_PageTransition {
    init() {
        super.init();
        const ele = this.leavingView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapperEle = ele.querySelector('.modal-wrapper');
        let wrapperEleRect = wrapperEle.getBoundingClientRect();
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        wrapper.fromTo('translateY', '0px', `${this.plt.height() - wrapperEleRect.top}px`);
        backdrop.fromTo('opacity', 0.4, 0.0);
        this
            .element(this.leavingView.pageRef())
            .easing('ease-out')
            .duration(250)
            .add(backdrop)
            .add(wrapper);
    }
}
class modal_transitions_ModalMDSlideIn extends page_transition_PageTransition {
    init() {
        super.init();
        const ele = this.enteringView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.modal-wrapper'));
        backdrop.fromTo('opacity', 0.01, 0.4);
        wrapper.fromTo('translateY', '40px', '0px');
        wrapper.fromTo('opacity', 0.01, 1);
        const DURATION = 280;
        const EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
        this.element(this.enteringView.pageRef()).easing(EASING).duration(DURATION)
            .add(backdrop)
            .add(wrapper);
    }
}
class modal_transitions_ModalMDSlideOut extends page_transition_PageTransition {
    init() {
        super.init();
        const ele = this.leavingView.pageRef().nativeElement;
        const backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        const wrapper = new animation_Animation(this.plt, ele.querySelector('.modal-wrapper'));
        backdrop.fromTo('opacity', 0.4, 0.0);
        wrapper.fromTo('translateY', '0px', '40px');
        wrapper.fromTo('opacity', 0.99, 0);
        this
            .element(this.leavingView.pageRef())
            .duration(200)
            .easing('cubic-bezier(0.47,0,0.745,0.715)')
            .add(wrapper)
            .add(backdrop);
    }
}
//# sourceMappingURL=modal-transitions.js.map
// CONCATENATED MODULE: ./src/components/modal/modal-impl.ts





class modal_impl_ModalImpl extends view_controller_ViewController {
    constructor(app, component, data, opts = {}, config) {
        data = data || {};
        data.component = component;
        opts.showBackdrop = isPresent(opts.showBackdrop) ? !!opts.showBackdrop : true;
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
        data.opts = opts;
        super(modal_component_ModalCmp, data, null);
        this._app = app;
        this._enterAnimation = opts.enterAnimation;
        this._leaveAnimation = opts.leaveAnimation;
        this.isOverlay = true;
        config.setTransition('modal-slide-in', modal_transitions_ModalSlideIn);
        config.setTransition('modal-slide-out', modal_transitions_ModalSlideOut);
        config.setTransition('modal-md-slide-in', modal_transitions_ModalMDSlideIn);
        config.setTransition('modal-md-slide-out', modal_transitions_ModalMDSlideOut);
    }
    getTransitionName(direction) {
        let key;
        if (direction === 'back') {
            if (this._leaveAnimation) {
                return this._leaveAnimation;
            }
            key = 'modalLeave';
        }
        else {
            if (this._enterAnimation) {
                return this._enterAnimation;
            }
            key = 'modalEnter';
        }
        return this._nav && this._nav.config.get(key);
    }
    present(navOptions = {}) {
        navOptions.minClickBlockDuration = navOptions.minClickBlockDuration || 400;
        return this._app.present(this, navOptions, PORTAL_MODAL);
    }
}
//# sourceMappingURL=modal-impl.js.map
// CONCATENATED MODULE: ./src/components/modal/modal.ts


class modal_Modal extends overlay_proxy_OverlayProxy {
    constructor(app, component, data, opts = {}, config, deepLinker) {
        super(app, component, config, deepLinker);
        this.data = data;
        this.opts = opts;
        this.isOverlay = true;
    }
    getImplementation() {
        return new modal_impl_ModalImpl(this._app, this._component, this.data, this.opts, this._config);
    }
}
//# sourceMappingURL=modal.js.map
// CONCATENATED MODULE: ./src/components/modal/modal-controller.ts







let modal_controller_ModalController = class ModalController {
    constructor(_app, config, deepLinker) {
        this._app = _app;
        this.config = config;
        this.deepLinker = deepLinker;
    }
    create(component, data = {}, opts = {}) {
        return new modal_Modal(this._app, component, data, opts, this.config, this.deepLinker);
    }
};
modal_controller_ModalController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (modal_controller__a = typeof app_App !== "undefined" && app_App) === "function" && modal_controller__a || Object, typeof (modal_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && modal_controller__b || Object, typeof (modal_controller__c = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && modal_controller__c || Object])
], modal_controller_ModalController);

var modal_controller__a, modal_controller__b, modal_controller__c;




// EXTERNAL MODULE: ./src/components/modal/modal-options.ts
var modal_options = __webpack_require__(52);
var modal_options_default = /*#__PURE__*/__webpack_require__.n(modal_options);

// CONCATENATED MODULE: ./src/components/nav/nav-pop.ts





let NavPop = class NavPop {
    constructor(_nav) {
        this._nav = _nav;
        if (!_nav) {
            console.error('navPop must be within a NavController');
        }
    }
    onClick() {
        if (this._nav) {
            this._nav.pop().catch(() => {
                console.debug('navPop was rejected');
            });
            return false;
        }
        return true;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", Boolean)
], NavPop.prototype, "onClick", null);
NavPop = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[navPop]'
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (nav_pop__a = typeof NavController !== "undefined" && NavController) === "function" && nav_pop__a || Object])
], NavPop);

var nav_pop__a;




// CONCATENATED MODULE: ./src/components/nav/nav-pop-anchor.ts







let NavPopAnchor = class NavPopAnchor {
    constructor(host, linker, viewCtrl) {
        this.host = host;
        this.linker = linker;
        this.viewCtrl = viewCtrl;
    }
    updateHref() {
        if (this.host && this.viewCtrl) {
            const previousView = this.host._nav.getPrevious(this.viewCtrl);
            this._href = (previousView && this.linker.createUrl(this.host._nav, this.viewCtrl.component, this.viewCtrl.data)) || '#';
        }
        else {
            this._href = '#';
        }
    }
    ngAfterContentInit() {
        this.updateHref();
    }
};
NavPopAnchor = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'a[navPop]',
        host: {
            '[attr.href]': '_href'
        }
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(2, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (nav_pop_anchor__a = typeof NavPop !== "undefined" && NavPop) === "function" && nav_pop_anchor__a || Object, typeof (nav_pop_anchor__b = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && nav_pop_anchor__b || Object, typeof (nav_pop_anchor__c = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && nav_pop_anchor__c || Object])
], NavPopAnchor);

var nav_pop_anchor__a, nav_pop_anchor__b, nav_pop_anchor__c;




// CONCATENATED MODULE: ./src/components/nav/nav-push.ts





let NavPush = class NavPush {
    constructor(_nav) {
        this._nav = _nav;
        if (!_nav) {
            console.error('navPush must be within a NavController');
        }
    }
    onClick() {
        if (this._nav && this.navPush) {
            this._nav.push(this.navPush, this.navParams);
            return false;
        }
        return true;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], NavPush.prototype, "navPush", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], NavPush.prototype, "navParams", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", Boolean)
], NavPush.prototype, "onClick", null);
NavPush = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[navPush]'
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (nav_push__a = typeof NavController !== "undefined" && NavController) === "function" && nav_push__a || Object])
], NavPush);

var nav_push__b, nav_push__a;




// CONCATENATED MODULE: ./src/components/nav/nav-push-anchor.ts






let NavPushAnchor = class NavPushAnchor {
    constructor(host, linker) {
        this.host = host;
        this.linker = linker;
    }
    updateHref() {
        if (this.host && this.linker) {
            this._href = this.linker.createUrl(this.host._nav, this.host.navPush, this.host.navParams) || '#';
        }
        else {
            this._href = '#';
        }
    }
    ngAfterContentInit() {
        this.updateHref();
    }
};
NavPushAnchor = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'a[navPush]',
        host: {
            '[attr.href]': '_href'
        }
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["s" /* Host */])()),
    Object(tslib_es6["__param"])(1, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (nav_push_anchor__a = typeof NavPush !== "undefined" && NavPush) === "function" && nav_push_anchor__a || Object, typeof (nav_push_anchor__b = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && nav_push_anchor__b || Object])
], NavPushAnchor);

var nav_push_anchor__a, nav_push_anchor__b;




// CONCATENATED MODULE: ./src/components/note/note.ts





let Note = class Note extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'note');
    }
};
Note = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-note'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (note__a = typeof config_Config !== "undefined" && config_Config) === "function" && note__a || Object, typeof (note__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && note__b || Object, typeof (note__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && note__c || Object])
], Note);

var note__a, note__b, note__c;




// CONCATENATED MODULE: ./src/components/option/option.ts




let option_Option = class Option {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._selected = false;
        this._disabled = false;
        this.ionSelect = new core_es5["r" /* EventEmitter */]();
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(val) {
        this._disabled = isTrueProperty(val);
    }
    get selected() {
        return this._selected;
    }
    set selected(val) {
        this._selected = isTrueProperty(val);
    }
    get value() {
        if (isPresent(this._value)) {
            return this._value;
        }
        return this.text;
    }
    set value(val) {
        this._value = val;
    }
    get text() {
        return this._elementRef.nativeElement.textContent;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], option_Option.prototype, "disabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], option_Option.prototype, "selected", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], option_Option.prototype, "value", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (option__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && option__a || Object)
], option_Option.prototype, "ionSelect", void 0);
option_Option = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-option'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (option__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && option__b || Object])
], option_Option);

var option__a, option__b;




// CONCATENATED MODULE: ./src/components/popover/popover-component.ts










let popover_component_PopoverCmp = class PopoverCmp {
    constructor(_cfr, _elementRef, _renderer, _config, _navParams, _viewCtrl, gestureCtrl, moduleLoader) {
        this._cfr = _cfr;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._config = _config;
        this._navParams = _navParams;
        this._viewCtrl = _viewCtrl;
        this.moduleLoader = moduleLoader;
        this._gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);
        this.d = _navParams.data.opts;
        _renderer.setElementClass(_elementRef.nativeElement, `popover-${_config.get('mode')}`, true);
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                if (cssClass.trim() !== '')
                    _renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++popoverIds);
    }
    ionViewPreLoad() {
        this._load(this._navParams.data.component);
    }
    _load(component) {
        if (component) {
            let cfr = this.moduleLoader.getComponentFactoryResolver(component);
            if (!cfr) {
                cfr = this._cfr;
            }
            const componentFactory = cfr.resolveComponentFactory(component);
            const componentRef = this._viewport.createComponent(componentFactory, this._viewport.length, this._viewport.parentInjector, []);
            this._viewCtrl._setInstance(componentRef.instance);
            this._enabled = true;
            this._viewCtrl.willEnter.subscribe(this._viewWillEnter.bind(this));
            this._viewCtrl.didLeave.subscribe(this._viewDidLeave.bind(this));
        }
    }
    _viewWillEnter() {
        this._gestureBlocker.block();
    }
    _viewDidLeave() {
        this._gestureBlocker.unblock();
    }
    _setCssClass(componentRef, className) {
        this._renderer.setElementClass(componentRef.location.nativeElement, className, true);
    }
    _bdClick() {
        if (this._enabled && this.d.enableBackdropDismiss) {
            return this._viewCtrl.dismiss(null, 'backdrop');
        }
    }
    _keyUp(ev) {
        if (this._enabled && ev.keyCode === KEY_ESCAPE && this._viewCtrl.isLast()) {
            this._bdClick();
        }
    }
    ngOnDestroy() {
        _assert(this._gestureBlocker.blocked === false, 'gesture blocker must be already unblocked');
        this._gestureBlocker.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('viewport', { read: core_es5["_0" /* ViewContainerRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (popover_component__a = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && popover_component__a || Object)
], popover_component_PopoverCmp.prototype, "_viewport", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('body:keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], popover_component_PopoverCmp.prototype, "_keyUp", null);
popover_component_PopoverCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-popover',
        template: '<ion-backdrop (click)="_bdClick()" [hidden]="!d.showBackdrop"></ion-backdrop>' +
            '<div class="popover-wrapper">' +
            '<div class="popover-arrow"></div>' +
            '<div class="popover-content">' +
            '<div class="popover-viewport">' +
            '<div #viewport nav-viewport></div>' +
            '</div>' +
            '</div>' +
            '</div>'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (popover_component__b = typeof core_es5["l" /* ComponentFactoryResolver */] !== "undefined" && core_es5["l" /* ComponentFactoryResolver */]) === "function" && popover_component__b || Object, typeof (popover_component__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && popover_component__c || Object, typeof (popover_component__d = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && popover_component__d || Object, typeof (popover_component__e = typeof config_Config !== "undefined" && config_Config) === "function" && popover_component__e || Object, typeof (popover_component__f = typeof NavParams !== "undefined" && NavParams) === "function" && popover_component__f || Object, typeof (popover_component__g = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && popover_component__g || Object, typeof (popover_component__h = typeof GestureController !== "undefined" && GestureController) === "function" && popover_component__h || Object, typeof (popover_component__j = typeof ModuleLoader !== "undefined" && ModuleLoader) === "function" && popover_component__j || Object])
], popover_component_PopoverCmp);

let popoverIds = -1;
var popover_component__a, popover_component__b, popover_component__c, popover_component__d, popover_component__e, popover_component__f, popover_component__g, popover_component__h, popover_component__j;




// CONCATENATED MODULE: ./src/components/popover/popover-transitions.ts


class PopoverTransition extends page_transition_PageTransition {
    mdPositionView(nativeEle, ev) {
        let originY = 'top';
        let originX = 'left';
        let popoverWrapperEle = nativeEle.querySelector('.popover-wrapper');
        let popoverEle = nativeEle.querySelector('.popover-content');
        let popoverDim = popoverEle.getBoundingClientRect();
        let popoverWidth = popoverDim.width;
        let popoverHeight = popoverDim.height;
        let bodyWidth = this.plt.width();
        let bodyHeight = this.plt.height();
        let targetDim = ev && ev.target && ev.target.getBoundingClientRect();
        let targetTop = (targetDim && 'top' in targetDim) ? targetDim.top : (bodyHeight / 2) - (popoverHeight / 2);
        let targetLeft = (targetDim && 'left' in targetDim) ? targetDim.left : (bodyWidth / 2) - (popoverWidth / 2);
        let targetHeight = targetDim && targetDim.height || 0;
        let popoverCSS = {
            top: targetTop,
            left: targetLeft
        };
        if (popoverCSS.left < POPOVER_MD_BODY_PADDING) {
            popoverCSS.left = POPOVER_MD_BODY_PADDING;
        }
        else if (popoverWidth + POPOVER_MD_BODY_PADDING + popoverCSS.left > bodyWidth) {
            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_MD_BODY_PADDING;
            originX = 'right';
        }
        if (targetTop + targetHeight + popoverHeight > bodyHeight && targetTop - popoverHeight > 0) {
            popoverCSS.top = targetTop - popoverHeight;
            nativeEle.className = nativeEle.className + ' popover-bottom';
            originY = 'bottom';
        }
        else if (targetTop + targetHeight + popoverHeight > bodyHeight) {
            popoverEle.style.bottom = POPOVER_MD_BODY_PADDING + 'px';
        }
        popoverEle.style.top = popoverCSS.top + 'px';
        popoverEle.style.left = popoverCSS.left + 'px';
        popoverEle.style[this.plt.Css.transformOrigin] = originY + ' ' + originX;
        popoverWrapperEle.style.opacity = '1';
    }
    iosPositionView(nativeEle, ev) {
        let originY = 'top';
        let originX = 'left';
        let popoverWrapperEle = nativeEle.querySelector('.popover-wrapper');
        let popoverEle = nativeEle.querySelector('.popover-content');
        let popoverDim = popoverEle.getBoundingClientRect();
        let popoverWidth = popoverDim.width;
        let popoverHeight = popoverDim.height;
        let bodyWidth = this.plt.width();
        let bodyHeight = this.plt.height();
        let targetDim = ev && ev.target && ev.target.getBoundingClientRect();
        let targetTop = (targetDim && 'top' in targetDim) ? targetDim.top : (bodyHeight / 2) - (popoverHeight / 2);
        let targetLeft = (targetDim && 'left' in targetDim) ? targetDim.left : (bodyWidth / 2);
        let targetWidth = targetDim && targetDim.width || 0;
        let targetHeight = targetDim && targetDim.height || 0;
        var arrowEle = nativeEle.querySelector('.popover-arrow');
        let arrowDim = arrowEle.getBoundingClientRect();
        var arrowWidth = arrowDim.width;
        var arrowHeight = arrowDim.height;
        if (!targetDim) {
            arrowEle.style.display = 'none';
        }
        let arrowCSS = {
            top: targetTop + targetHeight,
            left: targetLeft + (targetWidth / 2) - (arrowWidth / 2)
        };
        let popoverCSS = {
            top: targetTop + targetHeight + (arrowHeight - 1),
            left: targetLeft + (targetWidth / 2) - (popoverWidth / 2)
        };
        if (popoverCSS.left < POPOVER_IOS_BODY_PADDING) {
            popoverCSS.left = POPOVER_IOS_BODY_PADDING;
        }
        else if (popoverWidth + POPOVER_IOS_BODY_PADDING + popoverCSS.left > bodyWidth) {
            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_IOS_BODY_PADDING;
            originX = 'right';
        }
        if (targetTop + targetHeight + popoverHeight > bodyHeight && targetTop - popoverHeight > 0) {
            arrowCSS.top = targetTop - (arrowHeight + 1);
            popoverCSS.top = targetTop - popoverHeight - (arrowHeight - 1);
            nativeEle.className = nativeEle.className + ' popover-bottom';
            originY = 'bottom';
        }
        else if (targetTop + targetHeight + popoverHeight > bodyHeight) {
            popoverEle.style.bottom = POPOVER_IOS_BODY_PADDING + '%';
        }
        arrowEle.style.top = arrowCSS.top + 'px';
        arrowEle.style.left = arrowCSS.left + 'px';
        popoverEle.style.top = popoverCSS.top + 'px';
        popoverEle.style.left = popoverCSS.left + 'px';
        popoverEle.style[this.plt.Css.transformOrigin] = originY + ' ' + originX;
        popoverWrapperEle.style.opacity = '1';
    }
}
class popover_transitions_PopoverPopIn extends PopoverTransition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.popover-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1);
        backdrop.fromTo('opacity', 0.01, 0.08);
        this
            .easing('ease')
            .duration(100)
            .add(backdrop)
            .add(wrapper);
    }
    play() {
        this.plt.raf(() => {
            this.iosPositionView(this.enteringView.pageRef().nativeElement, this.opts.ev);
            super.play();
        });
    }
}
class popover_transitions_PopoverPopOut extends PopoverTransition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        let backdrop = new animation_Animation(this.plt, ele.querySelector('ion-backdrop'));
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.popover-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0);
        backdrop.fromTo('opacity', 0.08, 0);
        this
            .easing('ease')
            .duration(500)
            .add(backdrop)
            .add(wrapper);
    }
}
class popover_transitions_PopoverMdPopIn extends PopoverTransition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        let content = new animation_Animation(this.plt, ele.querySelector('.popover-content'));
        let viewport = new animation_Animation(this.plt, ele.querySelector('.popover-viewport'));
        content.fromTo('scale', 0.001, 1);
        viewport.fromTo('opacity', 0.01, 1);
        this
            .easing('cubic-bezier(0.36,0.66,0.04,1)')
            .duration(300)
            .add(content)
            .add(viewport);
    }
    play() {
        this.plt.raf(() => {
            this.mdPositionView(this.enteringView.pageRef().nativeElement, this.opts.ev);
            super.play();
        });
    }
}
class popover_transitions_PopoverMdPopOut extends PopoverTransition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        let wrapper = new animation_Animation(this.plt, ele.querySelector('.popover-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0);
        this
            .easing('ease')
            .duration(500)
            .fromTo('opacity', 0.01, 1)
            .add(wrapper);
    }
}
const POPOVER_IOS_BODY_PADDING = 2;
const POPOVER_MD_BODY_PADDING = 12;
//# sourceMappingURL=popover-transitions.js.map
// CONCATENATED MODULE: ./src/components/popover/popover-impl.ts




class popover_impl_PopoverImpl extends view_controller_ViewController {
    constructor(app, component, data = {}, opts = {}, config) {
        opts.showBackdrop = isPresent(opts.showBackdrop) ? !!opts.showBackdrop : true;
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
        data.component = component;
        data.opts = opts;
        super(popover_component_PopoverCmp, data, null);
        this._app = app;
        this.isOverlay = true;
        config.setTransition('popover-pop-in', popover_transitions_PopoverPopIn);
        config.setTransition('popover-pop-out', popover_transitions_PopoverPopOut);
        config.setTransition('popover-md-pop-in', popover_transitions_PopoverMdPopIn);
        config.setTransition('popover-md-pop-out', popover_transitions_PopoverMdPopOut);
    }
    getTransitionName(direction) {
        let key = (direction === 'back' ? 'popoverLeave' : 'popoverEnter');
        return this._nav && this._nav.config.get(key);
    }
    present(navOptions = {}) {
        return this._app.present(this, navOptions);
    }
}
//# sourceMappingURL=popover-impl.js.map
// CONCATENATED MODULE: ./src/components/popover/popover.ts


class popover_Popover extends overlay_proxy_OverlayProxy {
    constructor(app, component, data, opts = {}, config, deepLinker) {
        super(app, component, config, deepLinker);
        this.data = data;
        this.opts = opts;
        this.isOverlay = true;
    }
    getImplementation() {
        return new popover_impl_PopoverImpl(this._app, this._component, this.data, this.opts, this._config);
    }
}
//# sourceMappingURL=popover.js.map
// CONCATENATED MODULE: ./src/components/popover/popover-controller.ts







let popover_controller_PopoverController = class PopoverController {
    constructor(_app, config, _deepLinker) {
        this._app = _app;
        this.config = config;
        this._deepLinker = _deepLinker;
    }
    create(component, data = {}, opts = {}) {
        return new popover_Popover(this._app, component, data, opts, this.config, this._deepLinker);
    }
};
popover_controller_PopoverController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (popover_controller__a = typeof app_App !== "undefined" && app_App) === "function" && popover_controller__a || Object, typeof (popover_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && popover_controller__b || Object, typeof (popover_controller__c = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && popover_controller__c || Object])
], popover_controller_PopoverController);

var popover_controller__a, popover_controller__b, popover_controller__c;




// EXTERNAL MODULE: ./src/components/popover/popover-options.ts
var popover_options = __webpack_require__(53);
var popover_options_default = /*#__PURE__*/__webpack_require__.n(popover_options);

// CONCATENATED MODULE: ./src/components/radio/radio-group.ts






let radio_group_RadioGroup = RadioGroup_1 = class RadioGroup {
    constructor(_renderer, _elementRef, _cd) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._cd = _cd;
        this._disabled = false;
        this._btns = [];
        this._ids = -1;
        this._init = false;
        this.ionChange = new core_es5["r" /* EventEmitter */]();
        this.id = ++radioGroupIds;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(val) {
        this._disabled = isTrueProperty(val);
    }
    ngAfterContentInit() {
        let activeButton = this._btns.find(b => b.checked);
        if (activeButton) {
            this._setActive(activeButton);
        }
    }
    writeValue(val) {
        console.debug('radio group, writeValue', val);
        this.value = val;
        if (this._init) {
            this._update();
            this.onTouched();
            this.ionChange.emit(val);
        }
        this._init = true;
    }
    registerOnChange(fn) {
        this._fn = fn;
        this.onChange = (val) => {
            console.debug('radio group, onChange', val);
            fn(val);
            this.value = val;
            this._update();
            this.onTouched();
            this.ionChange.emit(val);
        };
    }
    registerOnTouched(fn) { this.onTouched = fn; }
    _update() {
        let hasChecked = false;
        this._btns.forEach(radioButton => {
            radioButton.checked = isCheckedProperty(this.value, radioButton.value) && !hasChecked;
            if (radioButton.checked) {
                this._setActive(radioButton);
                hasChecked = true;
            }
        });
    }
    _setActive(radioButton) {
        this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-activedescendant', radioButton.id);
    }
    add(button) {
        this._btns.push(button);
        button.ionSelect.subscribe((val) => {
            this.onChange(val);
        });
        return this.id + '-' + (++this._ids);
    }
    remove(button) {
        let index = this._btns.indexOf(button);
        if (index > -1) {
            if (button.value === this.value) {
                this.value = null;
            }
            this._btns.splice(index, 1);
        }
    }
    set _header(header) {
        if (header) {
            if (!header.id) {
                header.id = 'rg-hdr-' + this.id;
            }
            this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-describedby', header.id);
        }
    }
    onChange(val) {
        console.debug('radio group, onChange w/out formControlName', val);
        this.value = val;
        this._update();
        this.onTouched();
        this.ionChange.emit(val);
        this._cd.detectChanges();
    }
    onTouched() { }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], radio_group_RadioGroup.prototype, "disabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (radio_group__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && radio_group__a || Object)
], radio_group_RadioGroup.prototype, "ionChange", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(ListHeader),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], radio_group_RadioGroup.prototype, "_header", null);
radio_group_RadioGroup = RadioGroup_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[radio-group]',
        host: {
            'role': 'radiogroup'
        },
        providers: [{ provide: forms_es5["e" /* NG_VALUE_ACCESSOR */], useExisting: RadioGroup_1, multi: true }],
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (radio_group__b = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && radio_group__b || Object, typeof (radio_group__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && radio_group__c || Object, typeof (radio_group__d = typeof core_es5["i" /* ChangeDetectorRef */] !== "undefined" && core_es5["i" /* ChangeDetectorRef */]) === "function" && radio_group__d || Object])
], radio_group_RadioGroup);

let radioGroupIds = -1;
var RadioGroup_1, radio_group__a, radio_group__b, radio_group__c, radio_group__d;




// CONCATENATED MODULE: ./src/components/radio/radio-button.ts










let radio_button_RadioButton = class RadioButton extends Ion {
    constructor(_form, config, elementRef, renderer, _item, _group) {
        super(config, elementRef, renderer, 'radio');
        this._form = _form;
        this._item = _item;
        this._group = _group;
        this._checked = false;
        this._disabled = false;
        this._value = null;
        this.ionSelect = new core_es5["r" /* EventEmitter */]();
        _form.register(this);
        if (_group) {
            this.id = 'rb-' + _group.add(this);
        }
        if (_item) {
            this.id = 'rb-' + _item.registerInput('radio');
            this._labelId = 'lbl-' + _item.id;
            this._item.setElementClass('item-radio', true);
        }
    }
    set color(val) {
        this._setColor(val);
        if (this._item) {
            this._item._updateColor(val, 'item-radio');
        }
    }
    get value() {
        return isBlank(this._value) ? this.id : this._value;
    }
    set value(val) {
        this._value = val;
    }
    get checked() {
        return this._checked;
    }
    set checked(val) {
        this._checked = isTrueProperty(val);
        if (this._item) {
            this._item.setElementClass('item-radio-checked', this._checked);
        }
    }
    get disabled() {
        return this._disabled || (this._group != null && this._group.disabled);
    }
    set disabled(val) {
        this._disabled = isTrueProperty(val);
        this._item && this._item.setElementClass('item-radio-disabled', this._disabled);
    }
    initFocus() {
        this._elementRef.nativeElement.querySelector('button').focus();
    }
    _click(ev) {
        console.debug('radio, select', this.id);
        ev.preventDefault();
        ev.stopPropagation();
        this.checked = true;
        this.ionSelect.emit(this.value);
    }
    ngOnInit() {
        if (this._group && isPresent(this._group.value)) {
            this.checked = isCheckedProperty(this._group.value, this.value);
        }
        if (this._group && this._group.disabled) {
            this.disabled = this._group.disabled;
        }
    }
    ngOnDestroy() {
        this._form.deregister(this);
        this._group && this._group.remove(this);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], radio_button_RadioButton.prototype, "color", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (radio_button__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && radio_button__a || Object)
], radio_button_RadioButton.prototype, "ionSelect", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], radio_button_RadioButton.prototype, "value", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], radio_button_RadioButton.prototype, "checked", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], radio_button_RadioButton.prototype, "disabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], radio_button_RadioButton.prototype, "_click", null);
radio_button_RadioButton = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-radio',
        template: '<div class="radio-icon" [class.radio-checked]="_checked"> ' +
            '<div class="radio-inner"></div> ' +
            '</div> ' +
            '<button role="radio" ' +
            'type="button" ' +
            'ion-button="item-cover" ' +
            '[id]="id" ' +
            '[attr.aria-checked]="_checked" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.aria-disabled]="_disabled" ' +
            'class="item-cover"> ' +
            '</button>',
        host: {
            '[class.radio-disabled]': '_disabled'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(4, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(5, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (radio_button__b = typeof form_Form !== "undefined" && form_Form) === "function" && radio_button__b || Object, typeof (radio_button__c = typeof config_Config !== "undefined" && config_Config) === "function" && radio_button__c || Object, typeof (radio_button__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && radio_button__d || Object, typeof (radio_button__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && radio_button__e || Object, typeof (radio_button__f = typeof Item !== "undefined" && Item) === "function" && radio_button__f || Object, typeof (radio_button__g = typeof radio_group_RadioGroup !== "undefined" && radio_group_RadioGroup) === "function" && radio_button__g || Object])
], radio_button_RadioButton);

var radio_button__a, radio_button__b, radio_button__c, radio_button__d, radio_button__e, radio_button__f, radio_button__g;




// CONCATENATED MODULE: ./src/components/range/range.ts















let range_Range = Range_1 = class Range extends base_input_BaseInput {
    constructor(form, _haptic, item, config, _plt, elementRef, renderer, _dom, _cd) {
        super(config, elementRef, renderer, 'range', 0, form, item, null);
        this._haptic = _haptic;
        this._plt = _plt;
        this._dom = _dom;
        this._cd = _cd;
        this._min = 0;
        this._max = 100;
        this._step = 1;
        this._valA = 0;
        this._valB = 0;
        this._ratioA = 0;
        this._ratioB = 0;
        this._events = new ui_event_manager_UIEventManager(_plt);
    }
    get min() {
        return this._min;
    }
    set min(val) {
        val = Math.round(val);
        if (!isNaN(val)) {
            this._min = val;
            this._inputUpdated();
        }
    }
    get max() {
        return this._max;
    }
    set max(val) {
        val = Math.round(val);
        if (!isNaN(val)) {
            this._max = val;
            this._inputUpdated();
        }
    }
    get step() {
        return this._step;
    }
    set step(val) {
        val = Math.round(val);
        if (!isNaN(val) && val > 0) {
            this._step = val;
        }
    }
    get snaps() {
        return this._snaps;
    }
    set snaps(val) {
        this._snaps = isTrueProperty(val);
    }
    get pin() {
        return this._pin;
    }
    set pin(val) {
        this._pin = isTrueProperty(val);
    }
    get debounce() {
        return this._debouncer.wait;
    }
    set debounce(val) {
        this._debouncer.wait = val;
    }
    get dualKnobs() {
        return this._dual;
    }
    set dualKnobs(val) {
        this._dual = isTrueProperty(val);
    }
    get ratio() {
        if (this._dual) {
            return Math.min(this._ratioA, this._ratioB);
        }
        return this._ratioA;
    }
    get ratioUpper() {
        if (this._dual) {
            return Math.max(this._ratioA, this._ratioB);
        }
        return null;
    }
    ngAfterContentInit() {
        this._initialize();
        this._events.pointerEvents({
            element: this._slider.nativeElement,
            pointerDown: this._pointerDown.bind(this),
            pointerMove: this._pointerMove.bind(this),
            pointerUp: this._pointerUp.bind(this),
            zone: true
        });
        this._createTicks();
    }
    _pointerDown(ev) {
        if (this._disabled) {
            return false;
        }
        this._fireFocus();
        ev.preventDefault();
        ev.stopPropagation();
        const current = pointerCoord(ev);
        const rect = this._rect = this._plt.getElementBoundingClientRect(this._slider.nativeElement);
        const ratio = clamp(0, (current.x - rect.left) / (rect.width), 1);
        this._activeB = this._dual && (Math.abs(ratio - this._ratioA) > Math.abs(ratio - this._ratioB));
        this._update(current, rect, true);
        this._haptic.gestureSelectionStart();
        return true;
    }
    _pointerMove(ev) {
        if (this._disabled) {
            return;
        }
        ev.preventDefault();
        ev.stopPropagation();
        const hasChanged = this._update(pointerCoord(ev), this._rect, true);
        if (hasChanged && this._snaps) {
            this._haptic.gestureSelectionChanged();
        }
    }
    _pointerUp(ev) {
        if (this._disabled) {
            return;
        }
        ev.preventDefault();
        ev.stopPropagation();
        this._update(pointerCoord(ev), this._rect, false);
        this._haptic.gestureSelectionEnd();
        this._fireBlur();
    }
    _update(current, rect, isPressed) {
        let ratio = clamp(0, (current.x - rect.left) / (rect.width), 1);
        let val = this._ratioToValue(ratio);
        if (this._snaps) {
            ratio = this._valueToRatio(val);
        }
        this._pressed = isPressed;
        let valChanged = false;
        if (this._activeB) {
            this._pressedB = isPressed;
            this._pressedA = false;
            this._ratioB = ratio;
            valChanged = val === this._valB;
            this._valB = val;
        }
        else {
            this._pressedA = isPressed;
            this._pressedB = false;
            this._ratioA = ratio;
            valChanged = val === this._valA;
            this._valA = val;
        }
        this._updateBar();
        if (valChanged) {
            return false;
        }
        let value;
        if (this._dual) {
            value = {
                lower: Math.min(this._valA, this._valB),
                upper: Math.max(this._valA, this._valB)
            };
            console.debug(`range, updateKnob: ${ratio}, lower: ${this.value.lower}, upper: ${this.value.upper}`);
        }
        else {
            value = this._valA;
            console.debug(`range, updateKnob: ${ratio}, value: ${this.value}`);
        }
        this.value = value;
        return true;
    }
    _updateBar() {
        const ratioA = this._ratioA;
        const ratioB = this._ratioB;
        if (this._dual) {
            this._barL = `${(Math.min(ratioA, ratioB) * 100)}%`;
            this._barR = `${100 - (Math.max(ratioA, ratioB) * 100)}%`;
        }
        else {
            this._barL = '';
            this._barR = `${100 - (ratioA * 100)}%`;
        }
        this._updateTicks();
    }
    _createTicks() {
        if (this._snaps) {
            this._dom.write(() => {
                this._ticks = [];
                for (var value = this._min; value <= this._max; value += this._step) {
                    var ratio = this._valueToRatio(value);
                    this._ticks.push({
                        ratio: ratio,
                        left: `${ratio * 100}%`,
                    });
                }
                this._updateTicks();
            });
        }
    }
    _updateTicks() {
        const ticks = this._ticks;
        const ratio = this.ratio;
        if (this._snaps && ticks) {
            if (this._dual) {
                var upperRatio = this.ratioUpper;
                ticks.forEach(t => {
                    t.active = (t.ratio >= ratio && t.ratio <= upperRatio);
                });
            }
            else {
                ticks.forEach(t => {
                    t.active = (t.ratio <= ratio);
                });
            }
        }
    }
    _keyChg(isIncrease, isKnobB) {
        const step = this._step;
        if (isKnobB) {
            if (isIncrease) {
                this._valB += step;
            }
            else {
                this._valB -= step;
            }
            this._valB = clamp(this._min, this._valB, this._max);
            this._ratioB = this._valueToRatio(this._valB);
        }
        else {
            if (isIncrease) {
                this._valA += step;
            }
            else {
                this._valA -= step;
            }
            this._valA = clamp(this._min, this._valA, this._max);
            this._ratioA = this._valueToRatio(this._valA);
        }
        this._updateBar();
    }
    _ratioToValue(ratio) {
        ratio = Math.round(((this._max - this._min) * ratio));
        ratio = Math.round(ratio / this._step) * this._step + this._min;
        return clamp(this._min, ratio, this._max);
    }
    _valueToRatio(value) {
        value = Math.round((value - this._min) / this._step) * this._step;
        value = value / (this._max - this._min);
        return clamp(0, value, 1);
    }
    _inputNormalize(val) {
        if (this._dual) {
            return val;
        }
        else {
            val = parseFloat(val);
            return isNaN(val) ? undefined : val;
        }
    }
    _inputUpdated() {
        const val = this.value;
        if (this._dual) {
            this._valA = val.lower;
            this._valB = val.upper;
            this._ratioA = this._valueToRatio(val.lower);
            this._ratioB = this._valueToRatio(val.upper);
        }
        else {
            this._valA = val;
            this._ratioA = this._valueToRatio(val);
        }
        this._updateBar();
        this._cd.detectChanges();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._events.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('slider'),
    Object(tslib_es6["__metadata"])("design:type", typeof (range__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && range__a || Object)
], range_Range.prototype, "_slider", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], range_Range.prototype, "min", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], range_Range.prototype, "max", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], range_Range.prototype, "step", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], range_Range.prototype, "snaps", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], range_Range.prototype, "pin", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], range_Range.prototype, "debounce", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], range_Range.prototype, "dualKnobs", null);
range_Range = Range_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-range',
        template: '<ng-content select="[range-left]"></ng-content>' +
            '<div class="range-slider" #slider>' +
            '<div class="range-tick" *ngFor="let t of _ticks" [style.left]="t.left" [class.range-tick-active]="t.active" role="presentation"></div>' +
            '<div class="range-bar" role="presentation"></div>' +
            '<div class="range-bar range-bar-active" [style.left]="_barL" [style.right]="_barR" #bar role="presentation"></div>' +
            '<div class="range-knob-handle" (ionIncrease)="_keyChg(true, false)" (ionDecrease)="_keyChg(false, false)" [ratio]="_ratioA" [val]="_valA" [pin]="_pin" [pressed]="_pressedA" [min]="_min" [max]="_max" [disabled]="_disabled" [labelId]="_labelId"></div>' +
            '<div class="range-knob-handle" (ionIncrease)="_keyChg(true, true)" (ionDecrease)="_keyChg(false, true)" [ratio]="_ratioB" [val]="_valB" [pin]="_pin" [pressed]="_pressedB" [min]="_min" [max]="_max" [disabled]="_disabled" [labelId]="_labelId" *ngIf="_dual"></div>' +
            '</div>' +
            '<ng-content select="[range-right]"></ng-content>',
        host: {
            '[class.range-disabled]': '_disabled',
            '[class.range-pressed]': '_pressed',
            '[class.range-has-pin]': '_pin'
        },
        providers: [{ provide: forms_es5["e" /* NG_VALUE_ACCESSOR */], useExisting: Range_1, multi: true }],
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(2, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (range__b = typeof form_Form !== "undefined" && form_Form) === "function" && range__b || Object, typeof (range__c = typeof Haptic !== "undefined" && Haptic) === "function" && range__c || Object, typeof (range__d = typeof Item !== "undefined" && Item) === "function" && range__d || Object, typeof (range__e = typeof config_Config !== "undefined" && config_Config) === "function" && range__e || Object, typeof (range__f = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && range__f || Object, typeof (range__g = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && range__g || Object, typeof (range__h = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && range__h || Object, typeof (range__j = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && range__j || Object, typeof (range__k = typeof core_es5["i" /* ChangeDetectorRef */] !== "undefined" && core_es5["i" /* ChangeDetectorRef */]) === "function" && range__k || Object])
], range_Range);

var Range_1, range__a, range__b, range__c, range__d, range__e, range__f, range__g, range__h, range__j, range__k;




// CONCATENATED MODULE: ./src/components/range/range-knob.ts




let range_knob_RangeKnob = class RangeKnob {
    constructor() {
        this.ionIncrease = new core_es5["r" /* EventEmitter */]();
        this.ionDecrease = new core_es5["r" /* EventEmitter */]();
    }
    set ratio(r) {
        this._x = `${r * 100}%`;
    }
    _keyup(ev) {
        const keyCode = ev.keyCode;
        if (keyCode === KEY_LEFT || keyCode === KEY_DOWN) {
            console.debug(`range-knob, decrease, keyCode: ${keyCode}`);
            this.ionDecrease.emit();
            ev.preventDefault();
            ev.stopPropagation();
        }
        else if (keyCode === KEY_RIGHT || keyCode === KEY_UP) {
            console.debug(`range-knob, increase, keyCode: ${keyCode}`);
            this.ionIncrease.emit();
            ev.preventDefault();
            ev.stopPropagation();
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], range_knob_RangeKnob.prototype, "ratio", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean)
], range_knob_RangeKnob.prototype, "pressed", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean)
], range_knob_RangeKnob.prototype, "pin", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], range_knob_RangeKnob.prototype, "min", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], range_knob_RangeKnob.prototype, "max", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], range_knob_RangeKnob.prototype, "val", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean)
], range_knob_RangeKnob.prototype, "disabled", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], range_knob_RangeKnob.prototype, "labelId", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], range_knob_RangeKnob.prototype, "ionIncrease", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], range_knob_RangeKnob.prototype, "ionDecrease", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('keydown', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], range_knob_RangeKnob.prototype, "_keyup", null);
range_knob_RangeKnob = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: '.range-knob-handle',
        template: '<div class="range-pin" *ngIf="pin" role="presentation">{{val}}</div>' +
            '<div class="range-knob" role="presentation"></div>',
        host: {
            '[class.range-knob-pressed]': 'pressed',
            '[class.range-knob-min]': 'val===min||val===undefined',
            '[class.range-knob-max]': 'val===max',
            '[style.left]': '_x',
            '[attr.aria-valuenow]': 'val',
            '[attr.aria-valuemin]': 'min',
            '[attr.aria-valuemax]': 'max',
            '[attr.aria-disabled]': 'disabled',
            '[attr.aria-labelledby]': 'labelId',
            '[tabindex]': 'disabled?-1:0',
            'role': 'slider'
        }
    })
], range_knob_RangeKnob);





// CONCATENATED MODULE: ./src/components/refresher/refresher.ts










let refresher_Refresher = class Refresher {
    constructor(_plt, _content, _zone, gestureCtrl) {
        this._plt = _plt;
        this._content = _content;
        this._zone = _zone;
        this._appliedStyles = false;
        this._lastCheck = 0;
        this._isEnabled = true;
        this._top = '';
        this.state = STATE_INACTIVE;
        this.startY = null;
        this.currentY = null;
        this.deltaY = null;
        this.progress = 0;
        this.pullMin = 60;
        this.pullMax = this.pullMin + 60;
        this.closeDuration = 280;
        this.snapbackDuration = 280;
        this.ionRefresh = new core_es5["r" /* EventEmitter */]();
        this.ionPull = new core_es5["r" /* EventEmitter */]();
        this.ionStart = new core_es5["r" /* EventEmitter */]();
        this._events = new ui_event_manager_UIEventManager(_plt);
        _content._hasRefresher = true;
        this._gesture = gestureCtrl.createGesture({
            name: GESTURE_REFRESHER,
            priority: GESTURE_PRIORITY_REFRESHER
        });
    }
    get enabled() {
        return this._isEnabled;
    }
    set enabled(val) {
        this._isEnabled = isTrueProperty(val);
        this._setListeners(this._isEnabled);
    }
    _onStart(ev) {
        if (ev.touches && ev.touches.length > 1) {
            return false;
        }
        if (this.state !== STATE_INACTIVE) {
            return false;
        }
        let scrollHostScrollTop = this._content.getContentDimensions().scrollTop;
        if (scrollHostScrollTop > 0) {
            return false;
        }
        if (!this._gesture.canStart()) {
            return false;
        }
        let coord = pointerCoord(ev);
        console.debug('Pull-to-refresh, onStart', ev.type, 'y:', coord.y);
        if (this._content.contentTop > 0) {
            let newTop = this._content.contentTop + 'px';
            if (this._top !== newTop) {
                this._top = newTop;
            }
        }
        this.startY = this.currentY = coord.y;
        this.progress = 0;
        this.state = STATE_INACTIVE;
        return true;
    }
    _onMove(ev) {
        if (ev.touches && ev.touches.length > 1) {
            return 1;
        }
        if (!this._gesture.canStart()) {
            return 0;
        }
        if (this.startY === null || this.state === STATE_REFRESHING || this.state === STATE_CANCELLING || this.state === STATE_COMPLETING) {
            return 2;
        }
        let now = Date.now();
        if (this._lastCheck + 16 > now) {
            return 3;
        }
        this._lastCheck = now;
        let coord = pointerCoord(ev);
        this.currentY = coord.y;
        this.deltaY = (coord.y - this.startY);
        if (this.deltaY <= 0) {
            this.progress = 0;
            if (this.state !== STATE_INACTIVE) {
                this._zone.run(() => {
                    this.state = STATE_INACTIVE;
                });
            }
            if (this._appliedStyles) {
                this._setCss(0, '', false, '');
                return 5;
            }
            return 6;
        }
        if (this.state === STATE_INACTIVE) {
            let scrollHostScrollTop = this._content.getContentDimensions().scrollTop;
            if (scrollHostScrollTop > 0) {
                this.progress = 0;
                this.startY = null;
                return 7;
            }
            this.state = STATE_PULLING;
        }
        ev.preventDefault();
        this._setCss(this.deltaY, '0ms', true, '');
        if (!this.deltaY) {
            this.progress = 0;
            return 8;
        }
        this._zone.run(() => {
            this._onMoveInZone();
        });
    }
    _onMoveInZone() {
        this.progress = (this.deltaY / this.pullMin);
        if (!this._didStart) {
            this._didStart = true;
            this.ionStart.emit(this);
        }
        this.ionPull.emit(this);
        if (this.deltaY < this.pullMin) {
            this.state = STATE_PULLING;
            return 2;
        }
        if (this.deltaY > this.pullMax) {
            this._beginRefresh();
            return 3;
        }
        this.state = STATE_READY;
        return 4;
    }
    _onEnd() {
        if (this.state === STATE_READY) {
            this._zone.run(() => {
                this._beginRefresh();
            });
        }
        else if (this.state === STATE_PULLING) {
            this._zone.run(() => {
                this.cancel();
            });
        }
        this.startY = null;
    }
    _beginRefresh() {
        this.state = STATE_REFRESHING;
        this._setCss(this.pullMin, (this.snapbackDuration + 'ms'), true, '');
        this.ionRefresh.emit(this);
    }
    complete() {
        this._close(STATE_COMPLETING, '120ms');
    }
    cancel() {
        this._close(STATE_CANCELLING, '');
    }
    _close(state, delay) {
        var timer;
        function close(ev) {
            if (ev) {
                clearTimeout(timer);
            }
            this.state = STATE_INACTIVE;
            this.progress = 0;
            this._didStart = this.startY = this.currentY = this.deltaY = null;
            this._setCss(0, '0ms', false, '');
        }
        timer = setTimeout(close.bind(this), 600);
        this._content.onScrollElementTransitionEnd(close.bind(this));
        this.state = state;
        this._setCss(0, '', true, delay);
        if (this._pointerEvents) {
            this._pointerEvents.stop();
        }
    }
    _setCss(y, duration, overflowVisible, delay) {
        this._appliedStyles = (y > 0);
        const content = this._content;
        const Css = this._plt.Css;
        content.setScrollElementStyle(Css.transform, ((y > 0) ? 'translateY(' + y + 'px) translateZ(0px)' : 'translateZ(0px)'));
        content.setScrollElementStyle(Css.transitionDuration, duration);
        content.setScrollElementStyle(Css.transitionDelay, delay);
        content.setScrollElementStyle('overflow', (overflowVisible ? 'hidden' : ''));
    }
    _setListeners(shouldListen) {
        this._events.unlistenAll();
        this._pointerEvents = null;
        if (shouldListen) {
            this._pointerEvents = this._events.pointerEvents({
                element: this._content.getScrollElement(),
                pointerDown: this._onStart.bind(this),
                pointerMove: this._onMove.bind(this),
                pointerUp: this._onEnd.bind(this),
                zone: false
            });
        }
    }
    ngOnInit() {
        this._setListeners(this._isEnabled);
    }
    ngOnDestroy() {
        this._setListeners(false);
        this._events.destroy();
        this._gesture.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], refresher_Refresher.prototype, "pullMin", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], refresher_Refresher.prototype, "pullMax", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], refresher_Refresher.prototype, "closeDuration", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], refresher_Refresher.prototype, "snapbackDuration", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], refresher_Refresher.prototype, "enabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (refresher__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && refresher__a || Object)
], refresher_Refresher.prototype, "ionRefresh", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (refresher__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && refresher__b || Object)
], refresher_Refresher.prototype, "ionPull", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (refresher__c = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && refresher__c || Object)
], refresher_Refresher.prototype, "ionStart", void 0);
refresher_Refresher = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-refresher',
        host: {
            '[class.refresher-active]': 'state !== "inactive"',
            '[style.top]': '_top'
        }
    }),
    Object(tslib_es6["__param"])(1, Object(core_es5["s" /* Host */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (refresher__d = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && refresher__d || Object, typeof (refresher__e = typeof content_Content !== "undefined" && content_Content) === "function" && refresher__e || Object, typeof (refresher__f = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && refresher__f || Object, typeof (refresher__g = typeof GestureController !== "undefined" && GestureController) === "function" && refresher__g || Object])
], refresher_Refresher);

const STATE_INACTIVE = 'inactive';
const STATE_PULLING = 'pulling';
const STATE_READY = 'ready';
const STATE_REFRESHING = 'refreshing';
const STATE_CANCELLING = 'cancelling';
const STATE_COMPLETING = 'completing';
var refresher__a, refresher__b, refresher__c, refresher__d, refresher__e, refresher__f, refresher__g;




// CONCATENATED MODULE: ./src/components/refresher/refresher-content.ts





let RefresherContent = class RefresherContent {
    constructor(r, _config) {
        this.r = r;
        this._config = _config;
    }
    ngOnInit() {
        if (!this.pullingIcon) {
            this.pullingIcon = this._config.get('ionPullIcon', 'arrow-down');
        }
        if (!this.refreshingSpinner) {
            this.refreshingSpinner = this._config.get('ionRefreshingSpinner', this._config.get('spinner', 'ios'));
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], RefresherContent.prototype, "pullingIcon", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], RefresherContent.prototype, "pullingText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], RefresherContent.prototype, "refreshingSpinner", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], RefresherContent.prototype, "refreshingText", void 0);
RefresherContent = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-refresher-content',
        template: '<div class="refresher-pulling">' +
            '<div class="refresher-pulling-icon" *ngIf="pullingIcon">' +
            '<ion-icon [name]="pullingIcon"></ion-icon>' +
            '</div>' +
            '<div class="refresher-pulling-text" [innerHTML]="pullingText" *ngIf="pullingText"></div>' +
            '</div>' +
            '<div class="refresher-refreshing">' +
            '<div class="refresher-refreshing-icon">' +
            '<ion-spinner [name]="refreshingSpinner"></ion-spinner>' +
            '</div>' +
            '<div class="refresher-refreshing-text" [innerHTML]="refreshingText" *ngIf="refreshingText"></div>' +
            '</div>',
        host: {
            '[attr.state]': 'r.state'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (refresher_content__a = typeof refresher_Refresher !== "undefined" && refresher_Refresher) === "function" && refresher_content__a || Object, typeof (refresher_content__b = typeof config_Config !== "undefined" && config_Config) === "function" && refresher_content__b || Object])
], RefresherContent);

var refresher_content__a, refresher_content__b;




// CONCATENATED MODULE: ./src/components/scroll/scroll.ts




let scroll_Scroll = class Scroll {
    constructor() {
        this._scrollX = false;
        this._scrollY = false;
        this._zoom = false;
        this._maxZoom = 1;
        this.maxScale = 3;
        this.zoomDuration = 250;
    }
    get scrollX() {
        return this._scrollX;
    }
    set scrollX(val) {
        this._scrollX = isTrueProperty(val);
    }
    get scrollY() {
        return this._scrollY;
    }
    set scrollY(val) {
        this._scrollY = isTrueProperty(val);
    }
    get zoom() {
        return this._zoom;
    }
    set zoom(val) {
        this._zoom = isTrueProperty(val);
    }
    get maxZoom() {
        return this._maxZoom;
    }
    set maxZoom(val) {
        this._maxZoom = val;
    }
    addScrollEventListener(handler) {
        _assert(this._scrollContent, 'scroll element is missing');
        const ele = this._scrollContent.nativeElement;
        ele.addEventListener('scroll', handler);
        return () => {
            ele.removeEventListener('scroll', handler);
        };
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], scroll_Scroll.prototype, "scrollX", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], scroll_Scroll.prototype, "scrollY", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], scroll_Scroll.prototype, "zoom", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], scroll_Scroll.prototype, "maxZoom", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('scrollContent', { read: core_es5["p" /* ElementRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (scroll__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && scroll__a || Object)
], scroll_Scroll.prototype, "_scrollContent", void 0);
scroll_Scroll = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-scroll',
        template: '<div class="scroll-content" #scrollContent>' +
            '<div class="scroll-zoom-wrapper">' +
            '<ng-content></ng-content>' +
            '</div>' +
            '</div>',
        host: {
            '[class.scroll-x]': 'scrollX',
            '[class.scroll-y]': 'scrollY'
        },
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [])
], scroll_Scroll);

var scroll__a;




// CONCATENATED MODULE: ./src/components/searchbar/searchbar.ts










let searchbar_Searchbar = class Searchbar extends base_input_BaseInput {
    constructor(config, _plt, elementRef, renderer, ngControl) {
        super(config, elementRef, renderer, 'searchbar', '', null, null, ngControl);
        this._plt = _plt;
        this._shouldBlur = true;
        this._shouldAlignLeft = true;
        this._isCancelVisible = false;
        this._spellcheck = false;
        this._autocomplete = 'off';
        this._autocorrect = 'off';
        this._isActive = false;
        this._showCancelButton = false;
        this._animated = false;
        this._inputDebouncer = new TimeoutDebouncer(0);
        this.cancelButtonText = 'Cancel';
        this.placeholder = 'Search';
        this.type = 'search';
        this.ionInput = new core_es5["r" /* EventEmitter */]();
        this.ionCancel = new core_es5["r" /* EventEmitter */]();
        this.ionClear = new core_es5["r" /* EventEmitter */]();
        this.debounce = 250;
    }
    get showCancelButton() {
        return this._showCancelButton;
    }
    set showCancelButton(val) {
        this._showCancelButton = isTrueProperty(val);
    }
    get debounce() {
        return this._debouncer.wait;
    }
    set debounce(val) {
        this._debouncer.wait = val;
        this._inputDebouncer.wait = val;
    }
    set autocomplete(val) {
        this._autocomplete = (val === '' || val === 'on') ? 'on' : this._config.get('autocomplete', 'off');
    }
    set autocorrect(val) {
        this._autocorrect = (val === '' || val === 'on') ? 'on' : this._config.get('autocorrect', 'off');
    }
    set spellcheck(val) {
        this._spellcheck = (val === '' || val === 'true' || val === true) ? true : this._config.getBoolean('spellcheck', false);
    }
    get animated() {
        return this._animated;
    }
    set animated(val) {
        this._animated = isTrueProperty(val);
    }
    ngOnInit() {
        const showCancelButton = this.showCancelButton;
        if (typeof showCancelButton === 'string') {
            this.showCancelButton = (showCancelButton === '' || showCancelButton === 'true');
        }
    }
    _inputUpdated() {
        const ele = this._searchbarInput.nativeElement;
        const value = this._value;
        if (ele.value !== value) {
            ele.value = value;
        }
        this.positionElements();
    }
    positionElements() {
        const isAnimated = this._animated;
        const prevAlignLeft = this._shouldAlignLeft;
        const shouldAlignLeft = (!isAnimated || (this._value && this._value.toString().trim() !== '') || this._isFocus === true);
        this._shouldAlignLeft = shouldAlignLeft;
        if (this._mode !== 'ios') {
            return;
        }
        if (prevAlignLeft !== shouldAlignLeft) {
            this.positionPlaceholder();
        }
        if (isAnimated) {
            this.positionCancelButton();
        }
    }
    positionPlaceholder() {
        const inputEle = this._searchbarInput.nativeElement;
        const iconEle = this._searchbarIcon.nativeElement;
        if (this._shouldAlignLeft) {
            inputEle.removeAttribute('style');
            iconEle.removeAttribute('style');
        }
        else {
            var doc = this._plt.doc();
            var tempSpan = doc.createElement('span');
            tempSpan.innerHTML = this.placeholder;
            doc.body.appendChild(tempSpan);
            var textWidth = tempSpan.offsetWidth;
            doc.body.removeChild(tempSpan);
            var inputLeft = 'calc(50% - ' + (textWidth / 2) + 'px)';
            if (this._plt.isRTL) {
                inputEle.style.paddingRight = inputLeft;
            }
            else {
                inputEle.style.paddingLeft = inputLeft;
            }
            var iconLeft = 'calc(50% - ' + ((textWidth / 2) + 30) + 'px)';
            if (this._plt.isRTL) {
                iconEle.style.marginRight = iconLeft;
            }
            else {
                iconEle.style.marginLeft = iconLeft;
            }
        }
    }
    positionCancelButton() {
        const showShowCancel = this._isFocus;
        if (showShowCancel !== this._isCancelVisible) {
            var cancelStyleEle = this._cancelButton.nativeElement;
            var cancelStyle = cancelStyleEle.style;
            this._isCancelVisible = showShowCancel;
            if (showShowCancel) {
                if (this._plt.isRTL) {
                    cancelStyle.marginLeft = '0';
                }
                else {
                    cancelStyle.marginRight = '0';
                }
            }
            else {
                var offset = cancelStyleEle.offsetWidth;
                if (offset > 0) {
                    if (this._plt.isRTL) {
                        cancelStyle.marginLeft = -offset + 'px';
                    }
                    else {
                        cancelStyle.marginRight = -offset + 'px';
                    }
                }
            }
        }
    }
    inputChanged(ev) {
        this.value = ev.target.value;
        this._inputDebouncer.debounce(() => {
            this.ionInput.emit(ev);
        });
    }
    inputFocused() {
        this._isActive = true;
        this._fireFocus();
        this.positionElements();
    }
    inputBlurred() {
        if (this._shouldBlur === false) {
            this._searchbarInput.nativeElement.focus();
            this._shouldBlur = true;
            return;
        }
        this._fireBlur();
        this.positionElements();
    }
    clearInput(ev) {
        this.ionClear.emit(ev);
        setTimeout(() => {
            let value = this._value;
            if (isPresent(value) && value !== '') {
                this.value = '';
                this.ionInput.emit(ev);
            }
        }, 16 * 4);
        this._shouldBlur = false;
    }
    cancelSearchbar(ev) {
        this.ionCancel.emit(ev);
        this.clearInput(ev);
        this._shouldBlur = true;
        this._isActive = false;
    }
    setFocus() {
        this._renderer.invokeElementMethod(this._searchbarInput.nativeElement, 'focus');
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], searchbar_Searchbar.prototype, "cancelButtonText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], searchbar_Searchbar.prototype, "showCancelButton", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], searchbar_Searchbar.prototype, "debounce", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], searchbar_Searchbar.prototype, "placeholder", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], searchbar_Searchbar.prototype, "autocomplete", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], searchbar_Searchbar.prototype, "autocorrect", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], searchbar_Searchbar.prototype, "spellcheck", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], searchbar_Searchbar.prototype, "type", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], searchbar_Searchbar.prototype, "animated", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (searchbar__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && searchbar__a || Object)
], searchbar_Searchbar.prototype, "ionInput", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (searchbar__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && searchbar__b || Object)
], searchbar_Searchbar.prototype, "ionCancel", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (searchbar__c = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && searchbar__c || Object)
], searchbar_Searchbar.prototype, "ionClear", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('searchbarInput'),
    Object(tslib_es6["__metadata"])("design:type", typeof (searchbar__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && searchbar__d || Object)
], searchbar_Searchbar.prototype, "_searchbarInput", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('searchbarIcon'),
    Object(tslib_es6["__metadata"])("design:type", typeof (searchbar__e = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && searchbar__e || Object)
], searchbar_Searchbar.prototype, "_searchbarIcon", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('cancelButton', { read: core_es5["p" /* ElementRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (searchbar__f = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && searchbar__f || Object)
], searchbar_Searchbar.prototype, "_cancelButton", void 0);
searchbar_Searchbar = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-searchbar',
        template: '<div class="searchbar-input-container">' +
            '<button ion-button mode="md" (click)="cancelSearchbar($event)" (mousedown)="cancelSearchbar($event)" clear color="dark" class="searchbar-md-cancel" type="button">' +
            '<ion-icon name="md-arrow-back"></ion-icon>' +
            '</button>' +
            '<div #searchbarIcon class="searchbar-search-icon"></div>' +
            '<input #searchbarInput class="searchbar-input" (input)="inputChanged($event)" (blur)="inputBlurred()" (focus)="inputFocused()" ' +
            '[attr.placeholder]="placeholder" ' +
            '[attr.type]="type" ' +
            '[attr.autocomplete]="_autocomplete" ' +
            '[attr.autocorrect]="_autocorrect" ' +
            '[attr.spellcheck]="_spellcheck">' +
            '<button ion-button clear class="searchbar-clear-icon" [mode]="_mode" (click)="clearInput($event)" (mousedown)="clearInput($event)" type="button"></button>' +
            '</div>' +
            '<button ion-button #cancelButton mode="ios" [tabindex]="_isActive ? 1 : -1" clear (click)="cancelSearchbar($event)" (mousedown)="cancelSearchbar($event)" class="searchbar-ios-cancel" type="button">{{cancelButtonText}}</button>',
        host: {
            '[class.searchbar-animated]': '_animated',
            '[class.searchbar-has-value]': '_value',
            '[class.searchbar-active]': '_isActive',
            '[class.searchbar-show-cancel]': '_showCancelButton',
            '[class.searchbar-left-aligned]': '_shouldAlignLeft',
            '[class.searchbar-has-focus]': '_isFocus'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None
    }),
    Object(tslib_es6["__param"])(4, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (searchbar__g = typeof config_Config !== "undefined" && config_Config) === "function" && searchbar__g || Object, typeof (searchbar__h = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && searchbar__h || Object, typeof (searchbar__j = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && searchbar__j || Object, typeof (searchbar__k = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && searchbar__k || Object, typeof (searchbar__l = typeof forms_es5["f" /* NgControl */] !== "undefined" && forms_es5["f" /* NgControl */]) === "function" && searchbar__l || Object])
], searchbar_Searchbar);

var searchbar__a, searchbar__b, searchbar__c, searchbar__d, searchbar__e, searchbar__f, searchbar__g, searchbar__h, searchbar__j, searchbar__k, searchbar__l;




// CONCATENATED MODULE: ./src/components/segment/segment-button.ts




let segment_button_SegmentButton = class SegmentButton {
    constructor() {
        this.isActive = false;
        this._disabled = false;
        this.ionSelect = new core_es5["r" /* EventEmitter */]();
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(val) {
        this._disabled = isTrueProperty(val);
    }
    onClick() {
        console.debug('SegmentButton, select', this.value);
        this.ionSelect.emit(this);
    }
    ngOnInit() {
        if (!isPresent(this.value)) {
            console.warn('<ion-segment-button> requires a "value" attribute');
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], segment_button_SegmentButton.prototype, "value", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (segment_button__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && segment_button__a || Object)
], segment_button_SegmentButton.prototype, "ionSelect", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], segment_button_SegmentButton.prototype, "disabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], segment_button_SegmentButton.prototype, "onClick", null);
segment_button_SegmentButton = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-segment-button',
        template: '<ng-content></ng-content>' +
            '<div class="button-effect"></div>',
        host: {
            'tappable': '',
            'class': 'segment-button',
            'role': 'button',
            '[class.segment-button-disabled]': '_disabled',
            '[class.segment-activated]': 'isActive',
            '[attr.aria-pressed]': 'isActive'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [])
], segment_button_SegmentButton);

var segment_button__a;




// CONCATENATED MODULE: ./src/components/segment/segment.ts









let segment_Segment = class Segment extends base_input_BaseInput {
    constructor(config, elementRef, renderer, ngControl) {
        super(config, elementRef, renderer, 'segment', null, null, null, ngControl);
    }
    ngAfterContentInit() {
        this._initialize();
        this._buttons.forEach(button => {
            button.ionSelect.subscribe((selectedButton) => {
                this.value = selectedButton.value;
                this._fireTouched();
            });
        });
    }
    _inputUpdated() {
        if (!this._buttons) {
            _assert(false, 'buttons are undefined');
            return;
        }
        const buttons = this._buttons.toArray();
        const value = this.value;
        for (var button of buttons) {
            button.isActive = (button.value === value);
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(segment_button_SegmentButton),
    Object(tslib_es6["__metadata"])("design:type", typeof (segment__a = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && segment__a || Object)
], segment_Segment.prototype, "_buttons", void 0);
segment_Segment = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-segment',
        host: {
            '[class.segment-disabled]': '_disabled'
        }
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (segment__b = typeof config_Config !== "undefined" && config_Config) === "function" && segment__b || Object, typeof (segment__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && segment__c || Object, typeof (segment__d = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && segment__d || Object, typeof (segment__e = typeof forms_es5["f" /* NgControl */] !== "undefined" && forms_es5["f" /* NgControl */]) === "function" && segment__e || Object])
], segment_Segment);

var segment__a, segment__b, segment__c, segment__d, segment__e;




// CONCATENATED MODULE: ./src/components/select/select-popover-component.ts





let SelectPopover = class SelectPopover {
    constructor(navParams, viewController) {
        this.navParams = navParams;
        this.viewController = viewController;
    }
    get value() {
        let checkedOption = this.options.find(option => option.checked);
        return checkedOption ? checkedOption.value : undefined;
    }
    set value(value) {
        let checkedOption = this.options.find(option => option.value === value);
        if (checkedOption && checkedOption.handler) {
            checkedOption.handler();
        }
        this.viewController.dismiss(value);
    }
    ngOnInit() {
        this.options = this.navParams.data.options;
    }
};
SelectPopover = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        template: `
    <ion-list radio-group [(ngModel)]="value">
      <ion-item *ngFor="let option of options">
        <ion-label>{{option.text}}</ion-label>
        <ion-radio [checked]="option.checked" [value]="option.value" [disabled]="option.disabled"></ion-radio>
      </ion-item>
    </ion-list>
  `
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (select_popover_component__a = typeof NavParams !== "undefined" && NavParams) === "function" && select_popover_component__a || Object, typeof (select_popover_component__b = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && select_popover_component__b || Object])
], SelectPopover);

var select_popover_component__a, select_popover_component__b;




// CONCATENATED MODULE: ./src/components/select/select.ts

















let select_Select = Select_1 = class Select extends base_input_BaseInput {
    constructor(_app, form, config, elementRef, renderer, item, deepLinker) {
        super(config, elementRef, renderer, 'select', [], form, item, null);
        this._app = _app;
        this.config = config;
        this.deepLinker = deepLinker;
        this._multi = false;
        this._texts = [];
        this._text = '';
        this._compareWith = isCheckedProperty;
        this.cancelText = 'Cancel';
        this.okText = 'OK';
        this.selectOptions = {};
        this.interface = '';
        this.selectedText = '';
        this.ionCancel = new core_es5["r" /* EventEmitter */]();
    }
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            throw new Error(`compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
    }
    _click(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        this.open(ev);
    }
    _keyup() {
        this.open();
    }
    getValues() {
        const values = Array.isArray(this._value) ? this._value : [this._value];
        _assert(this._multi || values.length <= 1, 'single only can have one value');
        return values;
    }
    open(ev) {
        if (this.isFocus() || this._disabled) {
            return;
        }
        console.debug('select, open alert');
        const selectOptions = deepCopy(this.selectOptions);
        selectOptions.buttons = [{
                text: this.cancelText,
                role: 'cancel',
                handler: () => {
                    this.ionCancel.emit(this);
                }
            }];
        if (!selectOptions.title && this._item) {
            selectOptions.title = this._item.getLabelText();
        }
        let options = this._options.toArray();
        if (this.interface === 'action-sheet' && options.length > 6) {
            console.warn('Interface cannot be "action-sheet" with more than 6 options. Using the "alert" interface.');
            this.interface = 'alert';
        }
        if ((this.interface === 'action-sheet' || this.interface === 'popover') && this._multi) {
            console.warn('Interface cannot be "' + this.interface + '" with a multi-value select. Using the "alert" interface.');
            this.interface = 'alert';
        }
        if (this.interface === 'popover' && !ev) {
            console.warn('Interface cannot be "popover" without UIEvent.');
            this.interface = 'alert';
        }
        let overlay;
        if (this.interface === 'action-sheet') {
            selectOptions.buttons = selectOptions.buttons.concat(options.map(input => {
                return {
                    role: (input.selected ? 'selected' : ''),
                    text: input.text,
                    handler: () => {
                        this.value = input.value;
                        input.ionSelect.emit(input.value);
                    }
                };
            }));
            var selectCssClass = 'select-action-sheet';
            selectCssClass += selectOptions.cssClass ? ' ' + selectOptions.cssClass : '';
            selectOptions.cssClass = selectCssClass;
            overlay = new action_sheet_ActionSheet(this._app, selectOptions, this.config);
        }
        else if (this.interface === 'popover') {
            let popoverOptions = options.map(input => ({
                text: input.text,
                checked: input.selected,
                disabled: input.disabled,
                value: input.value,
                handler: () => {
                    this.value = input.value;
                    input.ionSelect.emit(input.value);
                }
            }));
            var popoverCssClass = 'select-popover';
            popoverCssClass += selectOptions.cssClass ? ' ' + selectOptions.cssClass : '';
            overlay = new popover_Popover(this._app, SelectPopover, {
                options: popoverOptions
            }, {
                cssClass: popoverCssClass
            }, this.config, this.deepLinker);
            Object.defineProperty(ev, 'target', { value: ev.currentTarget });
            selectOptions.ev = ev;
        }
        else {
            this.interface = 'alert';
            selectOptions.inputs = this._options.map(input => {
                return {
                    type: (this._multi ? 'checkbox' : 'radio'),
                    label: input.text,
                    value: input.value,
                    checked: input.selected,
                    disabled: input.disabled,
                    handler: (selectedOption) => {
                        if (selectedOption.checked) {
                            input.ionSelect.emit(input.value);
                        }
                    }
                };
            });
            let selectCssClass = 'select-alert';
            overlay = new alert_Alert(this._app, selectOptions, this.config);
            if (this._multi) {
                selectCssClass += ' multiple-select-alert';
            }
            else {
                selectCssClass += ' single-select-alert';
            }
            selectCssClass += selectOptions.cssClass ? ' ' + selectOptions.cssClass : '';
            overlay.setCssClass(selectCssClass);
            overlay.addButton({
                text: this.okText,
                handler: (selectedValues) => this.value = selectedValues
            });
        }
        overlay.present(selectOptions);
        this._fireFocus();
        overlay.onDidDismiss(() => {
            this._fireBlur();
            this._overlay = undefined;
        });
        this._overlay = overlay;
    }
    close() {
        if (!this._overlay || !this.isFocus()) {
            return;
        }
        return this._overlay.dismiss();
    }
    get multiple() {
        return this._multi;
    }
    set multiple(val) {
        this._multi = isTrueProperty(val);
    }
    get text() {
        return (this._multi ? this._texts : this._texts.join());
    }
    set options(val) {
        this._options = val;
        const values = this.getValues();
        if (values.length === 0) {
            this.writeValue(val.filter(o => o.selected).map(o => o.value));
        }
        else {
            this._updateText();
        }
    }
    _inputShouldChange(val) {
        return !deepEqual(this._value, val);
    }
    _inputChangeEvent() {
        return this.value;
    }
    _updateText() {
        this._texts.length = 0;
        if (this._options) {
            this._options.forEach(option => {
                option.selected = this.getValues().some(selectValue => {
                    return this._compareWith(selectValue, option.value);
                });
                if (option.selected) {
                    this._texts.push(option.text);
                }
            });
        }
        this._text = this._texts.join(', ');
    }
    _inputUpdated() {
        this._updateText();
        super._inputUpdated();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], select_Select.prototype, "cancelText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], select_Select.prototype, "okText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], select_Select.prototype, "placeholder", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], select_Select.prototype, "selectOptions", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], select_Select.prototype, "interface", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], select_Select.prototype, "selectedText", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Function])
], select_Select.prototype, "compareWith", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (select__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && select__a || Object)
], select_Select.prototype, "ionCancel", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], select_Select.prototype, "_click", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('keyup.space'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], select_Select.prototype, "_keyup", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], select_Select.prototype, "multiple", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(option_Option),
    Object(tslib_es6["__metadata"])("design:type", typeof (select__b = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && select__b || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (select__c = typeof core_es5["M" /* QueryList */] !== "undefined" && core_es5["M" /* QueryList */]) === "function" && select__c || Object])
], select_Select.prototype, "options", null);
select_Select = Select_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-select',
        template: '<div *ngIf="!_text" class="select-placeholder select-text">{{placeholder}}</div>' +
            '<div *ngIf="_text" class="select-text">{{selectedText || _text}}</div>' +
            '<div class="select-icon">' +
            '<div class="select-icon-inner"></div>' +
            '</div>' +
            '<button aria-haspopup="true" ' +
            'type="button" ' +
            '[id]="id" ' +
            'ion-button="item-cover" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.aria-disabled]="_disabled" ' +
            'class="item-cover">' +
            '</button>',
        host: {
            '[class.select-disabled]': '_disabled'
        },
        providers: [{ provide: forms_es5["e" /* NG_VALUE_ACCESSOR */], useExisting: Select_1, multi: true }],
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(5, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (select__d = typeof app_App !== "undefined" && app_App) === "function" && select__d || Object, typeof (select__e = typeof form_Form !== "undefined" && form_Form) === "function" && select__e || Object, typeof (select__f = typeof config_Config !== "undefined" && config_Config) === "function" && select__f || Object, typeof (select__g = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && select__g || Object, typeof (select__h = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && select__h || Object, typeof (select__j = typeof Item !== "undefined" && Item) === "function" && select__j || Object, typeof (select__k = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && select__k || Object])
], select_Select);

var Select_1, select__a, select__b, select__c, select__d, select__e, select__f, select__g, select__h, select__j, select__k;




// CONCATENATED MODULE: ./src/components/show-hide-when/display-when.ts
class DisplayWhen {
    constructor(conditions, _plt, zone) {
        this._plt = _plt;
        this.zone = zone;
        this.isMatch = false;
        if (!conditions)
            return;
        this.conditions = conditions.replace(/\s/g, '').split(',');
        for (let i = 0; i < this.conditions.length; i++) {
            if (this.conditions[i] && _plt.is(this.conditions[i])) {
                this.isMatch = true;
                return;
            }
        }
        if (this.orientation()) {
            this.resizeObs = _plt.resize.subscribe(this.orientation.bind(this));
        }
    }
    orientation() {
        for (let i = 0; i < this.conditions.length; i++) {
            if (this.conditions[i] === 'portrait') {
                this.isMatch = this._plt.isPortrait();
                return true;
            }
            if (this.conditions[i] === 'landscape') {
                this.isMatch = this._plt.isLandscape();
                return true;
            }
        }
        return false;
    }
    ngOnDestroy() {
        this.resizeObs && this.resizeObs.unsubscribe();
        this.resizeObs = null;
    }
}
//# sourceMappingURL=display-when.js.map
// CONCATENATED MODULE: ./src/components/show-hide-when/show-when.ts






let ShowWhen = class ShowWhen extends DisplayWhen {
    constructor(showWhen, plt, zone) {
        super(showWhen, plt, zone);
    }
};
ShowWhen = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[showWhen]',
        host: {
            '[class.hidden-show-when]': '!isMatch'
        }
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["g" /* Attribute */])('showWhen')),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String, typeof (show_when__a = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && show_when__a || Object, typeof (show_when__b = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && show_when__b || Object])
], ShowWhen);

var show_when__a, show_when__b;




// CONCATENATED MODULE: ./src/components/show-hide-when/hide-when.ts






let HideWhen = class HideWhen extends DisplayWhen {
    constructor(hideWhen, plt, zone) {
        super(hideWhen, plt, zone);
    }
};
HideWhen = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[hideWhen]',
        host: {
            '[class.hidden-hide-when]': 'isMatch'
        }
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["g" /* Attribute */])('hideWhen')),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String, typeof (hide_when__a = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && hide_when__a || Object, typeof (hide_when__b = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && hide_when__b || Object])
], HideWhen);

var hide_when__a, hide_when__b;




// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-utils.ts
function swiper_utils_round(a) {
    return Math.floor(a);
}
function inlineStyle(ele, styles) {
    if (ele) {
        if (ele.length) {
            for (var i = 0; i < ele.length; i++) {
                inlineStyle(ele[i], styles);
            }
        }
        else if (ele.nodeType) {
            var cssProps = Object.keys(styles);
            for (let i = 0; i < cssProps.length; i++) {
                ele.style[cssProps[i]] = styles[cssProps[i]];
            }
        }
    }
}
function addClass(ele, className) {
    if (ele) {
        if (ele.length) {
            for (var i = 0; i < ele.length; i++) {
                addClass(ele[i], className);
            }
        }
        else if (ele.nodeType) {
            if (Array.isArray(className)) {
                className.forEach(cls => {
                    ele.classList.add(cls);
                });
            }
            else {
                ele.classList.add(className);
            }
        }
    }
}
function removeClass(ele, className) {
    if (ele) {
        if (ele.length) {
            for (var i = 0; i < ele.length; i++) {
                removeClass(ele[i], className);
            }
        }
        else if (ele.nodeType) {
            if (Array.isArray(className)) {
                className.forEach(cls => {
                    ele.classList.remove(cls);
                });
            }
            else {
                ele.classList.remove(className);
            }
        }
    }
}
function getElementIndex(ele) {
    var i = 0;
    if (ele) {
        while ((ele = ele.previousSibling) !== null) {
            if (ele.nodeType === 1)
                i++;
        }
    }
    return i;
}
function queryChildren(parentEle, query) {
    if (parentEle) {
        return parentEle.querySelectorAll(query);
    }
    return [];
}
function eachChild(parentEle, query, callback) {
    if (parentEle) {
        var nodes = parentEle.querySelectorAll(query);
        for (var i = 0; i < nodes.length; i++) {
            callback(nodes[i]);
        }
    }
}
function swiper_utils_transform(ele, val) {
    if (ele) {
        var elStyle = ele.style;
        elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.transform = val;
    }
}
function swiper_utils_transition(ele, duration) {
    if (ele) {
        if (typeof duration !== 'string') {
            duration = duration + 'ms';
        }
        var elStyle = ele.style;
        elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.transitionDuration = duration;
    }
}
function triggerTransitionEnd(plt, ele) {
    try {
        var win = plt.win();
        var evt = new win.CustomEvent('transitionend', { bubbles: true, cancelable: true });
        ele.dispatchEvent(evt);
    }
    catch (e) { }
}
function swiper_utils_offset(ele, plt) {
    if (ele) {
        var box = plt.getElementBoundingClientRect(ele);
        var body = plt.doc().body;
        var win = plt.win();
        var clientTop = ele.clientTop || body.clientTop || 0;
        var clientLeft = ele.clientLeft || body.clientLeft || 0;
        var scrollTop = win.pageYOffset || ele.scrollTop;
        var scrollLeft = win.pageXOffset || ele.scrollLeft;
        return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
        };
    }
    return null;
}
function updateSlidesOffset(s) {
    for (var i = 0; i < s._slides.length; i++) {
        s._slides[i].swiperSlideOffset = isHorizontal(s) ? s._slides[i].offsetLeft : s._slides[i].offsetTop;
    }
}
function isHorizontal(s) {
    return s.direction === 'horizontal';
}
const formElements = ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON', 'VIDEO'];
function isFormElement(el) {
    return !!el && formElements.indexOf(el.tagName) > -1;
}
function minTranslate(s) {
    return (-s._snapGrid[0]);
}
function maxTranslate(s) {
    return (-s._snapGrid[s._snapGrid.length - 1]);
}
const CLS = {
    noSwiping: 'swiper-no-swiping',
    containerModifier: 'swiper-container-',
    slide: 'swiper-slide',
    slideActive: 'swiper-slide-active',
    slideDuplicateActive: 'swiper-slide-duplicate-active',
    slideVisible: 'swiper-slide-visible',
    slideDuplicate: 'swiper-slide-duplicate',
    slideNext: 'swiper-slide-next',
    slideDuplicateNext: 'swiper-slide-duplicate-next',
    slidePrev: 'swiper-slide-prev',
    slideDuplicatePrev: 'swiper-slide-duplicate-prev',
    wrapper: 'swiper-wrapper',
    bullet: 'swiper-pagination-bullet',
    bulletActive: 'swiper-pagination-bullet-active',
    buttonDisabled: 'swiper-button-disabled',
    paginationCurrent: 'swiper-pagination-current',
    paginationTotal: 'swiper-pagination-total',
    paginationHidden: 'swiper-pagination-hidden',
    paginationProgressbar: 'swiper-pagination-progressbar',
    paginationClickable: 'swiper-pagination-clickable',
    paginationModifier: 'swiper-pagination-',
    lazyLoading: 'swiper-lazy',
    lazyStatusLoading: 'swiper-lazy-loading',
    lazyStatusLoaded: 'swiper-lazy-loaded',
    lazyPreloader: 'swiper-lazy-preloader',
    notification: 'swiper-notification',
    preloader: 'preloader',
    zoomContainer: 'swiper-zoom-container',
};
//# sourceMappingURL=swiper-utils.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-parallax.ts

function setParallaxTransform(s, el, progress) {
    var p;
    var pX;
    var pY;
    var rtlFactor = s._rtl ? -1 : 1;
    p = el.getAttribute('data-swiper-parallax') || '0';
    pX = el.getAttribute('data-swiper-parallax-x');
    pY = el.getAttribute('data-swiper-parallax-y');
    if (pX || pY) {
        pX = pX || '0';
        pY = pY || '0';
    }
    else {
        if (isHorizontal(s)) {
            pX = p;
            pY = '0';
        }
        else {
            pY = p;
            pX = '0';
        }
    }
    if ((pX).indexOf('%') >= 0) {
        pX = parseInt(pX, 10) * progress * rtlFactor + '%';
    }
    else {
        pX = pX * progress * rtlFactor + 'px';
    }
    if ((pY).indexOf('%') >= 0) {
        pY = parseInt(pY, 10) * progress + '%';
    }
    else {
        pY = pY * progress + 'px';
    }
    swiper_utils_transform(el, 'translate3d(' + pX + ', ' + pY + ',0px)');
}
function parallaxSetTranslate(s) {
    eachChild(s.container, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]', (el) => {
        setParallaxTransform(s, el, s.progress);
    });
    for (var i = 0; i < s._slides.length; i++) {
        var slide = s._slides[i];
        eachChild(slide, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]', () => {
            var progress = Math.min(Math.max(slide.progress, -1), 1);
            setParallaxTransform(s, slide, progress);
        });
    }
}
function parallaxSetTransition(s, duration) {
    if (typeof duration === 'undefined')
        duration = s.speed;
    eachChild(s.container, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]', (el) => {
        var parallaxDuration = parseInt(el.getAttribute('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0)
            parallaxDuration = 0;
        swiper_utils_transition(el, parallaxDuration);
    });
}
//# sourceMappingURL=swiper-parallax.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-progress.ts

function updateProgress(s, translate) {
    if (typeof translate === 'undefined') {
        translate = s._translate || 0;
    }
    var translatesDiff = maxTranslate(s) - minTranslate(s);
    var wasBeginning = s._isBeginning;
    var wasEnd = s._isEnd;
    if (translatesDiff === 0) {
        s.progress = 0;
        s._isBeginning = s._isEnd = true;
    }
    else {
        s.progress = (translate - minTranslate(s)) / (translatesDiff);
        s._isBeginning = s.progress <= 0;
        s._isEnd = s.progress >= 1;
    }
    s._zone.run(() => {
        if (s._isBeginning && !wasBeginning) {
            s.ionSlideReachStart.emit();
        }
        if (s._isEnd && !wasEnd) {
            s.ionSlideReachEnd.emit();
        }
        if (s.watchSlidesProgress) {
            updateSlidesProgress(s, translate);
        }
        s.ionSlideProgress.emit(s.progress);
    });
}
function updateSlidesProgress(s, translate) {
    if (typeof translate === 'undefined') {
        translate = s._translate || 0;
    }
    if (s._slides.length === 0)
        return;
    if (typeof s._slides[0].swiperSlideOffset === 'undefined') {
        updateSlidesOffset(s);
    }
    var offsetCenter = -translate;
    if (s._rtl)
        offsetCenter = translate;
    removeClass(s._slides, CLS.slideVisible);
    for (var i = 0; i < s._slides.length; i++) {
        var slide = s._slides[i];
        var slideProgress = (offsetCenter + (s.centeredSlides ? minTranslate(s) : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.spaceBetween);
        if (s.watchSlidesVisibility) {
            var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
            var slideAfter = slideBefore + s._slidesSizesGrid[i];
            var isVisible = (slideBefore >= 0 && slideBefore < s._renderedSize) ||
                (slideAfter > 0 && slideAfter <= s._renderedSize) ||
                (slideBefore <= 0 && slideAfter >= s._renderedSize);
            if (isVisible) {
                s._slides[i].classList.add(CLS.slideVisible);
            }
        }
        slide.progress = s._rtl ? -slideProgress : slideProgress;
    }
}
//# sourceMappingURL=swiper-progress.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-a11y.ts

function initA11y(s, plt) {
    let unregs = [];
    s._liveRegion = plt.doc().createElement('span');
    s._liveRegion.className = CLS.notification;
    s._liveRegion.setAttribute('aria-live', 'assertive');
    s._liveRegion.setAttribute('aria-atomic', 'true');
    s.container.appendChild(s._liveRegion);
    if (s.nextButton) {
        makeFocusable(s.nextButton);
        addRole(s.nextButton, 'button');
        addLabel(s.nextButton, s.nextSlideMessage);
        plt.registerListener(s.nextButton, 'keydown', (ev) => {
            onEnterKey(s, ev);
        }, { zone: false }, unregs);
    }
    if (s.prevButton) {
        makeFocusable(s.prevButton);
        addRole(s.prevButton, 'button');
        addLabel(s.prevButton, s.prevSlideMessage);
        plt.registerListener(s.prevButton, 'keydown', (ev) => {
            onEnterKey(s, ev);
        }, { zone: false }, unregs);
    }
    return function () {
        unregs.forEach(unreg => {
            unreg();
        });
        unregs = null;
        if (s._liveRegion) {
            s._liveRegion.parentElement.removeChild(s._liveRegion);
        }
    };
}
function makeFocusable(ele) {
    ele.setAttribute('tabIndex', '0');
}
function addRole(ele, role) {
    ele.setAttribute('role', role);
}
function addLabel(ele, label) {
    ele.setAttribute('aria-label', label);
}
function ariaDisable(ele, isDisabled) {
    if (isDisabled) {
        ele.setAttribute('aria-disabled', 'true');
    }
    else if (ele.hasAttribute('aria-disabled')) {
        ele.removeAttribute('aria-disabled');
    }
}
function ariaHidden(ele, isHidden) {
    if (isHidden) {
        ele.setAttribute('aria-hidden', 'true');
    }
    else if (ele.hasAttribute('aria-hidden')) {
        ele.removeAttribute('aria-hidden');
    }
}
function onEnterKey(_, __) {
}
//# sourceMappingURL=swiper-a11y.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-pagination.ts

function updatePagination(s) {
    if (!s.paginationType || !s._paginationContainer)
        return;
    var paginationHTML = '';
    if (s.paginationType === 'bullets') {
        var numberOfBullets = s.loop ? Math.ceil((s._slides.length - s.loopedSlides * 2) / s.slidesPerGroup) : s._snapGrid.length;
        for (var i = 0; i < numberOfBullets; i++) {
            if (s.paginationBulletRender) {
                paginationHTML += s.paginationBulletRender(i, CLS.bullet);
            }
            else {
                paginationHTML += `<button class="${CLS.bullet}" aria-label="Go to slide ${i + 1}" data-slide-index="${i}"></button>`;
            }
        }
    }
    else if (s.paginationType === 'fraction') {
        paginationHTML =
            '<span class="' + CLS.paginationCurrent + '"></span>' +
                ' / ' +
                '<span class="' + CLS.paginationTotal + '"></span>';
    }
    else if (s.paginationType === 'progress') {
        paginationHTML = '<span class="' + CLS.paginationProgressbar + '"></span>';
    }
    s._paginationContainer.innerHTML = paginationHTML;
    s._bullets = s._paginationContainer.querySelectorAll('.' + CLS.bullet);
}
function updatePaginationClasses(s) {
    var current;
    var total = s.loop ? Math.ceil((s._slides.length - s.loopedSlides * 2) / s.slidesPerGroup) : s._snapGrid.length;
    if (s.loop) {
        current = Math.ceil((s._activeIndex - s.loopedSlides) / s.slidesPerGroup);
        if (current > s._slides.length - 1 - s.loopedSlides * 2) {
            current = current - (s._slides.length - s.loopedSlides * 2);
        }
        if (current > total - 1) {
            current = current - total;
        }
        if (current < 0 && s.paginationType !== 'bullets') {
            current = total + current;
        }
    }
    else {
        if (typeof s._snapIndex !== 'undefined') {
            current = s._snapIndex;
        }
        else {
            current = s._activeIndex || 0;
        }
    }
    if (s.paginationType === 'bullets' && s._bullets) {
        var selector = current + (current < 0 ? s._bullets.length : 0);
        for (var i = 0; i < s._bullets.length; i++) {
            if (i === selector) {
                addClass(s._bullets[i], CLS.bulletActive);
            }
            else {
                removeClass(s._bullets[i], CLS.bulletActive);
            }
        }
    }
    if (s.paginationType === 'fraction') {
        eachChild(s._paginationContainer, '.' + CLS.paginationCurrent, (ele) => {
            ele.textContent = (current + 1);
        });
        eachChild(s._paginationContainer, '.' + CLS.paginationTotal, ele => {
            ele.textContent = total;
        });
    }
    if (s.paginationType === 'progress') {
        var scale = (current + 1) / total, scaleX = scale, scaleY = 1;
        if (!isHorizontal(s)) {
            scaleY = scale;
            scaleX = 1;
        }
        eachChild(s._paginationContainer, '.' + CLS.paginationProgressbar, ele => {
            swiper_utils_transform(ele, 'translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')');
            swiper_utils_transition(ele, s.speed);
        });
    }
}
//# sourceMappingURL=swiper-pagination.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-classes.ts



function updateClasses(s) {
    var childElements;
    removeClass(s._slides, [CLS.slideActive, CLS.slideNext, CLS.slidePrev, CLS.slideDuplicateActive, CLS.slideDuplicateNext, CLS.slideDuplicatePrev]);
    for (var i = 0; i < s._slides.length; i++) {
        ariaHidden(s._slides[i], true);
    }
    var activeSlide = s._slides[s._activeIndex];
    if (!activeSlide) {
        return;
    }
    addClass(activeSlide, CLS.slideActive);
    ariaHidden(activeSlide, false);
    if (s.loop) {
        if (activeSlide.classList.contains(CLS.slideDuplicate)) {
            childElements = queryChildren(s._wrapper, '.' + CLS.slide + ':not(.' + CLS.slideDuplicate + ')[data-swiper-slide-index="' + s.realIndex + '"]');
        }
        else {
            childElements = queryChildren(s._wrapper, '.' + CLS.slide + '.' + CLS.slideDuplicate + '[data-swiper-slide-index="' + s.realIndex + '"]');
        }
        addClass(childElements, CLS.slideDuplicateActive);
    }
    var nextSlide = activeSlide.nextElementSibling;
    if (s.loop && !nextSlide) {
        nextSlide = s._slides[0];
    }
    nextSlide && nextSlide.classList.add(CLS.slideNext);
    var prevSlide = activeSlide.previousElementSibling;
    if (s.loop && !prevSlide) {
        prevSlide = s._slides[s._slides.length - 1];
    }
    prevSlide && prevSlide.classList.add(CLS.slidePrev);
    if (s.loop) {
        if (nextSlide.classList.contains(CLS.slideDuplicate)) {
            childElements = queryChildren(s._wrapper, '.' + CLS.slide + ':not(.' + CLS.slideDuplicate + ')[data-swiper-slide-index="' + nextSlide.getAttribute('data-swiper-slide-index') + '"]');
        }
        else {
            childElements = queryChildren(s._wrapper, '.' + CLS.slide + '.' + CLS.slideDuplicate + '[data-swiper-slide-index="' + nextSlide.getAttribute('data-swiper-slide-index') + '"]');
        }
        addClass(childElements, CLS.slideDuplicateNext);
        if (prevSlide.classList.contains(CLS.slideDuplicate)) {
            childElements = queryChildren(s._wrapper, '.' + CLS.slide + ':not(.' + CLS.slideDuplicate + ')[data-swiper-slide-index="' + prevSlide.getAttribute('data-swiper-slide-index') + '"]');
        }
        else {
            childElements = queryChildren(s._wrapper, '.' + CLS.slide + '.' + CLS.slideDuplicate + '[data-swiper-slide-index="' + prevSlide.getAttribute('data-swiper-slide-index') + '"]');
        }
        addClass(childElements, CLS.slideDuplicatePrev);
    }
    if (s._paginationContainer) {
        updatePaginationClasses(s);
    }
    if (!s.loop) {
        if (s.prevButton) {
            if (s._isBeginning) {
                s.prevButton.classList.add(CLS.buttonDisabled);
                ariaDisable(s.prevButton, true);
            }
            else {
                s.prevButton.classList.remove(CLS.buttonDisabled);
                ariaDisable(s.prevButton, false);
            }
        }
        if (s.nextButton) {
            if (s._isEnd) {
                s.nextButton.classList.add(CLS.buttonDisabled);
                ariaDisable(s.nextButton, true);
            }
            else {
                s.nextButton.classList.remove(CLS.buttonDisabled);
                ariaDisable(s.nextButton, false);
            }
        }
    }
}
//# sourceMappingURL=swiper-classes.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-index.ts

function updateActiveIndex(s) {
    var translate = s._rtl ? s._translate : -s._translate;
    var newActiveIndex;
    var i;
    var snapIndex;
    for (i = 0; i < s._slidesGrid.length; i++) {
        if (typeof s._slidesGrid[i + 1] !== 'undefined') {
            if (translate >= s._slidesGrid[i] && translate < s._slidesGrid[i + 1] - (s._slidesGrid[i + 1] - s._slidesGrid[i]) / 2) {
                newActiveIndex = i;
            }
            else if (translate >= s._slidesGrid[i] && translate < s._slidesGrid[i + 1]) {
                newActiveIndex = i + 1;
            }
        }
        else {
            if (translate >= s._slidesGrid[i]) {
                newActiveIndex = i;
            }
        }
    }
    snapIndex = Math.floor(newActiveIndex / s.slidesPerGroup);
    if (snapIndex >= s._snapGrid.length)
        snapIndex = s._snapGrid.length - 1;
    if (newActiveIndex === s._activeIndex) {
        return;
    }
    s._snapIndex = snapIndex;
    s._previousIndex = s._activeIndex;
    s._activeIndex = newActiveIndex;
    updateClasses(s);
    updateRealIndex(s);
}
function updateRealIndex(s) {
    var activeSlide = s._slides[s._activeIndex];
    if (activeSlide) {
        s.realIndex = parseInt(activeSlide.getAttribute('data-swiper-slide-index') || s._activeIndex, 10);
    }
}
//# sourceMappingURL=swiper-index.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-controller.ts




const SWIPER_CONTROLLER = {
    LinearSpline: function (_s, _platform, x, y) {
        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1;
        var i1, i3;
        this.interpolate = function (x2) {
            if (!x2)
                return 0;
            i3 = binarySearch(this.x, x2);
            i1 = i3 - 1;
            return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };
        var binarySearch = (function () {
            var maxIndex, minIndex, guess;
            return function (array, val) {
                minIndex = -1;
                maxIndex = array.length;
                while (maxIndex - minIndex > 1)
                    if (array[guess = maxIndex + minIndex >> 1] <= val) {
                        minIndex = guess;
                    }
                    else {
                        maxIndex = guess;
                    }
                return maxIndex;
            };
        })();
    },
    getInterpolateFunction: function (s, plt, c) {
        if (!s._spline)
            s._spline = s.loop ?
                new SWIPER_CONTROLLER.LinearSpline(s, plt, s._slidesGrid, c._slidesGrid) :
                new SWIPER_CONTROLLER.LinearSpline(s, plt, s._snapGrid, c._snapGrid);
    },
    setTranslate: function (s, plt, translate, byController, setWrapperTranslate) {
        var controlled = s.control;
        var multiplier, controlledTranslate;
        function setControlledTranslate(c) {
            translate = c._rtl && isHorizontal(c) ? -s._translate : s._translate;
            if (s.controlBy === 'slide') {
                SWIPER_CONTROLLER.getInterpolateFunction(s, plt, c);
                controlledTranslate = -s._spline.interpolate(-translate);
            }
            if (!controlledTranslate || s.controlBy === 'container') {
                multiplier = (maxTranslate(c) - minTranslate(c)) / (maxTranslate(s) - minTranslate(s));
                controlledTranslate = (translate - minTranslate(s)) * multiplier + minTranslate(c);
            }
            if (s.controlInverse) {
                controlledTranslate = maxTranslate(c) - controlledTranslate;
            }
            updateProgress(c, controlledTranslate);
            setWrapperTranslate(c, plt, controlledTranslate, false, s);
            updateActiveIndex(c);
        }
        if (Array.isArray(controlled)) {
            for (var i = 0; i < controlled.length; i++) {
                if (controlled[i] !== byController) {
                    setControlledTranslate(controlled[i]);
                }
            }
        }
        else if (byController !== controlled) {
            setControlledTranslate(controlled);
        }
    },
    setTransition: function (s, plt, duration, byController, setWrapperTransition) {
        var controlled = s.control;
        var i;
        function setControlledTransition(c) {
            setWrapperTransition(c, plt, duration, s);
            if (duration !== 0) {
                onTransitionStart(c);
                plt.transitionEnd(c._wrapper, () => {
                    if (!controlled)
                        return;
                    if (c.loop && s.controlBy === 'slide') {
                        fixLoop(c, plt);
                    }
                    swiper_onTransitionEnd(c, plt);
                });
            }
        }
        if (Array.isArray(controlled)) {
            for (i = 0; i < controlled.length; i++) {
                if (controlled[i] !== byController) {
                    setControlledTransition(controlled[i]);
                }
            }
        }
        else if (byController !== controlled) {
            setControlledTransition(controlled);
        }
    }
};
//# sourceMappingURL=swiper-controller.js.map
// CONCATENATED MODULE: ./src/platform/platform-utils.ts
function isCordova(plt) {
    const win = plt.win();
    return !!(win['cordova'] || win['PhoneGap'] || win['phonegap']);
}
function isElectron(plt) {
    return plt.testUserAgent('Electron');
}
function isIos(plt) {
    return plt.testNavigatorPlatform('iphone|ipad|ipod');
}
function isSafari(plt) {
    return plt.testUserAgent('Safari');
}
function isWKWebView(plt) {
    return isIos(plt) && !!plt.win()['webkit'];
}
function isIosUIWebView(plt) {
    return isIos(plt) && !isWKWebView(plt) && !isSafari(plt);
}
//# sourceMappingURL=platform-utils.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-effects.ts


const SWIPER_EFFECTS = {
    'fade': {
        setTranslate: function (s) {
            for (var i = 0; i < s._slides.length; i++) {
                var slide = s._slides[i];
                var offset = slide.swiperSlideOffset;
                var tx = -offset;
                if (!s.virtualTranslate) {
                    tx = tx - s._translate;
                }
                var ty = 0;
                if (!isHorizontal(s)) {
                    ty = tx;
                    tx = 0;
                }
                var slideOpacity = s.fade.crossFade ?
                    Math.max(1 - Math.abs(slide.progress), 0) :
                    1 + Math.min(Math.max(slide.progress, -1), 0);
                slide.style.opacity = slideOpacity;
                swiper_utils_transform(slide, 'translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
            }
        },
        setTransition: function (s, plt, duration) {
            var slides = s._slides;
            for (var i = 0; i < slides.length; i++) {
                swiper_utils_transition(slides[i], duration);
            }
            if (s.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                for (let i = 0; i < slides.length; i++) {
                    plt.transitionEnd(slides[i], () => {
                        if (eventTriggered || !s)
                            return;
                        eventTriggered = true;
                        s._animating = false;
                        triggerTransitionEnd(plt, s._wrapper);
                    });
                }
            }
        }
    },
    'flip': {
        setTranslate: function (s, plt) {
            for (var i = 0; i < s._slides.length; i++) {
                var slide = s._slides[i];
                var progress = slide.progress;
                if (s.flip.limitRotation) {
                    progress = Math.max(Math.min(slide.progress, 1), -1);
                }
                var offset = slide.swiperSlideOffset;
                var rotate = -180 * progress, rotateY = rotate, rotateX = 0, tx = -offset, ty = 0;
                if (!isHorizontal(s)) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                }
                else if (s._rtl) {
                    rotateY = -rotateY;
                }
                slide.style.zIndex = -Math.abs(Math.round(progress)) + s._slides.length;
                if (s.flip.slideShadows) {
                    var shadowBefore = (isHorizontal(s) ? slide.querySelector('.swiper-slide-shadow-left') : slide.querySelector('.swiper-slide-shadow-top'));
                    var shadowAfter = (isHorizontal(s) ? slide.querySelector('.swiper-slide-shadow-right') : slide.querySelector('.swiper-slide-shadow-bottom'));
                    if (!shadowBefore) {
                        shadowBefore = plt.doc().createElement('div');
                        shadowBefore.className = 'swiper-slide-shadow-' + (isHorizontal(s) ? 'left' : 'top');
                        slide.appendChild(shadowBefore);
                    }
                    if (!shadowAfter) {
                        shadowAfter = plt.doc().createElement('div');
                        shadowAfter.className = 'swiper-slide-shadow-' + (isHorizontal(s) ? 'right' : 'bottom');
                        slide.appendChild(shadowAfter);
                    }
                    if (shadowBefore) {
                        shadowBefore.style.opacity = Math.max(-progress, 0);
                    }
                    if (shadowAfter) {
                        shadowAfter.style.opacity = Math.max(progress, 0);
                    }
                }
                swiper_utils_transform(slide, 'translate3d(' + tx + 'px, ' + ty + 'px, 0px) rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)');
            }
        },
        setTransition: function (s, plt, duration) {
            for (var i = 0; i < s._slides.length; i++) {
                var slide = s._slides[i];
                swiper_utils_transition(slide, duration);
                eachChild(slide, '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left', el => {
                    swiper_utils_transition(el, duration);
                });
            }
            if (s.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                plt.transitionEnd(s._slides[s._activeIndex], (ev) => {
                    if (eventTriggered || !s)
                        return;
                    if (!ev.target.classList.contains(CLS.slideActive)) {
                        return;
                    }
                    eventTriggered = true;
                    s._animating = false;
                    triggerTransitionEnd(plt, s._wrapper);
                });
            }
        }
    },
    'cube': {
        setTranslate: function (s, plt) {
            var wrapperRotate = 0;
            var cubeShadow;
            if (s.cube.shadow) {
                if (isHorizontal(s)) {
                    cubeShadow = s._wrapper.querySelector('.swiper-cube-shadow');
                    if (!cubeShadow) {
                        cubeShadow = plt.doc().createElement('div');
                        cubeShadow.className = 'swiper-cube-shadow';
                        s._wrapper.appendChild(cubeShadow);
                    }
                    cubeShadow.style.height = s.renderedWidth + 'px';
                }
                else {
                    cubeShadow = s.container.querySelector('.swiper-cube-shadow');
                    if (!cubeShadow) {
                        cubeShadow = plt.doc().createElement('div');
                        cubeShadow.className = 'swiper-cube-shadow';
                        s._wrapper.appendChild(cubeShadow);
                    }
                }
            }
            for (var i = 0; i < s._slides.length; i++) {
                var slide = s._slides[i];
                var slideAngle = i * 90;
                var round = Math.floor(slideAngle / 360);
                if (s._rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                var progress = Math.max(Math.min(slide.progress, 1), -1);
                var tx = 0, ty = 0, tz = 0;
                if (i % 4 === 0) {
                    tx = -round * 4 * s._renderedSize;
                    tz = 0;
                }
                else if ((i - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * s._renderedSize;
                }
                else if ((i - 2) % 4 === 0) {
                    tx = s._renderedSize + round * 4 * s._renderedSize;
                    tz = s._renderedSize;
                }
                else if ((i - 3) % 4 === 0) {
                    tx = -s._renderedSize;
                    tz = 3 * s._renderedSize + s._renderedSize * 4 * round;
                }
                if (s._rtl) {
                    tx = -tx;
                }
                if (!isHorizontal(s)) {
                    ty = tx;
                    tx = 0;
                }
                var transformStr = 'rotateX(' + (isHorizontal(s) ? 0 : -slideAngle) + 'deg) rotateY(' + (isHorizontal(s) ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = i * 90 + progress * 90;
                    if (s._rtl)
                        wrapperRotate = -i * 90 - progress * 90;
                }
                swiper_utils_transform(slide, transformStr);
                if (s.cube.slideShadows) {
                    var shadowBefore = (isHorizontal(s) ? slide.querySelector('.swiper-slide-shadow-left') : slide.querySelector('.swiper-slide-shadow-top'));
                    var shadowAfter = (isHorizontal(s) ? slide.querySelector('.swiper-slide-shadow-right') : slide.querySelector('.swiper-slide-shadow-bottom'));
                    if (!shadowBefore) {
                        shadowBefore = plt.doc().createElement('div');
                        shadowBefore.className = 'swiper-slide-shadow-' + (isHorizontal(s) ? 'left' : 'top');
                        slide.appendChild(shadowBefore);
                    }
                    if (!shadowAfter) {
                        shadowAfter = plt.doc().createElement('div');
                        shadowAfter.className = 'swiper-slide-shadow-' + (isHorizontal(s) ? 'right' : 'bottom');
                        slide.appendChild(shadowAfter);
                    }
                    if (shadowBefore)
                        shadowBefore.style.opacity = Math.max(-progress, 0);
                    if (shadowAfter)
                        shadowAfter.style.opacity = Math.max(progress, 0);
                }
            }
            s._wrapper.style.transformOrigin = s._wrapper.style.webkitTransformOrigin = '50% 50% -' + (s._renderedSize / 2) + 'px';
            if (s.cube.shadow) {
                if (isHorizontal(s)) {
                    swiper_utils_transform(cubeShadow, 'translate3d(0px, ' + (s.renderedWidth / 2 + s.cube.shadowOffset) + 'px, ' + (-s.renderedWidth / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.cube.shadowScale) + ')');
                }
                else {
                    var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                    var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                    var scale1 = s.cube.shadowScale;
                    var scale2 = s.cube.shadowScale / multiplier;
                    var offset = s.cube.shadowOffset;
                    swiper_utils_transform(cubeShadow, 'scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.renderedHeight / 2 + offset) + 'px, ' + (-s.renderedHeight / 2 / scale2) + 'px) rotateX(-90deg)');
                }
            }
            var zFactor = (isSafari(plt) || isIosUIWebView(plt)) ? (-s._renderedSize / 2) : 0;
            swiper_utils_transform(s._wrapper, 'translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isHorizontal(s) ? 0 : wrapperRotate) + 'deg) rotateY(' + (isHorizontal(s) ? -wrapperRotate : 0) + 'deg)');
        },
        setTransition: function (s, _plt, duration) {
            for (var i = 0; i < s._slides.length; i++) {
                var slide = s._slides[i];
                swiper_utils_transition(slide, duration);
                eachChild(slide, '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left', el => {
                    swiper_utils_transition(el, duration);
                });
            }
            if (s.cube.shadow && !isHorizontal(s)) {
                eachChild(s.container, '.swiper-cube-shadow', el => {
                    swiper_utils_transition(el, duration);
                });
            }
        }
    },
    'coverflow': {
        setTranslate: function (s, plt) {
            var transformStr = s._translate;
            var center = isHorizontal(s) ? -transformStr + s.renderedWidth / 2 : -transformStr + s.renderedHeight / 2;
            var rotate = isHorizontal(s) ? s.coverflow.rotate : -s.coverflow.rotate;
            var translate = s.coverflow.depth;
            for (var i = 0, length = s._slides.length; i < length; i++) {
                var slide = s._slides[i];
                var slideSize = s._slidesSizesGrid[i];
                var slideOffset = slide.swiperSlideOffset;
                var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.coverflow.modifier;
                var rotateY = isHorizontal(s) ? rotate * offsetMultiplier : 0;
                var rotateX = isHorizontal(s) ? 0 : rotate * offsetMultiplier;
                var translateZ = -translate * Math.abs(offsetMultiplier);
                var translateY = isHorizontal(s) ? 0 : s.coverflow.stretch * (offsetMultiplier);
                var translateX = isHorizontal(s) ? s.coverflow.stretch * (offsetMultiplier) : 0;
                if (Math.abs(translateX) < 0.001)
                    translateX = 0;
                if (Math.abs(translateY) < 0.001)
                    translateY = 0;
                if (Math.abs(translateZ) < 0.001)
                    translateZ = 0;
                if (Math.abs(rotateY) < 0.001)
                    rotateY = 0;
                if (Math.abs(rotateX) < 0.001)
                    rotateX = 0;
                var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
                swiper_utils_transform(slide, slideTransform);
                slide.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (s.coverflow.slideShadows) {
                    var shadowBefore = (isHorizontal(s) ? slide.querySelector('.swiper-slide-shadow-left') : slide.querySelector('.swiper-slide-shadow-top'));
                    var shadowAfter = (isHorizontal(s) ? slide.querySelector('.swiper-slide-shadow-right') : slide.querySelector('.swiper-slide-shadow-bottom'));
                    if (!shadowBefore) {
                        shadowBefore = plt.doc().createElement('div');
                        shadowBefore.className = 'swiper-slide-shadow-' + (isHorizontal(s) ? 'left' : 'top');
                        slide.appendChild(shadowBefore);
                    }
                    if (!shadowAfter) {
                        shadowAfter = plt.doc().createElement('div');
                        shadowAfter.className = 'swiper-slide-shadow-' + (isHorizontal(s) ? 'right' : 'bottom');
                        slide.appendChild(shadowAfter);
                    }
                    if (shadowBefore) {
                        shadowBefore.style.opacity = (offsetMultiplier > 0 ? offsetMultiplier : 0);
                    }
                    if (shadowAfter) {
                        shadowAfter.style.opacity = ((-offsetMultiplier) > 0 ? -offsetMultiplier : 0);
                    }
                }
            }
        },
        setTransition: function (s, _plt, duration) {
            for (var i = 0; i < s._slides.length; i++) {
                var slide = s._slides[i];
                swiper_utils_transition(slide, duration);
                eachChild(slide, '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left', (el) => {
                    swiper_utils_transition(el, duration);
                });
            }
        }
    }
};
//# sourceMappingURL=swiper-effects.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-transition.ts






function swiper_transition_setWrapperTranslate(s, plt, translate, shouldUpdateActiveIndex, byController) {
    var x = 0, y = 0, z = 0;
    if (isHorizontal(s)) {
        x = s._rtl ? -translate : translate;
    }
    else {
        y = translate;
    }
    if (s.roundLengths) {
        x = swiper_utils_round(x);
        y = swiper_utils_round(y);
    }
    if (!s.virtualTranslate) {
        swiper_utils_transform(s._wrapper, 'translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
    }
    s._translate = isHorizontal(s) ? x : y;
    var progress;
    var translatesDiff = maxTranslate(s) - minTranslate(s);
    if (translatesDiff === 0) {
        progress = 0;
    }
    else {
        progress = (translate - minTranslate(s)) / (translatesDiff);
    }
    if (progress !== s.progress) {
        updateProgress(s, translate);
    }
    if (shouldUpdateActiveIndex) {
        updateActiveIndex(s);
    }
    if (s.effect !== 'slide' && SWIPER_EFFECTS[s.effect]) {
        SWIPER_EFFECTS[s.effect].setTranslate(s, plt);
    }
    if (s.parallax) {
        parallaxSetTranslate(s);
    }
    if (s.control) {
        SWIPER_CONTROLLER.setTranslate(s, plt, s._translate, byController, swiper_transition_setWrapperTranslate);
    }
}
function getTranslate(s, plt, el, axis) {
    var win = plt.win();
    var matrix;
    var curTransform;
    var curStyle;
    var transformMatrix;
    if (typeof axis === 'undefined') {
        axis = 'x';
    }
    if (s.virtualTranslate) {
        return s._rtl ? -s._translate : s._translate;
    }
    curStyle = plt.getElementComputedStyle(el);
    if (win.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(',').length > 6) {
            curTransform = curTransform.split(', ').map(function (a) {
                return a.replace(',', '.');
            }).join(', ');
        }
        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    }
    else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
    }
    if (axis === 'x') {
        if (win.WebKitCSSMatrix) {
            curTransform = transformMatrix.m41;
        }
        else if (matrix.length === 16) {
            curTransform = parseFloat(matrix[12]);
        }
        else {
            curTransform = parseFloat(matrix[4]);
        }
    }
    if (axis === 'y') {
        if (win.WebKitCSSMatrix) {
            curTransform = transformMatrix.m42;
        }
        else if (matrix.length === 16) {
            curTransform = parseFloat(matrix[13]);
        }
        else {
            curTransform = parseFloat(matrix[5]);
        }
    }
    if (s._rtl && curTransform) {
        curTransform = -curTransform;
    }
    return curTransform || 0;
}
function getWrapperTranslate(s, plt, axis) {
    if (typeof axis === 'undefined') {
        axis = isHorizontal(s) ? 'x' : 'y';
    }
    return getTranslate(s, plt, s._wrapper, axis);
}
function swiper_transition_setWrapperTransition(s, plt, duration, byController) {
    swiper_utils_transition(s._wrapper, duration);
    if (s.effect !== 'slide' && SWIPER_EFFECTS[s.effect]) {
        SWIPER_EFFECTS[s.effect].setTransition(s, plt, duration);
    }
    if (s.parallax) {
        parallaxSetTransition(s, duration);
    }
    if (s.control) {
        SWIPER_CONTROLLER.setTransition(s, plt, duration, byController, swiper_transition_setWrapperTransition);
    }
}
//# sourceMappingURL=swiper-transition.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-zoom.ts


function initZoom(s, plt) {
    s._supportGestures = ('ongesturestart' in plt.win());
    s._zoom = {
        scale: 1,
        currentScale: 1,
        isScaling: false,
        gesture: {
            slide: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            image: undefined,
            imageWrap: undefined,
            zoomMax: s.zoomMax
        },
        image: {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {}
        },
        velocity: {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined
        },
        unRegs: []
    };
    resetZoomEvents(s, plt);
    return function () {
        detachZoomEvents(s);
    };
}
function getDistanceBetweenTouches(ev) {
    if (ev.targetTouches.length < 2)
        return 1;
    var x1 = ev.targetTouches[0].pageX, y1 = ev.targetTouches[0].pageY, x2 = ev.targetTouches[1].pageX, y2 = ev.targetTouches[1].pageY;
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}
function onGestureStart(s, _plt, ev) {
    const z = s._zoom;
    s.originalEvent = ev;
    if (!s._supportGestures) {
        if (ev.type !== 'touchstart' || ev.type === 'touchstart' && ev.targetTouches.length < 2) {
            return;
        }
        z.gesture.scaleStart = getDistanceBetweenTouches(ev);
    }
    if (!z.gesture.slide) {
        if (ev.currentTarget && ev.currentTarget.classList.contains(CLS.slide)) {
            z.gesture.slide = ev.currentTarget;
        }
        if (!z.gesture.slide) {
            z.gesture.slide = s._slides[s._activeIndex];
        }
        z.gesture.image = z.gesture.slide.querySelector('img, svg, canvas, ion-img');
        z.gesture.imageWrap = z.gesture.image.closest('.' + CLS.zoomContainer);
        if (!z.gesture.imageWrap) {
            z.gesture.image = undefined;
            return;
        }
        z.gesture.zoomMax = parseInt(z.gesture.imageWrap.getAttribute('data-swiper-zoom') || s.zoomMax, 10);
    }
    swiper_utils_transition(z.gesture.image, 0);
    z.isScaling = true;
}
function onGestureChange(s, _plt, ev) {
    const z = s._zoom;
    s.originalEvent = ev;
    if (!s._supportGestures) {
        if (ev.type !== 'touchmove' || ev.type === 'touchmove' && ev.targetTouches.length < 2) {
            return;
        }
        z.gesture.scaleMove = getDistanceBetweenTouches(ev);
    }
    if (!z.gesture.image)
        return;
    if (s._supportGestures) {
        z.scale = ev.scale * z.currentScale;
    }
    else {
        z.scale = (z.gesture.scaleMove / z.gesture.scaleStart) * z.currentScale;
    }
    if (z.scale > z.gesture.zoomMax) {
        z.scale = z.gesture.zoomMax - 1 + Math.pow((z.scale - z.gesture.zoomMax + 1), 0.5);
    }
    if (z.scale < s.zoomMin) {
        z.scale = s.zoomMin + 1 - Math.pow((s.zoomMin - z.scale + 1), 0.5);
    }
    swiper_utils_transform(z.gesture.image, 'translate3d(0,0,0) scale(' + z.scale + ')');
}
function onGestureEnd(s, _plt, ev) {
    const z = s._zoom;
    s.originalEvent = ev;
    if (!s._supportGestures) {
        if (ev.type !== 'touchend' || ev.type === 'touchend' && ev.changedTouches.length < 2) {
            return;
        }
    }
    if (!z.gesture.image)
        return;
    z.scale = Math.max(Math.min(z.scale, z.gesture.zoomMax), s.zoomMin);
    swiper_utils_transition(z.gesture.image, s.speed);
    swiper_utils_transform(z.gesture.image, 'translate3d(0,0,0) scale(' + z.scale + ')');
    z.currentScale = z.scale;
    z.isScaling = false;
    if (z.scale === 1) {
        z.gesture.slide = undefined;
    }
}
function onTouchStart(s, plt, ev) {
    const z = s._zoom;
    s.originalEvent = ev;
    if (!z.gesture.image || z.image.isTouched)
        return;
    if (plt.is('android')) {
        ev.preventDefault();
    }
    z.image.isTouched = true;
    z.image.touchesStart.x = ev.type === 'touchstart' ? ev.targetTouches[0].pageX : ev.pageX;
    z.image.touchesStart.y = ev.type === 'touchstart' ? ev.targetTouches[0].pageY : ev.pageY;
}
function onTouchMove(s, plt, ev) {
    const z = s._zoom;
    s.originalEvent = ev;
    if (!z.gesture.image)
        return;
    s._allowClick = false;
    if (!z.image.isTouched || !z.gesture.slide)
        return;
    if (!z.image.isMoved) {
        z.image.width = z.gesture.image.offsetWidth;
        z.image.height = z.gesture.image.offsetHeight;
        z.image.startX = getTranslate(s, plt, z.gesture.imageWrap, 'x') || 0;
        z.image.startY = getTranslate(s, plt, z.gesture.imageWrap, 'y') || 0;
        z.gesture.slideWidth = z.gesture.slide.offsetWidth;
        z.gesture.slideHeight = z.gesture.slide.offsetHeight;
        swiper_utils_transition(z.gesture.imageWrap, 0);
        if (s._rtl) {
            z.image.startX = -z.image.startX;
            z.image.startY = -z.image.startY;
        }
    }
    var scaledWidth = z.image.width * z.scale;
    var scaledHeight = z.image.height * z.scale;
    if (scaledWidth < z.gesture.slideWidth && scaledHeight < z.gesture.slideHeight) {
        return;
    }
    z.image.minX = Math.min((z.gesture.slideWidth / 2 - scaledWidth / 2), 0);
    z.image.maxX = -z.image.minX;
    z.image.minY = Math.min((z.gesture.slideHeight / 2 - scaledHeight / 2), 0);
    z.image.maxY = -z.image.minY;
    z.image.touchesCurrent.x = ev.type === 'touchmove' ? ev.targetTouches[0].pageX : ev.pageX;
    z.image.touchesCurrent.y = ev.type === 'touchmove' ? ev.targetTouches[0].pageY : ev.pageY;
    if (!z.image.isMoved && !z.isScaling) {
        if (isHorizontal(s) &&
            (Math.floor(z.image.minX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x < z.image.touchesStart.x) ||
            (Math.floor(z.image.maxX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x > z.image.touchesStart.x)) {
            z.image.isTouched = false;
            return;
        }
        else if (!isHorizontal(s) &&
            (Math.floor(z.image.minY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y < z.image.touchesStart.y) ||
            (Math.floor(z.image.maxY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y > z.image.touchesStart.y)) {
            z.image.isTouched = false;
            return;
        }
    }
    ev.preventDefault();
    ev.stopPropagation();
    z.image.isMoved = true;
    z.image.currentX = z.image.touchesCurrent.x - z.image.touchesStart.x + z.image.startX;
    z.image.currentY = z.image.touchesCurrent.y - z.image.touchesStart.y + z.image.startY;
    if (z.image.currentX < z.image.minX) {
        z.image.currentX = z.image.minX + 1 - Math.pow((z.image.minX - z.image.currentX + 1), 0.8);
    }
    if (z.image.currentX > z.image.maxX) {
        z.image.currentX = z.image.maxX - 1 + Math.pow((z.image.currentX - z.image.maxX + 1), 0.8);
    }
    if (z.image.currentY < z.image.minY) {
        z.image.currentY = z.image.minY + 1 - Math.pow((z.image.minY - z.image.currentY + 1), 0.8);
    }
    if (z.image.currentY > z.image.maxY) {
        z.image.currentY = z.image.maxY - 1 + Math.pow((z.image.currentY - z.image.maxY + 1), 0.8);
    }
    if (!z.velocity.prevPositionX)
        z.velocity.prevPositionX = z.image.touchesCurrent.x;
    if (!z.velocity.prevPositionY)
        z.velocity.prevPositionY = z.image.touchesCurrent.y;
    if (!z.velocity.prevTime)
        z.velocity.prevTime = Date.now();
    z.velocity.x = (z.image.touchesCurrent.x - z.velocity.prevPositionX) / (Date.now() - z.velocity.prevTime) / 2;
    z.velocity.y = (z.image.touchesCurrent.y - z.velocity.prevPositionY) / (Date.now() - z.velocity.prevTime) / 2;
    if (Math.abs(z.image.touchesCurrent.x - z.velocity.prevPositionX) < 2)
        z.velocity.x = 0;
    if (Math.abs(z.image.touchesCurrent.y - z.velocity.prevPositionY) < 2)
        z.velocity.y = 0;
    z.velocity.prevPositionX = z.image.touchesCurrent.x;
    z.velocity.prevPositionY = z.image.touchesCurrent.y;
    z.velocity.prevTime = Date.now();
    swiper_utils_transform(z.gesture.imageWrap, 'translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
}
function onTouchEnd(s) {
    const z = s._zoom;
    if (!z.gesture.image)
        return;
    if (!z.image.isTouched || !z.image.isMoved) {
        z.image.isTouched = false;
        z.image.isMoved = false;
        return;
    }
    z.image.isTouched = false;
    z.image.isMoved = false;
    var momentumDurationX = 300;
    var momentumDurationY = 300;
    var momentumDistanceX = z.velocity.x * momentumDurationX;
    var newPositionX = z.image.currentX + momentumDistanceX;
    var momentumDistanceY = z.velocity.y * momentumDurationY;
    var newPositionY = z.image.currentY + momentumDistanceY;
    if (z.velocity.x !== 0)
        momentumDurationX = Math.abs((newPositionX - z.image.currentX) / z.velocity.x);
    if (z.velocity.y !== 0)
        momentumDurationY = Math.abs((newPositionY - z.image.currentY) / z.velocity.y);
    var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    z.image.currentX = newPositionX;
    z.image.currentY = newPositionY;
    var scaledWidth = z.image.width * z.scale;
    var scaledHeight = z.image.height * z.scale;
    z.image.minX = Math.min((z.gesture.slideWidth / 2 - scaledWidth / 2), 0);
    z.image.maxX = -z.image.minX;
    z.image.minY = Math.min((z.gesture.slideHeight / 2 - scaledHeight / 2), 0);
    z.image.maxY = -z.image.minY;
    z.image.currentX = Math.max(Math.min(z.image.currentX, z.image.maxX), z.image.minX);
    z.image.currentY = Math.max(Math.min(z.image.currentY, z.image.maxY), z.image.minY);
    swiper_utils_transition(z.gesture.imageWrap, momentumDuration);
    swiper_utils_transform(z.gesture.imageWrap, 'translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
}
function swiper_zoom_onTransitionEnd(s) {
    const z = s._zoom;
    if (z.gesture.slide && s._previousIndex !== s._activeIndex) {
        swiper_utils_transform(z.gesture.image, 'translate3d(0,0,0) scale(1)');
        swiper_utils_transform(z.gesture.imageWrap, 'translate3d(0,0,0)');
        z.gesture.slide = z.gesture.image = z.gesture.imageWrap = undefined;
        z.scale = z.currentScale = 1;
    }
}
function toggleZoom(s, plt) {
    const z = s._zoom;
    const ev = s.originalEvent;
    if (!z.gesture.slide) {
        z.gesture.slide = s.clickedSlide ? s.clickedSlide : s._slides[s._activeIndex];
        z.gesture.image = z.gesture.slide.querySelector('img, svg, canvas, ion-img');
        z.gesture.imageWrap = z.gesture.image.closest('.' + CLS.zoomContainer);
    }
    if (!z.gesture.image)
        return;
    var touchX;
    var touchY;
    var offsetX;
    var offsetY;
    var diffX;
    var diffY;
    var translateX;
    var translateY;
    var imageWidth;
    var imageHeight;
    var scaledWidth;
    var scaledHeight;
    var translateMinX;
    var translateMinY;
    var translateMaxX;
    var translateMaxY;
    var slideWidth;
    var slideHeight;
    if (typeof z.image.touchesStart.x === 'undefined' && ev) {
        touchX = ev.type === 'touchend' ? ev.changedTouches[0].pageX : ev.pageX;
        touchY = ev.type === 'touchend' ? ev.changedTouches[0].pageY : ev.pageY;
    }
    else {
        touchX = z.image.touchesStart.x;
        touchY = z.image.touchesStart.y;
    }
    if (z.scale && z.scale !== 1) {
        z.scale = z.currentScale = 1;
        swiper_utils_transition(z.gesture.imageWrap, 300);
        swiper_utils_transform(z.gesture.imageWrap, 'translate3d(0,0,0)');
        swiper_utils_transition(z.gesture.image, 300);
        swiper_utils_transform(z.gesture.image, 'translate3d(0,0,0) scale(1)');
        z.gesture.slide = undefined;
    }
    else {
        z.scale = z.currentScale = parseInt(z.gesture.imageWrap.getAttribute('data-swiper-zoom') || s.zoomMax, 10);
        if (ev) {
            slideWidth = z.gesture.slide.offsetWidth;
            slideHeight = z.gesture.slide.offsetHeight;
            var slideOffsets = swiper_utils_offset(z.gesture.slide, plt);
            offsetX = slideOffsets.left;
            offsetY = slideOffsets.top;
            diffX = offsetX + slideWidth / 2 - touchX;
            diffY = offsetY + slideHeight / 2 - touchY;
            imageWidth = z.gesture.image.offsetWidth;
            imageHeight = z.gesture.image.offsetHeight;
            scaledWidth = imageWidth * z.scale;
            scaledHeight = imageHeight * z.scale;
            translateMinX = Math.min((slideWidth / 2 - scaledWidth / 2), 0);
            translateMinY = Math.min((slideHeight / 2 - scaledHeight / 2), 0);
            translateMaxX = -translateMinX;
            translateMaxY = -translateMinY;
            translateX = diffX * z.scale;
            translateY = diffY * z.scale;
            if (translateX < translateMinX) {
                translateX = translateMinX;
            }
            if (translateX > translateMaxX) {
                translateX = translateMaxX;
            }
            if (translateY < translateMinY) {
                translateY = translateMinY;
            }
            if (translateY > translateMaxY) {
                translateY = translateMaxY;
            }
        }
        else {
            translateX = 0;
            translateY = 0;
        }
        swiper_utils_transition(z.gesture.imageWrap, 300);
        swiper_utils_transform(z.gesture.imageWrap, 'translate3d(' + translateX + 'px, ' + translateY + 'px,0)');
        swiper_utils_transition(z.gesture.image, 300);
        swiper_utils_transform(z.gesture.image, 'translate3d(0,0,0) scale(' + z.scale + ')');
    }
}
function resetZoomEvents(s, plt) {
    detachZoomEvents(s);
    const unRegs = s._zoom.unRegs;
    const evtOpts = { passive: s._touchEvents.start === 'touchstart', zone: false };
    const slides = s._slides;
    let slide;
    if (s._supportGestures) {
        for (let i = 0; i < slides.length; i++) {
            slide = slides[i];
            plt.registerListener(slide, 'gesturestart', (ev) => {
                onGestureStart(s, plt, ev);
            }, evtOpts, unRegs);
            plt.registerListener(slide, 'gesturechange', (ev) => {
                onGestureChange(s, plt, ev);
            }, evtOpts, unRegs);
            plt.registerListener(slide, 'gestureend', (ev) => {
                onGestureEnd(s, plt, ev);
            }, evtOpts, unRegs);
        }
    }
    else if (s._touchEvents.start === 'touchstart') {
        for (let i = 0; i < slides.length; i++) {
            slide = slides[i];
            plt.registerListener(slide, s._touchEvents.start, (ev) => {
                onGestureStart(s, plt, ev);
            }, evtOpts, unRegs);
            plt.registerListener(slide, s._touchEvents.move, (ev) => {
                onGestureChange(s, plt, ev);
            }, evtOpts, unRegs);
            plt.registerListener(slide, s._touchEvents.end, (ev) => {
                onGestureEnd(s, plt, ev);
            }, evtOpts, unRegs);
        }
    }
    var touchStartSub = s.ionSlideTouchStart.subscribe((ev) => {
        onTouchStart(s, plt, ev);
    });
    unRegs.push(() => { touchStartSub.unsubscribe(); });
    for (let i = 0; i < slides.length; i++) {
        slide = slides[i];
        if (slide.querySelector('.' + CLS.zoomContainer)) {
            plt.registerListener(slide, 's.touchEvents.move', (ev) => {
                onTouchMove(s, plt, ev);
            }, evtOpts, unRegs);
        }
    }
    var touchEndSub = s.ionSlideTouchEnd.subscribe(() => {
        onTouchEnd(s);
    });
    unRegs.push(() => { touchEndSub.unsubscribe(); });
    var transEndSub = s.ionSlideTouchEnd.subscribe(() => {
        swiper_zoom_onTransitionEnd(s);
    });
    unRegs.push(() => { transEndSub.unsubscribe(); });
    if (s.zoomToggle) {
        var doubleTapSub = s.ionSlideDoubleTap.subscribe(() => {
            toggleZoom(s, plt);
        });
        unRegs.push(() => { doubleTapSub.unsubscribe(); });
    }
}
function detachZoomEvents(s) {
    s._zoom.unRegs.forEach(unReg => {
        unReg();
    });
    s._zoom.unRegs.length = 0;
}
//# sourceMappingURL=swiper-zoom.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper.ts









function initSwiper(s, plt) {
    s._classNames = [];
    if (!s.container) {
        return;
    }
    s.container.swiper = s;
    const containerModifierClass = CLS.containerModifier;
    s._classNames.push(containerModifierClass + s.direction);
    if (s.freeMode) {
        s._classNames.push(containerModifierClass + 'free-mode');
    }
    if (s.autoHeight) {
        s._classNames.push(containerModifierClass + 'autoheight');
    }
    if (s.parallax || s.watchSlidesVisibility) {
        s.watchSlidesProgress = true;
    }
    if (s.touchReleaseOnEdges) {
        s.resistanceRatio = 0;
    }
    var effect = s.effect;
    if (['cube', 'coverflow', 'flip'].indexOf(effect) >= 0) {
        s.watchSlidesProgress = true;
        s._classNames.push(containerModifierClass + '3d');
    }
    if (effect !== 'slide') {
        s._classNames.push(containerModifierClass + effect);
    }
    if (effect === 'cube') {
        s.resistanceRatio = 0;
        s.slidesPerView = 1;
        s.slidesPerColumn = 1;
        s.slidesPerGroup = 1;
        s.centeredSlides = false;
        s.spaceBetween = 0;
        s.virtualTranslate = true;
        s.setWrapperSize = false;
    }
    if (effect === 'fade' || effect === 'flip') {
        s.slidesPerView = 1;
        s.slidesPerColumn = 1;
        s.slidesPerGroup = 1;
        s.watchSlidesProgress = true;
        s.spaceBetween = 0;
        s.setWrapperSize = false;
        s.virtualTranslate = true;
    }
    s._wrapper = s.container.querySelector('.' + CLS.wrapper);
    if (s.paginationType) {
        s._paginationContainer = s.container.querySelector('.swiper-pagination');
        if (s.paginationType === 'bullets') {
            s._paginationContainer.classList.add(CLS.paginationModifier + 'clickable');
        }
        s._paginationContainer.classList.add(CLS.paginationModifier + s.paginationType);
    }
    s._rtl = isHorizontal(s) && (s.container.dir.toLowerCase() === 'rtl' || s.container.style.direction === 'rtl');
    if (s._rtl) {
        s._classNames.push(containerModifierClass + 'rtl');
    }
    if (s.slidesPerColumn > 1) {
        s._classNames.push(containerModifierClass + 'multirow');
    }
    if (plt.is('android')) {
        s._classNames.push(containerModifierClass + 'android');
    }
    s._classNames.forEach(clsName => {
        s.container.classList.add(clsName);
    });
    s._translate = 0;
    s.progress = 0;
    s.velocity = 0;
    s._autoplayTimeoutId = undefined;
    s._autoplaying = false;
    s._autoplayPaused = false;
    s._allowClick = true;
    s._animating = false;
    s._touches = {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
    };
    if (s.loop) {
        createLoop(s);
    }
    updateContainerSize(s, plt);
    updateSlidesSize(s, plt);
    updatePagination(s);
    if (effect !== 'slide' && SWIPER_EFFECTS[effect]) {
        if (!s.loop) {
            updateProgress(s);
        }
        SWIPER_EFFECTS[effect].setTranslate(s, plt);
    }
    if (s.loop) {
        slideTo(s, plt, s.initialSlide + s.loopedSlides, 0, s.runCallbacksOnInit);
    }
    else {
        slideTo(s, plt, s.initialSlide, 0, s.runCallbacksOnInit);
        if (s.initialSlide === 0) {
            parallaxSetTranslate(s);
        }
    }
    if (s.autoplay) {
        startAutoplay(s, plt);
    }
}
function autoplay(s, plt) {
    var autoplayDelay = s.autoplay;
    var activeSlide = s._slides[s._activeIndex];
    if (activeSlide.hasAttribute('data-swiper-autoplay')) {
        autoplayDelay = (activeSlide.getAttribute('data-swiper-autoplay') || s.autoplay);
    }
    s._autoplayTimeoutId = plt.timeout(() => {
        s._zone.run(() => {
            if (s.loop) {
                fixLoop(s, plt);
                slideNext(s, plt, true, undefined, true);
                s.ionSlideAutoplay.emit(s);
            }
            else {
                if (!s._isEnd) {
                    slideNext(s, plt, true, undefined, true);
                    s.ionSlideAutoplay.emit(s);
                }
                else {
                    if (!s.autoplayStopOnLast) {
                        slideTo(s, plt, 0);
                        s.ionSlideAutoplay.emit(s);
                    }
                    else {
                        stopAutoplay(s);
                    }
                }
            }
        });
    }, autoplayDelay);
}
function startAutoplay(s, plt) {
    if (typeof s._autoplayTimeoutId !== 'undefined')
        return false;
    if (!s.autoplay || s._autoplaying) {
        return false;
    }
    s._autoplaying = true;
    s._zone.run(() => {
        s.ionSlideAutoplayStart.emit(s);
    });
    autoplay(s, plt);
}
function stopAutoplay(s) {
    if (!s._autoplayTimeoutId)
        return;
    if (s._autoplayTimeoutId)
        clearTimeout(s._autoplayTimeoutId);
    s._autoplaying = false;
    s._autoplayTimeoutId = undefined;
    s._zone.run(() => {
        s.ionSlideAutoplayStop.emit(s);
    });
}
function pauseAutoplay(s, plt, speed) {
    if (s._autoplayPaused)
        return;
    if (s._autoplayTimeoutId)
        clearTimeout(s._autoplayTimeoutId);
    s._autoplayPaused = true;
    if (speed === 0) {
        s._autoplayPaused = false;
        autoplay(s, plt);
    }
    else {
        plt.transitionEnd(s._wrapper, () => {
            if (!s)
                return;
            s._autoplayPaused = false;
            if (!s._autoplaying) {
                stopAutoplay(s);
            }
            else {
                autoplay(s, plt);
            }
        });
    }
}
function updateAutoHeight(s) {
    var activeSlides = [];
    var newHeight = 0;
    var i;
    if (s.slidesPerView !== 'auto' && s.slidesPerView > 1) {
        for (i = 0; i < Math.ceil(s.slidesPerView); i++) {
            var index = s._activeIndex + i;
            if (index > s._slides.length)
                break;
            activeSlides.push(s._slides[index]);
        }
    }
    else {
        activeSlides.push(s._slides[s._activeIndex]);
    }
    for (i = 0; i < activeSlides.length; i++) {
        if (typeof activeSlides[i] !== 'undefined') {
            var height = activeSlides[i].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
        }
    }
    if (newHeight) {
        s._wrapper.style.height = newHeight + 'px';
    }
}
function updateContainerSize(s, plt) {
    const container = s.container;
    let width;
    let height;
    if (typeof s.width !== 'undefined') {
        width = s.width;
    }
    else {
        width = container.clientWidth;
    }
    if (typeof s.renderedHeight !== 'undefined') {
        height = s.renderedHeight;
    }
    else {
        height = container.clientHeight;
    }
    if (width === 0 && isHorizontal(s) || height === 0 && !isHorizontal(s)) {
        return;
    }
    const containerStyles = plt.getElementComputedStyle(container);
    width = width - parseInt(containerStyles.paddingLeft, 10) - parseInt(containerStyles.paddingRight, 10);
    height = height - parseInt(containerStyles.paddingTop, 10) - parseInt(containerStyles.paddingBottom, 10);
    s.renderedWidth = width;
    s.renderedHeight = height;
    s._renderedSize = isHorizontal(s) ? width : height;
}
function updateSlidesSize(s, plt) {
    s._slides = s._wrapper.querySelectorAll('.' + CLS.slide);
    s._snapGrid = [];
    s._slidesGrid = [];
    s._slidesSizesGrid = [];
    var spaceBetween = s.spaceBetween;
    var slidePosition = -s.slidesOffsetBefore;
    var i;
    var prevSlideSize = 0;
    var index = 0;
    if (typeof s._renderedSize === 'undefined')
        return;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s._renderedSize;
    }
    s._virtualSize = -spaceBetween;
    if (s._rtl) {
        inlineStyle(s._slides, { marginLeft: '', marginTop: '' });
    }
    else {
        inlineStyle(s._slides, { marginRight: '', marginBottom: '' });
    }
    var slidesNumberEvenToRows;
    if (s.slidesPerColumn > 1) {
        if (Math.floor(s._slides.length / s.slidesPerColumn) === s._slides.length / s.slidesPerColumn) {
            slidesNumberEvenToRows = s._slides.length;
        }
        else {
            slidesNumberEvenToRows = Math.ceil(s._slides.length / s.slidesPerColumn) * s.slidesPerColumn;
        }
        if (s.slidesPerView !== 'auto' && s.slidesPerColumnFill === 'row') {
            slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.slidesPerView * s.slidesPerColumn);
        }
    }
    var slideSize;
    var slidesPerColumn = s.slidesPerColumn;
    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    var numFullColumns = slidesPerRow - (s.slidesPerColumn * slidesPerRow - s._slides.length);
    for (i = 0; i < s._slides.length; i++) {
        slideSize = 0;
        var slide = s._slides[i];
        if (s.slidesPerColumn > 1) {
            var newSlideOrderIndex;
            var column;
            var row;
            if (s.slidesPerColumnFill === 'column') {
                column = Math.floor(i / slidesPerColumn);
                row = i - column * slidesPerColumn;
                if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
                    if (++row >= slidesPerColumn) {
                        row = 0;
                        column++;
                    }
                }
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                inlineStyle(slide, {
                    '-webkit-box-ordinal-group': newSlideOrderIndex,
                    '-moz-box-ordinal-group': newSlideOrderIndex,
                    '-ms-flex-order': newSlideOrderIndex,
                    '-webkit-order': newSlideOrderIndex,
                    'order': newSlideOrderIndex
                });
            }
            else {
                row = Math.floor(i / slidesPerRow);
                column = i - row * slidesPerRow;
            }
            var cssVal = (row !== 0 && s.spaceBetween) && (s.spaceBetween + 'px');
            var cssObj = {};
            if (isHorizontal(s)) {
                cssObj['marginTop'] = cssVal;
            }
            else {
                cssObj['marginLeft'] = cssVal;
            }
            inlineStyle(slide, cssObj);
            slide.setAttribute('data-swiper-column', column);
            slide.setAttribute('data-swiper-row', row);
        }
        if (slide.style.display === 'none') {
            continue;
        }
        if (s.slidesPerView === 'auto') {
            var styles = plt.getElementComputedStyle(slide);
            if (isHorizontal(s)) {
                slideSize = slide.offsetWidth + parseFloat(styles.marginRight) + parseFloat(styles.marginLeft);
            }
            else {
                slideSize = slide.offsetHeight + parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
            }
            if (s.roundLengths)
                slideSize = swiper_utils_round(slideSize);
        }
        else {
            slideSize = (s._renderedSize - (s.slidesPerView - 1) * spaceBetween) / s.slidesPerView;
            if (s.roundLengths)
                slideSize = swiper_utils_round(slideSize);
            if (isHorizontal(s)) {
                s._slides[i].style.width = slideSize + 'px';
            }
            else {
                s._slides[i].style.height = slideSize + 'px';
            }
        }
        s._slides[i].swiperSlideSize = slideSize;
        s._slidesSizesGrid.push(slideSize);
        if (s.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (i === 0)
                slidePosition = slidePosition - s._renderedSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1000)
                slidePosition = 0;
            if ((index) % s.slidesPerGroup === 0)
                s._snapGrid.push(slidePosition);
            s._slidesGrid.push(slidePosition);
        }
        else {
            if ((index) % s.slidesPerGroup === 0)
                s._snapGrid.push(slidePosition);
            s._slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
        }
        s._virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index++;
    }
    s._virtualSize = Math.max(s._virtualSize, s._renderedSize) + s.slidesOffsetAfter;
    var newSlidesGrid;
    if (s._rtl && (s.effect === 'slide' || s.effect === 'coverflow')) {
        inlineStyle(s._wrapper, { width: s._virtualSize + s.spaceBetween + 'px' });
    }
    if (s.setWrapperSize) {
        if (isHorizontal(s)) {
            inlineStyle(s._wrapper, { width: s._virtualSize + s.spaceBetween + 'px' });
        }
        else {
            inlineStyle(s._wrapper, { height: s._virtualSize + s.spaceBetween + 'px' });
        }
    }
    if (s.slidesPerColumn > 1) {
        s._virtualSize = (slideSize + s.spaceBetween) * slidesNumberEvenToRows;
        s._virtualSize = Math.ceil(s._virtualSize / s.slidesPerColumn) - s.spaceBetween;
        if (isHorizontal(s)) {
            inlineStyle(s._wrapper, { width: s._virtualSize + s.spaceBetween + 'px' });
        }
        else {
            inlineStyle(s._wrapper, { height: s._virtualSize + s.spaceBetween + 'px' });
        }
        if (s.centeredSlides) {
            newSlidesGrid = [];
            for (i = 0; i < s._snapGrid.length; i++) {
                if (s._snapGrid[i] < s._virtualSize + s._snapGrid[0])
                    newSlidesGrid.push(s._snapGrid[i]);
            }
            s._snapGrid = newSlidesGrid;
        }
    }
    if (!s.centeredSlides) {
        newSlidesGrid = [];
        for (i = 0; i < s._snapGrid.length; i++) {
            if (s._snapGrid[i] <= s._virtualSize - s._renderedSize) {
                newSlidesGrid.push(s._snapGrid[i]);
            }
        }
        s._snapGrid = newSlidesGrid;
        if (Math.floor(s._virtualSize - s._renderedSize) - Math.floor(s._snapGrid[s._snapGrid.length - 1]) > 1) {
            s._snapGrid.push(s._virtualSize - s._renderedSize);
        }
    }
    if (s._snapGrid.length === 0)
        s._snapGrid = [0];
    if (s.spaceBetween !== 0) {
        if (isHorizontal(s)) {
            if (s._rtl) {
                inlineStyle(s._slides, { marginLeft: spaceBetween + 'px' });
            }
            else {
                inlineStyle(s._slides, { marginRight: spaceBetween + 'px' });
            }
        }
        else {
            inlineStyle(s._slides, { marginBottom: spaceBetween + 'px' });
        }
    }
    if (s.watchSlidesProgress) {
        updateSlidesOffset(s);
    }
}
function currentSlidesPerView(s) {
    var spv = 1;
    var i;
    var j;
    if (s.centeredSlides) {
        var size = s._slides[s._activeIndex].swiperSlideSize;
        var breakLoop;
        for (i = s._activeIndex + 1; i < s._slides.length; i++) {
            if (s._slides[i] && !breakLoop) {
                size += s._slides[i].swiperSlideSize;
                spv++;
                if (size > s._renderedSize)
                    breakLoop = true;
            }
        }
        for (j = s._activeIndex - 1; j >= 0; j--) {
            if (s._slides[j] && !breakLoop) {
                size += s._slides[j].swiperSlideSize;
                spv++;
                if (size > s._renderedSize)
                    breakLoop = true;
            }
        }
    }
    else {
        for (i = s._activeIndex + 1; i < s._slides.length; i++) {
            if (s._slidesGrid[i] - s._slidesGrid[s._activeIndex] < s._renderedSize) {
                spv++;
            }
        }
    }
    return spv;
}
function update(s, plt, updateTranslate) {
    if (!s)
        return;
    updateContainerSize(s, plt);
    updateSlidesSize(s, plt);
    updateProgress(s);
    updatePagination(s);
    updateClasses(s);
    if (s.zoom) {
        resetZoomEvents(s, plt);
    }
    var translated;
    var newTranslate;
    function forceSetTranslate() {
        newTranslate = Math.min(Math.max(s._translate, maxTranslate(s)), minTranslate(s));
        swiper_transition_setWrapperTranslate(s, plt, newTranslate);
        updateActiveIndex(s);
        updateClasses(s);
    }
    if (updateTranslate) {
        if (s._spline) {
            s._spline = undefined;
        }
        if (s.freeMode) {
            forceSetTranslate();
            if (s.autoHeight) {
                updateAutoHeight(s);
            }
        }
        else {
            if ((s.slidesPerView === 'auto' || s.slidesPerView > 1) && s._isEnd && !s.centeredSlides) {
                translated = slideTo(s, plt, s._slides.length - 1, 0, false, true);
            }
            else {
                translated = slideTo(s, plt, s._activeIndex, 0, false, true);
            }
            if (!translated) {
                forceSetTranslate();
            }
        }
    }
    else if (s.autoHeight) {
        updateAutoHeight(s);
    }
}
function createLoop(s) {
    eachChild(s._wrapper, '.' + CLS.slide + '.' + CLS.slideDuplicate, ele => {
        ele.parentElement.removeChild(ele);
    });
    var slides = s._wrapper.querySelectorAll('.' + CLS.slide);
    if (s.slidesPerView === 'auto' && !s.loopedSlides) {
        s.loopedSlides = slides.length;
    }
    s.loopedSlides = parseInt((s.loopedSlides || s.slidesPerView), 10);
    s.loopedSlides = s.loopedSlides + s.loopAdditionalSlides;
    if (s.loopedSlides > slides.length) {
        s.loopedSlides = slides.length;
    }
    var prependSlides = [];
    var appendSlides = [];
    for (var i = 0; i < slides.length; i++) {
        var slide = slides[i];
        if (i < s.loopedSlides)
            appendSlides.push(slide);
        if (i < slides.length && i >= slides.length - s.loopedSlides)
            prependSlides.push(slide);
        slide.setAttribute('data-swiper-slide-index', i);
    }
    for (i = 0; i < appendSlides.length; i++) {
        var appendClone = appendSlides[i].cloneNode(true);
        addClass(appendClone, CLS.slideDuplicate);
        s._wrapper.appendChild(appendClone);
    }
    for (i = prependSlides.length - 1; i >= 0; i--) {
        var prependClone = prependSlides[i].cloneNode(true);
        addClass(prependClone, CLS.slideDuplicate);
        s._wrapper.insertBefore(prependClone, s._wrapper.firstElementChild);
    }
}
function destroyLoop(s) {
    eachChild(s._wrapper, '.' + CLS.slide + '.' + CLS.slideDuplicate, ele => {
        ele.parentElement.removeChild(ele);
    });
    if (s._slides) {
        for (var i = 0; i < s._slides.length; i++) {
            s._slides[i].removeAttribute('data-swiper-slide-index');
        }
    }
}
function fixLoop(s, plt) {
    var newIndex;
    if (s._activeIndex < s.loopedSlides) {
        newIndex = s._slides.length - s.loopedSlides * 3 + s._activeIndex;
        newIndex = newIndex + s.loopedSlides;
        slideTo(s, plt, newIndex, 0, false, true);
    }
    else if ((s.slidesPerView === 'auto' && s._activeIndex >= s.loopedSlides * 2) || (s._activeIndex > s._slides.length - s.slidesPerView * 2)) {
        newIndex = -s._slides.length + s._activeIndex + s.loopedSlides;
        newIndex = newIndex + s.loopedSlides;
        slideTo(s, plt, newIndex, 0, false, true);
    }
}
function slideTo(s, plt, slideIndex, speed, runCallbacks = true, internal) {
    if (typeof slideIndex === 'undefined')
        slideIndex = 0;
    if (slideIndex < 0)
        slideIndex = 0;
    s._snapIndex = Math.floor(slideIndex / s.slidesPerGroup);
    if (s._snapIndex >= s._snapGrid.length)
        s._snapIndex = s._snapGrid.length - 1;
    var translate = -s._snapGrid[s._snapIndex];
    if (s.autoplay && s._autoplaying) {
        if (internal || !s.autoplayDisableOnInteraction) {
            pauseAutoplay(s, plt, speed);
        }
        else {
            stopAutoplay(s);
        }
    }
    updateProgress(s, translate);
    if (!s._allowSwipeToNext && translate < s._translate && translate < minTranslate(s)) {
        return false;
    }
    if (!s._allowSwipeToPrev && translate > s._translate && translate > maxTranslate(s)) {
        if ((s._activeIndex || 0) !== slideIndex)
            return false;
    }
    if (typeof speed === 'undefined')
        speed = s.speed;
    s._previousIndex = s._activeIndex || 0;
    s._activeIndex = slideIndex;
    updateRealIndex(s);
    if ((s._rtl && -translate === s._translate) || (!s._rtl && translate === s._translate)) {
        if (s.autoHeight) {
            updateAutoHeight(s);
        }
        updateClasses(s);
        if (s.effect !== 'slide') {
            swiper_transition_setWrapperTranslate(s, plt, translate);
        }
        return false;
    }
    updateClasses(s);
    onTransitionStart(s, runCallbacks);
    if (speed === 0) {
        swiper_transition_setWrapperTranslate(s, plt, translate);
        swiper_transition_setWrapperTransition(s, plt, 0);
        swiper_onTransitionEnd(s, plt, runCallbacks);
    }
    else {
        swiper_transition_setWrapperTranslate(s, plt, translate);
        swiper_transition_setWrapperTransition(s, plt, speed);
        if (!s._animating) {
            s._animating = true;
            plt.transitionEnd(s._wrapper, () => {
                if (!s)
                    return;
                swiper_onTransitionEnd(s, plt, runCallbacks);
            });
        }
    }
    return true;
}
function onTransitionStart(s, runCallbacks = true) {
    if (s.autoHeight) {
        updateAutoHeight(s);
    }
    if (runCallbacks) {
        s._zone.run(() => {
            s.ionSlideTransitionStart.emit(s);
            if (s._activeIndex !== s._previousIndex) {
                s.ionSlideWillChange.emit(s);
                if (s._activeIndex > s._previousIndex) {
                    s.ionSlideNextStart.emit(s);
                }
                else {
                    s.ionSlidePrevStart.emit(s);
                }
            }
        });
    }
}
function swiper_onTransitionEnd(s, plt, runCallbacks = true) {
    s._animating = false;
    swiper_transition_setWrapperTransition(s, plt, 0);
    if (runCallbacks) {
        s._zone.run(() => {
            s.ionSlideTransitionEnd.emit(s);
            if (s._activeIndex !== s._previousIndex) {
                s.ionSlideDidChange.emit(s);
                if (s._activeIndex > s._previousIndex) {
                    s.ionSlideNextEnd.emit(s);
                }
                else {
                    s.ionSlidePrevEnd.emit(s);
                }
            }
        });
    }
}
function slideNext(s, plt, runCallbacks, speed, internal) {
    if (s.loop) {
        if (s._animating)
            return false;
        fixLoop(s, plt);
        s.container.clientLeft;
        return slideTo(s, plt, s._activeIndex + s.slidesPerGroup, speed, runCallbacks, internal);
    }
    var nextSlide = s._activeIndex + s.slidesPerGroup;
    if (nextSlide < s._slides.length) {
        return slideTo(s, plt, nextSlide, speed, runCallbacks, internal);
    }
    return false;
}
function slidePrev(s, plt, runCallbacks, speed, internal) {
    if (s.loop) {
        if (s._animating)
            return false;
        fixLoop(s, plt);
        s.container.clientLeft;
        return slideTo(s, plt, s._activeIndex - 1, speed, runCallbacks, internal);
    }
    var previousSlide = s._activeIndex - 1;
    if (previousSlide >= 0) {
        return slideTo(s, plt, s._activeIndex - 1, speed, runCallbacks, internal);
    }
    return false;
}
function slideReset(s, plt, runCallbacks, speed) {
    return slideTo(s, plt, s._activeIndex, speed, runCallbacks, true);
}
function disableTouchControl(s) {
    s.onlyExternal = true;
    return true;
}
function enableTouchControl(s) {
    s.onlyExternal = false;
    return true;
}
function cleanupStyles(s) {
    if (!s.container || !s._wrapper) {
        return;
    }
    if (s.container) {
        removeClass(s.container, s._classNames);
        s.container.removeAttribute('style');
    }
    s._wrapper.removeAttribute('style');
    if (s._slides && s._slides.length) {
        removeClass(s._slides, [
            CLS.slideVisible,
            CLS.slideActive,
            CLS.slideNext,
            CLS.slidePrev
        ]);
        for (var i = 0; i < s._slides.length; i++) {
            var slide = s._slides[i];
            slide.removeAttribute('style');
            slide.removeAttribute('data-swiper-column');
            slide.removeAttribute('data-swiper-row');
        }
    }
    removeClass(s._bullets, CLS.bulletActive);
    removeClass(s.prevButton, CLS.buttonDisabled);
    removeClass(s.nextButton, CLS.buttonDisabled);
}
function destroySwiper(s) {
    stopAutoplay(s);
    if (s.loop) {
        destroyLoop(s);
    }
    cleanupStyles(s);
}
//# sourceMappingURL=swiper.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-keyboard.ts


function handleKeyboard(s, plt, e) {
    var win = plt.win();
    var kc = e.keyCode || e.charCode;
    if (!s._allowSwipeToNext && (isHorizontal(s) && kc === 39 || !isHorizontal(s) && kc === 40)) {
        return false;
    }
    if (!s._allowSwipeToPrev && (isHorizontal(s) && kc === 37 || !isHorizontal(s) && kc === 38)) {
        return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return;
    }
    var activeEle = plt.getActiveElement();
    if (activeEle && activeEle.nodeName && (activeEle.nodeName.toLowerCase() === 'input' || activeEle.nodeName.toLowerCase() === 'textarea')) {
        return;
    }
    if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
        var inView = false;
        if (s.container.closest('.' + CLS.slide) && !s.container.closest('.' + CLS.slideActive)) {
            return;
        }
        var windowScroll = {
            left: win.pageXOffset,
            top: win.pageYOffset
        };
        var windowWidth = plt.width();
        var windowHeight = plt.height();
        var swiperOffset = swiper_utils_offset(s.container, plt);
        if (s._rtl) {
            swiperOffset.left = swiperOffset.left - s.container.scrollLeft;
        }
        var swiperCoord = [
            [swiperOffset.left, swiperOffset.top],
            [swiperOffset.left + s.renderedWidth, swiperOffset.top],
            [swiperOffset.left, swiperOffset.top + s.renderedHeight],
            [swiperOffset.left + s.renderedWidth, swiperOffset.top + s.renderedHeight]
        ];
        for (var i = 0; i < swiperCoord.length; i++) {
            var point = swiperCoord[i];
            if (point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
                point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight) {
                inView = true;
            }
        }
        if (!inView)
            return;
    }
    if (isHorizontal(s)) {
        if (kc === 37 || kc === 39) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
        }
        if ((kc === 39 && !s._rtl) || (kc === 37 && s._rtl)) {
            slideNext(s, plt);
        }
        if ((kc === 37 && !s._rtl) || (kc === 39 && s._rtl)) {
            slidePrev(s, plt);
        }
    }
    else {
        if (kc === 38 || kc === 40) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
        }
        if (kc === 40) {
            slideNext(s, plt);
        }
        if (kc === 38) {
            slidePrev(s, plt);
        }
    }
}
function enableKeyboardControl(s, plt, shouldEnable) {
    if (shouldEnable && !s._keyboardUnReg) {
        s._keyboardUnReg = plt.registerListener(plt.doc(), 'keydown', (ev) => {
            handleKeyboard(s, plt, ev);
        }, { zone: false });
    }
    else if (!shouldEnable && s._keyboardUnReg) {
        s._keyboardUnReg();
    }
}
//# sourceMappingURL=swiper-keyboard.js.map
// CONCATENATED MODULE: ./src/components/slides/swiper/swiper-events.ts







function initEvents(s, plt) {
    const win = plt.win();
    const doc = plt.doc();
    s._supportTouch = (() => {
        return !!(('ontouchstart' in win) || win.DocumentTouch && doc instanceof win.DocumentTouch);
    })();
    s._touchEventsDesktop = { start: 'mousedown', move: 'mousemove', end: 'mouseup' };
    if (win.navigator.pointerEnabled) {
        s._touchEventsDesktop = { start: 'pointerdown', move: 'pointermove', end: 'pointerup' };
    }
    else if (win.navigator.msPointerEnabled) {
        s._touchEventsDesktop = { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' };
    }
    s._touchEvents = {
        start: s._supportTouch || !s.simulateTouch ? 'touchstart' : s._touchEventsDesktop.start,
        move: s._supportTouch || !s.simulateTouch ? 'touchmove' : s._touchEventsDesktop.move,
        end: s._supportTouch || !s.simulateTouch ? 'touchend' : s._touchEventsDesktop.end
    };
    if (win.navigator.pointerEnabled || win.navigator.msPointerEnabled) {
        (s.touchEventsTarget === 'container' ? s.container : s._wrapper).classList.add('swiper-wp8-' + s.direction);
    }
    let unregs = [];
    const touchEventsTarget = s.touchEventsTarget === 'container' ? s.container : s._wrapper;
    if (s._supportTouch) {
        plt.registerListener(touchEventsTarget, s._touchEvents.start, (ev) => {
            swiper_events_onTouchStart(s, plt, ev);
        }, { passive: true, zone: false }, unregs);
        plt.registerListener(touchEventsTarget, s._touchEvents.move, (ev) => {
            swiper_events_onTouchMove(s, plt, ev);
        }, { zone: false }, unregs);
        plt.registerListener(touchEventsTarget, s._touchEvents.end, (ev) => {
            swiper_events_onTouchEnd(s, plt, ev);
        }, { passive: true, zone: false }, unregs);
    }
    if ((s.simulateTouch && !plt.is('ios') && !plt.is('android')) || (s.simulateTouch && !s._supportTouch && plt.is('ios')) || plt.getQueryParam('ionicPlatform')) {
        plt.registerListener(touchEventsTarget, 'mousedown', (ev) => {
            swiper_events_onTouchStart(s, plt, ev);
        }, { zone: false }, unregs);
        plt.registerListener(plt.doc(), 'mousemove', (ev) => {
            swiper_events_onTouchMove(s, plt, ev);
        }, { zone: false }, unregs);
        plt.registerListener(plt.doc(), 'mouseup', (ev) => {
            swiper_events_onTouchEnd(s, plt, ev);
        }, { zone: false }, unregs);
    }
    let resizeObs = plt.resize.subscribe(() => onResize(s, plt, false));
    if (s.nextButton) {
        plt.registerListener(s.nextButton, 'click', (ev) => {
            onClickNext(s, plt, ev);
        }, { zone: false }, unregs);
    }
    if (s.prevButton) {
        plt.registerListener(s.prevButton, 'click', (ev) => {
            onClickPrev(s, plt, ev);
        }, { zone: false }, unregs);
    }
    if (s.paginationType) {
        plt.registerListener(s._paginationContainer, 'click', (ev) => {
            onClickIndex(s, plt, ev);
        }, { zone: false }, unregs);
    }
    if (s.preventClicks || s.preventClicksPropagation) {
        plt.registerListener(touchEventsTarget, 'click', (ev) => {
            preventClicks(s, ev);
        }, { zone: false, capture: true }, unregs);
    }
    return function () {
        resizeObs.unsubscribe();
        unregs.forEach(unreg => {
            unreg();
        });
        unregs = null;
    };
}
function preventClicks(s, e) {
    if (!s._allowClick) {
        if (s.preventClicks) {
            e.preventDefault();
        }
        if (s.preventClicksPropagation && s._animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }
    }
}
function onClickNext(s, plt, e) {
    e.preventDefault();
    if (s._isEnd && !s.loop) {
        return;
    }
    slideNext(s, plt);
}
function onClickPrev(s, plt, e) {
    e.preventDefault();
    if (s._isBeginning && !s.loop) {
        return;
    }
    slidePrev(s, plt);
}
function onClickIndex(s, plt, e) {
    var indexStr = e.target.getAttribute('data-slide-index');
    if (indexStr) {
        var index = parseInt(indexStr, 10);
        e.preventDefault();
        if (s.loop) {
            index = index + s.loopedSlides;
        }
        slideTo(s, plt, index);
    }
}
function findElementInEvent(e, selector) {
    var el = e.target;
    if (!el.matches(selector)) {
        if (typeof selector === 'string') {
            el = el.closest(selector);
        }
        else if (selector.nodeType) {
            var parentEl = el.parentElement;
            while (parentEl) {
                if (parentEl === selector) {
                    return selector;
                }
            }
            return undefined;
        }
    }
    return el;
}
function updateClickedSlide(s, plt, e) {
    var slide = findElementInEvent(e, '.' + CLS.slide);
    var slideIndex = -1;
    if (slide) {
        for (var i = 0; i < s._slides.length; i++) {
            if (s._slides[i] === slide) {
                slideIndex = i;
                break;
            }
        }
    }
    if (slide && slideIndex > -1) {
        s.clickedSlide = slide;
        s.clickedIndex = slideIndex;
    }
    else {
        s.clickedSlide = undefined;
        s.clickedIndex = undefined;
        return;
    }
    if (s.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s._activeIndex) {
        var slideToIndex = s.clickedIndex;
        var realIndex;
        var slidesPerView = s.slidesPerView === 'auto' ? currentSlidesPerView(s) : s.slidesPerView;
        if (s.loop) {
            if (s._animating)
                return;
            realIndex = parseInt(s.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
            if (s.centeredSlides) {
                if ((slideToIndex < s.loopedSlides - slidesPerView / 2) || (slideToIndex > s._slides.length - s.loopedSlides + slidesPerView / 2)) {
                    fixLoop(s, plt);
                    slideToIndex = getElementIndex(s._wrapper.querySelector('.' + CLS.slide + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + CLS.slideDuplicate + ')'));
                    plt.timeout(() => {
                        slideTo(s, plt, slideToIndex);
                    });
                }
                else {
                    slideTo(s, plt, slideToIndex);
                }
            }
            else {
                if (slideToIndex > s._slides.length - slidesPerView) {
                    fixLoop(s, plt);
                    slideToIndex = getElementIndex(s._wrapper.querySelector('.' + CLS.slide + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + CLS.slideDuplicate + ')'));
                    plt.timeout(() => {
                        slideTo(s, plt, slideToIndex);
                    });
                }
                else {
                    slideTo(s, plt, slideToIndex);
                }
            }
        }
        else {
            slideTo(s, plt, slideToIndex);
        }
    }
}
var isTouched;
var isMoved;
var allowTouchCallbacks;
var touchStartTime;
var isScrolling;
var currentTranslate;
var startTranslate;
var allowThresholdMove;
var lastClickTime = Date.now();
var clickTimeout;
var velocities = [];
var allowMomentumBounce;
var isTouchEvent;
var startMoving;
function swiper_events_onTouchStart(s, plt, ev) {
    console.debug(`ion-slide, onTouchStart: ${ev.type}`);
    if (ev.originalEvent) {
        ev = ev.originalEvent;
    }
    s.originalEvent = ev;
    isTouchEvent = ev.type === 'touchstart';
    if (!isTouchEvent && 'which' in ev && ev.which === 3) {
        return;
    }
    if (s.noSwiping && findElementInEvent(ev, '.' + CLS.noSwiping)) {
        s._allowClick = true;
        return;
    }
    if (s.swipeHandler) {
        if (!findElementInEvent(ev, s.swipeHandler))
            return;
    }
    var startX = s._touches.currentX = ev.type === 'touchstart' ? ev.targetTouches[0].pageX : ev.pageX;
    var startY = s._touches.currentY = ev.type === 'touchstart' ? ev.targetTouches[0].pageY : ev.pageY;
    if (plt.is('ios') && s.iOSEdgeSwipeDetection && startX <= s.iOSEdgeSwipeThreshold) {
        return;
    }
    isTouched = true;
    isMoved = false;
    allowTouchCallbacks = true;
    isScrolling = undefined;
    startMoving = undefined;
    s._touches.startX = startX;
    s._touches.startY = startY;
    touchStartTime = Date.now();
    s._allowClick = true;
    updateContainerSize(s, plt);
    s.swipeDirection = undefined;
    if (s.threshold > 0) {
        allowThresholdMove = false;
    }
    if (ev.type !== 'touchstart') {
        var preventDefault = true;
        if (isFormElement(ev.target)) {
            preventDefault = false;
        }
        plt.focusOutActiveElement();
        if (preventDefault) {
            ev.preventDefault();
        }
    }
    s.ionSlideTouchStart.emit(ev);
}
function swiper_events_onTouchMove(s, plt, ev) {
    console.debug(`ion-slide, onTouchMove: ${ev.type}`);
    if (ev.originalEvent) {
        ev = ev.originalEvent;
    }
    s.originalEvent = ev;
    if (isTouchEvent && ev.type === 'mousemove')
        return;
    if (ev.preventedByNestedSwiper) {
        s._touches.startX = ev.type === 'touchmove' ? ev.targetTouches[0].pageX : ev.pageX;
        s._touches.startY = ev.type === 'touchmove' ? ev.targetTouches[0].pageY : ev.pageY;
        return;
    }
    if (s.onlyExternal) {
        s._allowClick = false;
        if (isTouched) {
            s._touches.startX = s._touches.currentX = ev.type === 'touchmove' ? ev.targetTouches[0].pageX : ev.pageX;
            s._touches.startY = s._touches.currentY = ev.type === 'touchmove' ? ev.targetTouches[0].pageY : ev.pageY;
            touchStartTime = Date.now();
        }
        return;
    }
    if (isTouchEvent && s.touchReleaseOnEdges && !s.loop) {
        if (!isHorizontal(s)) {
            if ((s._touches.currentY < s._touches.startY && s._translate <= maxTranslate(s)) ||
                (s._touches.currentY > s._touches.startY && s._translate >= minTranslate(s))) {
                return;
            }
        }
        else {
            if ((s._touches.currentX < s._touches.startX && s._translate <= maxTranslate(s)) ||
                (s._touches.currentX > s._touches.startX && s._translate >= minTranslate(s))) {
                return;
            }
        }
    }
    const activeEle = plt.getActiveElement();
    if (isTouchEvent && activeEle) {
        if (ev.target === activeEle && isFormElement(ev.target)) {
            isMoved = true;
            s._allowClick = false;
            return;
        }
    }
    if (ev.targetTouches && ev.targetTouches.length > 1)
        return;
    s._touches.currentX = ev.type === 'touchmove' ? ev.targetTouches[0].pageX : ev.pageX;
    s._touches.currentY = ev.type === 'touchmove' ? ev.targetTouches[0].pageY : ev.pageY;
    if (typeof isScrolling === 'undefined') {
        var touchAngle;
        if (isHorizontal(s) && s._touches.currentY === s._touches.startY || !isHorizontal(s) && s._touches.currentX === s._touches.startX) {
            isScrolling = false;
        }
        else {
            touchAngle = Math.atan2(Math.abs(s._touches.currentY - s._touches.startY), Math.abs(s._touches.currentX - s._touches.startX)) * 180 / Math.PI;
            isScrolling = isHorizontal(s) ? touchAngle > s.touchAngle : (90 - touchAngle > s.touchAngle);
        }
    }
    if (!isTouched)
        return;
    if (isScrolling) {
        isTouched = false;
        return;
    }
    s._allowClick = false;
    s.ionSlideDrag.emit(s);
    ev.preventDefault();
    if (s.touchMoveStopPropagation) {
        ev.stopPropagation();
    }
    if (!isMoved) {
        if (s.loop) {
            fixLoop(s, plt);
        }
        startTranslate = getWrapperTranslate(s, plt);
        swiper_transition_setWrapperTransition(s, plt, 0);
        if (s._animating) {
            triggerTransitionEnd(plt, s._wrapper);
        }
        if (s.autoplay && s._autoplaying) {
            if (s.autoplayDisableOnInteraction) {
                stopAutoplay(s);
            }
            else {
                pauseAutoplay(s, plt);
            }
        }
        allowMomentumBounce = false;
    }
    isMoved = true;
    var diff = s._touches.diff = isHorizontal(s) ? s._touches.currentX - s._touches.startX : s._touches.currentY - s._touches.startY;
    diff = diff * s.touchRatio;
    if (s._rtl)
        diff = -diff;
    s.swipeDirection = diff > 0 ? 'prev' : 'next';
    currentTranslate = diff + startTranslate;
    var disableParentSwiper = true;
    if ((diff > 0 && currentTranslate > minTranslate(s))) {
        disableParentSwiper = false;
        if (s.resistance) {
            currentTranslate = minTranslate(s) - 1 + Math.pow(-minTranslate(s) + startTranslate + diff, s.resistanceRatio);
        }
    }
    else if (diff < 0 && currentTranslate < maxTranslate(s)) {
        disableParentSwiper = false;
        if (s.resistance)
            currentTranslate = maxTranslate(s) + 1 - Math.pow(maxTranslate(s) - startTranslate - diff, s.resistanceRatio);
    }
    if (disableParentSwiper) {
        ev.preventedByNestedSwiper = true;
    }
    if (!s._allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
        currentTranslate = startTranslate;
    }
    if (!s._allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
        currentTranslate = startTranslate;
    }
    if (s.threshold > 0) {
        if (Math.abs(diff) > s.threshold || allowThresholdMove) {
            if (!allowThresholdMove) {
                allowThresholdMove = true;
                s._touches.startX = s._touches.currentX;
                s._touches.startY = s._touches.currentY;
                currentTranslate = startTranslate;
                s._touches.diff = isHorizontal(s) ? s._touches.currentX - s._touches.startX : s._touches.currentY - s._touches.startY;
                return;
            }
        }
        else {
            currentTranslate = startTranslate;
            return;
        }
    }
    if (!s.followFinger)
        return;
    if (s.freeMode || s.watchSlidesProgress) {
        updateActiveIndex(s);
    }
    if (s.freeMode) {
        if (velocities.length === 0) {
            velocities.push({
                position: s._touches[isHorizontal(s) ? 'startX' : 'startY'],
                time: touchStartTime
            });
        }
        velocities.push({
            position: s._touches[isHorizontal(s) ? 'currentX' : 'currentY'],
            time: (new Date()).getTime()
        });
    }
    updateProgress(s, currentTranslate);
    swiper_transition_setWrapperTranslate(s, plt, currentTranslate);
}
function swiper_events_onTouchEnd(s, plt, ev) {
    console.debug(`ion-slide, onTouchEnd: ${ev.type}`);
    if (ev.originalEvent) {
        ev = ev.originalEvent;
    }
    s.originalEvent = ev;
    if (allowTouchCallbacks) {
        s.ionSlideTouchEnd.emit(ev);
    }
    allowTouchCallbacks = false;
    if (!isTouched)
        return;
    var touchEndTime = Date.now();
    var timeDiff = touchEndTime - touchStartTime;
    if (s._allowClick) {
        updateClickedSlide(s, plt, ev);
        s._zone.run(() => {
            s.ionSlideTap.emit(s);
            if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
                if (clickTimeout) {
                    plt.cancelTimeout(clickTimeout);
                }
                clickTimeout = plt.timeout(() => {
                    if (!s)
                        return;
                    if (s.paginationHide && s._paginationContainer && !ev.target.classList.contains(CLS.bullet)) {
                        s._paginationContainer.classList.toggle(CLS.paginationHidden);
                    }
                }, 300);
            }
            if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
                if (clickTimeout)
                    clearTimeout(clickTimeout);
                s.ionSlideDoubleTap.emit(s);
            }
        });
    }
    lastClickTime = Date.now();
    plt.timeout(() => {
        if (s) {
            s._allowClick = true;
        }
    });
    if (!isTouched || !isMoved || !s.swipeDirection || s._touches.diff === 0 || currentTranslate === startTranslate) {
        isTouched = isMoved = false;
        return;
    }
    isTouched = isMoved = false;
    var currentPos;
    if (s.followFinger) {
        currentPos = s._rtl ? s._translate : -s._translate;
    }
    else {
        currentPos = -currentTranslate;
    }
    if (s.freeMode) {
        if (currentPos < -minTranslate(s)) {
            slideTo(s, plt, s._activeIndex);
            return;
        }
        else if (currentPos > -maxTranslate(s)) {
            if (s._slides.length < s._snapGrid.length) {
                slideTo(s, plt, s._snapGrid.length - 1);
            }
            else {
                slideTo(s, plt, s._slides.length - 1);
            }
            return;
        }
        if (s.freeModeMomentum) {
            if (velocities.length > 1) {
                var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop();
                var distance = lastMoveEvent.position - velocityEvent.position;
                var time = lastMoveEvent.time - velocityEvent.time;
                s.velocity = distance / time;
                s.velocity = s.velocity / 2;
                if (Math.abs(s.velocity) < s.freeModeMinimumVelocity) {
                    s.velocity = 0;
                }
                if (time > 150 || (new Date().getTime() - lastMoveEvent.time) > 300) {
                    s.velocity = 0;
                }
            }
            else {
                s.velocity = 0;
            }
            s.velocity = s.velocity * s.freeModeMomentumVelocityRatio;
            velocities.length = 0;
            var momentumDuration = 1000 * s.freeModeMomentumRatio;
            var momentumDistance = s.velocity * momentumDuration;
            var newPosition = s._translate + momentumDistance;
            if (s._rtl)
                newPosition = -newPosition;
            var doBounce = false;
            var afterBouncePosition;
            var bounceAmount = Math.abs(s.velocity) * 20 * s.freeModeMomentumBounceRatio;
            if (newPosition < maxTranslate(s)) {
                if (s.freeModeMomentumBounce) {
                    if (newPosition + maxTranslate(s) < -bounceAmount) {
                        newPosition = maxTranslate(s) - bounceAmount;
                    }
                    afterBouncePosition = maxTranslate(s);
                    doBounce = true;
                    allowMomentumBounce = true;
                }
                else {
                    newPosition = maxTranslate(s);
                }
            }
            else if (newPosition > minTranslate(s)) {
                if (s.freeModeMomentumBounce) {
                    if (newPosition - minTranslate(s) > bounceAmount) {
                        newPosition = minTranslate(s) + bounceAmount;
                    }
                    afterBouncePosition = minTranslate(s);
                    doBounce = true;
                    allowMomentumBounce = true;
                }
                else {
                    newPosition = minTranslate(s);
                }
            }
            else if (s.freeModeSticky) {
                var j = 0;
                var nextSlide;
                for (j = 0; j < s._snapGrid.length; j += 1) {
                    if (s._snapGrid[j] > -newPosition) {
                        nextSlide = j;
                        break;
                    }
                }
                if (Math.abs(s._snapGrid[nextSlide] - newPosition) < Math.abs(s._snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                    newPosition = s._snapGrid[nextSlide];
                }
                else {
                    newPosition = s._snapGrid[nextSlide - 1];
                }
                if (!s._rtl)
                    newPosition = -newPosition;
            }
            if (s.velocity !== 0) {
                if (s._rtl) {
                    momentumDuration = Math.abs((-newPosition - s._translate) / s.velocity);
                }
                else {
                    momentumDuration = Math.abs((newPosition - s._translate) / s.velocity);
                }
            }
            else if (s.freeModeSticky) {
                slideReset(s, plt);
                return;
            }
            if (s.freeModeMomentumBounce && doBounce) {
                updateProgress(s, afterBouncePosition);
                swiper_transition_setWrapperTransition(s, plt, momentumDuration);
                swiper_transition_setWrapperTranslate(s, plt, newPosition);
                onTransitionStart(s);
                s._animating = true;
                plt.transitionEnd(s._wrapper, () => {
                    if (!s || !allowMomentumBounce)
                        return;
                    swiper_transition_setWrapperTransition(s, plt, s.speed);
                    swiper_transition_setWrapperTranslate(s, plt, afterBouncePosition);
                    plt.transitionEnd(s._wrapper, () => {
                        if (!s)
                            return;
                        swiper_onTransitionEnd(s, plt);
                    });
                });
            }
            else if (s.velocity) {
                updateProgress(s, newPosition);
                swiper_transition_setWrapperTransition(s, plt, momentumDuration);
                swiper_transition_setWrapperTranslate(s, plt, newPosition);
                onTransitionStart(s);
                if (!s._animating) {
                    s._animating = true;
                    plt.transitionEnd(s._wrapper, () => {
                        if (!s)
                            return;
                        swiper_onTransitionEnd(s, plt);
                    });
                }
            }
            else {
                updateProgress(s, newPosition);
            }
            updateActiveIndex(s);
        }
        if (!s.freeModeMomentum || timeDiff >= s.longSwipesMs) {
            updateProgress(s);
            updateActiveIndex(s);
        }
        return;
    }
    var stopIndex = 0;
    var groupSize = s._slidesSizesGrid[0];
    for (var i = 0; i < s._slidesGrid.length; i += s.slidesPerGroup) {
        if (typeof s._slidesGrid[i + s.slidesPerGroup] !== 'undefined') {
            if (currentPos >= s._slidesGrid[i] && currentPos < s._slidesGrid[i + s.slidesPerGroup]) {
                stopIndex = i;
                groupSize = s._slidesGrid[i + s.slidesPerGroup] - s._slidesGrid[i];
            }
        }
        else {
            if (currentPos >= s._slidesGrid[i]) {
                stopIndex = i;
                groupSize = s._slidesGrid[s._slidesGrid.length - 1] - s._slidesGrid[s._slidesGrid.length - 2];
            }
        }
    }
    var ratio = (currentPos - s._slidesGrid[stopIndex]) / groupSize;
    if (timeDiff > s.longSwipesMs) {
        if (!s.longSwipes) {
            slideTo(s, plt, s._activeIndex);
            return;
        }
        if (s.swipeDirection === 'next') {
            if (ratio >= s.longSwipesRatio) {
                slideTo(s, plt, stopIndex + s.slidesPerGroup);
            }
            else {
                slideTo(s, plt, stopIndex);
            }
        }
        if (s.swipeDirection === 'prev') {
            if (ratio > (1 - s.longSwipesRatio)) {
                slideTo(s, plt, stopIndex + s.slidesPerGroup);
            }
            else {
                slideTo(s, plt, stopIndex);
            }
        }
    }
    else {
        if (!s.shortSwipes) {
            slideTo(s, plt, s._activeIndex);
            return;
        }
        if (s.swipeDirection === 'next') {
            slideTo(s, plt, stopIndex + s.slidesPerGroup);
        }
        if (s.swipeDirection === 'prev') {
            slideTo(s, plt, stopIndex);
        }
    }
}
let resizeId;
function onResize(s, plt, forceUpdatePagination) {
    if (resizeId) {
        plt.cancelTimeout(resizeId);
        resizeId = null;
    }
    resizeId = plt.timeout(() => doResize(s, plt, forceUpdatePagination), 200);
}
function doResize(s, plt, forceUpdatePagination) {
    resizeId = null;
    var allowSwipeToPrev = s._allowSwipeToPrev;
    var allowSwipeToNext = s._allowSwipeToNext;
    s._allowSwipeToPrev = s._allowSwipeToNext = true;
    updateContainerSize(s, plt);
    updateSlidesSize(s, plt);
    if (s.slidesPerView === 'auto' || s.freeMode || forceUpdatePagination) {
        updatePagination(s);
    }
    if (s._spline) {
        s._spline = undefined;
    }
    var slideChangedBySlideTo = false;
    if (s.freeMode) {
        var newTranslate = Math.min(Math.max(s._translate, maxTranslate(s)), minTranslate(s));
        swiper_transition_setWrapperTranslate(s, plt, newTranslate);
        updateActiveIndex(s);
        updateClasses(s);
        if (s.autoHeight) {
            updateAutoHeight(s);
        }
    }
    else {
        updateClasses(s);
        if ((s.slidesPerView === 'auto' || s.slidesPerView > 1) && s._isEnd && !s.centeredSlides) {
            slideChangedBySlideTo = slideTo(s, plt, s._slides.length - 1, 0, false, true);
        }
        else {
            slideChangedBySlideTo = slideTo(s, plt, s._activeIndex, 0, false, true);
        }
    }
    s._allowSwipeToPrev = allowSwipeToPrev;
    s._allowSwipeToNext = allowSwipeToNext;
}
//# sourceMappingURL=swiper-events.js.map
// CONCATENATED MODULE: ./src/components/slides/slides.ts














let slides_Slides = Slides_1 = class Slides extends Ion {
    constructor(config, _plt, zone, viewCtrl, elementRef, renderer) {
        super(config, elementRef, renderer, 'slides');
        this._plt = _plt;
        this._control = null;
        this._effectName = 'slide';
        this._direction = 'horizontal';
        this._initialSlide = 0;
        this._isLoop = false;
        this._pager = false;
        this._paginationType = 'bullets';
        this.paginationBulletRender = null;
        this._isParallax = false;
        this._speedMs = 300;
        this._isZoom = false;
        this.virtualTranslate = false;
        this.roundLengths = false;
        this._spaceBetween = 0;
        this._slidesPerView = 1;
        this._centeredSlides = false;
        this.slidesPerColumn = 1;
        this.slidesPerColumnFill = 'column';
        this.slidesPerGroup = 1;
        this.slidesOffsetBefore = 0;
        this.slidesOffsetAfter = 0;
        this.autoplayDisableOnInteraction = true;
        this.autoplayStopOnLast = false;
        this.freeMode = false;
        this.freeModeMomentum = true;
        this.freeModeMomentumRatio = 1;
        this.freeModeMomentumBounce = true;
        this.freeModeMomentumBounceRatio = 1;
        this.freeModeMomentumVelocityRatio = 1;
        this.freeModeSticky = false;
        this.freeModeMinimumVelocity = 0.02;
        this.autoHeight = false;
        this.setWrapperSize = false;
        this.zoomMax = 3;
        this.zoomMin = 1;
        this.zoomToggle = true;
        this.touchRatio = 1;
        this.touchAngle = 45;
        this.simulateTouch = true;
        this.shortSwipes = true;
        this.longSwipes = true;
        this.longSwipesRatio = 0.5;
        this.longSwipesMs = 300;
        this.followFinger = true;
        this.onlyExternal = false;
        this.threshold = 0;
        this.touchMoveStopPropagation = true;
        this.touchReleaseOnEdges = false;
        this.iOSEdgeSwipeDetection = false;
        this.iOSEdgeSwipeThreshold = 20;
        this.paginationClickable = false;
        this.paginationHide = false;
        this.resistance = true;
        this.resistanceRatio = 0.85;
        this.watchSlidesProgress = false;
        this.watchSlidesVisibility = false;
        this.preventClicks = true;
        this.preventClicksPropagation = true;
        this.slideToClickedSlide = false;
        this.loopAdditionalSlides = 0;
        this.loopedSlides = null;
        this.swipeHandler = null;
        this.noSwiping = true;
        this.runCallbacksOnInit = true;
        this.controlBy = 'slide';
        this.controlInverse = false;
        this.keyboardControl = true;
        this.coverflow = {
            rotate: 50,
            stretch: 0,
            depth: 100,
            modifier: 1,
            slideShadows: true
        };
        this.flip = {
            slideShadows: true,
            limitRotation: true
        };
        this.cube = {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94
        };
        this.fade = {
            crossFade: false
        };
        this.prevSlideMessage = 'Previous slide';
        this.nextSlideMessage = 'Next slide';
        this.firstSlideMessage = 'This is the first slide';
        this.lastSlideMessage = 'This is the last slide';
        this.ionSlideWillChange = new core_es5["r" /* EventEmitter */]();
        this.ionSlideDidChange = new core_es5["r" /* EventEmitter */]();
        this.ionSlideDrag = new core_es5["r" /* EventEmitter */]();
        this.ionSlideReachStart = new core_es5["r" /* EventEmitter */]();
        this.ionSlideReachEnd = new core_es5["r" /* EventEmitter */]();
        this.ionSlideAutoplay = new core_es5["r" /* EventEmitter */]();
        this.ionSlideAutoplayStart = new core_es5["r" /* EventEmitter */]();
        this.ionSlideAutoplayStop = new core_es5["r" /* EventEmitter */]();
        this.ionSlideNextStart = new core_es5["r" /* EventEmitter */]();
        this.ionSlidePrevStart = new core_es5["r" /* EventEmitter */]();
        this.ionSlideNextEnd = new core_es5["r" /* EventEmitter */]();
        this.ionSlidePrevEnd = new core_es5["r" /* EventEmitter */]();
        this.ionSlideTap = new core_es5["r" /* EventEmitter */]();
        this.ionSlideDoubleTap = new core_es5["r" /* EventEmitter */]();
        this.ionSlideProgress = new core_es5["r" /* EventEmitter */]();
        this.ionSlideTransitionStart = new core_es5["r" /* EventEmitter */]();
        this.ionSlideTransitionEnd = new core_es5["r" /* EventEmitter */]();
        this.ionSlideTouchStart = new core_es5["r" /* EventEmitter */]();
        this.ionSlideTouchEnd = new core_es5["r" /* EventEmitter */]();
        this._unregs = [];
        this._allowSwipeToNext = true;
        this._allowSwipeToPrev = true;
        this._zone = zone;
        this.id = ++slidesId;
        this.slideId = 'slides-' + this.id;
        this.setElementClass(this.slideId, true);
        if (viewCtrl) {
            var subscription = viewCtrl.readReady.subscribe(() => {
                subscription.unsubscribe();
                this._initSlides();
            });
        }
    }
    get autoplay() {
        return this._autoplayMs;
    }
    set autoplay(val) {
        this._autoplayMs = parseInt(val, 10);
    }
    get control() {
        return this._control;
    }
    set control(val) {
        if (val instanceof Slides_1 || Array.isArray(val)) {
            this._control = val;
        }
    }
    get effect() {
        return this._effectName;
    }
    set effect(effectName) {
        if (SWIPER_EFFECTS[effectName]) {
            this._effectName = effectName;
        }
    }
    get direction() {
        return this._direction;
    }
    set direction(val) {
        if (val === 'horizontal' || val === 'vertical') {
            this._direction = val;
        }
    }
    get initialSlide() {
        return this._initialSlide;
    }
    set initialSlide(val) {
        this._initialSlide = parseInt(val, 10);
    }
    get loop() {
        return this._isLoop;
    }
    set loop(val) {
        this._isLoop = isTrueProperty(val);
    }
    get pager() {
        return this._pager;
    }
    set pager(val) {
        this._pager = isTrueProperty(val);
    }
    set dir(val) {
        this._rtl = (val.toLowerCase() === 'rtl');
    }
    get paginationType() {
        return this._paginationType;
    }
    set paginationType(val) {
        if (val === 'bullets' || val === 'fraction' || val === 'progress') {
            this._paginationType = val;
        }
    }
    get parallax() {
        return this._isParallax;
    }
    set parallax(val) {
        this._isParallax = isTrueProperty(val);
    }
    get speed() {
        return this._speedMs;
    }
    set speed(val) {
        this._speedMs = parseInt(val, 10);
    }
    get zoom() {
        return this._isZoom;
    }
    set zoom(val) {
        this._isZoom = isTrueProperty(val);
    }
    get spaceBetween() {
        return this._spaceBetween;
    }
    set spaceBetween(val) {
        this._spaceBetween = parseInt(val, 10);
    }
    get slidesPerView() {
        return this._slidesPerView;
    }
    set slidesPerView(val) {
        this._slidesPerView = val === 'auto' ? 'auto' : parseFloat(val);
    }
    get centeredSlides() {
        return this._centeredSlides;
    }
    set centeredSlides(val) {
        this._centeredSlides = isTrueProperty(val);
    }
    _initSlides() {
        if (!this._init) {
            console.debug(`ion-slides, init`);
            var s = this;
            var plt = s._plt;
            s.container = this.getNativeElement().children[0];
            initSwiper(s, plt);
            this._unregs.push(initEvents(s, plt));
            if (this.zoom) {
                this._unregs.push(initZoom(s, plt));
            }
            if (this.keyboardControl) {
                s.enableKeyboardControl(true);
            }
            this._init = true;
        }
    }
    ngAfterContentInit() {
        this._plt.timeout(() => {
            this._initSlides();
        }, 300);
    }
    update(debounce = 300) {
        if (this._init) {
            this._plt.cancelTimeout(this._tmr);
            this._tmr = this._plt.timeout(() => {
                update(this, this._plt);
                if (this.length() > 10) {
                    this.paginationType = undefined;
                }
            }, debounce);
        }
    }
    resize() {
        if (this._init) {
        }
    }
    slideTo(index, speed, runCallbacks) {
        slideTo(this, this._plt, index, speed, runCallbacks);
    }
    slideNext(speed, runCallbacks) {
        slideNext(this, this._plt, runCallbacks, speed, true);
    }
    slidePrev(speed, runCallbacks) {
        slidePrev(this, this._plt, runCallbacks, speed, true);
    }
    getActiveIndex() {
        return this._activeIndex;
    }
    getPreviousIndex() {
        return this._previousIndex;
    }
    length() {
        return this._slides.length;
    }
    isEnd() {
        return this._isEnd;
    }
    isBeginning() {
        return this._isBeginning;
    }
    startAutoplay() {
        startAutoplay(this, this._plt);
    }
    stopAutoplay() {
        stopAutoplay(this);
    }
    lockSwipeToNext(shouldLockSwipeToNext) {
        this._allowSwipeToNext = !shouldLockSwipeToNext;
    }
    lockSwipeToPrev(shouldLockSwipeToPrev) {
        this._allowSwipeToPrev = !shouldLockSwipeToPrev;
    }
    lockSwipes(shouldLockSwipes) {
        this._allowSwipeToNext = this._allowSwipeToPrev = !shouldLockSwipes;
    }
    enableKeyboardControl(shouldEnableKeyboard) {
        enableKeyboardControl(this, this._plt, shouldEnableKeyboard);
    }
    ngOnDestroy() {
        this._init = false;
        this._unregs.forEach(unReg => {
            unReg();
        });
        this._unregs.length = 0;
        destroySwiper(this);
        this.enableKeyboardControl(false);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], slides_Slides.prototype, "autoplay", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], slides_Slides.prototype, "control", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], slides_Slides.prototype, "effect", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], slides_Slides.prototype, "direction", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], slides_Slides.prototype, "initialSlide", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], slides_Slides.prototype, "loop", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], slides_Slides.prototype, "pager", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], slides_Slides.prototype, "dir", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], slides_Slides.prototype, "paginationType", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], slides_Slides.prototype, "parallax", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], slides_Slides.prototype, "speed", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], slides_Slides.prototype, "zoom", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], slides_Slides.prototype, "spaceBetween", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], slides_Slides.prototype, "slidesPerView", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], slides_Slides.prototype, "centeredSlides", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__a || Object)
], slides_Slides.prototype, "ionSlideWillChange", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__b || Object)
], slides_Slides.prototype, "ionSlideDidChange", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__c = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__c || Object)
], slides_Slides.prototype, "ionSlideDrag", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__d = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__d || Object)
], slides_Slides.prototype, "ionSlideReachStart", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__e = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__e || Object)
], slides_Slides.prototype, "ionSlideReachEnd", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__f = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__f || Object)
], slides_Slides.prototype, "ionSlideAutoplay", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__g = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__g || Object)
], slides_Slides.prototype, "ionSlideAutoplayStart", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__h = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__h || Object)
], slides_Slides.prototype, "ionSlideAutoplayStop", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__j = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__j || Object)
], slides_Slides.prototype, "ionSlideNextStart", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__k = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__k || Object)
], slides_Slides.prototype, "ionSlidePrevStart", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__l = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__l || Object)
], slides_Slides.prototype, "ionSlideNextEnd", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__m = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__m || Object)
], slides_Slides.prototype, "ionSlidePrevEnd", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__o = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__o || Object)
], slides_Slides.prototype, "ionSlideTap", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (slides__p = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && slides__p || Object)
], slides_Slides.prototype, "ionSlideDoubleTap", void 0);
slides_Slides = Slides_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-slides',
        template: '<div class="swiper-container" [attr.dir]="_rtl? \'rtl\' : null">' +
            '<div class="swiper-wrapper">' +
            '<ng-content></ng-content>' +
            '</div>' +
            '<div [class.hide]="!pager" class="swiper-pagination"></div>' +
            '</div>',
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (slides__q = typeof config_Config !== "undefined" && config_Config) === "function" && slides__q || Object, typeof (slides__r = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && slides__r || Object, typeof (slides__s = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && slides__s || Object, typeof (_t = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && _t || Object, typeof (_u = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && _u || Object, typeof (slides__v = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && slides__v || Object])
], slides_Slides);

let slidesId = -1;
var Slides_1, slides__a, slides__b, slides__c, slides__d, slides__e, slides__f, slides__g, slides__h, slides__j, slides__k, slides__l, slides__m, slides__o, slides__p, slides__q, slides__r, slides__s, _t, _u, slides__v;




// CONCATENATED MODULE: ./src/components/slides/slide.ts




let Slide = class Slide {
    constructor(elementRef, renderer, _slides) {
        this._slides = _slides;
        renderer.setElementClass(elementRef.nativeElement, 'swiper-slide', true);
        _slides.update(10);
    }
    ngOnDestroy() {
        this._slides.update(10);
    }
};
Slide = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-slide',
        template: '<div class="slide-zoom">' +
            '<ng-content></ng-content>' +
            '</div>',
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (slide__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && slide__a || Object, typeof (slide__b = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && slide__b || Object, typeof (slide__c = typeof slides_Slides !== "undefined" && slides_Slides) === "function" && slide__c || Object])
], Slide);

var slide__a, slide__b, slide__c;




// CONCATENATED MODULE: ./src/components/spinner/spinner.ts






let spinner_Spinner = class Spinner extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'spinner');
        this._dur = null;
        this._paused = false;
    }
    get name() {
        return this._name;
    }
    set name(val) {
        this._name = val;
        this.load();
    }
    get duration() {
        return this._dur;
    }
    set duration(val) {
        this._dur = val;
        this.load();
    }
    get paused() {
        return this._paused;
    }
    set paused(val) {
        this._paused = isTrueProperty(val);
    }
    ngOnInit() {
        this._init = true;
        this.load();
    }
    load() {
        if (this._init) {
            this._l = [];
            this._c = [];
            var name = this._name || this._config.get('spinner', 'ios');
            const spinner = SPINNERS[name];
            if (spinner) {
                if (spinner.lines) {
                    for (let i = 0, l = spinner.lines; i < l; i++) {
                        this._l.push(this._loadEle(spinner, i, l));
                    }
                }
                else if (spinner.circles) {
                    for (let i = 0, l = spinner.circles; i < l; i++) {
                        this._c.push(this._loadEle(spinner, i, l));
                    }
                }
                this.setElementClass(`spinner-${name}`, true);
                this.setElementClass(`spinner-${this._mode}-${name}`, true);
            }
        }
    }
    _loadEle(spinner, index, total) {
        let duration = this._dur || spinner.dur;
        let data = spinner.fn(duration, index, total);
        data.style.animationDuration = duration + 'ms';
        return data;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String),
    Object(tslib_es6["__metadata"])("design:paramtypes", [String])
], spinner_Spinner.prototype, "name", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Number])
], spinner_Spinner.prototype, "duration", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], spinner_Spinner.prototype, "paused", null);
spinner_Spinner = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-spinner',
        template: '<svg viewBox="0 0 64 64" *ngFor="let i of _c" [ngStyle]="i.style">' +
            '<circle [attr.r]="i.r" transform="translate(32,32)"></circle>' +
            '</svg>' +
            '<svg viewBox="0 0 64 64" *ngFor="let i of _l" [ngStyle]="i.style">' +
            '<line [attr.y1]="i.y1" [attr.y2]="i.y2" transform="translate(32,32)"></line>' +
            '</svg>',
        host: {
            '[class.spinner-paused]': '_paused'
        },
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (spinner__a = typeof config_Config !== "undefined" && config_Config) === "function" && spinner__a || Object, typeof (spinner__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && spinner__b || Object, typeof (spinner__d = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && spinner__d || Object])
], spinner_Spinner);

const SPINNERS = {
    ios: {
        dur: 1000,
        lines: 12,
        fn: function (dur, index, total) {
            const transform = 'rotate(' + (30 * index + (index < 6 ? 180 : -180)) + 'deg)';
            const animationDelay = -(dur - ((dur / total) * index)) + 'ms';
            return {
                y1: 17,
                y2: 29,
                style: {
                    transform: transform,
                    webkitTransform: transform,
                    animationDelay: animationDelay,
                    webkitAnimationDelay: animationDelay
                }
            };
        }
    },
    'ios-small': {
        dur: 1000,
        lines: 12,
        fn: function (dur, index, total) {
            const transform = 'rotate(' + (30 * index + (index < 6 ? 180 : -180)) + 'deg)';
            const animationDelay = -(dur - ((dur / total) * index)) + 'ms';
            return {
                y1: 12,
                y2: 20,
                style: {
                    transform: transform,
                    webkitTransform: transform,
                    animationDelay: animationDelay,
                    webkitAnimationDelay: animationDelay
                }
            };
        }
    },
    bubbles: {
        dur: 1000,
        circles: 9,
        fn: function (dur, index, total) {
            const animationDelay = -(dur - ((dur / total) * index)) + 'ms';
            return {
                r: 5,
                style: {
                    top: (9 * Math.sin(2 * Math.PI * index / total)) + 'px',
                    left: (9 * Math.cos(2 * Math.PI * index / total)) + 'px',
                    animationDelay: animationDelay,
                    webkitAnimationDelay: animationDelay
                }
            };
        }
    },
    circles: {
        dur: 1000,
        circles: 8,
        fn: function (dur, index, total) {
            const animationDelay = -(dur - ((dur / total) * index)) + 'ms';
            return {
                r: 5,
                style: {
                    top: (9 * Math.sin(2 * Math.PI * index / total)) + 'px',
                    left: (9 * Math.cos(2 * Math.PI * index / total)) + 'px',
                    animationDelay: animationDelay,
                    webkitAnimationDelay: animationDelay
                }
            };
        }
    },
    crescent: {
        dur: 750,
        circles: 1,
        fn: function () {
            return {
                r: 26,
                style: {}
            };
        }
    },
    dots: {
        dur: 750,
        circles: 3,
        fn: function (_dur, index) {
            const animationDelay = -(110 * index) + 'ms';
            return {
                r: 6,
                style: {
                    left: (9 - (9 * index)) + 'px',
                    animationDelay: animationDelay,
                    webkitAnimationDelay: animationDelay
                }
            };
        }
    }
};
var spinner__a, spinner__b, spinner__d;




// CONCATENATED MODULE: ./src/components/tabs/tab-highlight.ts




let TabHighlight = class TabHighlight {
    constructor(_elementRef, _dom) {
        this._elementRef = _elementRef;
        this._dom = _dom;
    }
    select(tab) {
        if (!tab) {
            return;
        }
        const dom = this._dom;
        dom.read(() => {
            const btnEle = tab.btn.getNativeElement();
            const transform = `translate3d(${btnEle.offsetLeft}px,0,0) scaleX(${btnEle.offsetWidth})`;
            dom.write(() => {
                const ele = this._elementRef.nativeElement;
                ele.style[dom.plt.Css.transform] = transform;
                if (!this._init) {
                    this._init = true;
                    dom.write(() => {
                        ele.classList.add('animate');
                    }, 80);
                }
            });
        }, 32);
    }
};
TabHighlight = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '.tab-highlight'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (tab_highlight__a = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && tab_highlight__a || Object, typeof (tab_highlight__b = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && tab_highlight__b || Object])
], TabHighlight);

var tab_highlight__a, tab_highlight__b;




// CONCATENATED MODULE: ./src/components/tabs/tabs.ts



















let tabs_Tabs = Tabs_1 = class Tabs extends Ion {
    constructor(parent, viewCtrl, _app, config, elementRef, _plt, renderer, _linker, keyboard) {
        super(config, elementRef, renderer, 'tabs');
        this.viewCtrl = viewCtrl;
        this._app = _app;
        this._plt = _plt;
        this._linker = _linker;
        this._ids = -1;
        this._tabs = [];
        this._selectHistory = [];
        this._onDestroy = new Subject["Subject"]();
        this.ionChange = new core_es5["r" /* EventEmitter */]();
        this.parent = parent;
        this.id = 't' + (++tabIds);
        this._sbPadding = config.getBoolean('statusbarPadding');
        this.tabsHighlight = config.getBoolean('tabsHighlight');
        if (this.parent) {
            this.parent.registerChildNav(this);
        }
        else if (viewCtrl && viewCtrl.getNav()) {
            this.parent = viewCtrl.getNav();
            this.parent.registerChildNav(this);
        }
        else if (this._app) {
            this._app.registerRootNav(this);
        }
        if (viewCtrl) {
            viewCtrl._setContent(this);
            viewCtrl._setContentRef(elementRef);
        }
        const keyboardResizes = config.getBoolean('keyboardResizes', false);
        if (keyboard && keyboardResizes) {
            keyboard.willHide
                .takeUntil(this._onDestroy)
                .subscribe(() => {
                this._plt.timeout(() => this.setTabbarHidden(false), 50);
            });
            keyboard.willShow
                .takeUntil(this._onDestroy)
                .subscribe(() => this.setTabbarHidden(true));
        }
    }
    setTabbarHidden(tabbarHidden) {
        this.setElementClass('tabbar-hidden', tabbarHidden);
        this.resize();
    }
    ngOnDestroy() {
        this._onDestroy.next();
        this.parent.unregisterChildNav(this);
    }
    ngAfterViewInit() {
        this._setConfig('tabsPlacement', 'bottom');
        this._setConfig('tabsLayout', 'icon-top');
        this._setConfig('tabsHighlight', this.tabsHighlight);
        if (this.tabsHighlight) {
            this._plt.resize
                .takeUntil(this._onDestroy)
                .subscribe(() => this._highlight.select(this.getSelected()));
        }
        this.initTabs();
    }
    initTabs() {
        let selectedIndex = (isBlank(this.selectedIndex) ? 0 : parseInt(this.selectedIndex, 10));
        const tabsSegment = this._linker.getSegmentByNavIdOrName(this.id, this.name);
        if (tabsSegment) {
            selectedIndex = this._getSelectedTabIndex(tabsSegment.secondaryId, selectedIndex);
        }
        let selectedTab = this._tabs.find((t, i) => i === selectedIndex && t.enabled && t.show);
        if (!selectedTab) {
            selectedTab = this._tabs.find(t => t.enabled && t.show);
        }
        if (selectedTab) {
            if (tabsSegment) {
                selectedTab._lazyRootFromUrl = tabsSegment.name;
                selectedTab._lazyRootFromUrlData = tabsSegment.data;
            }
            this.select(selectedTab);
        }
        this._tabs.forEach(t => {
            t.updateHref(t.root, t.rootParams);
        });
    }
    _setConfig(attrKey, fallback) {
        let val = this[attrKey];
        if (isBlank(val)) {
            val = this._config.get(attrKey, fallback);
        }
        this.setElementAttribute(attrKey, val);
    }
    add(tab) {
        this._tabs.push(tab);
        return this.id + '-' + (++this._ids);
    }
    select(tabOrIndex, opts = {}, fromUrl = false) {
        const selectedTab = (typeof tabOrIndex === 'number' ? this.getByIndex(tabOrIndex) : tabOrIndex);
        if (isBlank(selectedTab)) {
            return;
        }
        const currentTab = this.getSelected();
        if (selectedTab === currentTab && currentTab.getActive()) {
            return this._updateCurrentTab(selectedTab, fromUrl);
        }
        if (selectedTab.root) {
            var currentPage;
            if (currentTab) {
                currentPage = currentTab.getActive();
                currentPage && currentPage._willLeave(false);
            }
            const selectedPage = selectedTab.getActive();
            selectedPage && selectedPage._willEnter();
            opts.animate = false;
            selectedTab.load(opts, () => {
                this._tabSwitchEnd(selectedTab, selectedPage, currentPage);
                if (opts.updateUrl !== false) {
                    this._linker.navChange(DIRECTION_SWITCH);
                }
                _assert(this.getSelected() === selectedTab, 'selected tab does not match');
                this._fireChangeEvent(selectedTab);
            });
        }
        else {
            this._fireChangeEvent(selectedTab);
        }
    }
    _fireChangeEvent(selectedTab) {
        selectedTab.ionSelect.emit(selectedTab);
        this.ionChange.emit(selectedTab);
    }
    _tabSwitchEnd(selectedTab, selectedPage, currentPage) {
        _assert(selectedTab, 'selectedTab must be valid');
        _assert(this._tabs.indexOf(selectedTab) >= 0, 'selectedTab must be one of the tabs');
        const tabs = this._tabs;
        let tab;
        for (var i = 0; i < tabs.length; i++) {
            tab = tabs[i];
            tab.setSelected(tab === selectedTab);
        }
        if (this.tabsHighlight) {
            this._highlight.select(selectedTab);
        }
        selectedPage && selectedPage._didEnter();
        currentPage && currentPage._didLeave();
        if (this._selectHistory[this._selectHistory.length - 1] !== selectedTab.id) {
            this._selectHistory.push(selectedTab.id);
        }
    }
    previousTab(trimHistory = true) {
        console.debug('run previousTab', this._selectHistory);
        for (var i = this._selectHistory.length - 2; i >= 0; i--) {
            var tab = this._tabs.find(t => t.id === this._selectHistory[i]);
            if (tab && tab.enabled && tab.show) {
                if (trimHistory) {
                    this._selectHistory.splice(i + 1);
                }
                return tab;
            }
        }
        return null;
    }
    getByIndex(index) {
        return this._tabs[index];
    }
    getSelected() {
        const tabs = this._tabs;
        for (var i = 0; i < tabs.length; i++) {
            if (tabs[i].isSelected) {
                return tabs[i];
            }
        }
        return null;
    }
    getActiveChildNavs() {
        const selected = this.getSelected();
        return selected ? [selected] : [];
    }
    getAllChildNavs() {
        return this._tabs;
    }
    getIndex(tab) {
        return this._tabs.indexOf(tab);
    }
    length() {
        return this._tabs.length;
    }
    _updateCurrentTab(tab, fromUrl) {
        const active = tab.getActive();
        if (active) {
            if (fromUrl && tab._lazyRootFromUrl) {
                const vc = tab.getViewById(tab._lazyRootFromUrl);
                if (vc) {
                    tab.popTo(vc, {
                        animate: false,
                        updateUrl: false,
                    });
                }
                else {
                    tab.setRoot(tab._lazyRootFromUrl, tab._lazyRootFromUrlData, {
                        animate: false, updateUrl: false
                    });
                    tab._lazyRootFromUrl = null;
                    tab._lazyRootFromUrlData = null;
                }
            }
            else if (active._cmp && active._cmp.instance.ionSelected) {
                active._cmp.instance.ionSelected();
            }
            else if (tab.length() > 1) {
                tab.popToRoot();
            }
            else {
                getComponent(this._linker, tab.root).then(viewController => {
                    if (viewController.component !== active.component) {
                        return tab.setRoot(tab.root);
                    }
                }).catch(() => {
                    console.debug('Tabs: reset root was cancelled');
                });
            }
        }
    }
    setTabbarPosition(top, bottom) {
        if (this._top !== top || this._bottom !== bottom) {
            var tabbarEle = this._tabbar.nativeElement;
            tabbarEle.style.top = (top > -1 ? top + 'px' : '');
            tabbarEle.style.bottom = (bottom > -1 ? bottom + 'px' : '');
            tabbarEle.classList.add('show-tabbar');
            this._top = top;
            this._bottom = bottom;
        }
    }
    resize() {
        const tab = this.getSelected();
        tab && tab.resize();
    }
    initPane() {
        const isMain = this._elementRef.nativeElement.hasAttribute('main');
        return isMain;
    }
    paneChanged(isPane) {
        if (isPane) {
            this.resize();
        }
    }
    goToRoot(opts) {
        if (this._tabs.length) {
            return this.select(this._tabs[0], opts);
        }
    }
    getType() {
        return 'tabs';
    }
    getSecondaryIdentifier() {
        const tabs = this.getActiveChildNavs();
        if (tabs && tabs.length) {
            return this._linker._getTabSelector(tabs[0]);
        }
        return '';
    }
    _getSelectedTabIndex(secondaryId = '', fallbackIndex = 0) {
        const indexMatch = secondaryId.match(/tab-(\d+)/);
        if (indexMatch) {
            return parseInt(indexMatch[1], 10);
        }
        const tab = this._tabs.find(t => {
            return (isPresent(t.tabUrlPath) && t.tabUrlPath === secondaryId) ||
                (isPresent(t.tabTitle) && formatUrlPart(t.tabTitle) === secondaryId);
        });
        return isPresent(tab) ? tab.index : fallbackIndex;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tabs_Tabs.prototype, "name", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], tabs_Tabs.prototype, "selectedIndex", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tabs_Tabs.prototype, "tabsLayout", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tabs_Tabs.prototype, "tabsPlacement", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean)
], tabs_Tabs.prototype, "tabsHighlight", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (tabs__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && tabs__a || Object)
], tabs_Tabs.prototype, "ionChange", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])(TabHighlight),
    Object(tslib_es6["__metadata"])("design:type", typeof (tabs__b = typeof TabHighlight !== "undefined" && TabHighlight) === "function" && tabs__b || Object)
], tabs_Tabs.prototype, "_highlight", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('tabbar'),
    Object(tslib_es6["__metadata"])("design:type", typeof (tabs__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && tabs__c || Object)
], tabs_Tabs.prototype, "_tabbar", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('portal', { read: core_es5["_0" /* ViewContainerRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (tabs__d = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && tabs__d || Object)
], tabs_Tabs.prototype, "portal", void 0);
tabs_Tabs = Tabs_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-tabs',
        template: '<div class="tabbar" role="tablist" #tabbar>' +
            '<a *ngFor="let t of _tabs" [tab]="t" class="tab-button" role="tab" href="#" (ionSelect)="select(t)"></a>' +
            '<div class="tab-highlight"></div>' +
            '</div>' +
            '<ng-content></ng-content>' +
            '<div #portal tab-portal></div>',
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
        providers: [{ provide: RootNode, useExisting: Object(core_es5["_5" /* forwardRef */])(() => Tabs_1) }]
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(1, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (tabs__e = typeof NavController !== "undefined" && NavController) === "function" && tabs__e || Object, typeof (tabs__f = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && tabs__f || Object, typeof (tabs__g = typeof app_App !== "undefined" && app_App) === "function" && tabs__g || Object, typeof (tabs__h = typeof config_Config !== "undefined" && config_Config) === "function" && tabs__h || Object, typeof (tabs__j = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && tabs__j || Object, typeof (tabs__k = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && tabs__k || Object, typeof (tabs__l = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && tabs__l || Object, typeof (tabs__m = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && tabs__m || Object, typeof (tabs__o = typeof keyboard_Keyboard !== "undefined" && keyboard_Keyboard) === "function" && tabs__o || Object])
], tabs_Tabs);

let tabIds = -1;
var Tabs_1, tabs__a, tabs__b, tabs__c, tabs__d, tabs__e, tabs__f, tabs__g, tabs__h, tabs__j, tabs__k, tabs__l, tabs__m, tabs__o;




// CONCATENATED MODULE: ./src/components/tabs/tab.ts














let tab_Tab = class Tab extends nav_controller_base_NavControllerBase {
    constructor(parent, app, config, plt, elementRef, zone, renderer, cfr, _cd, gestureCtrl, transCtrl, linker, _dom, errHandler) {
        super(parent, app, config, plt, elementRef, zone, renderer, cfr, gestureCtrl, transCtrl, linker, _dom, errHandler);
        this._cd = _cd;
        this.linker = linker;
        this._dom = _dom;
        this._isEnabled = true;
        this._isShown = true;
        this.ionSelect = new core_es5["r" /* EventEmitter */]();
        this.id = parent.add(this);
        this._tabsHideOnSubPages = config.getBoolean('tabsHideOnSubPages');
        this._tabId = 'tabpanel-' + this.id;
        this._btnId = 'tab-' + this.id;
    }
    get enabled() {
        return this._isEnabled;
    }
    set enabled(val) {
        this._isEnabled = isTrueProperty(val);
    }
    get show() {
        return this._isShown;
    }
    set show(val) {
        this._isShown = isTrueProperty(val);
    }
    get tabsHideOnSubPages() {
        return this._tabsHideOnSubPages;
    }
    set tabsHideOnSubPages(val) {
        this._tabsHideOnSubPages = isTrueProperty(val);
    }
    set _vp(val) {
        this.setViewport(val);
    }
    ngOnInit() {
        this.tabBadgeStyle = this.tabBadgeStyle ? this.tabBadgeStyle : 'default';
    }
    load(opts, done) {
        if (this._lazyRootFromUrl || (!this._loaded && this.root)) {
            this.setElementClass('show-tab', true);
            const nameToUse = this._lazyRootFromUrl ? this._lazyRootFromUrl : this.root;
            const dataToUse = this._lazyRootFromUrlData ? this._lazyRootFromUrlData : this.rootParams;
            const numViews = this.length() - 1;
            for (let i = numViews; i >= 0; i--) {
                const viewController = this.getByIndex(i);
                if (viewController && (viewController.id === nameToUse || viewController.component === nameToUse)) {
                    if (i === numViews) {
                        if (done) {
                            done(false, false);
                        }
                        return;
                    }
                    else {
                        return this.popTo(viewController, {
                            animate: false,
                            updateUrl: false,
                        }, done);
                    }
                }
            }
            this.push(nameToUse, dataToUse, opts, done);
            this._lazyRootFromUrl = null;
            this._lazyRootFromUrlData = null;
            this._loaded = true;
        }
        else {
            this._dom.read(() => {
                this.resize();
            });
            if (done) {
                done(false, false);
            }
            return;
        }
    }
    resize() {
        const active = this.getActive();
        if (!active) {
            return;
        }
        const content = active.getIONContent();
        content && content.resize();
    }
    _viewAttachToDOM(viewCtrl, componentRef, viewport) {
        const isTabSubPage = (this._tabsHideOnSubPages && viewCtrl.index > 0);
        if (isTabSubPage) {
            viewport = this.parent.portal;
        }
        super._viewAttachToDOM(viewCtrl, componentRef, viewport);
        if (isTabSubPage) {
            const pageEleRef = viewCtrl.pageRef();
            if (pageEleRef) {
                this._renderer.setElementClass(pageEleRef.nativeElement, 'tab-subpage', true);
            }
        }
    }
    setSelected(isSelected) {
        this.isSelected = isSelected;
        this.setElementClass('show-tab', isSelected);
        this.setElementAttribute('aria-hidden', (!isSelected).toString());
        if (isSelected) {
            this._cd.reattach();
        }
        else {
            this._cd.detach();
        }
    }
    get index() {
        return this.parent.getIndex(this);
    }
    updateHref(component, data) {
        if (this.btn && this.linker) {
            let href = this.linker.createUrl(this.parent, component, data) || '#';
            this.btn.updateHref(href);
        }
    }
    ngOnDestroy() {
        this.destroy();
    }
    getType() {
        return 'tab';
    }
    goToRoot(opts) {
        return this.setRoot(this.root, this.rootParams, opts, null);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], tab_Tab.prototype, "root", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object)
], tab_Tab.prototype, "rootParams", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tab_Tab.prototype, "tabUrlPath", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tab_Tab.prototype, "tabTitle", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tab_Tab.prototype, "tabIcon", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tab_Tab.prototype, "tabBadge", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], tab_Tab.prototype, "tabBadgeStyle", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], tab_Tab.prototype, "enabled", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], tab_Tab.prototype, "show", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], tab_Tab.prototype, "tabsHideOnSubPages", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (tab__a = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && tab__a || Object)
], tab_Tab.prototype, "ionSelect", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["Y" /* ViewChild */])('viewport', { read: core_es5["_0" /* ViewContainerRef */] }),
    Object(tslib_es6["__metadata"])("design:type", typeof (tab__b = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && tab__b || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (tab__c = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && tab__c || Object])
], tab_Tab.prototype, "_vp", null);
tab_Tab = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-tab',
        template: '<div #viewport></div><div class="nav-decor"></div>',
        host: {
            '[attr.id]': '_tabId',
            '[attr.aria-labelledby]': '_btnId',
            'role': 'tabpanel'
        },
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(11, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (tab__d = typeof tabs_Tabs !== "undefined" && tabs_Tabs) === "function" && tab__d || Object, typeof (tab__e = typeof app_App !== "undefined" && app_App) === "function" && tab__e || Object, typeof (tab__f = typeof config_Config !== "undefined" && config_Config) === "function" && tab__f || Object, typeof (tab__g = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && tab__g || Object, typeof (tab__h = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && tab__h || Object, typeof (tab__j = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && tab__j || Object, typeof (tab__k = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && tab__k || Object, typeof (tab__l = typeof core_es5["l" /* ComponentFactoryResolver */] !== "undefined" && core_es5["l" /* ComponentFactoryResolver */]) === "function" && tab__l || Object, typeof (tab__m = typeof core_es5["i" /* ChangeDetectorRef */] !== "undefined" && core_es5["i" /* ChangeDetectorRef */]) === "function" && tab__m || Object, typeof (tab__o = typeof GestureController !== "undefined" && GestureController) === "function" && tab__o || Object, typeof (tab__p = typeof transition_controller_TransitionController !== "undefined" && transition_controller_TransitionController) === "function" && tab__p || Object, typeof (tab__q = typeof deep_linker_DeepLinker !== "undefined" && deep_linker_DeepLinker) === "function" && tab__q || Object, typeof (tab__r = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && tab__r || Object, typeof (tab__s = typeof core_es5["q" /* ErrorHandler */] !== "undefined" && core_es5["q" /* ErrorHandler */]) === "function" && tab__s || Object])
], tab_Tab);

var tab__a, tab__b, tab__c, tab__d, tab__e, tab__f, tab__g, tab__h, tab__j, tab__k, tab__l, tab__m, tab__o, tab__p, tab__q, tab__r, tab__s;




// CONCATENATED MODULE: ./src/components/tabs/tab-button.ts






let tab_button_TabButton = class TabButton extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer);
        this.ionSelect = new core_es5["r" /* EventEmitter */]();
        this.disHover = (config.get('hoverCSS') === false);
        this.layout = config.get('tabsLayout');
    }
    ngOnInit() {
        this.tab.btn = this;
        this.layout = this.tab.parent.tabsLayout || this.layout;
        this.hasTitle = !!this.tab.tabTitle;
        this.hasIcon = !!this.tab.tabIcon && this.layout !== 'icon-hide';
        this.hasTitleOnly = (this.hasTitle && !this.hasIcon);
        this.hasIconOnly = (this.hasIcon && !this.hasTitle);
        this.hasBadge = !!this.tab.tabBadge;
    }
    onClick() {
        this.ionSelect.emit(this.tab);
        return false;
    }
    updateHref(href) {
        this.setElementAttribute('href', href);
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (tab_button__a = typeof tab_Tab !== "undefined" && tab_Tab) === "function" && tab_button__a || Object)
], tab_button_TabButton.prototype, "tab", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["J" /* Output */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (tab_button__b = typeof core_es5["r" /* EventEmitter */] !== "undefined" && core_es5["r" /* EventEmitter */]) === "function" && tab_button__b || Object)
], tab_button_TabButton.prototype, "ionSelect", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('click'),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", []),
    Object(tslib_es6["__metadata"])("design:returntype", Boolean)
], tab_button_TabButton.prototype, "onClick", null);
tab_button_TabButton = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: '.tab-button',
        template: '<ion-icon *ngIf="tab.tabIcon" [name]="tab.tabIcon" [isActive]="tab.isSelected" class="tab-button-icon"></ion-icon>' +
            '<span *ngIf="tab.tabTitle" class="tab-button-text">{{tab.tabTitle}}</span>' +
            '<ion-badge *ngIf="tab.tabBadge" class="tab-badge" [color]="tab.tabBadgeStyle">{{tab.tabBadge}}</ion-badge>' +
            '<div class="button-effect"></div>',
        host: {
            '[attr.id]': 'tab._btnId',
            '[attr.aria-controls]': 'tab._tabId',
            '[attr.aria-selected]': 'tab.isSelected',
            '[class.has-title]': 'hasTitle',
            '[class.has-icon]': 'hasIcon',
            '[class.has-title-only]': 'hasTitleOnly',
            '[class.icon-only]': 'hasIconOnly',
            '[class.has-badge]': 'hasBadge',
            '[class.disable-hover]': 'disHover',
            '[class.tab-disabled]': '!tab.enabled',
            '[class.tab-hidden]': '!tab.show',
        }
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (tab_button__c = typeof config_Config !== "undefined" && config_Config) === "function" && tab_button__c || Object, typeof (tab_button__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && tab_button__d || Object, typeof (tab_button__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && tab_button__e || Object])
], tab_button_TabButton);

var tab_button__a, tab_button__b, tab_button__c, tab_button__d, tab_button__e;




// CONCATENATED MODULE: ./src/components/toast/toast-component.ts






let ToastCmp = class ToastCmp {
    constructor(_viewCtrl, _config, _elementRef, params, renderer) {
        this._viewCtrl = _viewCtrl;
        this._config = _config;
        this._elementRef = _elementRef;
        this.dismissTimeout = undefined;
        renderer.setElementClass(_elementRef.nativeElement, `toast-${_config.get('mode')}`, true);
        this.d = params.data;
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                if (cssClass.trim() !== '')
                    renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++toastIds);
        if (this.d.message) {
            this.hdrId = 'toast-hdr-' + this.id;
        }
    }
    ngAfterViewInit() {
        if (this.d.duration) {
            this.dismissTimeout = setTimeout(() => {
                this.dismiss('backdrop');
            }, this.d.duration);
        }
        this.enabled = true;
    }
    ionViewDidEnter() {
        const { activeElement } = document;
        if (activeElement) {
            activeElement.blur();
        }
        let focusableEle = this._elementRef.nativeElement.querySelector('button');
        if (focusableEle) {
            focusableEle.focus();
        }
    }
    cbClick() {
        if (this.enabled) {
            this.dismiss('close');
        }
    }
    dismiss(role) {
        clearTimeout(this.dismissTimeout);
        this.dismissTimeout = undefined;
        return this._viewCtrl.dismiss(null, role, { disableApp: false });
    }
};
ToastCmp = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-toast',
        template: '<div class="toast-wrapper" ' +
            '[class.toast-bottom]="d.position === \'bottom\'" ' +
            '[class.toast-middle]="d.position === \'middle\'" ' +
            '[class.toast-top]="d.position === \'top\'"> ' +
            '<div class="toast-container"> ' +
            '<div class="toast-message" id="{{hdrId}}" *ngIf="d.message">{{d.message}}</div> ' +
            '<button ion-button clear class="toast-button" *ngIf="d.showCloseButton" (click)="cbClick()"> ' +
            '{{ d.closeButtonText || \'Close\' }} ' +
            '</button> ' +
            '</div> ' +
            '</div>',
        host: {
            'role': 'dialog',
            '[attr.aria-labelledby]': 'hdrId',
            '[attr.aria-describedby]': 'descId',
        },
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toast_component__a = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && toast_component__a || Object, typeof (toast_component__b = typeof config_Config !== "undefined" && config_Config) === "function" && toast_component__b || Object, typeof (toast_component__c = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toast_component__c || Object, typeof (toast_component__d = typeof NavParams !== "undefined" && NavParams) === "function" && toast_component__d || Object, typeof (toast_component__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toast_component__e || Object])
], ToastCmp);

let toastIds = -1;
var toast_component__a, toast_component__b, toast_component__c, toast_component__d, toast_component__e;




// CONCATENATED MODULE: ./src/components/toast/toast-transitions.ts


class toast_transitions_ToastSlideIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        const wrapperEle = ele.querySelector('.toast-wrapper');
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        if (this.enteringView.data && this.enteringView.data.position === TOAST_POSITION_TOP) {
            wrapper.fromTo('translateY', '-100%', `${10}px`);
        }
        else if (this.enteringView.data && this.enteringView.data.position === TOAST_POSITION_MIDDLE) {
            let topPosition = Math.floor(ele.clientHeight / 2 - wrapperEle.clientHeight / 2);
            wrapperEle.style.top = `${topPosition}px`;
            wrapper.fromTo('opacity', 0.01, 1);
        }
        else {
            wrapper.fromTo('translateY', '100%', `${0 - 10}px`);
        }
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(wrapper);
    }
}
class toast_transitions_ToastSlideOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        const wrapperEle = ele.querySelector('.toast-wrapper');
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        if (this.leavingView.data && this.leavingView.data.position === TOAST_POSITION_TOP) {
            wrapper.fromTo('translateY', `${10}px`, '-100%');
        }
        else if (this.leavingView.data && this.leavingView.data.position === TOAST_POSITION_MIDDLE) {
            wrapper.fromTo('opacity', 0.99, 0);
        }
        else {
            wrapper.fromTo('translateY', `${0 - 10}px`, '100%');
        }
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(300).add(wrapper);
    }
}
class toast_transitions_ToastMdSlideIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        const wrapperEle = ele.querySelector('.toast-wrapper');
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        if (this.enteringView.data && this.enteringView.data.position === TOAST_POSITION_TOP) {
            wrapper.fromTo('translateY', '-100%', `0%`);
        }
        else if (this.enteringView.data && this.enteringView.data.position === TOAST_POSITION_MIDDLE) {
            let topPosition = Math.floor(ele.clientHeight / 2 - wrapperEle.clientHeight / 2);
            wrapperEle.style.top = `${topPosition}px`;
            wrapper.fromTo('opacity', 0.01, 1);
        }
        else {
            wrapper.fromTo('translateY', '100%', `0%`);
        }
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(wrapper);
    }
}
class toast_transitions_ToastMdSlideOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        const wrapperEle = ele.querySelector('.toast-wrapper');
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        if (this.leavingView.data && this.leavingView.data.position === TOAST_POSITION_TOP) {
            wrapper.fromTo('translateY', `${0}%`, '-100%');
        }
        else if (this.leavingView.data && this.leavingView.data.position === TOAST_POSITION_MIDDLE) {
            wrapper.fromTo('opacity', 0.99, 0);
        }
        else {
            wrapper.fromTo('translateY', `${0}%`, '100%');
        }
        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(wrapper);
    }
}
class toast_transitions_ToastWpPopIn extends Transition {
    init() {
        let ele = this.enteringView.pageRef().nativeElement;
        const wrapperEle = ele.querySelector('.toast-wrapper');
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        if (this.enteringView.data && this.enteringView.data.position === TOAST_POSITION_TOP) {
            wrapper.fromTo('opacity', 0.01, 1);
            wrapper.fromTo('scale', 1.3, 1);
        }
        else if (this.enteringView.data && this.enteringView.data.position === TOAST_POSITION_MIDDLE) {
            let topPosition = Math.floor(ele.clientHeight / 2 - wrapperEle.clientHeight / 2);
            wrapperEle.style.top = `${topPosition}px`;
            wrapper.fromTo('opacity', 0.01, 1);
            wrapper.fromTo('scale', 1.3, 1);
        }
        else {
            wrapper.fromTo('opacity', 0.01, 1);
            wrapper.fromTo('scale', 1.3, 1);
        }
        this.easing('cubic-bezier(0,0,0.05,1)').duration(200).add(wrapper);
    }
}
class toast_transitions_ToastWpPopOut extends Transition {
    init() {
        let ele = this.leavingView.pageRef().nativeElement;
        const wrapperEle = ele.querySelector('.toast-wrapper');
        let wrapper = new animation_Animation(this.plt, wrapperEle);
        if (this.leavingView.data && this.leavingView.data.position === TOAST_POSITION_TOP) {
            wrapper.fromTo('opacity', 0.99, 0);
            wrapper.fromTo('scale', 1, 1.3);
        }
        else if (this.leavingView.data && this.leavingView.data.position === TOAST_POSITION_MIDDLE) {
            wrapper.fromTo('opacity', 0.99, 0);
            wrapper.fromTo('scale', 1, 1.3);
        }
        else {
            wrapper.fromTo('opacity', 0.99, 0);
            wrapper.fromTo('scale', 1, 1.3);
        }
        const EASE = 'ease-out';
        const DURATION = 150;
        this.easing(EASE).duration(DURATION).add(wrapper);
    }
}
const TOAST_POSITION_TOP = 'top';
const TOAST_POSITION_MIDDLE = 'middle';
//# sourceMappingURL=toast-transitions.js.map
// CONCATENATED MODULE: ./src/components/toast/toast.ts





class toast_Toast extends view_controller_ViewController {
    constructor(app, opts = {}, config) {
        opts.dismissOnPageChange = isPresent(opts.dismissOnPageChange) ? !!opts.dismissOnPageChange : false;
        super(ToastCmp, opts, null);
        this._app = app;
        if (!opts.position || !this.isValidPosition(opts.position)) {
            opts.position = TOAST_POSITION_BOTTOM;
        }
        this.isOverlay = true;
        config.setTransition('toast-slide-in', toast_transitions_ToastSlideIn);
        config.setTransition('toast-slide-out', toast_transitions_ToastSlideOut);
        config.setTransition('toast-md-slide-in', toast_transitions_ToastMdSlideIn);
        config.setTransition('toast-md-slide-out', toast_transitions_ToastMdSlideOut);
        config.setTransition('toast-wp-slide-out', toast_transitions_ToastWpPopOut);
        config.setTransition('toast-wp-slide-in', toast_transitions_ToastWpPopIn);
    }
    getTransitionName(direction) {
        let key = 'toast' + (direction === 'back' ? 'Leave' : 'Enter');
        return this._nav && this._nav.config.get(key);
    }
    isValidPosition(position) {
        return position === toast_TOAST_POSITION_TOP || position === toast_TOAST_POSITION_MIDDLE || position === TOAST_POSITION_BOTTOM;
    }
    setMessage(message) {
        this.data.message = message;
        return this;
    }
    setDuration(dur) {
        this.data.duration = dur;
        return this;
    }
    setPosition(pos) {
        this.data.position = pos;
        return this;
    }
    setCssClass(cssClass) {
        this.data.cssClass = cssClass;
        return this;
    }
    setShowCloseButton(closeButton) {
        this.data.showCloseButton = closeButton;
        return this;
    }
    present(navOptions = {}) {
        navOptions.disableApp = false;
        navOptions.keyboardClose = false;
        return this._app.present(this, navOptions, PORTAL_TOAST);
    }
    dismissAll() {
        this._nav && this._nav.popAll();
    }
}
const toast_TOAST_POSITION_TOP = 'top';
const toast_TOAST_POSITION_MIDDLE = 'middle';
const TOAST_POSITION_BOTTOM = 'bottom';
//# sourceMappingURL=toast.js.map
// CONCATENATED MODULE: ./src/components/toast/toast-controller.ts






let toast_controller_ToastController = class ToastController {
    constructor(_app, config) {
        this._app = _app;
        this.config = config;
    }
    create(opts = {}) {
        return new toast_Toast(this._app, opts, this.config);
    }
};
toast_controller_ToastController = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toast_controller__a = typeof app_App !== "undefined" && app_App) === "function" && toast_controller__a || Object, typeof (toast_controller__b = typeof config_Config !== "undefined" && config_Config) === "function" && toast_controller__b || Object])
], toast_controller_ToastController);

var toast_controller__a, toast_controller__b;




// EXTERNAL MODULE: ./src/components/toast/toast-options.ts
var toast_options = __webpack_require__(54);
var toast_options_default = /*#__PURE__*/__webpack_require__.n(toast_options);

// CONCATENATED MODULE: ./src/components/toggle/toggle-gesture.ts



class toggle_gesture_ToggleGesture extends pan_gesture_PanGesture {
    constructor(plt, toggle, gestureCtrl, domCtrl) {
        super(plt, toggle.getNativeElement(), {
            threshold: 0,
            zone: false,
            domController: domCtrl,
            gesture: gestureCtrl.createGesture({
                name: GESTURE_TOGGLE,
                priority: GESTURE_PRIORITY_TOGGLE
            })
        });
        this.toggle = toggle;
    }
    canStart() {
        return true;
    }
    onDragStart(ev) {
        ev.preventDefault();
        this.toggle._onDragStart(pointerCoord(ev).x);
    }
    onDragMove(ev) {
        ev.preventDefault();
        this.toggle._onDragMove(pointerCoord(ev).x);
    }
    onDragEnd(ev) {
        ev.preventDefault();
        this.toggle._onDragEnd(pointerCoord(ev).x);
    }
}
//# sourceMappingURL=toggle-gesture.js.map
// CONCATENATED MODULE: ./src/components/toggle/toggle.ts
















let toggle_Toggle = Toggle_1 = class Toggle extends base_input_BaseInput {
    constructor(form, config, _plt, elementRef, renderer, _haptic, item, _gestureCtrl, _domCtrl, _zone) {
        super(config, elementRef, renderer, 'toggle', false, form, item, null);
        this._plt = _plt;
        this._haptic = _haptic;
        this._gestureCtrl = _gestureCtrl;
        this._domCtrl = _domCtrl;
        this._zone = _zone;
        this._activated = false;
    }
    get checked() {
        return this.value;
    }
    set checked(val) {
        this.value = val;
    }
    ngAfterContentInit() {
        this._initialize();
        this._gesture = new toggle_gesture_ToggleGesture(this._plt, this, this._gestureCtrl, this._domCtrl);
        this._gesture.listen();
    }
    _inputUpdated() { }
    _inputNormalize(val) {
        return isTrueProperty(val);
    }
    _onDragStart(startX) {
        _assert(startX, 'startX must be valid');
        console.debug('toggle, _onDragStart', startX);
        this._zone.run(() => {
            this._startX = startX;
            this._fireFocus();
            this._activated = true;
        });
    }
    _onDragMove(currentX) {
        if (!this._startX) {
            _assert(false, '_startX must be valid');
            return;
        }
        if (this._shouldToggle(currentX, -15)) {
            this._zone.run(() => {
                this.value = !this.value;
                this._startX = currentX;
                this._haptic.selection();
            });
        }
    }
    _onDragEnd(endX) {
        if (!this._startX) {
            _assert(false, '_startX must be valid');
            return;
        }
        console.debug('toggle, _onDragEnd', endX);
        this._zone.run(() => {
            if (this._shouldToggle(endX, 4)) {
                this.value = !this.value;
                this._haptic.selection();
            }
            this._activated = false;
            this._fireBlur();
            this._startX = null;
        });
    }
    _shouldToggle(currentX, margin) {
        const isLTR = !this._plt.isRTL;
        const startX = this._startX;
        if (this._value) {
            return (isLTR && (startX + margin > currentX)) ||
                (!isLTR && (startX - margin < currentX));
        }
        else {
            return (isLTR && (startX - margin < currentX)) ||
                (!isLTR && (startX + margin > currentX));
        }
    }
    _keyup(ev) {
        if (ev.keyCode === KEY_SPACE || ev.keyCode === KEY_ENTER) {
            console.debug(`toggle, keyup: ${ev.keyCode}`);
            ev.preventDefault();
            ev.stopPropagation();
            this.value = !this.value;
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._gesture && this._gesture.destroy();
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Boolean),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Boolean])
], toggle_Toggle.prototype, "checked", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["u" /* HostListener */])('keyup', ['$event']),
    Object(tslib_es6["__metadata"])("design:type", Function),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object]),
    Object(tslib_es6["__metadata"])("design:returntype", void 0)
], toggle_Toggle.prototype, "_keyup", null);
toggle_Toggle = Toggle_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-toggle',
        template: '<div class="toggle-icon">' +
            '<div class="toggle-inner"></div>' +
            '</div>' +
            '<button role="checkbox" ' +
            'type="button" ' +
            'ion-button="item-cover" ' +
            '[id]="id" ' +
            '[attr.aria-checked]="_value" ' +
            '[attr.aria-labelledby]="_labelId" ' +
            '[attr.aria-disabled]="_disabled" ' +
            'class="item-cover" disable-activated>' +
            '</button>',
        host: {
            '[class.toggle-disabled]': '_disabled',
            '[class.toggle-checked]': '_value',
            '[class.toggle-activated]': '_activated',
        },
        providers: [{ provide: forms_es5["e" /* NG_VALUE_ACCESSOR */], useExisting: Toggle_1, multi: true }],
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(6, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toggle__a = typeof form_Form !== "undefined" && form_Form) === "function" && toggle__a || Object, typeof (toggle__b = typeof config_Config !== "undefined" && config_Config) === "function" && toggle__b || Object, typeof (toggle__c = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && toggle__c || Object, typeof (toggle__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toggle__d || Object, typeof (toggle__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toggle__e || Object, typeof (toggle__f = typeof Haptic !== "undefined" && Haptic) === "function" && toggle__f || Object, typeof (toggle__g = typeof Item !== "undefined" && Item) === "function" && toggle__g || Object, typeof (toggle__h = typeof GestureController !== "undefined" && GestureController) === "function" && toggle__h || Object, typeof (toggle__j = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && toggle__j || Object, typeof (toggle__k = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && toggle__k || Object])
], toggle_Toggle);

var Toggle_1, toggle__a, toggle__b, toggle__c, toggle__d, toggle__e, toggle__f, toggle__g, toggle__h, toggle__j, toggle__k;




// CONCATENATED MODULE: ./src/components/toolbar/toolbar-footer.ts







let Footer = class Footer extends Ion {
    constructor(config, elementRef, renderer, viewCtrl) {
        super(config, elementRef, renderer, 'footer');
        viewCtrl && viewCtrl._setFooter(this);
    }
};
Footer = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-footer'
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toolbar_footer__a = typeof config_Config !== "undefined" && config_Config) === "function" && toolbar_footer__a || Object, typeof (toolbar_footer__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toolbar_footer__b || Object, typeof (toolbar_footer__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toolbar_footer__c || Object, typeof (toolbar_footer__d = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && toolbar_footer__d || Object])
], Footer);

var toolbar_footer__a, toolbar_footer__b, toolbar_footer__c, toolbar_footer__d;




// CONCATENATED MODULE: ./src/components/toolbar/toolbar-header.ts







let Header = class Header extends Ion {
    constructor(config, elementRef, renderer, viewCtrl) {
        super(config, elementRef, renderer, 'header');
        viewCtrl && viewCtrl._setHeader(this);
    }
};
Header = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-header'
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toolbar_header__a = typeof config_Config !== "undefined" && config_Config) === "function" && toolbar_header__a || Object, typeof (toolbar_header__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toolbar_header__b || Object, typeof (toolbar_header__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toolbar_header__c || Object, typeof (toolbar_header__d = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && toolbar_header__d || Object])
], Header);

var toolbar_header__a, toolbar_header__b, toolbar_header__c, toolbar_header__d;




// CONCATENATED MODULE: ./src/components/toolbar/toolbar.ts





let Toolbar = class Toolbar extends ToolbarBase {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer);
        this._sbPadding = config.getBoolean('statusbarPadding');
    }
};
Toolbar = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-toolbar',
        template: '<div class="toolbar-background" [ngClass]="\'toolbar-background-\' + _mode"></div>' +
            '<ng-content select="[menuToggle],ion-buttons[left]"></ng-content>' +
            '<ng-content select="ion-buttons[start]"></ng-content>' +
            '<ng-content select="ion-buttons[end],ion-buttons[right]"></ng-content>' +
            '<div class="toolbar-content" [ngClass]="\'toolbar-content-\' + _mode">' +
            '<ng-content></ng-content>' +
            '</div>',
        host: {
            'class': 'toolbar',
            '[class.statusbar-padding]': '_sbPadding'
        },
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toolbar__a = typeof config_Config !== "undefined" && config_Config) === "function" && toolbar__a || Object, typeof (toolbar__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toolbar__b || Object, typeof (toolbar__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toolbar__c || Object])
], Toolbar);

var toolbar__a, toolbar__b, toolbar__c;




// CONCATENATED MODULE: ./src/components/toolbar/toolbar-item.ts









let ToolbarItem = class ToolbarItem extends Ion {
    constructor(config, elementRef, renderer, toolbar, navbar) {
        super(config, elementRef, renderer, 'bar-buttons');
        this.inToolbar = !!(toolbar || navbar);
    }
    set _buttons(buttons) {
        if (this.inToolbar) {
            buttons.forEach((button) => {
                button.setRole('bar-button');
            });
        }
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["n" /* ContentChildren */])(button_Button),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], ToolbarItem.prototype, "_buttons", null);
ToolbarItem = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-buttons,[menuToggle]'
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(4, Object(core_es5["I" /* Optional */])()), Object(tslib_es6["__param"])(4, Object(core_es5["v" /* Inject */])(Object(core_es5["_5" /* forwardRef */])(() => navbar_Navbar))),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toolbar_item__a = typeof config_Config !== "undefined" && config_Config) === "function" && toolbar_item__a || Object, typeof (toolbar_item__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toolbar_item__b || Object, typeof (toolbar_item__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toolbar_item__c || Object, typeof (toolbar_item__d = typeof Toolbar !== "undefined" && Toolbar) === "function" && toolbar_item__d || Object, typeof (toolbar_item__e = typeof navbar_Navbar !== "undefined" && navbar_Navbar) === "function" && toolbar_item__e || Object])
], ToolbarItem);

var toolbar_item__a, toolbar_item__b, toolbar_item__c, toolbar_item__d, toolbar_item__e;




// CONCATENATED MODULE: ./src/components/toolbar/toolbar-title.ts








let ToolbarTitle = class ToolbarTitle extends Ion {
    constructor(config, elementRef, renderer, toolbar, navbar) {
        super(config, elementRef, renderer, 'title');
        toolbar && toolbar._setTitle(this);
        navbar && navbar._setTitle(this);
    }
    getTitleText() {
        return this._elementRef.nativeElement.textContent;
    }
};
ToolbarTitle = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        selector: 'ion-title',
        template: '<div class="toolbar-title" [ngClass]="\'toolbar-title-\' + _mode">' +
            '<ng-content></ng-content>' +
            '</div>',
        changeDetection: core_es5["h" /* ChangeDetectionStrategy */].OnPush,
        encapsulation: core_es5["_1" /* ViewEncapsulation */].None,
    }),
    Object(tslib_es6["__param"])(3, Object(core_es5["I" /* Optional */])()),
    Object(tslib_es6["__param"])(4, Object(core_es5["I" /* Optional */])()), Object(tslib_es6["__param"])(4, Object(core_es5["v" /* Inject */])(Object(core_es5["_5" /* forwardRef */])(() => navbar_Navbar))),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (toolbar_title__a = typeof config_Config !== "undefined" && config_Config) === "function" && toolbar_title__a || Object, typeof (toolbar_title__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && toolbar_title__b || Object, typeof (toolbar_title__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && toolbar_title__c || Object, typeof (toolbar_title__d = typeof Toolbar !== "undefined" && Toolbar) === "function" && toolbar_title__d || Object, typeof (toolbar_title__e = typeof navbar_Navbar !== "undefined" && navbar_Navbar) === "function" && toolbar_title__e || Object])
], ToolbarTitle);

var toolbar_title__a, toolbar_title__b, toolbar_title__c, toolbar_title__d, toolbar_title__e;




// CONCATENATED MODULE: ./src/components/thumbnail/thumbnail.ts


let Thumbnail = class Thumbnail {
};
Thumbnail = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: 'ion-thumbnail'
    })
], Thumbnail);





// CONCATENATED MODULE: ./src/components/typography/typography.ts





let Typography = class Typography extends Ion {
    constructor(config, elementRef, renderer) {
        super(config, elementRef, renderer, 'text');
    }
};
Typography = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[ion-text]'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (typography__a = typeof config_Config !== "undefined" && config_Config) === "function" && typography__a || Object, typeof (typography__b = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && typography__b || Object, typeof (typography__c = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && typography__c || Object])
], Typography);

var typography__a, typography__b, typography__c;




// CONCATENATED MODULE: ./src/components/virtual-scroll/virtual-footer.ts



let VirtualFooter = class VirtualFooter {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
VirtualFooter = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({ selector: '[virtualFooter]' }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (virtual_footer__a = typeof core_es5["U" /* TemplateRef */] !== "undefined" && core_es5["U" /* TemplateRef */]) === "function" && virtual_footer__a || Object])
], VirtualFooter);

var virtual_footer__a;




// CONCATENATED MODULE: ./src/components/virtual-scroll/virtual-header.ts



let VirtualHeader = class VirtualHeader {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
VirtualHeader = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({ selector: '[virtualHeader]' }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (virtual_header__a = typeof core_es5["U" /* TemplateRef */] !== "undefined" && core_es5["U" /* TemplateRef */]) === "function" && virtual_header__a || Object])
], VirtualHeader);

var virtual_header__a;




// CONCATENATED MODULE: ./src/components/virtual-scroll/virtual-item.ts



let VirtualItem = class VirtualItem {
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
    }
};
VirtualItem = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({ selector: '[virtualItem]' }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (virtual_item__a = typeof core_es5["U" /* TemplateRef */] !== "undefined" && core_es5["U" /* TemplateRef */]) === "function" && virtual_item__a || Object, typeof (virtual_item__b = typeof core_es5["_0" /* ViewContainerRef */] !== "undefined" && core_es5["_0" /* ViewContainerRef */]) === "function" && virtual_item__b || Object])
], VirtualItem);

var virtual_item__a, virtual_item__b;




// CONCATENATED MODULE: ./src/components/virtual-scroll/virtual-util.ts
const PREVIOUS_CELL = {
    row: 0,
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    tmpl: -1
};
function processRecords(stopAtHeight, records, cells, headerFn, footerFn, data) {
    let record;
    let startRecordIndex;
    let previousCell;
    let tmpData;
    let lastRecordIndex = records ? (records.length - 1) : -1;
    if (cells.length) {
        previousCell = cells[cells.length - 1];
        if (previousCell.top + previousCell.height > stopAtHeight) {
            return;
        }
        startRecordIndex = (previousCell.record + 1);
    }
    else {
        previousCell = PREVIOUS_CELL;
        startRecordIndex = 0;
    }
    let processedTotal = 0;
    for (var recordIndex = startRecordIndex; recordIndex <= lastRecordIndex; recordIndex++) {
        record = records[recordIndex];
        if (headerFn) {
            tmpData = headerFn(record, recordIndex, records);
            if (tmpData !== null) {
                previousCell = addCell(previousCell, recordIndex, TEMPLATE_HEADER, tmpData, data.hdrWidth, data.hdrHeight, data.viewWidth);
                cells.push(previousCell);
            }
        }
        previousCell = addCell(previousCell, recordIndex, TEMPLATE_ITEM, null, data.itmWidth, data.itmHeight, data.viewWidth);
        cells.push(previousCell);
        if (footerFn) {
            tmpData = footerFn(record, recordIndex, records);
            if (tmpData !== null) {
                previousCell = addCell(previousCell, recordIndex, TEMPLATE_FOOTER, tmpData, data.ftrWidth, data.ftrHeight, data.viewWidth);
                cells.push(previousCell);
            }
        }
        if (previousCell.record === lastRecordIndex) {
            previousCell.isLast = true;
        }
        processedTotal++;
        if (previousCell.top + previousCell.height + data.itmHeight > stopAtHeight && processedTotal > 3) {
            return;
        }
    }
}
function addCell(previousCell, recordIndex, tmpl, tmplData, cellWidth, cellHeight, viewportWidth) {
    let newCell;
    if (previousCell.left + previousCell.width + cellWidth > viewportWidth) {
        newCell = {
            record: recordIndex,
            tmpl: tmpl,
            row: (previousCell.row + 1),
            width: cellWidth,
            height: cellHeight,
            top: (previousCell.top + previousCell.height),
            left: 0,
            reads: 0,
        };
    }
    else {
        newCell = {
            record: recordIndex,
            tmpl: tmpl,
            row: previousCell.row,
            width: cellWidth,
            height: cellHeight,
            top: previousCell.top,
            left: (previousCell.left + previousCell.width),
            reads: 0,
        };
    }
    if (tmplData) {
        newCell.data = tmplData;
    }
    return newCell;
}
function populateNodeData(startCellIndex, endCellIndex, scrollingDown, cells, records, nodes, viewContainer, itmTmp, hdrTmp, ftrTmp, initialLoad) {
    if (!records || records.length === 0) {
        nodes.length = 0;
        return true;
    }
    const recordsLength = records.length;
    let hasChanges = false;
    let node;
    let availableNode;
    let cell;
    let isAlreadyRendered;
    let viewInsertIndex = null;
    let totalNodes = nodes.length;
    let templateRef;
    startCellIndex = Math.max(startCellIndex, 0);
    endCellIndex = Math.min(endCellIndex, cells.length - 1);
    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {
        cell = cells[cellIndex];
        availableNode = null;
        isAlreadyRendered = false;
        if (!initialLoad) {
            for (var i = 0; i < totalNodes; i++) {
                node = nodes[i];
                if (cell.tmpl !== node.tmpl || i === 0 && cellIndex !== 0) {
                    continue;
                }
                if (node.cell === cellIndex) {
                    isAlreadyRendered = true;
                    break;
                }
                if (node.cell < startCellIndex || node.cell > endCellIndex) {
                    if (!availableNode) {
                        availableNode = nodes[i];
                    }
                    else if (scrollingDown) {
                        if (node.cell < availableNode.cell) {
                            availableNode = nodes[i];
                        }
                    }
                    else {
                        if (node.cell > availableNode.cell) {
                            availableNode = nodes[i];
                        }
                    }
                }
            }
            if (isAlreadyRendered) {
                continue;
            }
        }
        if (!availableNode) {
            if (viewInsertIndex === null) {
                viewInsertIndex = -1;
                for (var j = totalNodes - 1; j >= 0; j--) {
                    node = nodes[j];
                    if (node) {
                        viewInsertIndex = viewContainer.indexOf(node.view);
                        break;
                    }
                }
            }
            templateRef = cell.tmpl === TEMPLATE_HEADER ? hdrTmp : cell.tmpl === TEMPLATE_FOOTER ? ftrTmp : itmTmp;
            if (!templateRef) {
                console.error(`virtual${cell.tmpl === TEMPLATE_HEADER ? 'Header' : cell.tmpl === TEMPLATE_FOOTER ? 'Footer' : 'Item'} template required`);
                continue;
            }
            availableNode = {
                tmpl: cell.tmpl,
                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)
            };
            totalNodes = nodes.push(availableNode);
        }
        availableNode.cell = cellIndex;
        var context = availableNode.view.context;
        context.$implicit = cell.data || records[cell.record];
        context.index = cellIndex;
        context.count = recordsLength;
        availableNode.hasChanges = true;
        availableNode.lastTransform = null;
        hasChanges = true;
    }
    return hasChanges;
}
function initReadNodes(plt, nodes, cells, data) {
    if (nodes.length && cells.length) {
        var ele = getElement(nodes[0]);
        var firstCell = cells[0];
        firstCell.top = ele.clientTop;
        firstCell.left = ele.clientLeft;
        firstCell.row = 0;
        updateDimensions(plt, nodes, cells, data, true);
    }
}
function updateDimensions(plt, nodes, cells, data, initialUpdate) {
    let node;
    let element;
    let cell;
    let previousCell;
    const totalCells = cells.length;
    for (var i = 0; i < nodes.length; i++) {
        node = nodes[i];
        cell = cells[node.cell];
        if (cell && cell.reads < REQUIRED_DOM_READS) {
            element = getElement(node);
            readElements(plt, cell, element);
            if (initialUpdate) {
                if (cell.tmpl === TEMPLATE_HEADER) {
                    data.hdrHeight = cell.height;
                    if (cell.left === 0) {
                        data.hdrWidth = cell.width;
                    }
                }
                else if (cell.tmpl === TEMPLATE_FOOTER) {
                    data.ftrHeight = cell.height;
                    if (cell.left === 0) {
                        data.ftrWidth = cell.width;
                    }
                }
                else {
                    data.itmHeight = cell.height;
                    if (cell.left === 0) {
                        data.itmWidth = cell.width;
                    }
                }
            }
            cell.reads++;
        }
    }
    const viewableBottom = (data.scrollTop + data.viewHeight);
    data.topViewCell = totalCells;
    data.bottomViewCell = 0;
    if (totalCells > 0) {
        cell = cells[0];
        previousCell = {
            row: 0,
            width: 0,
            height: 0,
            top: cell.top,
            left: 0,
            tmpl: -1
        };
        for (let i = 0; i < totalCells; i++) {
            cell = cells[i];
            if (previousCell.left + previousCell.width + cell.width > data.viewWidth) {
                cell.row++;
                cell.top = (previousCell.top + previousCell.height);
                cell.left = 0;
            }
            else {
                cell.row = previousCell.row;
                cell.top = previousCell.top;
                cell.left = (previousCell.left + previousCell.width);
            }
            if (cell.top + cell.height > data.scrollTop && i < data.topViewCell) {
                data.topViewCell = i;
            }
            else if (cell.top < viewableBottom && i > data.bottomViewCell) {
                data.bottomViewCell = i;
            }
            previousCell = cell;
        }
    }
}
function updateNodeContext(nodes, cells, data) {
    let node;
    let cell;
    let bounds;
    for (var i = 0, ilen = nodes.length; i < ilen; i++) {
        node = nodes[i];
        cell = cells[node.cell];
        if (node && cell) {
            bounds = node.view.context.bounds;
            bounds.top = cell.top + data.viewTop;
            bounds.bottom = bounds.top + cell.height;
            bounds.left = cell.left + data.viewLeft;
            bounds.right = bounds.left + cell.width;
            bounds.width = cell.width;
            bounds.height = cell.height;
        }
    }
}
function readElements(plt, cell, element) {
    const styles = plt.getElementComputedStyle(element);
    cell.left = (element.clientLeft - parseFloat(styles.marginLeft));
    cell.width = (element.offsetWidth + parseFloat(styles.marginLeft) + parseFloat(styles.marginRight));
    cell.height = (element.offsetHeight + parseFloat(styles.marginTop) + parseFloat(styles.marginBottom));
}
function writeToNodes(plt, nodes, cells, totalRecords) {
    let node;
    let element;
    let cell;
    let transform;
    const totalCells = Math.max(totalRecords, cells.length);
    for (var i = 0, ilen = nodes.length; i < ilen; i++) {
        node = nodes[i];
        cell = cells[node.cell];
        transform = `translate3d(${cell.left}px,${cell.top}px,0px)`;
        if (node.lastTransform !== transform) {
            element = getElement(node);
            if (element) {
                element.style[plt.Css.transform] = node.lastTransform = transform;
                element.classList.add('virtual-position');
                element.setAttribute('aria-posinset', node.cell + 1);
                element.setAttribute('aria-setsize', totalCells);
            }
        }
    }
}
function adjustRendered(cells, data) {
    let cell;
    let lastRow = -1;
    let cellsRenderHeight = 0;
    let maxRenderHeight = (data.renderHeight - data.itmHeight);
    let totalCells = cells.length;
    let viewableRenderedPadding = (data.itmHeight < 90 ? VIEWABLE_RENDERED_PADDING : 0);
    if (data.scrollDiff > 0) {
        data.topCell = Math.max(data.topViewCell - viewableRenderedPadding, 0);
        data.bottomCell = Math.min(data.topCell + 2, totalCells - 1);
        for (var i = data.topCell; i < totalCells; i++) {
            cell = cells[i];
            if (cell.row !== lastRow) {
                cellsRenderHeight += cell.height;
                lastRow = cell.row;
            }
            if (i > data.bottomCell) {
                data.bottomCell = i;
            }
            if (cellsRenderHeight >= maxRenderHeight) {
                break;
            }
        }
    }
    else {
        data.bottomCell = Math.min(data.bottomViewCell + viewableRenderedPadding, totalCells - 1);
        data.topCell = Math.max(data.bottomCell - 2, 0);
        for (let i = data.bottomCell; i >= 0; i--) {
            cell = cells[i];
            if (cell.row !== lastRow) {
                cellsRenderHeight += cell.height;
                lastRow = cell.row;
            }
            if (i < data.topCell) {
                data.topCell = i;
            }
            if (cellsRenderHeight >= maxRenderHeight) {
                break;
            }
        }
    }
}
function getVirtualHeight(totalRecords, lastCell) {
    if (lastCell.record >= totalRecords - 1) {
        return (lastCell.top + lastCell.height);
    }
    let unknownRecords = (totalRecords - lastCell.record - 1);
    let knownHeight = (lastCell.top + lastCell.height);
    return Math.ceil(knownHeight + ((knownHeight / (totalRecords - unknownRecords)) * unknownRecords));
}
function estimateHeight(totalRecords, lastCell, existingHeight, difference) {
    if (!totalRecords || !lastCell) {
        return 0;
    }
    const newHeight = getVirtualHeight(totalRecords, lastCell);
    const percentToBottom = (lastCell.record / (totalRecords - 1));
    const diff = Math.abs(existingHeight - newHeight);
    if ((diff > (newHeight * difference)) ||
        (percentToBottom > .995)) {
        return newHeight;
    }
    return existingHeight;
}
function calcDimensions(data, virtualScrollElement, approxItemWidth, approxItemHeight, appoxHeaderWidth, approxHeaderHeight, approxFooterWidth, approxFooterHeight, bufferRatio) {
    const viewportElement = virtualScrollElement.parentElement;
    data.viewWidth = viewportElement.offsetWidth;
    data.viewHeight = viewportElement.offsetHeight;
    data.viewTop = virtualScrollElement.offsetTop;
    data.viewLeft = virtualScrollElement.offsetLeft;
    data.renderHeight = (data.viewHeight * bufferRatio);
    if (data.viewWidth > 0 && data.viewHeight > 0) {
        data.itmWidth = calcWidth(data.viewWidth, approxItemWidth);
        data.itmHeight = calcHeight(data.viewHeight, approxItemHeight);
        data.hdrWidth = calcWidth(data.viewWidth, appoxHeaderWidth);
        data.hdrHeight = calcHeight(data.viewHeight, approxHeaderHeight);
        data.ftrWidth = calcWidth(data.viewWidth, approxFooterWidth);
        data.ftrHeight = calcHeight(data.viewHeight, approxFooterHeight);
        data.valid = true;
    }
}
function calcWidth(viewportWidth, approxWidth) {
    if (approxWidth.indexOf('%') > 0) {
        return (viewportWidth * (parseFloat(approxWidth) / 100));
    }
    else if (approxWidth.indexOf('px') > 0) {
        return parseFloat(approxWidth);
    }
    throw 'virtual scroll width can only use "%" or "px" units';
}
function calcHeight(_viewportHeight, approxHeight) {
    if (approxHeight.indexOf('px') > 0) {
        return parseFloat(approxHeight);
    }
    throw 'virtual scroll height must use "px" units';
}
function getElement(node) {
    const rootNodes = node.view.rootNodes;
    for (var i = 0; i < rootNodes.length; i++) {
        if (rootNodes[i].nodeType === 1) {
            return rootNodes[i];
        }
    }
    return null;
}
class VirtualContext {
    constructor($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
        this.bounds = {};
    }
    get first() { return this.index === 0; }
    get last() { return this.index === this.count - 1; }
    get even() { return this.index % 2 === 0; }
    get odd() { return !this.even; }
}
const TEMPLATE_ITEM = 0;
const TEMPLATE_HEADER = 1;
const TEMPLATE_FOOTER = 2;
const VIEWABLE_RENDERED_PADDING = 3;
const REQUIRED_DOM_READS = 2;
//# sourceMappingURL=virtual-util.js.map
// CONCATENATED MODULE: ./src/components/virtual-scroll/virtual-scroll.ts













let virtual_scroll_VirtualScroll = class VirtualScroll {
    constructor(_iterableDiffers, _elementRef, _renderer, _zone, _cd, _content, _plt, _ctrl, _config, _dom) {
        this._iterableDiffers = _iterableDiffers;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._zone = _zone;
        this._cd = _cd;
        this._content = _content;
        this._plt = _plt;
        this._ctrl = _ctrl;
        this._config = _config;
        this._dom = _dom;
        this._init = false;
        this._lastEle = false;
        this._records = [];
        this._cells = [];
        this._nodes = [];
        this._vHeight = 0;
        this._lastCheck = 0;
        this._recordSize = 0;
        this._data = {
            scrollTop: 0,
        };
        this._queue = SCROLL_QUEUE_NO_CHANGES;
        this.bufferRatio = 3;
        this.approxItemWidth = '100%';
        this.approxHeaderWidth = '100%';
        this.approxHeaderHeight = '40px';
        this.approxFooterWidth = '100%';
        this.approxFooterHeight = '40px';
        this.setElementClass('virtual-loading', true);
        const readSub = _ctrl.readReady.subscribe(() => {
            readSub.unsubscribe();
            this.readUpdate(true);
        });
        const writeSub = _ctrl.writeReady.subscribe(() => {
            writeSub.unsubscribe();
            this._init = true;
            this.writeUpdate(true);
            this._listeners();
        });
    }
    set virtualScroll(val) {
        this._records = val;
        this._updateDiffer();
    }
    set headerFn(val) {
        if (isFunction(val)) {
            this._hdrFn = val.bind((this._ctrl._cmp) || this);
        }
    }
    set footerFn(val) {
        if (isFunction(val)) {
            this._ftrFn = val.bind((this._ctrl._cmp) || this);
        }
    }
    set virtualTrackBy(val) {
        if (isPresent(val)) {
            this._virtualTrackBy = val;
            this._updateDiffer();
        }
    }
    get virtualTrackBy() {
        return this._virtualTrackBy;
    }
    firstRecord() {
        const cells = this._cells;
        return (cells.length > 0) ? cells[0].record : 0;
    }
    lastRecord() {
        const cells = this._cells;
        return (cells.length > 0) ? cells[cells.length - 1].record : 0;
    }
    ngDoCheck() {
        if (!this._init) {
            return;
        }
        const changes = this._changes();
        if (!isPresent(changes)) {
            return;
        }
        let needClean = false;
        if (changes) {
            var lastRecord = this._recordSize;
            changes.forEachOperation((_, pindex, cindex) => {
                if (pindex === null && (cindex < lastRecord)) {
                    console.debug('adding record before current position, slow path');
                    needClean = true;
                    return;
                }
                if (pindex < lastRecord && cindex === null) {
                    console.debug('removing record before current position, slow path');
                    needClean = true;
                    return;
                }
            });
        }
        else {
            needClean = true;
        }
        this._recordSize = this._records.length;
        this.readUpdate(needClean);
        this.writeUpdate(needClean);
    }
    readUpdate(needClean) {
        if (needClean) {
            console.debug('virtual-scroll, readUpdate: slow path');
            this._cells.length = 0;
            this._nodes.length = 0;
            this._itmTmp.viewContainer.clear();
            this.calcDimensions();
        }
        else {
            console.debug(`virtual-scroll, readUpdate: fast path`);
        }
    }
    writeUpdate(needClean) {
        console.debug('virtual-scroll, writeUpdate need clean:', needClean);
        const data = this._data;
        const stopAtHeight = (data.scrollTop + data.renderHeight);
        data.scrollDiff = SCROLL_DIFFERENCE_MINIMUM + 1;
        processRecords(stopAtHeight, this._records, this._cells, this._hdrFn, this._ftrFn, this._data);
        this.renderVirtual(needClean);
    }
    calcDimensions() {
        calcDimensions(this._data, this._elementRef.nativeElement, this.approxItemWidth, this.approxItemHeight, this.approxHeaderWidth, this.approxHeaderHeight, this.approxFooterWidth, this.approxFooterHeight, this.bufferRatio);
    }
    _changes() {
        if (isPresent(this._records) && isPresent(this._differ)) {
            return this._differ.diff(this._records);
        }
        return null;
    }
    _updateDiffer() {
        if (isPresent(this._records)) {
            this._differ = this._iterableDiffers.find(this._records).create(this._virtualTrackBy);
        }
    }
    renderVirtual(needClean) {
        this._plt.raf(() => {
            const nodes = this._nodes;
            const cells = this._cells;
            const data = this._data;
            const records = this._records;
            if (needClean) {
                updateDimensions(this._plt, nodes, cells, data, true);
                data.topCell = 0;
                data.bottomCell = (cells.length - 1);
            }
            adjustRendered(cells, data);
            this._zone.run(() => {
                populateNodeData(data.topCell, data.bottomCell, true, cells, records, nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef, needClean);
            });
            if (needClean) {
                this._cd.detectChanges();
            }
            this._dom.read(() => initReadNodes(this._plt, nodes, cells, data));
            this._dom.write(() => {
                updateNodeContext(nodes, cells, data);
                this._stepChangeDetection();
                this._stepDOMWrite();
                this._content.imgsUpdate();
                if (!this._lastEle) {
                    var ele = this._elementRef.nativeElement;
                    var lastEle = this._renderer.createElement(ele, 'div');
                    lastEle.className = 'virtual-last';
                    this._lastEle = true;
                    this.setElementClass('virtual-scroll', true);
                    this.setElementClass('virtual-loading', false);
                }
                _assert(this._queue === SCROLL_QUEUE_NO_CHANGES, 'queue value should be NO_CHANGES');
            });
        });
    }
    resize() {
        if (!this._init) {
            return;
        }
        console.debug('virtual-list: resized window');
        this.calcDimensions();
        this.writeUpdate(false);
    }
    _stepDOMWrite() {
        const cells = this._cells;
        const nodes = this._nodes;
        const recordsLength = this._records.length;
        writeToNodes(this._plt, nodes, cells, recordsLength);
        this._setHeight(estimateHeight(recordsLength, cells[cells.length - 1], this._vHeight, 0.25));
        this._queue = SCROLL_QUEUE_NO_CHANGES;
    }
    _stepChangeDetection() {
        const nodes = this._nodes;
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].hasChanges) {
                nodes[i].view.detectChanges();
            }
        }
        this._queue = SCROLL_QUEUE_DOM_WRITE;
    }
    _stepNoChanges() {
        const data = this._data;
        const diff = data.scrollDiff = (data.scrollTop - this._lastCheck);
        if (Math.abs(diff) < SCROLL_DIFFERENCE_MINIMUM) {
            return;
        }
        const cells = this._cells;
        const nodes = this._nodes;
        const records = this._records;
        this._lastCheck = data.scrollTop;
        if (diff > 0) {
            var stopAtHeight = (data.scrollTop + data.renderHeight);
            processRecords(stopAtHeight, records, cells, this._hdrFn, this._ftrFn, data);
        }
        updateDimensions(this._plt, nodes, cells, data, false);
        adjustRendered(cells, data);
        var hasChanges = populateNodeData(data.topCell, data.bottomCell, diff > 0, cells, records, nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef, false);
        if (hasChanges) {
            this._queue = SCROLL_QUEUE_CHANGE_DETECTION;
            updateNodeContext(nodes, cells, data);
        }
    }
    scrollUpdate(ev) {
        this._data.scrollTop = ev.scrollTop;
        const queue = this._queue;
        if (queue === SCROLL_QUEUE_NO_CHANGES) {
            this._stepNoChanges();
        }
        else if (queue === SCROLL_QUEUE_CHANGE_DETECTION) {
            this._dom.write(() => this._stepChangeDetection());
        }
        else {
            _assert(queue === SCROLL_QUEUE_DOM_WRITE, 'queue value unexpected');
            this._dom.write(() => this._stepDOMWrite());
        }
    }
    scrollEnd() {
        updateDimensions(this._plt, this._nodes, this._cells, this._data, false);
        adjustRendered(this._cells, this._data);
        this._dom.write(() => {
            updateNodeContext(this._nodes, this._cells, this._data);
            this._stepChangeDetection();
            this._stepDOMWrite();
        });
    }
    _listeners() {
        _assert(!this._scrollSub, '_listeners was already called');
        if (!this._scrollSub) {
            if (this._config.getBoolean('virtualScrollEventAssist')) {
                this._content.enableJsScroll();
            }
            this._resizeSub = this._plt.resize.subscribe(this.resize.bind(this));
            this._scrollSub = this._content.ionScroll.subscribe(this.scrollUpdate.bind(this));
            this._scrollEndSub = this._content.ionScrollEnd.subscribe(this.scrollEnd.bind(this));
        }
    }
    _setHeight(newVirtualHeight) {
        if (newVirtualHeight !== this._vHeight) {
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'height', newVirtualHeight > 0 ? newVirtualHeight + 'px' : '');
            this._vHeight = newVirtualHeight;
            console.debug('VirtualScroll, height', newVirtualHeight);
        }
    }
    ngAfterContentInit() {
        _assert(this._itmTmp, 'virtualItem required within virtualScroll');
        if (!this.approxItemHeight) {
            this.approxItemHeight = '40px';
            console.warn('Virtual Scroll: Please provide an "approxItemHeight" input to ensure proper virtual scroll rendering');
        }
    }
    setElementClass(className, add) {
        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);
    }
    ngOnDestroy() {
        this._resizeSub && this._resizeSub.unsubscribe();
        this._scrollSub && this._scrollSub.unsubscribe();
        this._scrollEndSub && this._scrollEndSub.unsubscribe();
        this._resizeSub = this._scrollEndSub = this._scrollSub = null;
        this._hdrFn = this._ftrFn = this._records = this._cells = this._nodes = this._data = null;
    }
};
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(VirtualItem),
    Object(tslib_es6["__metadata"])("design:type", typeof (virtual_scroll__a = typeof VirtualItem !== "undefined" && VirtualItem) === "function" && virtual_scroll__a || Object)
], virtual_scroll_VirtualScroll.prototype, "_itmTmp", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(VirtualHeader),
    Object(tslib_es6["__metadata"])("design:type", typeof (virtual_scroll__b = typeof VirtualHeader !== "undefined" && VirtualHeader) === "function" && virtual_scroll__b || Object)
], virtual_scroll_VirtualScroll.prototype, "_hdrTmp", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["m" /* ContentChild */])(VirtualFooter),
    Object(tslib_es6["__metadata"])("design:type", typeof (virtual_scroll__c = typeof VirtualFooter !== "undefined" && VirtualFooter) === "function" && virtual_scroll__c || Object)
], virtual_scroll_VirtualScroll.prototype, "_ftrTmp", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], virtual_scroll_VirtualScroll.prototype, "virtualScroll", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Number)
], virtual_scroll_VirtualScroll.prototype, "bufferRatio", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], virtual_scroll_VirtualScroll.prototype, "approxItemWidth", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], virtual_scroll_VirtualScroll.prototype, "approxItemHeight", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], virtual_scroll_VirtualScroll.prototype, "approxHeaderWidth", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], virtual_scroll_VirtualScroll.prototype, "approxHeaderHeight", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], virtual_scroll_VirtualScroll.prototype, "approxFooterWidth", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", String)
], virtual_scroll_VirtualScroll.prototype, "approxFooterHeight", void 0);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], virtual_scroll_VirtualScroll.prototype, "headerFn", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [Object])
], virtual_scroll_VirtualScroll.prototype, "footerFn", null);
Object(tslib_es6["__decorate"])([
    Object(core_es5["z" /* Input */])(),
    Object(tslib_es6["__metadata"])("design:type", typeof (virtual_scroll__d = typeof core_es5["TrackByFn"] !== "undefined" && core_es5["TrackByFn"]) === "function" && virtual_scroll__d || Object),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (virtual_scroll__e = typeof core_es5["TrackByFn"] !== "undefined" && core_es5["TrackByFn"]) === "function" && virtual_scroll__e || Object])
], virtual_scroll_VirtualScroll.prototype, "virtualTrackBy", null);
virtual_scroll_VirtualScroll = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '[virtualScroll]'
    }),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (virtual_scroll__f = typeof core_es5["A" /* IterableDiffers */] !== "undefined" && core_es5["A" /* IterableDiffers */]) === "function" && virtual_scroll__f || Object, typeof (virtual_scroll__g = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && virtual_scroll__g || Object, typeof (virtual_scroll__h = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && virtual_scroll__h || Object, typeof (virtual_scroll__j = typeof core_es5["G" /* NgZone */] !== "undefined" && core_es5["G" /* NgZone */]) === "function" && virtual_scroll__j || Object, typeof (virtual_scroll__k = typeof core_es5["i" /* ChangeDetectorRef */] !== "undefined" && core_es5["i" /* ChangeDetectorRef */]) === "function" && virtual_scroll__k || Object, typeof (virtual_scroll__l = typeof content_Content !== "undefined" && content_Content) === "function" && virtual_scroll__l || Object, typeof (virtual_scroll__m = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && virtual_scroll__m || Object, typeof (virtual_scroll__o = typeof view_controller_ViewController !== "undefined" && view_controller_ViewController) === "function" && virtual_scroll__o || Object, typeof (virtual_scroll__p = typeof config_Config !== "undefined" && config_Config) === "function" && virtual_scroll__p || Object, typeof (virtual_scroll__q = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && virtual_scroll__q || Object])
], virtual_scroll_VirtualScroll);

const SCROLL_DIFFERENCE_MINIMUM = 40;
const SCROLL_QUEUE_NO_CHANGES = 1;
const SCROLL_QUEUE_CHANGE_DETECTION = 2;
const SCROLL_QUEUE_DOM_WRITE = 3;
var virtual_scroll__a, virtual_scroll__b, virtual_scroll__c, virtual_scroll__d, virtual_scroll__e, virtual_scroll__f, virtual_scroll__g, virtual_scroll__h, virtual_scroll__j, virtual_scroll__k, virtual_scroll__l, virtual_scroll__m, virtual_scroll__o, virtual_scroll__p, virtual_scroll__q;




// CONCATENATED MODULE: ./src/navigation/ionic-page.ts
function IonicPage(_config) {
    return function (clazz) {
        return clazz;
    };
}
//# sourceMappingURL=ionic-page.js.map
// CONCATENATED MODULE: ./src/tap-click/activator-base.ts
class ActivatorBase {
}
function isActivatedDisabled(ev, activatableEle) {
    if (!activatableEle || !activatableEle.parentNode) {
        return true;
    }
    if (!ev) {
        return false;
    }
    if (ev.defaultPrevented) {
        return true;
    }
    let targetEle = ev.target;
    for (let i = 0; i < 4; i++) {
        if (!targetEle) {
            break;
        }
        if (targetEle.hasAttribute('disable-activated')) {
            return true;
        }
        targetEle = targetEle.parentElement;
    }
    return false;
}
//# sourceMappingURL=activator-base.js.map
// CONCATENATED MODULE: ./src/tap-click/activator.ts

class activator_Activator {
    constructor(app, config, dom) {
        this.app = app;
        this.dom = dom;
        this._queue = [];
        this._active = [];
        this.activatedDelay = ADD_ACTIVATED_DEFERS;
        this.clearDelay = CLEAR_STATE_DEFERS;
        this._css = config.get('activatedClass', 'activated');
    }
    clickAction(ev, activatableEle, _startCoord) {
        if (isActivatedDisabled(ev, activatableEle)) {
            return;
        }
        this._scheduleClear();
        this._queue.length = 0;
        for (var i = 0; i < this._active.length; i++) {
            this._active[i].classList.remove(this._css);
        }
        this._active.length = 0;
        if (activatableEle && activatableEle.parentNode) {
            this._active.push(activatableEle);
            activatableEle.classList.add(this._css);
        }
    }
    downAction(ev, activatableEle, _startCoord) {
        if (isActivatedDisabled(ev, activatableEle)) {
            return;
        }
        this.unscheduleClear();
        this.deactivate(true);
        this._queue.push(activatableEle);
        this._activeDefer = this.dom.write(() => {
            this._activeDefer = null;
            let activatableEle;
            for (let i = 0; i < this._queue.length; i++) {
                activatableEle = this._queue[i];
                this._active.push(activatableEle);
                activatableEle.classList.add(this._css);
            }
            this._queue.length = 0;
        }, this.activatedDelay);
    }
    upAction(_ev, _activatableEle, _startCoord) {
        this._scheduleClear();
    }
    _scheduleClear() {
        if (this._clearDefer) {
            return;
        }
        this._clearDefer = this.dom.write(() => {
            this.clearState(true);
            this._clearDefer = null;
        }, this.clearDelay);
    }
    unscheduleClear() {
        if (this._clearDefer) {
            this._clearDefer();
            this._clearDefer = null;
        }
    }
    clearState(animated) {
        if (!this.app.isEnabled()) {
            this.dom.write(() => {
                this.clearState(animated);
            }, 600);
        }
        else {
            this.deactivate(animated);
        }
    }
    deactivate(animated) {
        this._clearDeferred();
        this._queue.length = 0;
        let ele;
        for (var i = 0; i < this._active.length; i++) {
            ele = this._active[i];
            ele.style[this.dom.plt.Css.transition] = animated ? '' : 'none';
            ele.classList.remove(this._css);
        }
        this._active.length = 0;
    }
    _clearDeferred() {
        if (this._activeDefer) {
            this._activeDefer();
            this._activeDefer = null;
        }
    }
}
const ADD_ACTIVATED_DEFERS = 80;
const CLEAR_STATE_DEFERS = 80;
//# sourceMappingURL=activator.js.map
// CONCATENATED MODULE: ./src/tap-click/ripple.ts



class ripple_RippleActivator {
    constructor(app, config, dom) {
        this.dom = dom;
        this.highlight = new activator_Activator(app, config, dom);
    }
    clickAction(ev, activatableEle, startCoord) {
        this.highlight && this.highlight.clickAction(ev, activatableEle, startCoord);
        this._clickAction(ev, activatableEle, startCoord);
    }
    downAction(ev, activatableEle, startCoord) {
        this.highlight && this.highlight.downAction(ev, activatableEle, startCoord);
        this._downAction(ev, activatableEle, startCoord);
    }
    upAction(ev, activatableEle, startCoord) {
        this.highlight && this.highlight.upAction(ev, activatableEle, startCoord);
        this._upAction(ev, activatableEle, startCoord);
    }
    clearState(animated) {
        this.highlight && this.highlight.clearState(animated);
    }
    _downAction(ev, activatableEle, _startCoord) {
        if (isActivatedDisabled(ev, activatableEle)) {
            return;
        }
        var j = activatableEle.childElementCount;
        while (j--) {
            var rippleEle = activatableEle.children[j];
            if (rippleEle.classList.contains('button-effect')) {
                var clientRect = activatableEle.getBoundingClientRect();
                rippleEle.$top = clientRect.top;
                rippleEle.$left = clientRect.left;
                rippleEle.$width = clientRect.width;
                rippleEle.$height = clientRect.height;
                break;
            }
        }
    }
    _upAction(ev, activatableEle, startCoord) {
        if (!hasPointerMoved(6, startCoord, pointerCoord(ev))) {
            let i = activatableEle.childElementCount;
            while (i--) {
                var rippleEle = activatableEle.children[i];
                if (rippleEle.classList.contains('button-effect')) {
                    this.startRippleEffect(rippleEle, activatableEle, startCoord);
                    break;
                }
            }
        }
    }
    _clickAction(_ev, _activatableEle, _startCoord) {
    }
    startRippleEffect(rippleEle, activatableEle, startCoord) {
        if (!startCoord) {
            return;
        }
        let clientPointerX = (startCoord.x - rippleEle.$left);
        let clientPointerY = (startCoord.y - rippleEle.$top);
        let x = Math.max(Math.abs(rippleEle.$width - clientPointerX), clientPointerX) * 2;
        let y = Math.max(Math.abs(rippleEle.$height - clientPointerY), clientPointerY) * 2;
        let diameter = Math.min(Math.max(Math.hypot(x, y), 64), 240);
        if (activatableEle.hasAttribute('ion-item')) {
            diameter = Math.min(diameter, 140);
        }
        clientPointerX -= diameter / 2;
        clientPointerY -= diameter / 2;
        clientPointerX = Math.round(clientPointerX);
        clientPointerY = Math.round(clientPointerY);
        diameter = Math.round(diameter);
        const Css = this.dom.plt.Css;
        rippleEle.style.opacity = '';
        rippleEle.style[Css.transform] = `translate3d(${clientPointerX}px, ${clientPointerY}px, 0px) scale(0.001)`;
        rippleEle.style[Css.transition] = '';
        let radius = Math.sqrt(rippleEle.$width + rippleEle.$height);
        let scaleTransitionDuration = Math.max(1600 * Math.sqrt(radius / TOUCH_DOWN_ACCEL) + 0.5, 260);
        let opacityTransitionDuration = Math.round(scaleTransitionDuration * 0.7);
        let opacityTransitionDelay = Math.round(scaleTransitionDuration - opacityTransitionDuration);
        scaleTransitionDuration = Math.round(scaleTransitionDuration);
        let transform = `translate3d(${clientPointerX}px, ${clientPointerY}px, 0px) scale(1)`;
        let transition = `transform ${scaleTransitionDuration}ms,opacity ${opacityTransitionDuration}ms ${opacityTransitionDelay}ms`;
        this.dom.write(() => {
            rippleEle.style.width = rippleEle.style.height = diameter + 'px';
            rippleEle.style.opacity = '0';
            rippleEle.style[Css.transform] = transform;
            rippleEle.style[Css.transition] = transition;
        }, 16);
    }
}
const TOUCH_DOWN_ACCEL = 300;
//# sourceMappingURL=ripple.js.map
// CONCATENATED MODULE: ./src/tap-click/tap-click.ts














let tap_click_TapClick = class TapClick {
    constructor(config, plt, dom, app, gestureCtrl) {
        this.plt = plt;
        this.app = app;
        this.gestureCtrl = gestureCtrl;
        this.disableClick = 0;
        this.events = new ui_event_manager_UIEventManager(plt);
        let activator = config.get('activator');
        if (activator === 'ripple') {
            this.activator = new ripple_RippleActivator(app, config, dom);
        }
        else if (activator === 'highlight') {
            this.activator = new activator_Activator(app, config, dom);
        }
        this.usePolyfill = config.getBoolean('tapPolyfill');
        console.debug('Using usePolyfill:', this.usePolyfill);
        const doc = plt.doc();
        this.events.listen(doc, 'click', this.click.bind(this), { passive: false, capture: true });
        this.pointerEvents = this.events.pointerEvents({
            element: doc,
            pointerDown: this.pointerStart.bind(this),
            pointerMove: this.pointerMove.bind(this),
            pointerUp: this.pointerEnd.bind(this),
            passive: true
        });
        this.pointerEvents.mouseWait = DISABLE_NATIVE_CLICK_AMOUNT;
    }
    pointerStart(ev) {
        if (this.startCoord) {
            return false;
        }
        if (!this.app.isEnabled()) {
            return false;
        }
        this.lastTouchEnd = 0;
        this.dispatchClick = true;
        if (this.plt.doc() === ev.target) {
            this.startCoord = pointerCoord(ev);
            return true;
        }
        let activatableEle = getActivatableTarget(ev.target);
        if (!activatableEle) {
            this.startCoord = null;
            return false;
        }
        this.startCoord = pointerCoord(ev);
        this.activator && this.activator.downAction(ev, activatableEle, this.startCoord);
        return true;
    }
    pointerMove(ev) {
        if (this.startCoord && this.shouldCancelEvent(ev)) {
            this.pointerCancel(ev);
        }
    }
    pointerEnd(ev, pointerEventType) {
        if (!this.dispatchClick)
            return;
        _runInDev(() => this.lastTouchEnd = Date.now());
        if (!this.startCoord) {
            return;
        }
        if (this.activator && ev.target !== this.plt.doc()) {
            let activatableEle = getActivatableTarget(ev.target);
            if (activatableEle) {
                this.activator.upAction(ev, activatableEle, this.startCoord);
            }
        }
        if (this.usePolyfill && pointerEventType === POINTER_EVENT_TYPE_TOUCH && this.app.isEnabled()) {
            this.handleTapPolyfill(ev);
        }
        this.startCoord = null;
    }
    pointerCancel(ev) {
        console.debug(`pointerCancel from ${ev.type} ${Date.now()}`);
        this.startCoord = null;
        this.dispatchClick = false;
        this.activator && this.activator.clearState(false);
        this.pointerEvents.stop();
    }
    shouldCancelEvent(ev) {
        return (this.app.isScrolling() ||
            this.gestureCtrl.isCaptured() ||
            hasPointerMoved(POINTER_TOLERANCE, this.startCoord, pointerCoord(ev)));
    }
    click(ev) {
        if (this.shouldCancelClick(ev)) {
            ev.preventDefault();
            ev.stopPropagation();
            return;
        }
        if (this.activator && this.plt.doc() !== ev.target) {
            const activatableEle = getActivatableTarget(ev.target);
            if (activatableEle) {
                this.activator.clickAction(ev, activatableEle, this.startCoord);
            }
        }
        _runInDev(() => this.profileClickDelay(ev));
    }
    shouldCancelClick(ev) {
        if (this.usePolyfill) {
            if (!ev.isIonicTap && this.isDisabledNativeClick()) {
                console.debug('click prevent: nativeClick');
                return true;
            }
        }
        else if (!this.dispatchClick) {
            console.debug('click prevent: tap-click');
            return true;
        }
        if (!this.app.isEnabled()) {
            console.debug('click prevent: appDisabled');
            return true;
        }
        if (this.gestureCtrl.isCaptured()) {
            console.debug('click prevent: tap-click (gesture is captured)');
            return true;
        }
        return false;
    }
    profileClickDelay(ev) {
        if (this.lastTouchEnd) {
            let diff = Date.now() - this.lastTouchEnd;
            if (diff < 100) {
                console.debug(`FAST click dispatched. Delay(ms):`, diff);
            }
            else {
                console.warn(`SLOW click dispatched. Delay(ms):`, diff, ev);
            }
            this.lastTouchEnd = null;
        }
        else {
            console.debug('Click dispatched. Unknown delay');
        }
    }
    handleTapPolyfill(ev) {
        _assert(this.usePolyfill, 'this code should not be used if tapPolyfill is disabled');
        let endCoord = pointerCoord(ev);
        if (hasPointerMoved(POINTER_TOLERANCE, this.startCoord, endCoord)) {
            console.debug(`click from touch prevented by pointer moved`);
            return;
        }
        this.disableClick = Date.now() + DISABLE_NATIVE_CLICK_AMOUNT;
        if (this.app.isScrolling()) {
            console.debug(`click from touch prevented by scrolling ${Date.now()}`);
        }
        else {
            console.debug(`create click from touch ${Date.now()}`);
            let clickEvent = this.plt.doc().createEvent('MouseEvents');
            clickEvent.initMouseEvent('click', true, true, this.plt.win(), 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
            clickEvent.isIonicTap = true;
            ev.target.dispatchEvent(clickEvent);
        }
    }
    isDisabledNativeClick() {
        return this.disableClick > Date.now();
    }
};
tap_click_TapClick = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])(),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (tap_click__a = typeof config_Config !== "undefined" && config_Config) === "function" && tap_click__a || Object, typeof (tap_click__b = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && tap_click__b || Object, typeof (tap_click__c = typeof dom_controller_DomController !== "undefined" && dom_controller_DomController) === "function" && tap_click__c || Object, typeof (tap_click__d = typeof app_App !== "undefined" && app_App) === "function" && tap_click__d || Object, typeof (tap_click__e = typeof GestureController !== "undefined" && GestureController) === "function" && tap_click__e || Object])
], tap_click_TapClick);

function getActivatableTarget(ele) {
    let targetEle = ele;
    for (let x = 0; x < 10; x++) {
        if (!targetEle)
            break;
        if (isActivatable(targetEle)) {
            return targetEle;
        }
        targetEle = targetEle.parentElement;
    }
    return null;
}
function isActivatable(ele) {
    if (ACTIVATABLE_ELEMENTS.indexOf(ele.tagName) > -1) {
        return true;
    }
    for (let i = 0, l = ACTIVATABLE_ATTRIBUTES.length; i < l; i++) {
        if (ele.hasAttribute && ele.hasAttribute(ACTIVATABLE_ATTRIBUTES[i])) {
            return true;
        }
    }
    return false;
}
const ACTIVATABLE_ELEMENTS = ['A', 'BUTTON'];
const ACTIVATABLE_ATTRIBUTES = ['tappable', 'ion-button'];
const POINTER_TOLERANCE = 100;
const DISABLE_NATIVE_CLICK_AMOUNT = 2500;
function setupTapClick(config, plt, dom, app, gestureCtrl) {
    return function () {
        return new tap_click_TapClick(config, plt, dom, app, gestureCtrl);
    };
}
var tap_click__a, tap_click__b, tap_click__c, tap_click__d, tap_click__e;




// CONCATENATED MODULE: ./src/gestures/hammer.ts
const hammer_win = window;
const hammer_doc = document;
var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = hammer_doc.createElement('div');
var TYPE_FUNCTION = 'function';
var hammer_round = Math.round;
var abs = Math.abs;
var hammer_now = Date.now;
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}
function each(obj, iterator, context) {
    var i;
    if (!obj) {
        return;
    }
    if (obj.forEach) {
        obj.forEach(iterator, context);
    }
    else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    }
    else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}
function inherit(child, base, properties) {
    var baseP = base.prototype, childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;
    if (properties) {
        Object.assign(childP, properties);
    }
}
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}
function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
        target.addEventListener(type, handler, false);
    });
}
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
        target.removeEventListener(type, handler, false);
    });
}
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}
function inStr(str, find) {
    return str.indexOf(find) > -1;
}
function splitStr(str) {
    return str.trim().split(/\s+/g);
}
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    }
    else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;
    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }
    if (sort) {
        if (!key) {
            results = results.sort();
        }
        else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key] ? 1 : 0;
            });
        }
    }
    return results;
}
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;
        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}
var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';
var COMPUTE_INTERVAL = 25;
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;
    this.domHandler = function (ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };
    this.init();
}
Input.prototype = {
    handler: function () { },
    init: function () {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },
    destroy: function () {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;
    if (inputClass) {
        Type = inputClass;
    }
    else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    }
    else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    }
    else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    }
    else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;
    if (isFirst) {
        manager.session = {};
    }
    input.eventType = eventType;
    computeInputData(manager, input);
    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
}
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    }
    else if (pointersLength === 1) {
        session.firstMultiple = false;
    }
    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = hammer_now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);
    computeIntervalInputData(session, input);
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}
function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};
    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };
        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }
    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;
        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);
        session.lastInterval = input;
    }
    else {
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }
    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}
function simpleCloneInputData(input) {
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: hammer_round(input.pointers[i].clientX),
            clientY: hammer_round(input.pointers[i].clientY)
        };
        i++;
    }
    return {
        timeStamp: hammer_now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}
function getCenter(pointers) {
    var pointersLength = pointers.length;
    if (pointersLength === 1) {
        return {
            x: hammer_round(pointers[0].clientX),
            y: hammer_round(pointers[0].clientY)
        };
    }
    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }
    return {
        x: hammer_round(x / pointersLength),
        y: hammer_round(y / pointersLength)
    };
}
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }
    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
    return Math.sqrt((x * x) + (y * y));
}
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}
var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};
var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
function MouseInput(_manager, _handler) {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.allow = true;
    this.pressed = false;
    Input.apply(this, arguments);
}
inherit(MouseInput, Input, {
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }
        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }
        if (!this.pressed || !this.allow) {
            return;
        }
        if (eventType & INPUT_END) {
            this.pressed = false;
        }
        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});
var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT
};
var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
if (hammer_win.MSPointerEvent && !hammer_win.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = (this.manager.session.pointerEvents = []);
}
inherit(PointerEventInput, Input, {
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;
        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
        var isTouch = (pointerType == INPUT_TYPE_TOUCH);
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        }
        else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }
        if (storeIndex < 0) {
            return;
        }
        store[storeIndex] = ev;
        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });
        if (removePointer) {
            store.splice(storeIndex, 1);
        }
    }
});
var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};
var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
}
inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
        if (type === INPUT_START) {
            this.started = true;
        }
        if (!this.started) {
            return;
        }
        var touches = normalizeSingleTouches.call(this, ev, type);
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }
        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);
    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }
    return [all, changed];
}
var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};
var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
function TouchInput(_manager, _handler) {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
}
inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }
        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }
    var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
    targetTouches = allTouches.filter(function (touch) {
        return hasParent(touch.target, target);
    });
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }
    if (!changedTargetTouches.length) {
        return;
    }
    return [
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}
function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}
inherit(TouchMouseInput, Input, {
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH), isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);
        if (isTouch) {
            this.mouse.allow = false;
        }
        else if (isMouse && !this.mouse.allow) {
            return;
        }
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }
        this.callback(manager, inputEvent, inputData);
    },
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});
var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation';
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}
TouchAction.prototype = {
    set: function (value) {
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }
        if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },
    update: function () {
        this.set(this.manager.options.touchAction);
    },
    compute: function () {
        var actions = [];
        each(this.manager.recognizers, function (recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },
    preventDefaults: function (input) {
        if (NATIVE_TOUCH_ACTION) {
            return;
        }
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }
        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }
        if (hasPanX && hasPanY) {
            return;
        }
        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },
    preventSrc: function (srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};
function cleanTouchActions(actions) {
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }
    return TOUCH_ACTION_AUTO;
}
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;
function Recognizer(options) {
    this.options = Object.assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null;
    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
}
Recognizer.prototype = {
    defaults: {},
    set: function (options) {
        Object.assign(this.options, options);
        this.manager && this.manager.touchAction.update();
        return this;
    },
    recognizeWith: function (otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }
        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },
    dropRecognizeWith: function (otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },
    requireFailure: function (otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }
        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },
    dropRequireFailure: function (otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },
    hasRequireFailures: function () {
        return this.requireFail.length > 0;
    },
    canRecognizeWith: function (otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },
    emit: function (input) {
        var self = this;
        var state = this.state;
        function emit(event) {
            self.manager.emit(event, input);
        }
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
        emit(self.options.event);
        if (input.additionalEvent) {
            emit(input.additionalEvent);
        }
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },
    tryEmit: function (input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        this.state = STATE_FAILED;
    },
    canEmit: function () {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },
    recognize: function (inputData) {
        var inputDataClone = Object.assign({}, inputData);
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }
        this.state = this.process(inputDataClone);
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },
    process: function (_inputData) { },
    getTouchAction: function () { },
    reset: function () { }
};
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    }
    else if (state & STATE_ENDED) {
        return 'end';
    }
    else if (state & STATE_CHANGED) {
        return 'move';
    }
    else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    }
    else if (direction == DIRECTION_UP) {
        return 'up';
    }
    else if (direction == DIRECTION_LEFT) {
        return 'left';
    }
    else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}
inherit(AttrRecognizer, Recognizer, {
    defaults: {
        pointers: 1
    },
    attrTest: function (input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },
    process: function (input) {
        var state = this.state;
        var eventType = input.eventType;
        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        }
        else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            }
            else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});
function hammer_PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
}
inherit(hammer_PanRecognizer, AttrRecognizer, {
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },
    getTouchAction: function () {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },
    directionTest: function (input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            }
            else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function (input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },
    emit: function (input) {
        this.pX = input.deltaX;
        this.pY = input.deltaY;
        var direction = directionStr(input.direction);
        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}
inherit(PinchRecognizer, AttrRecognizer, {
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },
    getTouchAction: function () {
        return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function (input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});
function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
}
inherit(PressRecognizer, Recognizer, {
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251,
        threshold: 9
    },
    getTouchAction: function () {
        return [TOUCH_ACTION_AUTO];
    },
    process: function (input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;
        this._input = input;
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        }
        else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function () {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        }
        else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },
    reset: function () {
        clearTimeout(this._timer);
    },
    emit: function (input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }
        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        }
        else {
            this._input.timeStamp = hammer_now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}
inherit(RotateRecognizer, AttrRecognizer, {
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },
    getTouchAction: function () {
        return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}
inherit(SwipeRecognizer, AttrRecognizer, {
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },
    getTouchAction: function () {
        return hammer_PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function (input) {
        var direction = this.options.direction;
        var velocity;
        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        }
        else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        }
        else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }
        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function (input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }
        this.manager.emit(this.options.event, input);
    }
});
function TapRecognizer() {
    Recognizer.apply(this, arguments);
    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
}
inherit(TapRecognizer, Recognizer, {
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300,
        time: 250,
        threshold: 9,
        posThreshold: 10
    },
    getTouchAction: function () {
        return [TOUCH_ACTION_MANIPULATION];
    },
    process: function (input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;
        this.reset();
        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }
            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
                this.count = 1;
            }
            else {
                this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                }
                else {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },
    failTimeout: function () {
        this._timer = setTimeoutContext(function () {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },
    reset: function () {
        clearTimeout(this._timer);
    },
    emit: function () {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, _defaults.preset);
    return new Manager(element, options);
}
var _defaults = {
    domEvents: false,
    touchAction: TOUCH_ACTION_COMPUTE,
    enable: true,
    inputTarget: null,
    inputClass: null,
    preset: [
        [RotateRecognizer, { enable: false }],
        [PinchRecognizer, { enable: false }, ['rotate']],
        [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
        [hammer_PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
        [PressRecognizer]
    ],
    cssProps: {
        userSelect: 'none',
        touchSelect: 'none',
        touchCallout: 'none',
        contentZooming: 'none',
        userDrag: 'none',
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};
var STOP = 1;
var FORCED_STOP = 2;
function Manager(element, options) {
    this.options = Object.assign({}, _defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}
Manager.prototype = {
    set: function (options) {
        Object.assign(this.options, options);
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },
    stop: function (force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },
    recognize: function (inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }
        this.touchAction.preventDefaults(inputData);
        var recognizer;
        var recognizers = this.recognizers;
        var curRecognizer = session.curRecognizer;
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }
        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer ||
                recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
            }
            else {
                recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },
    get: function (recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }
        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },
    add: function (recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }
        this.recognizers.push(recognizer);
        recognizer.manager = this;
        this.touchAction.update();
        return recognizer;
    },
    remove: function (recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }
        recognizer = this.get(recognizer);
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }
        return this;
    },
    on: function (events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function (event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },
    off: function (events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function (event) {
            if (!handler) {
                delete handlers[event];
            }
            else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },
    emit: function (event, data) {
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }
        data.type = event;
        data.preventDefault = function () {
            data.srcEvent.preventDefault();
        };
        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },
    destroy: function () {
        this.element && toggleCssProps(this, false);
        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    each(manager.options.cssProps, function (value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}
function triggerDomEvent(event, data) {
    var gestureEvent = hammer_doc.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}
Object.assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: hammer_PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});
hammer_win.Hammer = Hammer;

//# sourceMappingURL=hammer.js.map
// CONCATENATED MODULE: ./src/gestures/gesture.ts


class gesture_Gesture {
    constructor(element, opts = {}) {
        this._callbacks = {};
        this.isListening = false;
        defaults(opts, {
            domEvents: true
        });
        this.element = element;
        this.direction = opts.direction || 'x';
        opts.direction = this.direction === 'x' ?
            DIRECTION_HORIZONTAL :
            DIRECTION_VERTICAL;
        this._options = opts;
    }
    options(opts) {
        Object.assign(this._options, opts);
    }
    on(type, cb) {
        if (type === 'pinch' || type === 'rotate') {
            this._hammer.get(type).set({ enable: true });
        }
        this._hammer.on(type, cb);
        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
    }
    off(type, cb) {
        this._hammer.off(type, this._callbacks[type] ? cb : null);
    }
    listen() {
        if (!this.isListening) {
            this._hammer = Hammer(this.element, this._options);
        }
        this.isListening = true;
    }
    unlisten() {
        let eventType;
        let i;
        if (this._hammer && this.isListening) {
            for (eventType in this._callbacks) {
                for (i = 0; i < this._callbacks[eventType].length; i++) {
                    this._hammer.off(eventType, this._callbacks[eventType]);
                }
            }
            this._hammer.destroy();
        }
        this._callbacks = {};
        this._hammer = null;
        this.isListening = false;
    }
    destroy() {
        this.unlisten();
        this.element = this._options = null;
    }
}
//# sourceMappingURL=gesture.js.map
// CONCATENATED MODULE: ./src/util/events.ts

class Events {
    constructor() {
        this._channels = [];
    }
    subscribe(topic, ...handlers) {
        if (!this._channels[topic]) {
            this._channels[topic] = [];
        }
        handlers.forEach((handler) => {
            this._channels[topic].push(handler);
        });
    }
    unsubscribe(topic, handler = null) {
        let t = this._channels[topic];
        if (!t) {
            return false;
        }
        if (!handler) {
            delete this._channels[topic];
            return true;
        }
        let i = t.indexOf(handler);
        if (i < 0) {
            return false;
        }
        t.splice(i, 1);
        if (!t.length) {
            delete this._channels[topic];
        }
        return true;
    }
    publish(topic, ...args) {
        var t = this._channels[topic];
        if (!t) {
            return null;
        }
        let responses = [];
        t.forEach((handler) => {
            responses.push(handler(...args));
        });
        return responses;
    }
}
function setupEvents(plt, dom) {
    const events = new Events();
    const win = plt.win();
    const doc = plt.doc();
    plt.timeout(() => {
        win.addEventListener('online', (ev) => {
            events.publish('app:online', ev);
        }, false);
        win.addEventListener('offline', (ev) => {
            events.publish('app:offline', ev);
        }, false);
        win.addEventListener('orientationchange', (ev) => {
            events.publish('app:rotated', ev);
        });
        win.addEventListener('statusTap', () => {
            let el = doc.elementFromPoint(plt.width() / 2, plt.height() / 2);
            if (!el) {
                return;
            }
            let contentEle = el.closest('.scroll-content');
            if (contentEle) {
                var style = contentEle.style;
                var scroll = new scroll_view_ScrollView(null, plt, dom);
                scroll._el = contentEle;
                style['WebkitBackfaceVisibility'] = 'hidden';
                style['WebkitTransform'] = 'translate3d(0,0,0)';
                dom.write(function () {
                    style.overflow = 'hidden';
                    function finish() {
                        style.overflow = '';
                        style['WebkitBackfaceVisibility'] = '';
                        style['WebkitTransform'] = '';
                    }
                    let didScrollTimeout = plt.timeout(() => {
                        finish();
                    }, 400);
                    scroll.scrollTo(0, 0, 300).then(() => {
                        plt.cancelTimeout(didScrollTimeout);
                        finish();
                    });
                });
            }
        });
    }, 2000);
    return events;
}
function setupProvideEvents(plt, dom) {
    return function () {
        return setupEvents(plt, dom);
    };
}
//# sourceMappingURL=events.js.map
// CONCATENATED MODULE: ./src/util/ionic-error-handler.ts

class IonicErrorHandler extends core_es5["q" /* ErrorHandler */] {
    constructor() {
        super(false);
    }
    handleError(err) {
        super.handleError(err);
        try {
            const win = window;
            let monitor;
            monitor = win['IonicDevServer'];
            monitor && monitor.handleError && monitor.handleError(err);
            monitor = (win['Ionic'] = win['Ionic'] || {}).Monitor;
            monitor && monitor.handleError && monitor.handleError(err);
        }
        catch (e) { }
    }
}
//# sourceMappingURL=ionic-error-handler.js.map
// CONCATENATED MODULE: ./src/platform/platform-registry.ts


const PLATFORM_CONFIGS = {
    'core': {
        settings: {
            mode: 'md',
            keyboardHeight: 290
        }
    },
    'mobile': {},
    'phablet': {
        isMatch(plt) {
            let smallest = Math.min(plt.width(), plt.height());
            let largest = Math.max(plt.width(), plt.height());
            return (smallest > 390 && smallest < 520) &&
                (largest > 620 && largest < 800);
        }
    },
    'tablet': {
        isMatch(plt) {
            let smallest = Math.min(plt.width(), plt.height());
            let largest = Math.max(plt.width(), plt.height());
            return (smallest > 460 && smallest < 820) &&
                (largest > 780 && largest < 1400);
        }
    },
    'android': {
        superset: 'mobile',
        subsets: [
            'phablet',
            'tablet'
        ],
        settings: {
            activator: function (plt) {
                if (plt.testNavigatorPlatform('linux')) {
                    let chromeVersion = plt.matchUserAgentVersion(/Chrome\/(\d+).(\d+)?/);
                    if (chromeVersion) {
                        if (parseInt(chromeVersion.major, 10) < 36 || plt.version().major < 5) {
                            return 'none';
                        }
                        else {
                            return 'ripple';
                        }
                    }
                    if (plt.version().major < 5) {
                        return 'none';
                    }
                }
                return 'ripple';
            },
            autoFocusAssist: 'immediate',
            inputCloning: true,
            scrollAssist: true,
            hoverCSS: false,
            keyboardHeight: 300,
            mode: 'md',
        },
        isMatch(plt) {
            return plt.isPlatformMatch('android', ['android', 'silk'], ['windows phone']);
        },
        versionParser(plt) {
            return plt.matchUserAgentVersion(/Android (\d+).(\d+)?/);
        }
    },
    'ios': {
        superset: 'mobile',
        subsets: [
            'ipad',
            'iphone'
        ],
        settings: {
            autoFocusAssist: 'delay',
            hideCaretOnScroll: true,
            hoverCSS: false,
            inputBlurring: isIos,
            inputCloning: isIos,
            keyboardHeight: 300,
            mode: 'ios',
            scrollAssist: isIos,
            statusbarPadding: isCordova,
            swipeBackEnabled: isIos,
            tapPolyfill: isIosUIWebView,
            virtualScrollEventAssist: isIosUIWebView,
            disableScrollAssist: isIos,
            keyboardResizes: platform_registry_keyboardResizes,
            resizeAssist: platform_registry_keyboardResizes,
        },
        isMatch(plt) {
            return plt.isPlatformMatch('ios', ['iphone', 'ipad', 'ipod'], ['windows phone']);
        },
        versionParser(plt) {
            return plt.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
        }
    },
    'ipad': {
        superset: 'tablet',
        settings: {
            keyboardHeight: 500,
        },
        isMatch(plt) {
            return plt.isPlatformMatch('ipad');
        }
    },
    'iphone': {
        subsets: [
            'phablet'
        ],
        isMatch(plt) {
            return plt.isPlatformMatch('iphone');
        }
    },
    'windows': {
        superset: 'mobile',
        subsets: [
            'phablet',
            'tablet'
        ],
        settings: {
            mode: 'wp',
            autoFocusAssist: 'immediate',
            hoverCSS: false
        },
        isMatch(plt) {
            return plt.isPlatformMatch('windows', ['windows phone']);
        },
        versionParser(plt) {
            return plt.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
        }
    },
    'cordova': {
        isEngine: true,
        initialize: function (plt) {
            plt.prepareReady = function () {
                plt.windowLoad(function (win, doc) {
                    doc.addEventListener('deviceready', function () {
                        doc.addEventListener('backbutton', function (ev) {
                            plt.zone.run(() => {
                                plt.backButton.emit(ev);
                            });
                        });
                        doc.addEventListener('pause', function (ev) {
                            plt.zone.run(() => {
                                plt.pause.emit(ev);
                            });
                        });
                        doc.addEventListener('resume', function (ev) {
                            plt.zone.run(() => {
                                plt.resume.emit(ev);
                            });
                        });
                        plt.exitApp = function () {
                            win['navigator']['app'].exitApp();
                        };
                        plt.triggerReady('cordova');
                    });
                });
            };
        },
        isMatch(plt) {
            return isCordova(plt);
        }
    },
    'electron': {
        superset: 'core',
        initialize: function (plt) {
            plt.prepareReady = function () {
                plt.windowLoad(function () {
                    plt.triggerReady('electron');
                });
            };
        },
        isMatch(plt) {
            return isElectron(plt);
        }
    }
};
function platform_registry_keyboardResizes(plt) {
    const win = plt.win();
    if (win.Ionic && win.Ionic.keyboardResizes === true) {
        return true;
    }
    return false;
}
const PlatformConfigToken = new core_es5["H" /* OpaqueToken */]('PLTCONFIG');
function providePlatformConfigs() {
    return PLATFORM_CONFIGS;
}
//# sourceMappingURL=platform-registry.js.map
// CONCATENATED MODULE: ./src/config/mode-registry.ts
const MODE_IOS = {
    activator: 'highlight',
    actionSheetEnter: 'action-sheet-slide-in',
    actionSheetLeave: 'action-sheet-slide-out',
    alertEnter: 'alert-pop-in',
    alertLeave: 'alert-pop-out',
    backButtonText: 'Back',
    backButtonIcon: 'ios-arrow-back',
    iconMode: 'ios',
    loadingEnter: 'loading-pop-in',
    loadingLeave: 'loading-pop-out',
    menuType: 'reveal',
    modalEnter: 'modal-slide-in',
    modalLeave: 'modal-slide-out',
    pageTransition: 'ios-transition',
    pickerEnter: 'picker-slide-in',
    pickerLeave: 'picker-slide-out',
    pickerRotateFactor: -0.46,
    pickerScaleFactor: 1,
    popoverEnter: 'popover-pop-in',
    popoverLeave: 'popover-pop-out',
    spinner: 'ios',
    tabsHighlight: false,
    tabsPlacement: 'bottom',
    tabsHideOnSubPages: false,
    toastEnter: 'toast-slide-in',
    toastLeave: 'toast-slide-out',
};
const MODE_MD = {
    activator: 'ripple',
    actionSheetEnter: 'action-sheet-md-slide-in',
    actionSheetLeave: 'action-sheet-md-slide-out',
    alertEnter: 'alert-md-pop-in',
    alertLeave: 'alert-md-pop-out',
    backButtonText: '',
    backButtonIcon: 'md-arrow-back',
    iconMode: 'md',
    loadingEnter: 'loading-md-pop-in',
    loadingLeave: 'loading-md-pop-out',
    menuType: 'overlay',
    modalEnter: 'modal-md-slide-in',
    modalLeave: 'modal-md-slide-out',
    pageTransition: 'md-transition',
    pickerEnter: 'picker-slide-in',
    pickerLeave: 'picker-slide-out',
    pickerRotateFactor: 0,
    pickerScaleFactor: 0.81,
    popoverEnter: 'popover-md-pop-in',
    popoverLeave: 'popover-md-pop-out',
    spinner: 'crescent',
    tabsHighlight: false,
    tabsPlacement: 'bottom',
    tabsHideOnSubPages: false,
    toastEnter: 'toast-md-slide-in',
    toastLeave: 'toast-md-slide-out',
};
const MODE_WP = {
    activator: 'highlight',
    actionSheetEnter: 'action-sheet-wp-slide-in',
    actionSheetLeave: 'action-sheet-wp-slide-out',
    alertEnter: 'alert-wp-pop-in',
    alertLeave: 'alert-wp-pop-out',
    backButtonText: '',
    backButtonIcon: 'ios-arrow-back',
    iconMode: 'ios',
    loadingEnter: 'loading-wp-pop-in',
    loadingLeave: 'loading-wp-pop-out',
    menuType: 'overlay',
    modalEnter: 'modal-md-slide-in',
    modalLeave: 'modal-md-slide-out',
    pageTransition: 'wp-transition',
    pickerEnter: 'picker-slide-in',
    pickerLeave: 'picker-slide-out',
    pickerRotateFactor: 0,
    pickerScaleFactor: 0.81,
    popoverEnter: 'popover-md-pop-in',
    popoverLeave: 'popover-md-pop-out',
    spinner: 'circles',
    tabsHighlight: false,
    tabsPlacement: 'top',
    tabsHideOnSubPages: true,
    toastEnter: 'toast-wp-slide-in',
    toastLeave: 'toast-wp-slide-out',
};
function registerModeConfigs(config) {
    return function () {
        config.setModeConfig('ios', MODE_IOS);
        config.setModeConfig('md', MODE_MD);
        config.setModeConfig('wp', MODE_WP);
    };
}
//# sourceMappingURL=mode-registry.js.map
// CONCATENATED MODULE: ./src/gestures/gesture-config.ts



let IonicGestureConfig = class IonicGestureConfig extends platform_browser_es5["g" /* HammerGestureConfig */] {
    buildHammer(element) {
        const mc = new window.Hammer(element);
        for (let eventName in this.overrides) {
            mc.get(eventName).set(this.overrides[eventName]);
        }
        return mc;
    }
};
IonicGestureConfig = Object(tslib_es6["__decorate"])([
    Object(core_es5["w" /* Injectable */])()
], IonicGestureConfig);





// EXTERNAL MODULE: ./node_modules/@angular/common/@angular/common.es5.js
var common_es5 = __webpack_require__(2);

// CONCATENATED MODULE: ./src/components/app/click-block.ts







let ClickBlock = class ClickBlock {
    constructor(app, config, plt, elementRef, renderer) {
        this.plt = plt;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._showing = false;
        app._clickBlock = this;
        const enabled = this.isEnabled = config.getBoolean('clickBlock', true);
        if (enabled) {
            this._setElementClass('click-block-enabled', true);
        }
    }
    activate(shouldShow, expire = 100, minDuration = 0) {
        if (this.isEnabled) {
            this.plt.cancelTimeout(this._tmr);
            if (shouldShow) {
                this._start = Date.now();
                this._minEnd = this._start + (minDuration || 0);
                this._activate(true);
            }
            this._tmr = this.plt.timeout(this._activate.bind(this, false), expire);
        }
    }
    _activate(shouldShow) {
        if (this._showing !== shouldShow) {
            if (!shouldShow) {
                var now = Date.now();
                if (now < this._minEnd) {
                    this._tmr = this.plt.timeout(this._activate.bind(this, false), this._minEnd - now);
                    return;
                }
            }
            this._setElementClass('click-block-active', shouldShow);
            this._showing = shouldShow;
        }
    }
    _setElementClass(className, add) {
        this.renderer.setElementClass(this.elementRef.nativeElement, className, add);
    }
};
ClickBlock = Object(tslib_es6["__decorate"])([
    Object(core_es5["o" /* Directive */])({
        selector: '.click-block'
    }),
    Object(tslib_es6["__param"])(0, Object(core_es5["v" /* Inject */])(Object(core_es5["_5" /* forwardRef */])(() => app_App))),
    Object(tslib_es6["__metadata"])("design:paramtypes", [typeof (click_block__a = typeof app_App !== "undefined" && app_App) === "function" && click_block__a || Object, typeof (click_block__b = typeof config_Config !== "undefined" && config_Config) === "function" && click_block__b || Object, typeof (click_block__c = typeof platform_Platform !== "undefined" && platform_Platform) === "function" && click_block__c || Object, typeof (click_block__d = typeof core_es5["p" /* ElementRef */] !== "undefined" && core_es5["p" /* ElementRef */]) === "function" && click_block__d || Object, typeof (click_block__e = typeof core_es5["O" /* Renderer */] !== "undefined" && core_es5["O" /* Renderer */]) === "function" && click_block__e || Object])
], ClickBlock);

var click_block__a, click_block__b, click_block__c, click_block__d, click_block__e;




// CONCATENATED MODULE: ./src/module.ts



























































































































let module_IonicModule = IonicModule_1 = class IonicModule {
    static forRoot(appRoot, config = null, deepLinkConfig = null) {
        return {
            ngModule: IonicModule_1,
            providers: [
                { provide: AppRootToken, useValue: appRoot },
                { provide: ConfigToken, useValue: config },
                { provide: DeepLinkConfigToken, useValue: deepLinkConfig },
                { provide: common_es5["a" /* APP_BASE_HREF */], useValue: '/' },
                { provide: PlatformConfigToken, useFactory: providePlatformConfigs },
                { provide: platform_Platform, useFactory: setupPlatform, deps: [platform_browser_es5["b" /* DOCUMENT */], PlatformConfigToken, core_es5["G" /* NgZone */]] },
                { provide: config_Config, useFactory: setupConfig, deps: [ConfigToken, platform_Platform] },
                { provide: core_es5["c" /* APP_INITIALIZER */], useFactory: registerModeConfigs, deps: [config_Config], multi: true },
                { provide: core_es5["c" /* APP_INITIALIZER */], useFactory: setupProvideEvents, deps: [platform_Platform, dom_controller_DomController], multi: true },
                { provide: core_es5["c" /* APP_INITIALIZER */], useFactory: setupTapClick, deps: [config_Config, platform_Platform, dom_controller_DomController, app_App, GestureController], multi: true },
                { provide: core_es5["c" /* APP_INITIALIZER */], useFactory: setupPreloading, deps: [config_Config, DeepLinkConfigToken, ModuleLoader, core_es5["G" /* NgZone */]], multi: true },
                { provide: platform_browser_es5["f" /* HAMMER_GESTURE_CONFIG */], useClass: IonicGestureConfig },
                { provide: core_es5["a" /* ANALYZE_FOR_ENTRY_COMPONENTS */], useValue: appRoot, multi: true },
                action_sheet_controller_ActionSheetController,
                alert_controller_AlertController,
                app_App,
                dom_controller_DomController,
                Events,
                form_Form,
                GestureController,
                Haptic,
                keyboard_Keyboard,
                loading_controller_LoadingController,
                common_es5["e" /* Location */],
                menu_controller_MenuController,
                modal_controller_ModalController,
                ng_module_loader_NgModuleLoader,
                picker_controller_PickerController,
                popover_controller_PopoverController,
                tap_click_TapClick,
                toast_controller_ToastController,
                transition_controller_TransitionController,
                { provide: ModuleLoader, useFactory: provideModuleLoader, deps: [ng_module_loader_NgModuleLoader, core_es5["y" /* Injector */]] },
                { provide: common_es5["f" /* LocationStrategy */], useFactory: provideLocationStrategy, deps: [common_es5["q" /* PlatformLocation */], [new core_es5["v" /* Inject */](common_es5["a" /* APP_BASE_HREF */]), new core_es5["I" /* Optional */]()], config_Config] },
                { provide: url_serializer_UrlSerializer, useFactory: setupUrlSerializer, deps: [app_App, DeepLinkConfigToken] },
                { provide: deep_linker_DeepLinker, useFactory: setupDeepLinker, deps: [app_App, url_serializer_UrlSerializer, common_es5["e" /* Location */], ModuleLoader, core_es5["l" /* ComponentFactoryResolver */]] },
            ]
        };
    }
};
module_IonicModule = IonicModule_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["D" /* NgModule */])({
        declarations: [
            action_sheet_component_ActionSheetCmp,
            alert_component_AlertCmp,
            ClickBlock,
            app_root_IonicApp,
            OverlayPortal,
            Avatar,
            Backdrop,
            Badge,
            button_Button,
            Card,
            CardContent,
            CardHeader,
            CardTitle,
            checkbox_Checkbox,
            Chip,
            Col,
            content_Content,
            datetime_DateTime,
            FabButton,
            fab_container_FabContainer,
            fab_list_FabList,
            Grid,
            img_Img,
            icon_Icon,
            infinite_scroll_InfiniteScroll,
            InfiniteScrollContent,
            Item,
            ItemContent,
            ItemDivider,
            ItemGroup,
            item_options_ItemOptions,
            item_reorder_ItemReorder,
            item_sliding_ItemSliding,
            Label,
            list_List,
            ListHeader,
            reorder_Reorder,
            loading_component_LoadingCmp,
            menu_Menu,
            MenuClose,
            MenuToggle,
            modal_component_ModalCmp,
            Nav,
            NavPop,
            NavPopAnchor,
            NavPush,
            NavPushAnchor,
            Note,
            option_Option,
            picker_component_PickerCmp,
            picker_column_PickerColumnCmp,
            popover_component_PopoverCmp,
            radio_button_RadioButton,
            radio_group_RadioGroup,
            range_Range,
            range_knob_RangeKnob,
            refresher_Refresher,
            RefresherContent,
            Row,
            scroll_Scroll,
            searchbar_Searchbar,
            segment_Segment,
            segment_button_SegmentButton,
            select_Select,
            SelectPopover,
            ShowWhen,
            HideWhen,
            Slide,
            slides_Slides,
            spinner_Spinner,
            split_pane_SplitPane,
            tab_Tab,
            tab_button_TabButton,
            TabHighlight,
            tabs_Tabs,
            input_TextInput,
            Thumbnail,
            ToastCmp,
            toggle_Toggle,
            Footer,
            Header,
            Toolbar,
            ToolbarItem,
            ToolbarTitle,
            navbar_Navbar,
            Typography,
            VirtualFooter,
            VirtualHeader,
            VirtualItem,
            virtual_scroll_VirtualScroll
        ],
        imports: [
            common_es5["b" /* CommonModule */],
            forms_es5["d" /* FormsModule */],
            forms_es5["i" /* ReactiveFormsModule */],
        ],
        exports: [
            common_es5["b" /* CommonModule */],
            forms_es5["d" /* FormsModule */],
            forms_es5["i" /* ReactiveFormsModule */],
            action_sheet_component_ActionSheetCmp,
            alert_component_AlertCmp,
            ClickBlock,
            app_root_IonicApp,
            OverlayPortal,
            Avatar,
            Backdrop,
            Badge,
            button_Button,
            Card,
            CardContent,
            CardHeader,
            CardTitle,
            checkbox_Checkbox,
            Chip,
            Col,
            content_Content,
            datetime_DateTime,
            FabButton,
            fab_container_FabContainer,
            fab_list_FabList,
            Grid,
            img_Img,
            icon_Icon,
            infinite_scroll_InfiniteScroll,
            InfiniteScrollContent,
            Item,
            ItemContent,
            ItemDivider,
            ItemGroup,
            item_options_ItemOptions,
            item_reorder_ItemReorder,
            item_sliding_ItemSliding,
            Label,
            list_List,
            ListHeader,
            reorder_Reorder,
            loading_component_LoadingCmp,
            menu_Menu,
            MenuClose,
            MenuToggle,
            modal_component_ModalCmp,
            Nav,
            NavPop,
            NavPopAnchor,
            NavPush,
            NavPushAnchor,
            Note,
            option_Option,
            picker_component_PickerCmp,
            picker_column_PickerColumnCmp,
            popover_component_PopoverCmp,
            radio_button_RadioButton,
            radio_group_RadioGroup,
            range_Range,
            range_knob_RangeKnob,
            refresher_Refresher,
            RefresherContent,
            Row,
            scroll_Scroll,
            searchbar_Searchbar,
            segment_Segment,
            segment_button_SegmentButton,
            select_Select,
            SelectPopover,
            ShowWhen,
            HideWhen,
            Slide,
            slides_Slides,
            spinner_Spinner,
            split_pane_SplitPane,
            tab_Tab,
            tab_button_TabButton,
            TabHighlight,
            tabs_Tabs,
            input_TextInput,
            Thumbnail,
            ToastCmp,
            toggle_Toggle,
            Footer,
            Header,
            Toolbar,
            ToolbarItem,
            ToolbarTitle,
            navbar_Navbar,
            Typography,
            VirtualFooter,
            VirtualHeader,
            VirtualItem,
            virtual_scroll_VirtualScroll
        ],
        entryComponents: [
            action_sheet_component_ActionSheetCmp,
            alert_component_AlertCmp,
            app_root_IonicApp,
            loading_component_LoadingCmp,
            modal_component_ModalCmp,
            picker_component_PickerCmp,
            popover_component_PopoverCmp,
            SelectPopover,
            ToastCmp
        ]
    })
], module_IonicModule);

let module_IonicPageModule = IonicPageModule_1 = class IonicPageModule {
    static forChild(page) {
        return {
            ngModule: IonicPageModule_1,
            providers: [
                { provide: LAZY_LOADED_TOKEN, useValue: page },
                { provide: core_es5["a" /* ANALYZE_FOR_ENTRY_COMPONENTS */], useValue: page, multi: true },
            ]
        };
    }
};
module_IonicPageModule = IonicPageModule_1 = Object(tslib_es6["__decorate"])([
    Object(core_es5["D" /* NgModule */])({
        imports: [module_IonicModule],
        exports: [module_IonicModule]
    })
], module_IonicPageModule);

function provideLocationStrategy(platformLocationStrategy, baseHref, config) {
    return config.get('locationStrategy') === 'path' ?
        new common_es5["p" /* PathLocationStrategy */](platformLocationStrategy, baseHref) :
        new common_es5["d" /* HashLocationStrategy */](platformLocationStrategy, baseHref);
}
var IonicModule_1, IonicPageModule_1;




// CONCATENATED MODULE: ./src/index.ts
















































































































































//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./demos/src/searchbar/pages/page-one/page-one.ts


let PageOne = class PageOne {
    ngOnInit() {
        this.setItems();
    }
    setItems() {
        this.items = ['Orange', 'Banana', 'Pear', 'Tomato', 'Grape', 'Apple', 'Cherries', 'Cranberries', 'Raspberries', 'Strawberries', 'Watermelon'];
    }
    filterItems(ev) {
        this.setItems();
        let val = ev.value;
        if (val && val.trim() !== '') {
            this.items = this.items.filter(function (item) {
                return item.toLowerCase().includes(val.toLowerCase());
            });
        }
    }
};
PageOne = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        templateUrl: 'page-one.html'
    })
], PageOne);





// CONCATENATED MODULE: ./demos/src/searchbar/app/app.component.ts



let app_component_AppComponent = class AppComponent {
    constructor() {
        this.root = PageOne;
    }
};
app_component_AppComponent = Object(tslib_es6["__decorate"])([
    Object(core_es5["k" /* Component */])({
        template: '<ion-nav [root]="root"></ion-nav>'
    })
], app_component_AppComponent);





// CONCATENATED MODULE: ./demos/src/searchbar/pages/page-one/page-one.module.ts




let PageOneModule = class PageOneModule {
};
PageOneModule = Object(tslib_es6["__decorate"])([
    Object(core_es5["D" /* NgModule */])({
        declarations: [
            PageOne,
        ],
        imports: [
            module_IonicPageModule.forChild(PageOne),
        ],
        entryComponents: [
            PageOne,
        ]
    })
], PageOneModule);





// CONCATENATED MODULE: ./demos/src/searchbar/app/app.module.ts






let AppModule = class AppModule {
};
AppModule = Object(tslib_es6["__decorate"])([
    Object(core_es5["D" /* NgModule */])({
        declarations: [
            app_component_AppComponent
        ],
        imports: [
            platform_browser_es5["a" /* BrowserModule */],
            module_IonicModule.forRoot(app_component_AppComponent),
            PageOneModule
        ],
        bootstrap: [app_root_IonicApp]
    })
], AppModule);





// CONCATENATED MODULE: ./src/components/button/button.ngfactory.ts



const styles_Button = [];
const RenderType_Button = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Button,
    data: {} });
function View_Button_0(_l) {
    return core_es5["_38" /* vid */](2, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'span', [['class',
                'button-inner']], null, null, null, null, null)),
        core_es5["_31" /* ncd */](null, 0), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'button-effect']], null, null, null, null, null))], null, null);
}
function View_Button_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['ion-button',
                '']], null, null, null, View_Button_0, RenderType_Button)),
        core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, ''], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null)], null, null);
}
const ButtonNgFactory = core_es5["_13" /* ccf */]('[ion-button]', button_Button, View_Button_Host_0, { color: 'color', mode: 'mode', large: 'large', small: 'small',
    default: 'default', outline: 'outline', clear: 'clear', solid: 'solid', round: 'round',
    block: 'block', full: 'full', strong: 'strong' }, {}, ['*']);
//# sourceMappingURL=button.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/action-sheet/action-sheet-component.ngfactory.ts











const styles_ActionSheetCmp = [];
const RenderType_ActionSheetCmp = core_es5["_15" /* crt */]({ encapsulation: 2,
    styles: styles_ActionSheetCmp, data: {} });
function View_ActionSheetCmp_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'action-sheet-title']], [[8, 'id', 0]], null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = core_es5["_21" /* inlineInterpolate */](1, '', _co.hdrId, '');
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _co.d.title;
        _ck(_v, 1, 0, currVal_1);
    });
}
function View_ActionSheetCmp_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'action-sheet-sub-title']], [[8, 'id', 0]], null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = core_es5["_21" /* inlineInterpolate */](1, '', _co.descId, '');
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _co.d.subTitle;
        _ck(_v, 1, 0, currVal_1);
    });
}
function View_ActionSheetCmp_4(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-icon', [['class',
                'action-sheet-icon'], ['role', 'img']], [[2, 'hide', null]], null, null, null, null)), core_es5["_16" /* did */](147456, null, 0, icon_Icon, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { name: [0, 'name'] }, null)], (_ck, _v) => {
        const currVal_1 = _v.parent.context.$implicit.icon;
        _ck(_v, 1, 0, currVal_1);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._hidden;
        _ck(_v, 0, 0, currVal_0);
    });
}
function View_ActionSheetCmp_3(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'button', [['class',
                'disable-hover'], ['ion-button', 'action-sheet-button']], [[1, 'icon-start', 0]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.click(_v.context.$implicit) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0,
                'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, 'action-sheet-button'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_12" /* and */](16777216, null, 0, 1, null, View_ActionSheetCmp_4)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(), core_es5["_37" /* ted */](0, ['', '']))], (_ck, _v) => {
        const currVal_1 = 'disable-hover';
        const currVal_2 = _v.context.$implicit.cssClass;
        _ck(_v, 1, 0, currVal_1, currVal_2);
        const currVal_3 = _v.context.$implicit.icon;
        _ck(_v, 4, 0, currVal_3);
    }, (_ck, _v) => {
        const currVal_0 = (_v.context.$implicit.icon ? '' : null);
        _ck(_v, 0, 0, currVal_0);
        const currVal_4 = _v.context.$implicit.text;
        _ck(_v, 5, 0, currVal_4);
    });
}
function View_ActionSheetCmp_6(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-icon', [['class',
                'action-sheet-icon'], ['role', 'img']], [[2, 'hide', null]], null, null, null, null)), core_es5["_16" /* did */](147456, null, 0, icon_Icon, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { name: [0, 'name'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = _co.cancelButton.icon;
        _ck(_v, 1, 0, currVal_1);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._hidden;
        _ck(_v, 0, 0, currVal_0);
    });
}
function View_ActionSheetCmp_5(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 6, 'div', [['class',
                'action-sheet-group']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'button', [['class',
                'action-sheet-cancel disable-hover'], ['ion-button', 'action-sheet-button']], [[1,
                'icon-start', 0]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.click(_co.cancelButton) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0,
                'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, 'action-sheet-button'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_12" /* and */](16777216, null, 0, 1, null, View_ActionSheetCmp_6)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(), core_es5["_37" /* ted */](0, ['', '']))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = 'action-sheet-cancel disable-hover';
        const currVal_2 = _co.cancelButton.cssClass;
        _ck(_v, 2, 0, currVal_1, currVal_2);
        const currVal_3 = _co.cancelButton.icon;
        _ck(_v, 5, 0, currVal_3);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = (_co.cancelButton.icon ? '' : null);
        _ck(_v, 1, 0, currVal_0);
        const currVal_4 = _co.cancelButton.text;
        _ck(_v, 6, 0, currVal_4);
    });
}
function View_ActionSheetCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-backdrop', [['disable-activated', ''], ['role', 'presentation'], ['tappable', '']], [[2, 'backdrop-no-tappable',
                null]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.bdClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, Backdrop, [core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 10, 'div', [['class', 'action-sheet-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 9, 'div', [['class', 'action-sheet-container']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 6, 'div', [['class', 'action-sheet-group']], null, null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_ActionSheetCmp_1)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(),
            core_es5["_12" /* and */](16777216, null, null, 1, null, View_ActionSheetCmp_2)),
        core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0,
                'ngIf'] }, null), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_ActionSheetCmp_3)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_ActionSheetCmp_5)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = _co.d.title;
        _ck(_v, 6, 0, currVal_1);
        const currVal_2 = _co.d.subTitle;
        _ck(_v, 8, 0, currVal_2);
        const currVal_3 = _co.d.buttons;
        _ck(_v, 10, 0, currVal_3);
        const currVal_4 = _co.cancelButton;
        _ck(_v, 12, 0, currVal_4);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = !_co.d.enableBackdropDismiss;
        _ck(_v, 0, 0, currVal_0);
    });
}
function View_ActionSheetCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-action-sheet', [['role', 'dialog']], [[1, 'aria-labelledby', 0], [1, 'aria-describedby', 0]], [['body',
                'keyup']], (_v, en, $event) => {
            var ad = true;
            if (('body:keyup' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1).keyUp($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_ActionSheetCmp_0, RenderType_ActionSheetCmp)), core_es5["_16" /* did */](180224, null, 0, action_sheet_component_ActionSheetCmp, [view_controller_ViewController, config_Config, core_es5["p" /* ElementRef */], GestureController,
            NavParams, core_es5["O" /* Renderer */]], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1).hdrId;
        const currVal_1 = core_es5["_32" /* nov */](_v, 1).descId;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
const ActionSheetCmpNgFactory = core_es5["_13" /* ccf */]('ion-action-sheet', action_sheet_component_ActionSheetCmp, View_ActionSheetCmp_Host_0, {}, {}, []);
//# sourceMappingURL=action-sheet-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/alert/alert-component.ngfactory.ts












const styles_AlertCmp = [];
const RenderType_AlertCmp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_AlertCmp,
    data: {} });
function View_AlertCmp_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'h2', [['class',
                'alert-title']], [[8, 'id', 0], [8, 'innerHTML', 1]], null, null, null, null))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = core_es5["_21" /* inlineInterpolate */](1, '', _co.hdrId, '');
        const currVal_1 = _co.d.title;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
function View_AlertCmp_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'h3', [['class',
                'alert-sub-title']], [[8, 'id', 0], [8, 'innerHTML', 1]], null, null, null, null))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = core_es5["_21" /* inlineInterpolate */](1, '', _co.subHdrId, '');
        const currVal_1 = _co.d.subTitle;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
function View_AlertCmp_5(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'button', [['class',
                'alert-tappable alert-radio'], ['ion-button', 'alert-radio-button'], ['role', 'radio']], [[1, 'aria-checked', 0], [8, 'disabled', 0], [1, 'id', 0]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.rbClick(_v.context.$implicit) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, 'alert-radio-button'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, 0, 1, 'div', [['class', 'alert-radio-icon']], null, null, null, null, null)), (_l()(),
            core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'alert-radio-inner']], null, null, null, null, null)),
        (_l()(), core_es5["_18" /* eld */](0, null, 0, 1, 'div', [['class', 'alert-radio-label']], null, null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.checked;
        const currVal_1 = _v.context.$implicit.disabled;
        const currVal_2 = _v.context.$implicit.id;
        _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2);
        const currVal_3 = _v.context.$implicit.label;
        _ck(_v, 5, 0, currVal_3);
    });
}
function View_AlertCmp_4(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class',
                'alert-radio-group'], ['role', 'radiogroup']], [[1, 'aria-labelledby', 0], [1, 'aria-activedescendant',
                0]], null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_5)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_2 = _co.d.inputs;
        _ck(_v, 2, 0, currVal_2);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.hdrId;
        const currVal_1 = _co.activeId;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
function View_AlertCmp_7(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'button', [['class',
                'alert-tappable alert-checkbox'], ['ion-button', 'alert-checkbox-button'], ['role',
                'checkbox']], [[1, 'aria-checked', 0], [1, 'id', 0], [8, 'disabled', 0]], [[null,
                'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.cbClick(_v.context.$implicit) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, 'alert-checkbox-button'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, 0, 1, 'div', [['class', 'alert-checkbox-icon']], null, null, null, null, null)), (_l()(),
            core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'alert-checkbox-inner']], null, null, null, null, null)),
        (_l()(), core_es5["_18" /* eld */](0, null, 0, 1, 'div', [['class', 'alert-checkbox-label']], null, null, null, null, null)),
        (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.checked;
        const currVal_1 = _v.context.$implicit.id;
        const currVal_2 = _v.context.$implicit.disabled;
        _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2);
        const currVal_3 = _v.context.$implicit.label;
        _ck(_v, 5, 0, currVal_3);
    });
}
function View_AlertCmp_6(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class',
                'alert-checkbox-group']], null, null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_7)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.d.inputs;
        _ck(_v, 2, 0, currVal_0);
    }, null);
}
function View_AlertCmp_9(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 6, 'div', [['class',
                'alert-input-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'input', [['class',
                'alert-input']], [[8, 'placeholder', 0], [8, 'type', 0], [8, 'min', 0], [8, 'max', 0], [1,
                'id', 0], [2, 'ng-untouched', null], [2, 'ng-touched', null], [2, 'ng-pristine',
                null], [2, 'ng-dirty', null], [2, 'ng-valid', null], [2,
                'ng-invalid', null], [2, 'ng-pending', null]], [[null,
                'ngModelChange'], [null, 'input'], [null, 'blur'], [null,
                'compositionstart'], [null, 'compositionend']], (_v, en, $event) => {
            var ad = true;
            if (('input' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 2)._handleInput($event.target.value) !== false);
                ad = (pd_0 && ad);
            }
            if (('blur' === en)) {
                const pd_1 = (core_es5["_32" /* nov */](_v, 2).onTouched() !== false);
                ad = (pd_1 && ad);
            }
            if (('compositionstart' === en)) {
                const pd_2 = (core_es5["_32" /* nov */](_v, 2)._compositionStart() !== false);
                ad = (pd_2 && ad);
            }
            if (('compositionend' === en)) {
                const pd_3 = (core_es5["_32" /* nov */](_v, 2)._compositionEnd($event.target.value) !== false);
                ad = (pd_3 && ad);
            }
            if (('ngModelChange' === en)) {
                const pd_4 = ((_v.context.$implicit.value = $event) !== false);
                ad = (pd_4 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, forms_es5["b" /* DefaultValueAccessor */], [core_es5["P" /* Renderer2 */], core_es5["p" /* ElementRef */], [2, forms_es5["a" /* COMPOSITION_BUFFER_MODE */]]], null, null),
        core_es5["_34" /* prd */](1024, null, forms_es5["e" /* NG_VALUE_ACCESSOR */], (p0_0) => {
            return [p0_0];
        }, [forms_es5["b" /* DefaultValueAccessor */]]), core_es5["_16" /* did */](671744, null, 0, forms_es5["h" /* NgModel */], [[8, null],
            [8, null], [8, null], [2, forms_es5["e" /* NG_VALUE_ACCESSOR */]]], { model: [0,
                'model'] }, { update: 'ngModelChange' }), core_es5["_34" /* prd */](2048, null, forms_es5["f" /* NgControl */], null, [forms_es5["h" /* NgModel */]]), core_es5["_16" /* did */](16384, null, 0, forms_es5["g" /* NgControlStatus */], [forms_es5["f" /* NgControl */]], null, null)], (_ck, _v) => {
        const currVal_12 = _v.context.$implicit.value;
        _ck(_v, 4, 0, currVal_12);
    }, (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.placeholder;
        const currVal_1 = _v.context.$implicit.type;
        const currVal_2 = _v.context.$implicit.min;
        const currVal_3 = _v.context.$implicit.max;
        const currVal_4 = _v.context.$implicit.id;
        const currVal_5 = core_es5["_32" /* nov */](_v, 6).ngClassUntouched;
        const currVal_6 = core_es5["_32" /* nov */](_v, 6).ngClassTouched;
        const currVal_7 = core_es5["_32" /* nov */](_v, 6).ngClassPristine;
        const currVal_8 = core_es5["_32" /* nov */](_v, 6).ngClassDirty;
        const currVal_9 = core_es5["_32" /* nov */](_v, 6).ngClassValid;
        const currVal_10 = core_es5["_32" /* nov */](_v, 6).ngClassInvalid;
        const currVal_11 = core_es5["_32" /* nov */](_v, 6).ngClassPending;
        _ck(_v, 1, 1, [currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5, currVal_6,
            currVal_7, currVal_8, currVal_9, currVal_10, currVal_11]);
    });
}
function View_AlertCmp_8(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class',
                'alert-input-group']], null, null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_9)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.d.inputs;
        _ck(_v, 2, 0, currVal_0);
    }, null);
}
function View_AlertCmp_3(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 7, 'div', [], null, null, null, null, null)), core_es5["_16" /* did */](16384, null, 0, common_es5["m" /* NgSwitch */], [], { ngSwitch: [0, 'ngSwitch'] }, null),
        (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_4)),
        core_es5["_16" /* did */](278528, null, 0, common_es5["n" /* NgSwitchCase */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */],
            common_es5["m" /* NgSwitch */]], { ngSwitchCase: [0, 'ngSwitchCase'] }, null), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_6)), core_es5["_16" /* did */](278528, null, 0, common_es5["n" /* NgSwitchCase */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], common_es5["m" /* NgSwitch */]], { ngSwitchCase: [0, 'ngSwitchCase'] }, null), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_8)), core_es5["_16" /* did */](16384, null, 0, common_es5["o" /* NgSwitchDefault */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], common_es5["m" /* NgSwitch */]], null, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.inputType;
        _ck(_v, 1, 0, currVal_0);
        const currVal_1 = 'radio';
        _ck(_v, 3, 0, currVal_1);
        const currVal_2 = 'checkbox';
        _ck(_v, 5, 0, currVal_2);
    }, null);
}
function View_AlertCmp_10(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 3, 'button', [['ion-button',
                'alert-button']], null, [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.btnClick(_v.context.$implicit) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { ngClass: [0,
                'ngClass'] }, null), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8,
                'alert-button'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null),
        (_l()(), core_es5["_37" /* ted */](0, ['', '']))], (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.cssClass;
        _ck(_v, 1, 0, currVal_0);
    }, (_ck, _v) => {
        const currVal_1 = _v.context.$implicit.text;
        _ck(_v, 3, 0, currVal_1);
    });
}
function View_AlertCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-backdrop', [['disable-activated', ''], ['role', 'presentation'], ['tappable', '']], [[2, 'backdrop-no-tappable',
                null]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.bdClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, Backdrop, [core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 13, 'div', [['class', 'alert-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'div', [['class', 'alert-head']], null, null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_1)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_2)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null),
        (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'alert-message']], [[8, 'id', 0], [8, 'innerHTML', 1]], null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_3)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'div', [['class', 'alert-button-group']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_33" /* pod */]({ 'alert-button-group-vertical': 0 }),
        (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_AlertCmp_10)),
        core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */],
            core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = _co.d.title;
        _ck(_v, 5, 0, currVal_1);
        const currVal_2 = _co.d.subTitle;
        _ck(_v, 7, 0, currVal_2);
        const currVal_5 = _co.d.inputs.length;
        _ck(_v, 10, 0, currVal_5);
        const currVal_6 = 'alert-button-group';
        const currVal_7 = _ck(_v, 13, 0, (_co.d.buttons.length > 2));
        _ck(_v, 12, 0, currVal_6, currVal_7);
        const currVal_8 = _co.d.buttons;
        _ck(_v, 15, 0, currVal_8);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = !_co.d.enableBackdropDismiss;
        _ck(_v, 0, 0, currVal_0);
        const currVal_3 = core_es5["_21" /* inlineInterpolate */](1, '', _co.msgId, '');
        const currVal_4 = _co.d.message;
        _ck(_v, 8, 0, currVal_3, currVal_4);
    });
}
function View_AlertCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-alert', [['role',
                'dialog']], [[1, 'aria-labelledby', 0], [1, 'aria-describedby', 0]], [['body', 'keyup']], (_v, en, $event) => {
            var ad = true;
            if (('body:keyup' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1).keyUp($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_AlertCmp_0, RenderType_AlertCmp)), core_es5["_16" /* did */](180224, null, 0, alert_component_AlertCmp, [view_controller_ViewController, core_es5["p" /* ElementRef */], config_Config, GestureController, NavParams,
            core_es5["O" /* Renderer */], platform_Platform], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1).hdrId;
        const currVal_1 = core_es5["_32" /* nov */](_v, 1).descId;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
const AlertCmpNgFactory = core_es5["_13" /* ccf */]('ion-alert', alert_component_AlertCmp, View_AlertCmp_Host_0, {}, {}, []);
//# sourceMappingURL=alert-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/app/app-root.ngfactory.ts











const styles_IonicApp = [];
const RenderType_IonicApp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_IonicApp,
    data: {} });
function View_IonicApp_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](402653184, 1, { _viewport: 0 }), core_es5["_35" /* qud */](402653184, 2, { _modalPortal: 0 }),
        core_es5["_35" /* qud */](402653184, 3, { _overlayPortal: 0 }), core_es5["_35" /* qud */](402653184, 4, { _loadingPortal: 0 }),
        core_es5["_35" /* qud */](402653184, 5, { _toastPortal: 0 }), (_l()(), core_es5["_18" /* eld */](16777216, [[1, 3], ['viewport',
                1]], null, 0, 'div', [['app-viewport', '']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](16777216, [['modalPortal',
                1]], null, 1, 'div', [['overlay-portal', '']], null, null, null, null, null)), core_es5["_16" /* did */](147456, [[2, 4]], 0, OverlayPortal, [app_App, config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */], core_es5["O" /* Renderer */], core_es5["l" /* ComponentFactoryResolver */],
            GestureController, transition_controller_TransitionController, [2, deep_linker_DeepLinker], core_es5["_0" /* ViewContainerRef */],
            dom_controller_DomController, core_es5["q" /* ErrorHandler */]], { _overlayPortal: [0, '_overlayPortal'] }, null), (_l()(), core_es5["_18" /* eld */](16777216, [['overlayPortal', 1]], null, 1, 'div', [['overlay-portal', '']], null, null, null, null, null)), core_es5["_16" /* did */](147456, [[3, 4]], 0, OverlayPortal, [app_App, config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */], core_es5["O" /* Renderer */], core_es5["l" /* ComponentFactoryResolver */],
            GestureController, transition_controller_TransitionController, [2, deep_linker_DeepLinker], core_es5["_0" /* ViewContainerRef */],
            dom_controller_DomController, core_es5["q" /* ErrorHandler */]], { _overlayPortal: [0, '_overlayPortal'] }, null), (_l()(), core_es5["_18" /* eld */](16777216, [['loadingPortal', 1]], null, 1, 'div', [['class', 'loading-portal'], ['overlay-portal', '']], null, null, null, null, null)), core_es5["_16" /* did */](147456, [[4, 4]], 0, OverlayPortal, [app_App, config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */],
            core_es5["O" /* Renderer */], core_es5["l" /* ComponentFactoryResolver */], GestureController, transition_controller_TransitionController,
            [2, deep_linker_DeepLinker], core_es5["_0" /* ViewContainerRef */], dom_controller_DomController, core_es5["q" /* ErrorHandler */]], { _overlayPortal: [0, '_overlayPortal'] }, null), (_l()(), core_es5["_18" /* eld */](16777216, [['toastPortal', 1]], null, 1, 'div', [['class', 'toast-portal']], null, null, null, null, null)), core_es5["_16" /* did */](147456, [[5, 4]], 0, OverlayPortal, [app_App, config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */],
            core_es5["O" /* Renderer */], core_es5["l" /* ComponentFactoryResolver */], GestureController, transition_controller_TransitionController,
            [2, deep_linker_DeepLinker], core_es5["_0" /* ViewContainerRef */], dom_controller_DomController, core_es5["q" /* ErrorHandler */]], { _overlayPortal: [0, '_overlayPortal'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class', 'click-block']], null, null, null, null, null)), core_es5["_16" /* did */](16384, null, 0, ClickBlock, [app_App, config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null)], (_ck, _v) => {
        const currVal_0 = '';
        _ck(_v, 7, 0, currVal_0);
        const currVal_1 = '';
        _ck(_v, 9, 0, currVal_1);
        const currVal_2 = '';
        _ck(_v, 11, 0, currVal_2);
        const currVal_3 = 10000;
        _ck(_v, 13, 0, currVal_3);
    }, null);
}
function View_IonicApp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-app', [], null, null, null, View_IonicApp_0, RenderType_IonicApp)),
        core_es5["_16" /* did */](114688, null, 0, app_root_IonicApp, [AppRootToken, core_es5["l" /* ComponentFactoryResolver */],
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], config_Config, platform_Platform, app_App], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, null);
}
const IonicAppNgFactory = core_es5["_13" /* ccf */]('ion-app', app_root_IonicApp, View_IonicApp_Host_0, { color: 'color', mode: 'mode' }, {}, []);
//# sourceMappingURL=app-root.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/spinner/spinner.ngfactory.ts




const styles_Spinner = [];
const RenderType_Spinner = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Spinner,
    data: {} });
function View_Spinner_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, ':svg:svg', [['viewBox',
                '0 0 64 64']], null, null, null, null, null)),
        core_es5["_16" /* did */](278528, null, 0, common_es5["l" /* NgStyle */], [core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], { ngStyle: [0, 'ngStyle'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, ':svg:circle', [['transform', 'translate(32,32)']], [[1, 'r',
                0]], null, null, null, null))], (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.style;
        _ck(_v, 1, 0, currVal_0);
    }, (_ck, _v) => {
        const currVal_1 = _v.context.$implicit.r;
        _ck(_v, 2, 0, currVal_1);
    });
}
function View_Spinner_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, ':svg:svg', [['viewBox',
                '0 0 64 64']], null, null, null, null, null)),
        core_es5["_16" /* did */](278528, null, 0, common_es5["l" /* NgStyle */], [core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], { ngStyle: [0, 'ngStyle'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, ':svg:line', [['transform', 'translate(32,32)']], [[1, 'y1',
                0], [1, 'y2', 0]], null, null, null, null))], (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.style;
        _ck(_v, 1, 0, currVal_0);
    }, (_ck, _v) => {
        const currVal_1 = _v.context.$implicit.y1;
        const currVal_2 = _v.context.$implicit.y2;
        _ck(_v, 2, 0, currVal_1, currVal_2);
    });
}
function View_Spinner_0(_l) {
    return core_es5["_38" /* vid */](2, [(_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_Spinner_1)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null), (_l()(),
            core_es5["_12" /* and */](16777216, null, null, 1, null, View_Spinner_2)),
        core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */],
            core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co._c;
        _ck(_v, 1, 0, currVal_0);
        const currVal_1 = _co._l;
        _ck(_v, 3, 0, currVal_1);
    }, null);
}
function View_Spinner_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-spinner', [], [[2, 'spinner-paused', null]], null, null, View_Spinner_0, RenderType_Spinner)), core_es5["_16" /* did */](114688, null, 0, spinner_Spinner, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._paused;
        _ck(_v, 0, 0, currVal_0);
    });
}
const SpinnerNgFactory = core_es5["_13" /* ccf */]('ion-spinner', spinner_Spinner, View_Spinner_Host_0, { color: 'color', mode: 'mode', name: 'name', duration: 'duration',
    paused: 'paused' }, {}, []);
//# sourceMappingURL=spinner.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/loading/loading-component.ngfactory.ts










const styles_LoadingCmp = [];
const RenderType_LoadingCmp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_LoadingCmp,
    data: {} });
function View_LoadingCmp_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class',
                'loading-spinner']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-spinner', [], [[2, 'spinner-paused', null]], null, null, View_Spinner_0, RenderType_Spinner)), core_es5["_16" /* did */](114688, null, 0, spinner_Spinner, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { name: [0, 'name'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = _co.d.spinner;
        _ck(_v, 2, 0, currVal_1);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 2)._paused;
        _ck(_v, 1, 0, currVal_0);
    });
}
function View_LoadingCmp_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class',
                'loading-content']], [[8, 'innerHTML', 1]], null, null, null, null))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.d.content;
        _ck(_v, 0, 0, currVal_0);
    });
}
function View_LoadingCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-backdrop', [['disable-activated', ''], ['role', 'presentation'], ['tappable', '']], [[8, 'hidden',
                0], [2, 'backdrop-no-tappable', null]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.bdClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, Backdrop, [core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'div', [['class', 'loading-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_LoadingCmp_1)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_LoadingCmp_2)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_2 = _co.showSpinner;
        _ck(_v, 4, 0, currVal_2);
        const currVal_3 = _co.d.content;
        _ck(_v, 6, 0, currVal_3);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = !_co.d.showBackdrop;
        const currVal_1 = !_co.d.enableBackdropDismiss;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
function View_LoadingCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-loading', [['role', 'dialog']], null, [['body', 'keyup']], (_v, en, $event) => {
            var ad = true;
            if (('body:keyup' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1).keyUp($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_LoadingCmp_0, RenderType_LoadingCmp)), core_es5["_16" /* did */](245760, null, 0, loading_component_LoadingCmp, [view_controller_ViewController, config_Config, core_es5["p" /* ElementRef */], GestureController, NavParams,
            core_es5["O" /* Renderer */]], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, null);
}
const LoadingCmpNgFactory = core_es5["_13" /* ccf */]('ion-loading', loading_component_LoadingCmp, View_LoadingCmp_Host_0, {}, {}, []);
//# sourceMappingURL=loading-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/modal/modal-component.ngfactory.ts







const styles_ModalCmp = [];
const RenderType_ModalCmp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_ModalCmp,
    data: {} });
function View_ModalCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](402653184, 1, { _viewport: 0 }), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-backdrop', [['disable-activated', ''], ['role', 'presentation'],
            ['tappable', '']], [[2, 'backdrop-no-tappable', null]], [[null,
                'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co._bdClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, Backdrop, [core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class', 'modal-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](16777216, [[1, 3], ['viewport', 1]], null, 0, 'div', [['nav-viewport', '']], null, null, null, null, null))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = !_co._bdDismiss;
        _ck(_v, 1, 0, currVal_0);
    });
}
function View_ModalCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-modal', [], null, [['body', 'keyup']], (_v, en, $event) => {
            var ad = true;
            if (('body:keyup' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1)._keyUp($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_ModalCmp_0, RenderType_ModalCmp)), core_es5["_16" /* did */](180224, null, 0, modal_component_ModalCmp, [core_es5["l" /* ComponentFactoryResolver */], core_es5["O" /* Renderer */], core_es5["p" /* ElementRef */], NavParams, view_controller_ViewController,
            GestureController, ModuleLoader], null, null)], null, null);
}
const ModalCmpNgFactory = core_es5["_13" /* ccf */]('ion-modal', modal_component_ModalCmp, View_ModalCmp_Host_0, {}, {}, []);
//# sourceMappingURL=modal-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/picker/picker-column.ngfactory.ts







const styles_PickerColumnCmp = [];
const RenderType_PickerColumnCmp = core_es5["_15" /* crt */]({ encapsulation: 2,
    styles: styles_PickerColumnCmp, data: {} });
function View_PickerColumnCmp_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'picker-prefix']], [[4, 'width', null]], null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.col.prefixWidth;
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _co.col.prefix;
        _ck(_v, 1, 0, currVal_1);
    });
}
function View_PickerColumnCmp_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'button', [['class',
                'picker-opt'], ['disable-activated', '']], [[2, 'picker-opt-disabled', null]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.optClick($event, _v.context.index) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.disabled;
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _v.context.$implicit.text;
        _ck(_v, 1, 0, currVal_1);
    });
}
function View_PickerColumnCmp_3(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'picker-suffix']], [[4, 'width', null]], null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.col.suffixWidth;
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _co.col.suffix;
        _ck(_v, 1, 0, currVal_1);
    });
}
function View_PickerColumnCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](402653184, 1, { colEle: 0 }), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_PickerColumnCmp_1)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null),
        (_l()(), core_es5["_18" /* eld */](0, [[1, 0], ['colEle', 1]], null, 2, 'div', [['class', 'picker-opts']], [[4, 'max-width', null]], null, null, null, null)), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_PickerColumnCmp_2)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null),
        (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_PickerColumnCmp_3)),
        core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0,
                'ngIf'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.col.prefix;
        _ck(_v, 2, 0, currVal_0);
        const currVal_2 = _co.col.options;
        _ck(_v, 5, 0, currVal_2);
        const currVal_3 = _co.col.suffix;
        _ck(_v, 7, 0, currVal_3);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = _co.col.optionsWidth;
        _ck(_v, 3, 0, currVal_1);
    });
}
function View_PickerColumnCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'picker-col']], [[4, 'max-width', null], [2, 'picker-opts-left', null],
            [2, 'picker-opts-right', null]], null, null, View_PickerColumnCmp_0, RenderType_PickerColumnCmp)), core_es5["_16" /* did */](4374528, null, 0, picker_column_PickerColumnCmp, [config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */], Haptic, platform_Platform, dom_controller_DomController], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1).col.columnWidth;
        const currVal_1 = (core_es5["_32" /* nov */](_v, 1).col.align == 'left');
        const currVal_2 = (core_es5["_32" /* nov */](_v, 1).col.align == 'right');
        _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2);
    });
}
const PickerColumnCmpNgFactory = core_es5["_13" /* ccf */]('.picker-col', picker_column_PickerColumnCmp, View_PickerColumnCmp_Host_0, { col: 'col' }, { ionChange: 'ionChange' }, []);
//# sourceMappingURL=picker-column.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/picker/picker-component.ngfactory.ts















const styles_PickerCmp = [];
const RenderType_PickerCmp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_PickerCmp,
    data: {} });
function View_PickerCmp_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 7, 'div', [['class',
                'picker-toolbar-button']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */],
            core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1,
                'ngClass'] }, null), (_l()(), core_es5["_37" /* ted */](null, ['\n          '])),
        (_l()(), core_es5["_18" /* eld */](0, null, null, 3, 'button', [['class', 'picker-button'],
            ['clear', ''], ['ion-button', '']], null, [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.btnClick(_v.context.$implicit) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, ''], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { clear: [0,
                'clear'] }, null), (_l()(), core_es5["_37" /* ted */](0, ['\n            ', '\n          '])),
        (_l()(), core_es5["_37" /* ted */](null, ['\n        ']))], (_ck, _v) => {
        const currVal_0 = 'picker-toolbar-button';
        const currVal_1 = _v.context.$implicit.cssRole;
        _ck(_v, 1, 0, currVal_0, currVal_1);
        const currVal_2 = 'picker-button';
        const currVal_3 = _v.context.$implicit.cssClass;
        _ck(_v, 4, 0, currVal_2, currVal_3);
        const currVal_4 = '';
        _ck(_v, 5, 0, currVal_4);
    }, (_ck, _v) => {
        const currVal_5 = _v.context.$implicit.text;
        _ck(_v, 6, 0, currVal_5);
    });
}
function View_PickerCmp_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'picker-col']], [[4, 'max-width', null], [2, 'picker-opts-left', null],
            [2, 'picker-opts-right', null]], [[null, 'ionChange']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('ionChange' === en)) {
                const pd_0 = (_co._colChange($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_PickerColumnCmp_0, RenderType_PickerColumnCmp)), core_es5["_16" /* did */](4374528, [[1,
                4]], 0, picker_column_PickerColumnCmp, [config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */], Haptic,
            platform_Platform, dom_controller_DomController], { col: [0, 'col'] }, { ionChange: 'ionChange' })], (_ck, _v) => {
        const currVal_3 = _v.context.$implicit;
        _ck(_v, 1, 0, currVal_3);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1).col.columnWidth;
        const currVal_1 = (core_es5["_32" /* nov */](_v, 1).col.align == 'left');
        const currVal_2 = (core_es5["_32" /* nov */](_v, 1).col.align == 'right');
        _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2);
    });
}
function View_PickerCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](671088640, 1, { _cols: 1 }), (_l()(), core_es5["_37" /* ted */](null, ['\n    '])),
        (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-backdrop', [['disable-activated',
                ''], ['role', 'presentation'], ['tappable', '']], null, [[null,
                'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.bdClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, Backdrop, [core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_37" /* ted */](null, ['\n    '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 17, 'div', [['class',
                'picker-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['\n      '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'div', [['class', 'picker-toolbar']], null, null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['\n        '])), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_PickerCmp_1)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null), (_l()(), core_es5["_37" /* ted */](null, ['\n      '])), (_l()(), core_es5["_37" /* ted */](null, ['\n      '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 8, 'div', [['class',
                'picker-columns']], null, null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, ['\n        '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'picker-above-highlight']], null, null, null, null, null)),
        (_l()(), core_es5["_37" /* ted */](null, ['\n        '])), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_PickerCmp_2)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0,
                'ngForOf'] }, null), (_l()(), core_es5["_37" /* ted */](null, ['\n        '])),
        (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'picker-below-highlight']], null, null, null, null, null)),
        (_l()(), core_es5["_37" /* ted */](null, ['\n      '])), (_l()(), core_es5["_37" /* ted */](null, ['\n    '])),
        (_l()(), core_es5["_37" /* ted */](null, ['\n  ']))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.d.buttons;
        _ck(_v, 10, 0, currVal_0);
        const currVal_1 = _co.d.columns;
        _ck(_v, 18, 0, currVal_1);
    }, null);
}
function View_PickerCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-picker-cmp', [['role', 'dialog']], null, [['body', 'keyup']], (_v, en, $event) => {
            var ad = true;
            if (('body:keyup' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1)._keyUp($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_PickerCmp_0, RenderType_PickerCmp)), core_es5["_16" /* did */](180224, null, 0, picker_component_PickerCmp, [view_controller_ViewController, core_es5["p" /* ElementRef */], config_Config, GestureController, NavParams,
            core_es5["O" /* Renderer */]], null, null)], null, null);
}
const PickerCmpNgFactory = core_es5["_13" /* ccf */]('ion-picker-cmp', picker_component_PickerCmp, View_PickerCmp_Host_0, {}, {}, []);
//# sourceMappingURL=picker-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/popover/popover-component.ngfactory.ts








const styles_PopoverCmp = [];
const RenderType_PopoverCmp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_PopoverCmp,
    data: {} });
function View_PopoverCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](402653184, 1, { _viewport: 0 }), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-backdrop', [['disable-activated', ''], ['role', 'presentation'],
            ['tappable', '']], [[8, 'hidden', 0]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co._bdClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](16384, null, 0, Backdrop, [core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'div', [['class', 'popover-wrapper']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'popover-arrow']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class', 'popover-content']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class', 'popover-viewport']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](16777216, [[1, 3], ['viewport', 1]], null, 0, 'div', [['nav-viewport', '']], null, null, null, null, null))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = !_co.d.showBackdrop;
        _ck(_v, 1, 0, currVal_0);
    });
}
function View_PopoverCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-popover', [], null, [['body', 'keyup']], (_v, en, $event) => {
            var ad = true;
            if (('body:keyup' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1)._keyUp($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_PopoverCmp_0, RenderType_PopoverCmp)), core_es5["_16" /* did */](180224, null, 0, popover_component_PopoverCmp, [core_es5["l" /* ComponentFactoryResolver */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], config_Config, NavParams,
            view_controller_ViewController, GestureController, ModuleLoader], null, null)], null, null);
}
const PopoverCmpNgFactory = core_es5["_13" /* ccf */]('ion-popover', popover_component_PopoverCmp, View_PopoverCmp_Host_0, {}, {}, []);
//# sourceMappingURL=popover-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/item/reorder.ngfactory.ts




const styles_Reorder = [];
const RenderType_Reorder = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Reorder,
    data: {} });
function View_Reorder_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-icon', [['name',
                'reorder'], ['role', 'img']], [[2, 'hide', null]], null, null, null, null)), core_es5["_16" /* did */](147456, null, 0, icon_Icon, [config_Config,
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { name: [0, 'name'] }, null)], (_ck, _v) => {
        const currVal_1 = 'reorder';
        _ck(_v, 1, 0, currVal_1);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._hidden;
        _ck(_v, 0, 0, currVal_0);
    });
}
function View_Reorder_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-reorder', [], null, [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            if (('click' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1).onClick($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Reorder_0, RenderType_Reorder)), core_es5["_16" /* did */](49152, null, 0, reorder_Reorder, [core_es5["p" /* ElementRef */]], null, null)], null, null);
}
const ReorderNgFactory = core_es5["_13" /* ccf */]('ion-reorder', reorder_Reorder, View_Reorder_Host_0, {}, {}, []);
//# sourceMappingURL=reorder.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/item/item.ngfactory.ts









const styles_Item = [];
const RenderType_Item = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Item,
    data: {} });
function View_Item_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'ion-label', [], null, null, null, null, null)), core_es5["_16" /* did */](16384, [[1, 4]], 0, Label, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [8, null], [8,
                null], [8, null], [8, null]], null, null),
        core_es5["_31" /* ncd */](null, 2)], null, null);
}
function View_Item_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-reorder', [], null, [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            if (('click' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1).onClick($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Reorder_0, RenderType_Reorder)), core_es5["_16" /* did */](49152, null, 0, reorder_Reorder, [core_es5["p" /* ElementRef */]], null, null)], null, null);
}
function View_Item_0(_l) {
    return core_es5["_38" /* vid */](2, [core_es5["_35" /* qud */](671088640, 1, { viewLabel: 0 }), core_es5["_31" /* ncd */](null, 0), (_l()(),
            core_es5["_18" /* eld */](0, null, null, 8, 'div', [['class', 'item-inner']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'div', [['class', 'input-wrapper']], null, null, null, null, null)), core_es5["_31" /* ncd */](null, 1), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_Item_1)),
        core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0,
                'ngIf'] }, null), core_es5["_31" /* ncd */](null, 3), core_es5["_31" /* ncd */](null, 4),
        (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_Item_2)),
        core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0,
                'ngIf'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'button-effect']], null, null, null, null, null))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co._viewLabel;
        _ck(_v, 6, 0, currVal_0);
        const currVal_1 = _co._hasReorder;
        _ck(_v, 10, 0, currVal_1);
    }, null);
}
function View_Item_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 4, 'ion-list-header', [['class', 'item']], null, null, null, View_Item_0, RenderType_Item)),
        core_es5["_16" /* did */](1097728, null, 3, Item, [form_Form, config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */],
            [2, item_reorder_ItemReorder]], null, null), core_es5["_35" /* qud */](335544320, 1, { contentLabel: 0 }),
        core_es5["_35" /* qud */](603979776, 2, { _buttons: 1 }), core_es5["_35" /* qud */](603979776, 3, { _icons: 1 })], null, null);
}
const ItemNgFactory = core_es5["_13" /* ccf */]('ion-list-header,ion-item,[ion-item],ion-item-divider', Item, View_Item_Host_0, { color: 'color', mode: 'mode' }, {}, ['[item-start],[item-left],ion-checkbox:not([item-end]):not([item-right])',
    'ion-label', '*', 'ion-select,ion-input,ion-textarea,ion-datetime,ion-range,[item-content]',
    '[item-end],[item-right],ion-radio,ion-toggle']);
//# sourceMappingURL=item.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/radio/radio-button.ngfactory.ts








const styles_RadioButton = [];
const RenderType_RadioButton = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_RadioButton,
    data: {} });
function View_RadioButton_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 3, 'div', [['class',
                'radio-icon']], [[2, 'radio-checked', null]], null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(),
            core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'radio-inner']], null, null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'button', [['class', 'item-cover'], ['ion-button', 'item-cover'],
            ['role', 'radio'], ['type', 'button']], [[8, 'id', 0], [1, 'aria-checked', 0], [1,
                'aria-labelledby', 0], [1, 'aria-disabled', 0]], null, null, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, 'item-cover'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null),
        (_l()(), core_es5["_37" /* ted */](0, [' ']))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co._checked;
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _co.id;
        const currVal_2 = _co._checked;
        const currVal_3 = _co._labelId;
        const currVal_4 = _co._disabled;
        _ck(_v, 5, 0, currVal_1, currVal_2, currVal_3, currVal_4);
    });
}
function View_RadioButton_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-radio', [], [[2, 'radio-disabled', null]], [[null, 'click']], (_v, en, $event) => {
            var ad = true;
            if (('click' === en)) {
                const pd_0 = (core_es5["_32" /* nov */](_v, 1)._click($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_RadioButton_0, RenderType_RadioButton)), core_es5["_16" /* did */](245760, null, 0, radio_button_RadioButton, [form_Form, config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, Item], [2, radio_group_RadioGroup]], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._disabled;
        _ck(_v, 0, 0, currVal_0);
    });
}
const RadioButtonNgFactory = core_es5["_13" /* ccf */]('ion-radio', radio_button_RadioButton, View_RadioButton_Host_0, { color: 'color', mode: 'mode', value: 'value',
    checked: 'checked', disabled: 'disabled' }, { ionSelect: 'ionSelect' }, []);
//# sourceMappingURL=radio-button.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/select/select-popover-component.ngfactory.ts




















const styles_SelectPopover = [];
const RenderType_SelectPopover = core_es5["_15" /* crt */]({ encapsulation: 2,
    styles: styles_SelectPopover, data: {} });
function View_SelectPopover_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 13, 'ion-item', [['class',
                'item item-block']], null, null, null, View_Item_0, RenderType_Item)), core_es5["_16" /* did */](1097728, null, 3, Item, [form_Form, config_Config,
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, item_reorder_ItemReorder]], null, null), core_es5["_35" /* qud */](335544320, 2, { contentLabel: 0 }), core_es5["_35" /* qud */](603979776, 3, { _buttons: 1 }), core_es5["_35" /* qud */](603979776, 4, { _icons: 1 }),
        core_es5["_16" /* did */](16384, null, 0, ItemContent, [], null, null),
        (_l()(), core_es5["_37" /* ted */](2, ['\n        '])), (_l()(), core_es5["_18" /* eld */](0, null, 1, 2, 'ion-label', [], null, null, null, null, null)),
        core_es5["_16" /* did */](16384, [[2, 4]], 0, Label, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [8, null],
            [8, null], [8, null], [8, null]], null, null),
        (_l()(), core_es5["_37" /* ted */](null, ['', ''])), (_l()(), core_es5["_37" /* ted */](2, ['\n        '])), (_l()(),
            core_es5["_18" /* eld */](0, null, 4, 1, 'ion-radio', [], [[2, 'radio-disabled',
                    null]], [[null, 'click']], (_v, en, $event) => {
                var ad = true;
                if (('click' === en)) {
                    const pd_0 = (core_es5["_32" /* nov */](_v, 12)._click($event) !== false);
                    ad = (pd_0 && ad);
                }
                return ad;
            }, View_RadioButton_0, RenderType_RadioButton)), core_es5["_16" /* did */](245760, null, 0, radio_button_RadioButton, [form_Form, config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, Item],
            [2, radio_group_RadioGroup]], { value: [0, 'value'], checked: [1, 'checked'], disabled: [2,
                'disabled'] }, null), (_l()(), core_es5["_37" /* ted */](2, ['\n      ']))], (_ck, _v) => {
        const currVal_2 = _v.context.$implicit.value;
        const currVal_3 = _v.context.$implicit.checked;
        const currVal_4 = _v.context.$implicit.disabled;
        _ck(_v, 12, 0, currVal_2, currVal_3, currVal_4);
    }, (_ck, _v) => {
        const currVal_0 = _v.context.$implicit.text;
        _ck(_v, 9, 0, currVal_0);
        const currVal_1 = core_es5["_32" /* nov */](_v, 12)._disabled;
        _ck(_v, 11, 0, currVal_1);
    });
}
function View_SelectPopover_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_37" /* ted */](null, ['\n    '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 11, 'ion-list', [['radio-group', ''], ['role', 'radiogroup']], [[2, 'ng-untouched',
                null], [2, 'ng-touched', null], [2, 'ng-pristine', null],
            [2, 'ng-dirty', null], [2, 'ng-valid', null], [2, 'ng-invalid',
                null], [2, 'ng-pending', null]], [[null, 'ngModelChange']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('ngModelChange' === en)) {
                const pd_0 = ((_co.value = $event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, null, null)), core_es5["_16" /* did */](1064960, null, 1, radio_group_RadioGroup, [core_es5["O" /* Renderer */], core_es5["p" /* ElementRef */], core_es5["i" /* ChangeDetectorRef */]], null, null),
        core_es5["_35" /* qud */](335544320, 1, { _header: 0 }), core_es5["_34" /* prd */](1024, null, forms_es5["e" /* NG_VALUE_ACCESSOR */], (p0_0) => {
            return [p0_0];
        }, [radio_group_RadioGroup]), core_es5["_16" /* did */](671744, null, 0, forms_es5["h" /* NgModel */], [[8, null],
            [8, null], [8, null], [2, forms_es5["e" /* NG_VALUE_ACCESSOR */]]], { model: [0,
                'model'] }, { update: 'ngModelChange' }), core_es5["_34" /* prd */](2048, null, forms_es5["f" /* NgControl */], null, [forms_es5["h" /* NgModel */]]), core_es5["_16" /* did */](16384, null, 0, forms_es5["g" /* NgControlStatus */], [forms_es5["f" /* NgControl */]], null, null), core_es5["_16" /* did */](16384, null, 0, list_List, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], platform_Platform, GestureController,
            dom_controller_DomController], null, null), (_l()(), core_es5["_37" /* ted */](null, ['\n      '])), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_SelectPopover_1)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */],
            core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0, 'ngForOf'] }, null),
        (_l()(), core_es5["_37" /* ted */](null, ['\n    '])), (_l()(), core_es5["_37" /* ted */](null, ['\n  ']))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_7 = _co.value;
        _ck(_v, 5, 0, currVal_7);
        const currVal_8 = _co.options;
        _ck(_v, 11, 0, currVal_8);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 7).ngClassUntouched;
        const currVal_1 = core_es5["_32" /* nov */](_v, 7).ngClassTouched;
        const currVal_2 = core_es5["_32" /* nov */](_v, 7).ngClassPristine;
        const currVal_3 = core_es5["_32" /* nov */](_v, 7).ngClassDirty;
        const currVal_4 = core_es5["_32" /* nov */](_v, 7).ngClassValid;
        const currVal_5 = core_es5["_32" /* nov */](_v, 7).ngClassInvalid;
        const currVal_6 = core_es5["_32" /* nov */](_v, 7).ngClassPending;
        _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5, currVal_6);
    });
}
function View_SelectPopover_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ng-component', [], null, null, null, View_SelectPopover_0, RenderType_SelectPopover)), core_es5["_16" /* did */](114688, null, 0, SelectPopover, [NavParams, view_controller_ViewController], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, null);
}
const SelectPopoverNgFactory = core_es5["_13" /* ccf */]('ng-component', SelectPopover, View_SelectPopover_Host_0, {}, {}, []);
//# sourceMappingURL=select-popover-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/toast/toast-component.ngfactory.ts








const styles_ToastCmp = [];
const RenderType_ToastCmp = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_ToastCmp,
    data: {} });
function View_ToastCmp_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'toast-message']], [[8, 'id', 0]], null, null, null, null)),
        (_l()(), core_es5["_37" /* ted */](null, ['', '']))], null, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = core_es5["_21" /* inlineInterpolate */](1, '', _co.hdrId, '');
        _ck(_v, 0, 0, currVal_0);
        const currVal_1 = _co.d.message;
        _ck(_v, 1, 0, currVal_1);
    });
}
function View_ToastCmp_2(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'button', [['class',
                'toast-button'], ['clear', ''], ['ion-button', '']], null, [[null,
                'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.cbClick() !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, ''], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { clear: [0, 'clear'] }, null),
        (_l()(), core_es5["_37" /* ted */](0, [' ', ' ']))], (_ck, _v) => {
        const currVal_0 = '';
        _ck(_v, 1, 0, currVal_0);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_1 = (_co.d.closeButtonText || 'Close');
        _ck(_v, 2, 0, currVal_1);
    });
}
function View_ToastCmp_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 10, 'div', [['class',
                'toast-wrapper']], [[2, 'toast-bottom', null], [2, 'toast-middle', null],
            [2, 'toast-top', null]], null, null, null, null)),
        (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 7, 'div', [['class', 'toast-container']], null, null, null, null, null)), (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(),
            core_es5["_12" /* and */](16777216, null, null, 1, null, View_ToastCmp_1)),
        core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0,
                'ngIf'] }, null), (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_ToastCmp_2)), core_es5["_16" /* did */](16384, null, 0, common_es5["i" /* NgIf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */]], { ngIf: [0, 'ngIf'] }, null), (_l()(), core_es5["_37" /* ted */](null, [' '])), (_l()(), core_es5["_37" /* ted */](null, [' ']))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_3 = _co.d.message;
        _ck(_v, 5, 0, currVal_3);
        const currVal_4 = _co.d.showCloseButton;
        _ck(_v, 8, 0, currVal_4);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = (_co.d.position === 'bottom');
        const currVal_1 = (_co.d.position === 'middle');
        const currVal_2 = (_co.d.position === 'top');
        _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2);
    });
}
function View_ToastCmp_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-toast', [['role',
                'dialog']], [[1, 'aria-labelledby', 0], [1, 'aria-describedby', 0]], null, null, View_ToastCmp_0, RenderType_ToastCmp)), core_es5["_16" /* did */](4243456, null, 0, ToastCmp, [view_controller_ViewController, config_Config, core_es5["p" /* ElementRef */], NavParams, core_es5["O" /* Renderer */]], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1).hdrId;
        const currVal_1 = core_es5["_32" /* nov */](_v, 1).descId;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
const ToastCmpNgFactory = core_es5["_13" /* ccf */]('ion-toast', ToastCmp, View_ToastCmp_Host_0, {}, {}, []);
//# sourceMappingURL=toast-component.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/toolbar/navbar.ngfactory.ts










const styles_Navbar = [];
const RenderType_Navbar = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Navbar,
    data: {} });
function View_Navbar_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'toolbar-background']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */],
            core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1,
                'ngClass'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, null, 8, 'button', [['class', 'back-button'], ['ion-button', 'bar-button']], [[8, 'hidden', 0]], [[null,
                'click']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.backButtonClick($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0,
                'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, 'bar-button'], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_18" /* eld */](0, null, 0, 2, 'ion-icon', [['class', 'back-button-icon'],
            ['role', 'img']], [[2, 'hide', null]], null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */],
            core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1,
                'ngClass'] }, null), core_es5["_16" /* did */](147456, null, 0, icon_Icon, [config_Config,
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { name: [0, 'name'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, 0, 2, 'span', [['class', 'back-button-text']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0,
                'klass'], ngClass: [1, 'ngClass'] }, null), (_l()(), core_es5["_37" /* ted */](null, ['', ''])), core_es5["_31" /* ncd */](null, 0), core_es5["_31" /* ncd */](null, 1), core_es5["_31" /* ncd */](null, 2), (_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class', 'toolbar-content']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_31" /* ncd */](null, 3)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = 'toolbar-background';
        const currVal_1 = ('toolbar-background-' + _co._mode);
        _ck(_v, 1, 0, currVal_0, currVal_1);
        const currVal_3 = 'back-button';
        const currVal_4 = ('back-button-' + _co._mode);
        _ck(_v, 3, 0, currVal_3, currVal_4);
        const currVal_6 = 'back-button-icon';
        const currVal_7 = ('back-button-icon-' + _co._mode);
        _ck(_v, 6, 0, currVal_6, currVal_7);
        const currVal_8 = _co._bbIcon;
        _ck(_v, 7, 0, currVal_8);
        const currVal_9 = 'back-button-text';
        const currVal_10 = ('back-button-text-' + _co._mode);
        _ck(_v, 9, 0, currVal_9, currVal_10);
        const currVal_12 = 'toolbar-content';
        const currVal_13 = ('toolbar-content-' + _co._mode);
        _ck(_v, 15, 0, currVal_12, currVal_13);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_2 = _co._hideBb;
        _ck(_v, 2, 0, currVal_2);
        const currVal_5 = core_es5["_32" /* nov */](_v, 7)._hidden;
        _ck(_v, 5, 0, currVal_5);
        const currVal_11 = _co._backText;
        _ck(_v, 10, 0, currVal_11);
    });
}
function View_Navbar_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-navbar', [['class',
                'toolbar']], [[8, 'hidden', 0], [2, 'statusbar-padding', null]], null, null, View_Navbar_0, RenderType_Navbar)), core_es5["_16" /* did */](49152, null, 0, navbar_Navbar, [app_App, [2, view_controller_ViewController], [2, NavController], config_Config, core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */]], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._hidden;
        const currVal_1 = core_es5["_32" /* nov */](_v, 1)._sbPadding;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
const NavbarNgFactory = core_es5["_13" /* ccf */]('ion-navbar', navbar_Navbar, View_Navbar_Host_0, { color: 'color', mode: 'mode', hideBackButton: 'hideBackButton' }, {}, ['[menuToggle],ion-buttons[left]', 'ion-buttons[start]', 'ion-buttons[end],ion-buttons[right]',
    '*']);
//# sourceMappingURL=navbar.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/toolbar/toolbar-title.ngfactory.ts






const styles_ToolbarTitle = [];
const RenderType_ToolbarTitle = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_ToolbarTitle,
    data: {} });
function View_ToolbarTitle_0(_l) {
    return core_es5["_38" /* vid */](2, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class',
                'toolbar-title']], null, null, null, null, null)),
        core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */],
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1, 'ngClass'] }, null),
        core_es5["_31" /* ncd */](null, 0)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = 'toolbar-title';
        const currVal_1 = ('toolbar-title-' + _co._mode);
        _ck(_v, 1, 0, currVal_0, currVal_1);
    }, null);
}
function View_ToolbarTitle_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-title', [], null, null, null, View_ToolbarTitle_0, RenderType_ToolbarTitle)),
        core_es5["_16" /* did */](49152, null, 0, ToolbarTitle, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */],
            [2, Toolbar], [2, navbar_Navbar]], null, null)], null, null);
}
const ToolbarTitleNgFactory = core_es5["_13" /* ccf */]('ion-title', ToolbarTitle, View_ToolbarTitle_Host_0, { color: 'color', mode: 'mode' }, {}, ['*']);
//# sourceMappingURL=toolbar-title.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/toolbar/toolbar.ngfactory.ts




const styles_Toolbar = [];
const RenderType_Toolbar = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Toolbar,
    data: {} });
function View_Toolbar_0(_l) {
    return core_es5["_38" /* vid */](2, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'div', [['class',
                'toolbar-background']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */],
            core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0, 'klass'], ngClass: [1,
                'ngClass'] }, null), core_es5["_31" /* ncd */](null, 0), core_es5["_31" /* ncd */](null, 1),
        core_es5["_31" /* ncd */](null, 2), (_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'div', [['class', 'toolbar-content']], null, null, null, null, null)), core_es5["_16" /* did */](278528, null, 0, common_es5["g" /* NgClass */], [core_es5["A" /* IterableDiffers */], core_es5["B" /* KeyValueDiffers */], core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { klass: [0,
                'klass'], ngClass: [1, 'ngClass'] }, null), core_es5["_31" /* ncd */](null, 3)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = 'toolbar-background';
        const currVal_1 = ('toolbar-background-' + _co._mode);
        _ck(_v, 1, 0, currVal_0, currVal_1);
        const currVal_2 = 'toolbar-content';
        const currVal_3 = ('toolbar-content-' + _co._mode);
        _ck(_v, 6, 0, currVal_2, currVal_3);
    }, null);
}
function View_Toolbar_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-toolbar', [['class', 'toolbar']], [[2, 'statusbar-padding', null]], null, null, View_Toolbar_0, RenderType_Toolbar)), core_es5["_16" /* did */](49152, null, 0, Toolbar, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._sbPadding;
        _ck(_v, 0, 0, currVal_0);
    });
}
const ToolbarNgFactory = core_es5["_13" /* ccf */]('ion-toolbar', Toolbar, View_Toolbar_Host_0, { color: 'color', mode: 'mode' }, {}, ['[menuToggle],ion-buttons[left]',
    'ion-buttons[start]', 'ion-buttons[end],ion-buttons[right]', '*']);
//# sourceMappingURL=toolbar.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/searchbar/searchbar.ngfactory.ts








const styles_Searchbar = [];
const RenderType_Searchbar = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Searchbar,
    data: {} });
function View_Searchbar_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](402653184, 1, { _searchbarInput: 0 }), core_es5["_35" /* qud */](402653184, 2, { _searchbarIcon: 0 }),
        core_es5["_35" /* qud */](402653184, 3, { _cancelButton: 0 }), (_l()(), core_es5["_18" /* eld */](0, null, null, 8, 'div', [['class', 'searchbar-input-container']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 3, 'button', [['class', 'searchbar-md-cancel'], ['clear', ''], ['color',
                'dark'], ['ion-button', ''], ['mode', 'md'], ['type', 'button']], null, [[null, 'click'], [null, 'mousedown']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.cancelSearchbar($event) !== false);
                ad = (pd_0 && ad);
            }
            if (('mousedown' === en)) {
                const pd_1 = (_co.cancelSearchbar($event) !== false);
                ad = (pd_1 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, ''], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { color: [0, 'color'],
            mode: [1, 'mode'], clear: [2, 'clear'] }, null), (_l()(), core_es5["_18" /* eld */](0, null, 0, 1, 'ion-icon', [['name', 'md-arrow-back'], ['role', 'img']], [[2,
                'hide', null]], null, null, null, null)),
        core_es5["_16" /* did */](147456, null, 0, icon_Icon, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { name: [0, 'name'] }, null), (_l()(), core_es5["_18" /* eld */](0, [[2, 0], ['searchbarIcon',
                1]], null, 0, 'div', [['class', 'searchbar-search-icon']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, [[1, 0], ['searchbarInput', 1]], null, 0, 'input', [['class', 'searchbar-input']], [[1, 'placeholder', 0], [1, 'type', 0], [1, 'autocomplete', 0], [1, 'autocorrect',
                0], [1, 'spellcheck', 0]], [[null, 'input'], [null, 'blur'],
            [null, 'focus']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('input' === en)) {
                const pd_0 = (_co.inputChanged($event) !== false);
                ad = (pd_0 && ad);
            }
            if (('blur' === en)) {
                const pd_1 = (_co.inputBlurred() !== false);
                ad = (pd_1 && ad);
            }
            if (('focus' === en)) {
                const pd_2 = (_co.inputFocused() !== false);
                ad = (pd_2 && ad);
            }
            return ad;
        }, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'button', [['class', 'searchbar-clear-icon'], ['clear', ''], ['ion-button',
                ''], ['type', 'button']], null, [[null, 'click'], [null,
                'mousedown']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.clearInput($event) !== false);
                ad = (pd_0 && ad);
            }
            if (('mousedown' === en)) {
                const pd_1 = (_co.clearInput($event) !== false);
                ad = (pd_1 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, null, 0, button_Button, [[8, ''], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { mode: [0, 'mode'],
            clear: [1, 'clear'] }, null), (_l()(), core_es5["_18" /* eld */](0, [[3, 0]], null, 2, 'button', [['class', 'searchbar-ios-cancel'], ['clear', ''], ['ion-button',
                ''], ['mode', 'ios'], ['type', 'button']], [[8, 'tabIndex', 0]], [[null,
                'click'], [null, 'mousedown']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('click' === en)) {
                const pd_0 = (_co.cancelSearchbar($event) !== false);
                ad = (pd_0 && ad);
            }
            if (('mousedown' === en)) {
                const pd_1 = (_co.cancelSearchbar($event) !== false);
                ad = (pd_1 && ad);
            }
            return ad;
        }, View_Button_0, RenderType_Button)), core_es5["_16" /* did */](1097728, [['cancelButton',
                4]], 0, button_Button, [[8, ''], config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { mode: [0, 'mode'],
            clear: [1, 'clear'] }, null), (_l()(), core_es5["_37" /* ted */](0, ['', '']))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = 'dark';
        const currVal_1 = 'md';
        const currVal_2 = '';
        _ck(_v, 5, 0, currVal_0, currVal_1, currVal_2);
        const currVal_4 = 'md-arrow-back';
        _ck(_v, 7, 0, currVal_4);
        const currVal_10 = _co._mode;
        const currVal_11 = '';
        _ck(_v, 11, 0, currVal_10, currVal_11);
        const currVal_13 = 'ios';
        const currVal_14 = '';
        _ck(_v, 13, 0, currVal_13, currVal_14);
    }, (_ck, _v) => {
        var _co = _v.component;
        const currVal_3 = core_es5["_32" /* nov */](_v, 7)._hidden;
        _ck(_v, 6, 0, currVal_3);
        const currVal_5 = _co.placeholder;
        const currVal_6 = _co.type;
        const currVal_7 = _co._autocomplete;
        const currVal_8 = _co._autocorrect;
        const currVal_9 = _co._spellcheck;
        _ck(_v, 9, 0, currVal_5, currVal_6, currVal_7, currVal_8, currVal_9);
        const currVal_12 = (_co._isActive ? 1 : (0 - 1));
        _ck(_v, 12, 0, currVal_12);
        const currVal_15 = _co.cancelButtonText;
        _ck(_v, 14, 0, currVal_15);
    });
}
function View_Searchbar_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-searchbar', [], [[2, 'searchbar-animated', null], [2, 'searchbar-has-value',
                null], [2, 'searchbar-active', null], [2, 'searchbar-show-cancel',
                null], [2, 'searchbar-left-aligned', null], [2, 'searchbar-has-focus',
                null]], null, null, View_Searchbar_0, RenderType_Searchbar)),
        core_es5["_16" /* did */](1294336, null, 0, searchbar_Searchbar, [config_Config, platform_Platform, core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */], [2, forms_es5["f" /* NgControl */]]], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1)._animated;
        const currVal_1 = core_es5["_32" /* nov */](_v, 1)._value;
        const currVal_2 = core_es5["_32" /* nov */](_v, 1)._isActive;
        const currVal_3 = core_es5["_32" /* nov */](_v, 1)._showCancelButton;
        const currVal_4 = core_es5["_32" /* nov */](_v, 1)._shouldAlignLeft;
        const currVal_5 = core_es5["_32" /* nov */](_v, 1)._isFocus;
        _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5);
    });
}
const SearchbarNgFactory = core_es5["_13" /* ccf */]('ion-searchbar', searchbar_Searchbar, View_Searchbar_Host_0, { color: 'color', mode: 'mode', disabled: 'disabled',
    cancelButtonText: 'cancelButtonText', showCancelButton: 'showCancelButton', debounce: 'debounce',
    placeholder: 'placeholder', autocomplete: 'autocomplete', autocorrect: 'autocorrect',
    spellcheck: 'spellcheck', type: 'type', animated: 'animated' }, { ionFocus: 'ionFocus',
    ionChange: 'ionChange', ionBlur: 'ionBlur', ionInput: 'ionInput', ionCancel: 'ionCancel',
    ionClear: 'ionClear' }, []);
//# sourceMappingURL=searchbar.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/content/content.ngfactory.ts









const styles_Content = [];
const RenderType_Content = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Content,
    data: {} });
function View_Content_0(_l) {
    return core_es5["_38" /* vid */](2, [core_es5["_35" /* qud */](402653184, 1, { _fixedContent: 0 }), core_es5["_35" /* qud */](402653184, 2, { _scrollContent: 0 }),
        (_l()(), core_es5["_18" /* eld */](0, [[1, 0], ['fixedContent', 1]], null, 1, 'div', [['class',
                'fixed-content']], null, null, null, null, null)), core_es5["_31" /* ncd */](null, 0), (_l()(), core_es5["_18" /* eld */](0, [[2, 0], ['scrollContent',
                1]], null, 1, 'div', [['class', 'scroll-content']], null, null, null, null, null)), core_es5["_31" /* ncd */](null, 1), core_es5["_31" /* ncd */](null, 2)], null, null);
}
function View_Content_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ion-content', [], [[2, 'statusbar-padding', null], [2, 'has-refresher', null]], null, null, View_Content_0, RenderType_Content)), core_es5["_16" /* did */](4374528, null, 0, content_Content, [config_Config, platform_Platform, dom_controller_DomController, core_es5["p" /* ElementRef */],
            core_es5["O" /* Renderer */], app_App, keyboard_Keyboard, core_es5["G" /* NgZone */], [2, view_controller_ViewController], [2, NavController]], null, null)], null, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 1).statusbarPadding;
        const currVal_1 = core_es5["_32" /* nov */](_v, 1)._hasRefresher;
        _ck(_v, 0, 0, currVal_0, currVal_1);
    });
}
const ContentNgFactory = core_es5["_13" /* ccf */]('ion-content', content_Content, View_Content_Host_0, { color: 'color', mode: 'mode', fullscreen: 'fullscreen',
    scrollDownOnLoad: 'scrollDownOnLoad' }, { ionScrollStart: 'ionScrollStart', ionScroll: 'ionScroll',
    ionScrollEnd: 'ionScrollEnd' }, ['[ion-fixed],ion-fab', '*', 'ion-refresher']);
//# sourceMappingURL=content.ngfactory.js.map
// CONCATENATED MODULE: ./demos/src/searchbar/pages/page-one/page-one.ngfactory.ts






























const styles_PageOne = [];
const RenderType_PageOne = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_PageOne,
    data: {} });
function View_PageOne_1(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 6, 'ion-item', [['class',
                'item item-block']], null, null, null, View_Item_0, RenderType_Item)), core_es5["_16" /* did */](1097728, null, 3, Item, [form_Form, config_Config,
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, item_reorder_ItemReorder]], null, null), core_es5["_35" /* qud */](335544320, 1, { contentLabel: 0 }), core_es5["_35" /* qud */](603979776, 2, { _buttons: 1 }), core_es5["_35" /* qud */](603979776, 3, { _icons: 1 }),
        core_es5["_16" /* did */](16384, null, 0, ItemContent, [], null, null),
        (_l()(), core_es5["_37" /* ted */](2, ['\n      ', '\n    ']))], null, (_ck, _v) => {
        const currVal_0 = _v.context.$implicit;
        _ck(_v, 6, 0, currVal_0);
    });
}
function View_PageOne_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 17, 'ion-header', [], null, null, null, null, null)),
        core_es5["_16" /* did */](16384, null, 0, Header, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */],
            [2, view_controller_ViewController]], null, null), (_l()(), core_es5["_37" /* ted */](null, ['\n\n  '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 6, 'ion-navbar', [['class', 'toolbar'], ['no-border-bottom', '']], [[8, 'hidden', 0], [2, 'statusbar-padding',
                null]], null, null, View_Navbar_0, RenderType_Navbar)),
        core_es5["_16" /* did */](49152, null, 0, navbar_Navbar, [app_App, [2, view_controller_ViewController], [2, NavController],
            config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(),
            core_es5["_37" /* ted */](3, ['\n    '])), (_l()(), core_es5["_18" /* eld */](0, null, 3, 2, 'ion-title', [], null, null, null, View_ToolbarTitle_0, RenderType_ToolbarTitle)),
        core_es5["_16" /* did */](49152, null, 0, ToolbarTitle, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */],
            [2, Toolbar], [2, navbar_Navbar]], null, null), (_l()(), core_es5["_37" /* ted */](0, ['Searchbar'])), (_l()(), core_es5["_37" /* ted */](3, ['\n  '])), (_l()(), core_es5["_37" /* ted */](null, ['\n\n  '])), (_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'ion-toolbar', [['class', 'toolbar'], ['no-border-top', '']], [[2, 'statusbar-padding', null]], null, null, View_Toolbar_0, RenderType_Toolbar)),
        core_es5["_16" /* did */](49152, null, 0, Toolbar, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], null, null), (_l()(), core_es5["_37" /* ted */](3, ['\n    '])), (_l()(), core_es5["_18" /* eld */](0, null, 3, 1, 'ion-searchbar', [['placeholder', 'Filter Items']], [[2, 'searchbar-animated',
                null], [2, 'searchbar-has-value', null], [2, 'searchbar-active',
                null], [2, 'searchbar-show-cancel', null], [2, 'searchbar-left-aligned',
                null], [2, 'searchbar-has-focus', null]], [[null,
                'ionInput']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('ionInput' === en)) {
                const pd_0 = (_co.filterItems($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Searchbar_0, RenderType_Searchbar)), core_es5["_16" /* did */](1294336, null, 0, searchbar_Searchbar, [config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, forms_es5["f" /* NgControl */]]], { placeholder: [0, 'placeholder'] }, { ionInput: 'ionInput' }), (_l()(), core_es5["_37" /* ted */](3, ['\n  '])), (_l()(), core_es5["_37" /* ted */](null, ['\n\n'])), (_l()(), core_es5["_37" /* ted */](null, ['\n\n'])), (_l()(), core_es5["_18" /* eld */](0, null, null, 15, 'ion-content', [], [[2, 'statusbar-padding', null], [2, 'has-refresher',
                null]], null, null, View_Content_0, RenderType_Content)),
        core_es5["_16" /* did */](4374528, null, 0, content_Content, [config_Config, platform_Platform, dom_controller_DomController,
            core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], app_App, keyboard_Keyboard, core_es5["G" /* NgZone */], [2, view_controller_ViewController],
            [2, NavController]], null, null), (_l()(), core_es5["_37" /* ted */](1, ['\n\n  '])),
        (_l()(), core_es5["_18" /* eld */](0, null, 1, 1, 'ion-searchbar', [['color', 'danger'], ['placeholder',
                'Filter Items with Cancel'], ['showCancelButton', '']], [[2, 'searchbar-animated',
                null], [2, 'searchbar-has-value', null], [2, 'searchbar-active',
                null], [2, 'searchbar-show-cancel', null], [2, 'searchbar-left-aligned',
                null], [2, 'searchbar-has-focus', null]], [[null,
                'ionInput']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('ionInput' === en)) {
                const pd_0 = (_co.filterItems($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Searchbar_0, RenderType_Searchbar)), core_es5["_16" /* did */](1294336, null, 0, searchbar_Searchbar, [config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, forms_es5["f" /* NgControl */]]], { color: [0, 'color'], showCancelButton: [1, 'showCancelButton'], placeholder: [2,
                'placeholder'] }, { ionInput: 'ionInput' }), (_l()(), core_es5["_37" /* ted */](1, ['\n\n  '])),
        (_l()(), core_es5["_18" /* eld */](0, null, 1, 1, 'p', [['padding-left', ''], ['padding-right',
                '']], null, null, null, null, null)),
        (_l()(), core_es5["_37" /* ted */](null, ['Searchbars can be placed in a toolbar or anywhere in the content.'])),
        (_l()(), core_es5["_37" /* ted */](1, ['\n\n  '])), (_l()(), core_es5["_18" /* eld */](0, null, 1, 5, 'ion-list', [], null, null, null, null, null)),
        core_es5["_16" /* did */](16384, null, 0, list_List, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */],
            platform_Platform, GestureController, dom_controller_DomController], null, null),
        (_l()(), core_es5["_37" /* ted */](null, ['\n    '])), (_l()(), core_es5["_12" /* and */](16777216, null, null, 1, null, View_PageOne_1)), core_es5["_16" /* did */](802816, null, 0, common_es5["h" /* NgForOf */], [core_es5["_0" /* ViewContainerRef */], core_es5["U" /* TemplateRef */], core_es5["A" /* IterableDiffers */]], { ngForOf: [0,
                'ngForOf'] }, null), (_l()(), core_es5["_37" /* ted */](null, ['\n  '])),
        (_l()(), core_es5["_37" /* ted */](1, ['\n\n'])), (_l()(), core_es5["_37" /* ted */](null, ['\n\n\n'])), (_l()(),
            core_es5["_18" /* eld */](0, null, null, 9, 'ion-footer', [], null, null, null, null, null)), core_es5["_16" /* did */](16384, null, 0, Footer, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, view_controller_ViewController]], null, null), (_l()(), core_es5["_37" /* ted */](null, ['\n\n  '])),
        (_l()(), core_es5["_18" /* eld */](0, null, null, 5, 'ion-toolbar', [['class', 'toolbar'],
            ['color', 'danger']], [[2, 'statusbar-padding', null]], null, null, View_Toolbar_0, RenderType_Toolbar)), core_es5["_16" /* did */](49152, null, 0, Toolbar, [config_Config, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */]], { color: [0,
                'color'] }, null), (_l()(), core_es5["_37" /* ted */](3, ['\n    '])), (_l()(), core_es5["_18" /* eld */](0, null, 3, 1, 'ion-searchbar', [['placeholder', 'Search']], [[2, 'searchbar-animated',
                null], [2, 'searchbar-has-value', null], [2, 'searchbar-active',
                null], [2, 'searchbar-show-cancel', null], [2, 'searchbar-left-aligned',
                null], [2, 'searchbar-has-focus', null]], [[null,
                'ionInput']], (_v, en, $event) => {
            var ad = true;
            var _co = _v.component;
            if (('ionInput' === en)) {
                const pd_0 = (_co.filterItems($event) !== false);
                ad = (pd_0 && ad);
            }
            return ad;
        }, View_Searchbar_0, RenderType_Searchbar)), core_es5["_16" /* did */](1294336, null, 0, searchbar_Searchbar, [config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["O" /* Renderer */], [2, forms_es5["f" /* NgControl */]]], { placeholder: [0, 'placeholder'] }, { ionInput: 'ionInput' }), (_l()(), core_es5["_37" /* ted */](3, ['\n  '])), (_l()(), core_es5["_37" /* ted */](null, ['\n\n'])), (_l()(), core_es5["_37" /* ted */](null, ['\n']))], (_ck, _v) => {
        var _co = _v.component;
        const currVal_9 = 'Filter Items';
        _ck(_v, 15, 0, currVal_9);
        const currVal_18 = 'danger';
        const currVal_19 = '';
        const currVal_20 = 'Filter Items with Cancel';
        _ck(_v, 23, 0, currVal_18, currVal_19, currVal_20);
        const currVal_21 = _co.items;
        _ck(_v, 32, 0, currVal_21);
        const currVal_23 = 'danger';
        _ck(_v, 40, 0, currVal_23);
        const currVal_30 = 'Search';
        _ck(_v, 43, 0, currVal_30);
    }, (_ck, _v) => {
        const currVal_0 = core_es5["_32" /* nov */](_v, 4)._hidden;
        const currVal_1 = core_es5["_32" /* nov */](_v, 4)._sbPadding;
        _ck(_v, 3, 0, currVal_0, currVal_1);
        const currVal_2 = core_es5["_32" /* nov */](_v, 12)._sbPadding;
        _ck(_v, 11, 0, currVal_2);
        const currVal_3 = core_es5["_32" /* nov */](_v, 15)._animated;
        const currVal_4 = core_es5["_32" /* nov */](_v, 15)._value;
        const currVal_5 = core_es5["_32" /* nov */](_v, 15)._isActive;
        const currVal_6 = core_es5["_32" /* nov */](_v, 15)._showCancelButton;
        const currVal_7 = core_es5["_32" /* nov */](_v, 15)._shouldAlignLeft;
        const currVal_8 = core_es5["_32" /* nov */](_v, 15)._isFocus;
        _ck(_v, 14, 0, currVal_3, currVal_4, currVal_5, currVal_6, currVal_7, currVal_8);
        const currVal_10 = core_es5["_32" /* nov */](_v, 20).statusbarPadding;
        const currVal_11 = core_es5["_32" /* nov */](_v, 20)._hasRefresher;
        _ck(_v, 19, 0, currVal_10, currVal_11);
        const currVal_12 = core_es5["_32" /* nov */](_v, 23)._animated;
        const currVal_13 = core_es5["_32" /* nov */](_v, 23)._value;
        const currVal_14 = core_es5["_32" /* nov */](_v, 23)._isActive;
        const currVal_15 = core_es5["_32" /* nov */](_v, 23)._showCancelButton;
        const currVal_16 = core_es5["_32" /* nov */](_v, 23)._shouldAlignLeft;
        const currVal_17 = core_es5["_32" /* nov */](_v, 23)._isFocus;
        _ck(_v, 22, 0, currVal_12, currVal_13, currVal_14, currVal_15, currVal_16, currVal_17);
        const currVal_22 = core_es5["_32" /* nov */](_v, 40)._sbPadding;
        _ck(_v, 39, 0, currVal_22);
        const currVal_24 = core_es5["_32" /* nov */](_v, 43)._animated;
        const currVal_25 = core_es5["_32" /* nov */](_v, 43)._value;
        const currVal_26 = core_es5["_32" /* nov */](_v, 43)._isActive;
        const currVal_27 = core_es5["_32" /* nov */](_v, 43)._showCancelButton;
        const currVal_28 = core_es5["_32" /* nov */](_v, 43)._shouldAlignLeft;
        const currVal_29 = core_es5["_32" /* nov */](_v, 43)._isFocus;
        _ck(_v, 42, 0, currVal_24, currVal_25, currVal_26, currVal_27, currVal_28, currVal_29);
    });
}
function View_PageOne_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ng-component', [], null, null, null, View_PageOne_0, RenderType_PageOne)),
        core_es5["_16" /* did */](114688, null, 0, PageOne, [], null, null)], (_ck, _v) => {
        _ck(_v, 1, 0);
    }, null);
}
const PageOneNgFactory = core_es5["_13" /* ccf */]('ng-component', PageOne, View_PageOne_Host_0, {}, {}, []);
//# sourceMappingURL=page-one.ngfactory.js.map
// CONCATENATED MODULE: ./src/components/nav/nav.ngfactory.ts












const styles_Nav = [];
const RenderType_Nav = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_Nav,
    data: {} });
function View_Nav_0(_l) {
    return core_es5["_38" /* vid */](0, [core_es5["_35" /* qud */](402653184, 1, { _vp: 0 }), (_l()(), core_es5["_18" /* eld */](16777216, [[1, 3], ['viewport',
                1]], null, 0, 'div', [['nav-viewport', '']], null, null, null, null, null)), (_l()(), core_es5["_18" /* eld */](0, null, null, 0, 'div', [['class', 'nav-decor']], null, null, null, null, null))], null, null);
}
function View_Nav_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'ion-nav', [], null, null, null, View_Nav_0, RenderType_Nav)), core_es5["_34" /* prd */](6144, null, RootNode, null, [Nav]), core_es5["_16" /* did */](4374528, null, 0, Nav, [[2, view_controller_ViewController], [2, NavController], app_App, config_Config, platform_Platform,
            core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */], core_es5["O" /* Renderer */], core_es5["l" /* ComponentFactoryResolver */], GestureController,
            transition_controller_TransitionController, [2, deep_linker_DeepLinker], dom_controller_DomController, core_es5["q" /* ErrorHandler */]], null, null)], null, null);
}
const NavNgFactory = core_es5["_13" /* ccf */]('ion-nav', Nav, View_Nav_Host_0, { color: 'color', mode: 'mode', swipeBackEnabled: 'swipeBackEnabled', root: 'root', rootParams: 'rootParams',
    name: 'name' }, {}, []);
//# sourceMappingURL=nav.ngfactory.js.map
// CONCATENATED MODULE: ./demos/src/searchbar/app/app.component.ngfactory.ts














const styles_AppComponent = [];
const RenderType_AppComponent = core_es5["_15" /* crt */]({ encapsulation: 2, styles: styles_AppComponent,
    data: {} });
function View_AppComponent_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 2, 'ion-nav', [], null, null, null, View_Nav_0, RenderType_Nav)),
        core_es5["_34" /* prd */](6144, null, RootNode, null, [Nav]), core_es5["_16" /* did */](4374528, null, 0, Nav, [[2, view_controller_ViewController], [2, NavController], app_App,
            config_Config, platform_Platform, core_es5["p" /* ElementRef */], core_es5["G" /* NgZone */], core_es5["O" /* Renderer */], core_es5["l" /* ComponentFactoryResolver */],
            GestureController, transition_controller_TransitionController, [2, deep_linker_DeepLinker], dom_controller_DomController,
            core_es5["q" /* ErrorHandler */]], { root: [0, 'root'] }, null)], (_ck, _v) => {
        var _co = _v.component;
        const currVal_0 = _co.root;
        _ck(_v, 2, 0, currVal_0);
    }, null);
}
function View_AppComponent_Host_0(_l) {
    return core_es5["_38" /* vid */](0, [(_l()(), core_es5["_18" /* eld */](0, null, null, 1, 'ng-component', [], null, null, null, View_AppComponent_0, RenderType_AppComponent)), core_es5["_16" /* did */](49152, null, 0, app_component_AppComponent, [], null, null)], null, null);
}
const AppComponentNgFactory = core_es5["_13" /* ccf */]('ng-component', app_component_AppComponent, View_AppComponent_Host_0, {}, {}, []);
//# sourceMappingURL=app.component.ngfactory.js.map
// CONCATENATED MODULE: ./demos/src/searchbar/app/app.module.ngfactory.ts















































const AppModuleNgFactory = core_es5["_14" /* cmf */](AppModule, [app_root_IonicApp], (_l) => {
    return core_es5["_29" /* mod */]([core_es5["_30" /* mpd */](512, core_es5["l" /* ComponentFactoryResolver */], core_es5["_10" /* CodegenComponentFactoryResolver */], [[8, [ActionSheetCmpNgFactory, AlertCmpNgFactory, IonicAppNgFactory,
                    LoadingCmpNgFactory, ModalCmpNgFactory, PickerCmpNgFactory, PopoverCmpNgFactory,
                    SelectPopoverNgFactory, ToastCmpNgFactory, PageOneNgFactory,
                    AppComponentNgFactory]], [3, core_es5["l" /* ComponentFactoryResolver */]], core_es5["E" /* NgModuleRef */]]),
        core_es5["_30" /* mpd */](5120, core_es5["C" /* LOCALE_ID */], core_es5["_28" /* m */], [[3, core_es5["C" /* LOCALE_ID */]]]), core_es5["_30" /* mpd */](4608, common_es5["k" /* NgLocalization */], common_es5["j" /* NgLocaleLocalization */], [core_es5["C" /* LOCALE_ID */]]), core_es5["_30" /* mpd */](5120, core_es5["b" /* APP_ID */], core_es5["_19" /* f */], []), core_es5["_30" /* mpd */](5120, core_es5["A" /* IterableDiffers */], core_es5["_25" /* k */], []),
        core_es5["_30" /* mpd */](5120, core_es5["B" /* KeyValueDiffers */], core_es5["_26" /* l */], []), core_es5["_30" /* mpd */](4608, platform_browser_es5["c" /* DomSanitizer */], platform_browser_es5["t" /* e */], [common_es5["c" /* DOCUMENT */]]), core_es5["_30" /* mpd */](6144, core_es5["S" /* Sanitizer */], null, [platform_browser_es5["c" /* DomSanitizer */]]),
        core_es5["_30" /* mpd */](4608, platform_browser_es5["f" /* HAMMER_GESTURE_CONFIG */], IonicGestureConfig, []),
        core_es5["_30" /* mpd */](5120, platform_browser_es5["d" /* EVENT_MANAGER_PLUGINS */], (p0_0, p1_0, p2_0, p2_1) => {
            return [new platform_browser_es5["l" /* DomEventsPlugin */](p0_0), new platform_browser_es5["p" /* KeyEventsPlugin */](p1_0),
                new platform_browser_es5["o" /* HammerGesturesPlugin */](p2_0, p2_1)];
        }, [common_es5["c" /* DOCUMENT */], common_es5["c" /* DOCUMENT */], common_es5["c" /* DOCUMENT */], platform_browser_es5["f" /* HAMMER_GESTURE_CONFIG */]]), core_es5["_30" /* mpd */](4608, platform_browser_es5["e" /* EventManager */], platform_browser_es5["e" /* EventManager */], [platform_browser_es5["d" /* EVENT_MANAGER_PLUGINS */], core_es5["G" /* NgZone */]]),
        core_es5["_30" /* mpd */](135680, platform_browser_es5["n" /* DomSharedStylesHost */], platform_browser_es5["n" /* DomSharedStylesHost */], [common_es5["c" /* DOCUMENT */]]),
        core_es5["_30" /* mpd */](4608, platform_browser_es5["m" /* DomRendererFactory2 */], platform_browser_es5["m" /* DomRendererFactory2 */], [platform_browser_es5["e" /* EventManager */],
            platform_browser_es5["n" /* DomSharedStylesHost */]]), core_es5["_30" /* mpd */](6144, core_es5["Q" /* RendererFactory2 */], null, [platform_browser_es5["m" /* DomRendererFactory2 */]]), core_es5["_30" /* mpd */](6144, platform_browser_es5["q" /* SharedStylesHost */], null, [platform_browser_es5["n" /* DomSharedStylesHost */]]), core_es5["_30" /* mpd */](4608, core_es5["V" /* Testability */], core_es5["V" /* Testability */], [core_es5["G" /* NgZone */]]), core_es5["_30" /* mpd */](4608, platform_browser_es5["h" /* Meta */], platform_browser_es5["h" /* Meta */], [common_es5["c" /* DOCUMENT */]]), core_es5["_30" /* mpd */](4608, platform_browser_es5["j" /* Title */], platform_browser_es5["j" /* Title */], [common_es5["c" /* DOCUMENT */]]), core_es5["_30" /* mpd */](4608, forms_es5["k" /* i */], forms_es5["k" /* i */], []),
        core_es5["_30" /* mpd */](4608, forms_es5["c" /* FormBuilder */], forms_es5["c" /* FormBuilder */], []), core_es5["_30" /* mpd */](4608, action_sheet_controller_ActionSheetController, action_sheet_controller_ActionSheetController, [app_App, config_Config]),
        core_es5["_30" /* mpd */](4608, alert_controller_AlertController, alert_controller_AlertController, [app_App, config_Config]),
        core_es5["_30" /* mpd */](4608, Events, Events, []), core_es5["_30" /* mpd */](4608, form_Form, form_Form, []), core_es5["_30" /* mpd */](4608, Haptic, Haptic, [platform_Platform]),
        core_es5["_30" /* mpd */](4608, keyboard_Keyboard, keyboard_Keyboard, [config_Config, platform_Platform, core_es5["G" /* NgZone */],
            dom_controller_DomController]), core_es5["_30" /* mpd */](4608, loading_controller_LoadingController, loading_controller_LoadingController, [app_App, config_Config]), core_es5["_30" /* mpd */](5120, common_es5["f" /* LocationStrategy */], provideLocationStrategy, [common_es5["q" /* PlatformLocation */], [2, common_es5["a" /* APP_BASE_HREF */]], config_Config]), core_es5["_30" /* mpd */](4608, common_es5["e" /* Location */], common_es5["e" /* Location */], [common_es5["f" /* LocationStrategy */]]), core_es5["_30" /* mpd */](5120, url_serializer_UrlSerializer, setupUrlSerializer, [app_App, DeepLinkConfigToken]), core_es5["_30" /* mpd */](5120, deep_linker_DeepLinker, setupDeepLinker, [app_App, url_serializer_UrlSerializer, common_es5["e" /* Location */],
            ModuleLoader, core_es5["l" /* ComponentFactoryResolver */]]), core_es5["_30" /* mpd */](4608, modal_controller_ModalController, modal_controller_ModalController, [app_App, config_Config, deep_linker_DeepLinker]), core_es5["_30" /* mpd */](4608, picker_controller_PickerController, picker_controller_PickerController, [app_App, config_Config]), core_es5["_30" /* mpd */](4608, popover_controller_PopoverController, popover_controller_PopoverController, [app_App, config_Config, deep_linker_DeepLinker]),
        core_es5["_30" /* mpd */](4608, tap_click_TapClick, tap_click_TapClick, [config_Config, platform_Platform, dom_controller_DomController,
            app_App, GestureController]), core_es5["_30" /* mpd */](4608, toast_controller_ToastController, toast_controller_ToastController, [app_App, config_Config]), core_es5["_30" /* mpd */](4608, transition_controller_TransitionController, transition_controller_TransitionController, [platform_Platform, config_Config]), core_es5["_30" /* mpd */](512, common_es5["b" /* CommonModule */], common_es5["b" /* CommonModule */], []), core_es5["_30" /* mpd */](1024, core_es5["q" /* ErrorHandler */], platform_browser_es5["r" /* a */], []), core_es5["_30" /* mpd */](256, ConfigToken, null, []), core_es5["_30" /* mpd */](1024, PlatformConfigToken, providePlatformConfigs, []), core_es5["_30" /* mpd */](1024, platform_Platform, setupPlatform, [platform_browser_es5["b" /* DOCUMENT */], PlatformConfigToken, core_es5["G" /* NgZone */]]),
        core_es5["_30" /* mpd */](1024, config_Config, setupConfig, [ConfigToken, platform_Platform]),
        core_es5["_30" /* mpd */](512, dom_controller_DomController, dom_controller_DomController, [platform_Platform]), core_es5["_30" /* mpd */](512, menu_controller_MenuController, menu_controller_MenuController, []), core_es5["_30" /* mpd */](512, app_App, app_App, [config_Config, platform_Platform, [2, menu_controller_MenuController]]), core_es5["_30" /* mpd */](512, GestureController, GestureController, [app_App]), core_es5["_30" /* mpd */](256, DeepLinkConfigToken, null, []), core_es5["_30" /* mpd */](512, core_es5["j" /* Compiler */], core_es5["j" /* Compiler */], []),
        core_es5["_30" /* mpd */](512, ng_module_loader_NgModuleLoader, ng_module_loader_NgModuleLoader, [core_es5["j" /* Compiler */]]), core_es5["_30" /* mpd */](1024, ModuleLoader, provideModuleLoader, [ng_module_loader_NgModuleLoader, core_es5["y" /* Injector */]]),
        core_es5["_30" /* mpd */](1024, core_es5["c" /* APP_INITIALIZER */], (p0_0, p0_1, p1_0, p2_0, p2_1, p3_0, p3_1, p3_2, p3_3, p3_4, p4_0, p4_1, p4_2, p4_3) => {
            return [platform_browser_es5["s" /* c */](p0_0, p0_1), registerModeConfigs(p1_0), setupProvideEvents(p2_0, p2_1), setupTapClick(p3_0, p3_1, p3_2, p3_3, p3_4), setupPreloading(p4_0, p4_1, p4_2, p4_3)];
        }, [[2, platform_browser_es5["i" /* NgProbeToken */]], [2, core_es5["F" /* NgProbeToken */]], config_Config, platform_Platform, dom_controller_DomController,
            config_Config, platform_Platform, dom_controller_DomController, app_App, GestureController,
            config_Config, DeepLinkConfigToken, ModuleLoader, core_es5["G" /* NgZone */]]), core_es5["_30" /* mpd */](512, core_es5["d" /* ApplicationInitStatus */], core_es5["d" /* ApplicationInitStatus */], [[2, core_es5["c" /* APP_INITIALIZER */]]]),
        core_es5["_30" /* mpd */](131584, core_es5["_17" /* e */], core_es5["_17" /* e */], [core_es5["G" /* NgZone */], core_es5["_11" /* Console */], core_es5["y" /* Injector */], core_es5["q" /* ErrorHandler */],
            core_es5["l" /* ComponentFactoryResolver */], core_es5["d" /* ApplicationInitStatus */]]), core_es5["_30" /* mpd */](2048, core_es5["f" /* ApplicationRef */], null, [core_es5["_17" /* e */]]), core_es5["_30" /* mpd */](512, core_es5["e" /* ApplicationModule */], core_es5["e" /* ApplicationModule */], [core_es5["f" /* ApplicationRef */]]), core_es5["_30" /* mpd */](512, platform_browser_es5["a" /* BrowserModule */], platform_browser_es5["a" /* BrowserModule */], [[3, platform_browser_es5["a" /* BrowserModule */]]]), core_es5["_30" /* mpd */](512, forms_es5["j" /* ba */], forms_es5["j" /* ba */], []), core_es5["_30" /* mpd */](512, forms_es5["d" /* FormsModule */], forms_es5["d" /* FormsModule */], []),
        core_es5["_30" /* mpd */](512, forms_es5["i" /* ReactiveFormsModule */], forms_es5["i" /* ReactiveFormsModule */], []),
        core_es5["_30" /* mpd */](512, module_IonicModule, module_IonicModule, []), core_es5["_30" /* mpd */](512, module_IonicPageModule, module_IonicPageModule, []), core_es5["_30" /* mpd */](512, PageOneModule, PageOneModule, []), core_es5["_30" /* mpd */](512, AppModule, AppModule, []),
        core_es5["_30" /* mpd */](256, LAZY_LOADED_TOKEN, PageOne, []), core_es5["_30" /* mpd */](256, AppRootToken, app_component_AppComponent, []), core_es5["_30" /* mpd */](256, common_es5["a" /* APP_BASE_HREF */], '/', [])]);
});
//# sourceMappingURL=app.module.ngfactory.js.map
// CONCATENATED MODULE: ./demos/src/searchbar/app/main.ts



Object(core_es5["_4" /* enableProdMode */])();
Object(platform_browser_es5["k" /* platformBrowser */])().bootstrapModuleFactory(AppModuleNgFactory);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 43:
/***/ (function(module, exports) {

//# sourceMappingURL=action-sheet-options.js.map

/***/ }),

/***/ 44:
/***/ (function(module, exports) {

//# sourceMappingURL=alert-options.js.map

/***/ }),

/***/ 51:
/***/ (function(module, exports) {

//# sourceMappingURL=loading-options.js.map

/***/ }),

/***/ 52:
/***/ (function(module, exports) {

//# sourceMappingURL=modal-options.js.map

/***/ }),

/***/ 53:
/***/ (function(module, exports) {

//# sourceMappingURL=popover-options.js.map

/***/ }),

/***/ 54:
/***/ (function(module, exports) {

//# sourceMappingURL=toast-options.js.map

/***/ })

},[25]);
//# sourceMappingURL=main.js.map